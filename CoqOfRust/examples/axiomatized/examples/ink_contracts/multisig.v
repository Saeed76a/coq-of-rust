(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module  Mapping.
Section Mapping.
  Context (K V : Set).
  
  Record t : Set := {
    _key : core.marker.PhantomData.t K;
    _value : core.marker.PhantomData.t V;
  }.
  
  Global Instance Get__key : Notations.Dot "_key" := {
    Notations.dot := Ref.map (fun x => x.(_key)) (fun v x => x <| _key := v |>);
  }.
  Global Instance Get_AF__key : Notations.DoubleColon t "_key" := {
    Notations.double_colon (x : M.Val t) := x.["_key"];
  }.
  Global Instance Get__value : Notations.Dot "_value" := {
    Notations.dot :=
      Ref.map (fun x => x.(_value)) (fun v x => x <| _value := v |>);
  }.
  Global Instance Get_AF__value : Notations.DoubleColon t "_value" := {
    Notations.double_colon (x : M.Val t) := x.["_value"];
  }.
End Mapping.
End Mapping.

Module  Impl_core_default_Default_for_multisig_Mapping_t_K_V.
Section Impl_core_default_Default_for_multisig_Mapping_t_K_V.
  Context {K V : Set}.
  
  Context
    {ℋ_0 : core.default.Default.Trait K}
    {ℋ_1 : core.default.Default.Trait V}.
  
  Definition Self : Set := multisig.Mapping.t K V.
  
  (*
  Default
  *)
  Parameter default : M (multisig.Mapping.t K V).
  
  Global Instance AssociatedFunction_default :
    Notations.DoubleColon Self "default" := {
    Notations.double_colon := default;
  }.
  
  Global Instance ℐ : core.default.Default.Trait Self := {
    core.default.Default.default := default;
  }.
End Impl_core_default_Default_for_multisig_Mapping_t_K_V.
End Impl_core_default_Default_for_multisig_Mapping_t_K_V.

Module  Impl_multisig_Mapping_t_K_V.
Section Impl_multisig_Mapping_t_K_V.
  Context {K V : Set}.
  
  Definition Self : Set := multisig.Mapping.t K V.
  
  (*
      fn contains(&self, _key: &K) -> bool {
          unimplemented!()
      }
  *)
  Parameter contains : (ref Self) -> (ref K) -> M bool.t.
  
  Global Instance AssociatedFunction_contains :
    Notations.DoubleColon Self "contains" := {
    Notations.double_colon := contains;
  }.
  
  (*
      fn get(&self, _key: &K) -> Option<V> {
          unimplemented!()
      }
  *)
  Parameter get : (ref Self) -> (ref K) -> M (core.option.Option.t V).
  
  Global Instance AssociatedFunction_get : Notations.DoubleColon Self "get" := {
    Notations.double_colon := get;
  }.
  
  (*
      fn insert(&mut self, _key: K, _value: V) -> Option<u32> {
          unimplemented!()
      }
  *)
  Parameter insert : (mut_ref Self) -> K -> V -> M (core.option.Option.t u32.t).
  
  Global Instance AssociatedFunction_insert :
    Notations.DoubleColon Self "insert" := {
    Notations.double_colon := insert;
  }.
  
  (*
      fn remove(&self, _key: K) {
          unimplemented!()
      }
  *)
  Parameter remove : (ref Self) -> K -> M unit.
  
  Global Instance AssociatedFunction_remove :
    Notations.DoubleColon Self "remove" := {
    Notations.double_colon := remove;
  }.
  
  (*
      fn size(&self, _key: K) -> Option<u32> {
          unimplemented!()
      }
  *)
  Parameter size : (ref Self) -> K -> M (core.option.Option.t u32.t).
  
  Global Instance AssociatedFunction_size :
    Notations.DoubleColon Self "size" := {
    Notations.double_colon := size;
  }.
  
  (*
      fn take(&self, _key: K) -> Option<V> {
          unimplemented!()
      }
  *)
  Parameter take : (ref Self) -> K -> M (core.option.Option.t V).
  
  Global Instance AssociatedFunction_take :
    Notations.DoubleColon Self "take" := {
    Notations.double_colon := take;
  }.
End Impl_multisig_Mapping_t_K_V.
End Impl_multisig_Mapping_t_K_V.

Module  AccountId.
Section AccountId.
  Record t : Set := {
    x0 : u128.t;
  }.
  
  Global Instance Get_0 : Notations.Dot "0" := {
    Notations.dot := Ref.map (fun x => x.(x0)) (fun v x => x <| x0 := v |>);
  }.
End AccountId.
End AccountId.

Module  Impl_core_default_Default_for_multisig_AccountId_t.
Section Impl_core_default_Default_for_multisig_AccountId_t.
  Definition Self : Set := multisig.AccountId.t.
  
  (*
  Default
  *)
  Parameter default : M multisig.AccountId.t.
  
  Global Instance AssociatedFunction_default :
    Notations.DoubleColon Self "default" := {
    Notations.double_colon := default;
  }.
  
  Global Instance ℐ : core.default.Default.Trait Self := {
    core.default.Default.default := default;
  }.
End Impl_core_default_Default_for_multisig_AccountId_t.
End Impl_core_default_Default_for_multisig_AccountId_t.

Module  Impl_core_fmt_Debug_for_multisig_AccountId_t.
Section Impl_core_fmt_Debug_for_multisig_AccountId_t.
  Definition Self : Set := multisig.AccountId.t.
  
  (*
  Debug
  *)
  Parameter fmt :
      (ref Self) -> (mut_ref core.fmt.Formatter.t) -> M ltac:(core.fmt.Result).
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_multisig_AccountId_t.
End Impl_core_fmt_Debug_for_multisig_AccountId_t.

Module  Impl_core_clone_Clone_for_multisig_AccountId_t.
Section Impl_core_clone_Clone_for_multisig_AccountId_t.
  Definition Self : Set := multisig.AccountId.t.
  
  (*
  Clone
  *)
  Parameter clone : (ref Self) -> M multisig.AccountId.t.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_multisig_AccountId_t.
End Impl_core_clone_Clone_for_multisig_AccountId_t.

Module  Impl_core_marker_Copy_for_multisig_AccountId_t.
Section Impl_core_marker_Copy_for_multisig_AccountId_t.
  Definition Self : Set := multisig.AccountId.t.
  
  Global Instance ℐ : core.marker.Copy.Trait Self := {
  }.
End Impl_core_marker_Copy_for_multisig_AccountId_t.
End Impl_core_marker_Copy_for_multisig_AccountId_t.

Module  Impl_core_marker_StructuralPartialEq_for_multisig_AccountId_t.
Section Impl_core_marker_StructuralPartialEq_for_multisig_AccountId_t.
  Definition Self : Set := multisig.AccountId.t.
  
  Global Instance ℐ : core.marker.StructuralPartialEq.Trait Self := {
  }.
End Impl_core_marker_StructuralPartialEq_for_multisig_AccountId_t.
End Impl_core_marker_StructuralPartialEq_for_multisig_AccountId_t.

Module  Impl_core_cmp_PartialEq_for_multisig_AccountId_t.
Section Impl_core_cmp_PartialEq_for_multisig_AccountId_t.
  Definition Self : Set := multisig.AccountId.t.
  
  (*
  PartialEq
  *)
  Parameter eq : (ref Self) -> (ref multisig.AccountId.t) -> M bool.t.
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ :
    core.cmp.PartialEq.Required.Trait Self
      (Rhs := core.cmp.PartialEq.Default.Rhs Self) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_for_multisig_AccountId_t.
End Impl_core_cmp_PartialEq_for_multisig_AccountId_t.

Module  Impl_core_marker_StructuralEq_for_multisig_AccountId_t.
Section Impl_core_marker_StructuralEq_for_multisig_AccountId_t.
  Definition Self : Set := multisig.AccountId.t.
  
  Global Instance ℐ : core.marker.StructuralEq.Trait Self := {
  }.
End Impl_core_marker_StructuralEq_for_multisig_AccountId_t.
End Impl_core_marker_StructuralEq_for_multisig_AccountId_t.

Module  Impl_core_cmp_Eq_for_multisig_AccountId_t.
Section Impl_core_cmp_Eq_for_multisig_AccountId_t.
  Definition Self : Set := multisig.AccountId.t.
  
  (*
  Eq
  *)
  Parameter assert_receiver_is_total_eq : (ref Self) -> M unit.
  
  Global Instance AssociatedFunction_assert_receiver_is_total_eq :
    Notations.DoubleColon Self "assert_receiver_is_total_eq" := {
    Notations.double_colon := assert_receiver_is_total_eq;
  }.
  
  Global Instance ℐ : core.cmp.Eq.Required.Trait Self := {
    core.cmp.Eq.assert_receiver_is_total_eq :=
      Datatypes.Some assert_receiver_is_total_eq;
  }.
End Impl_core_cmp_Eq_for_multisig_AccountId_t.
End Impl_core_cmp_Eq_for_multisig_AccountId_t.

Module  Impl_core_cmp_PartialOrd_for_multisig_AccountId_t.
Section Impl_core_cmp_PartialOrd_for_multisig_AccountId_t.
  Definition Self : Set := multisig.AccountId.t.
  
  (*
  PartialOrd
  *)
  Parameter partial_cmp :
      (ref Self) ->
        (ref multisig.AccountId.t) ->
        M (core.option.Option.t core.cmp.Ordering.t).
  
  Global Instance AssociatedFunction_partial_cmp :
    Notations.DoubleColon Self "partial_cmp" := {
    Notations.double_colon := partial_cmp;
  }.
  
  Global Instance ℐ :
    core.cmp.PartialOrd.Required.Trait Self
      (Rhs := core.cmp.PartialOrd.Default.Rhs Self) := {
    core.cmp.PartialOrd.partial_cmp := partial_cmp;
    core.cmp.PartialOrd.lt := Datatypes.None;
    core.cmp.PartialOrd.le := Datatypes.None;
    core.cmp.PartialOrd.gt := Datatypes.None;
    core.cmp.PartialOrd.ge := Datatypes.None;
  }.
End Impl_core_cmp_PartialOrd_for_multisig_AccountId_t.
End Impl_core_cmp_PartialOrd_for_multisig_AccountId_t.

Module  Impl_core_cmp_Ord_for_multisig_AccountId_t.
Section Impl_core_cmp_Ord_for_multisig_AccountId_t.
  Definition Self : Set := multisig.AccountId.t.
  
  (*
  Ord
  *)
  Parameter cmp :
      (ref Self) -> (ref multisig.AccountId.t) -> M core.cmp.Ordering.t.
  
  Global Instance AssociatedFunction_cmp : Notations.DoubleColon Self "cmp" := {
    Notations.double_colon := cmp;
  }.
  
  Global Instance ℐ : core.cmp.Ord.Required.Trait Self := {
    core.cmp.Ord.cmp := cmp;
    core.cmp.Ord.max := Datatypes.None;
    core.cmp.Ord.min := Datatypes.None;
    core.cmp.Ord.clamp := Datatypes.None;
  }.
End Impl_core_cmp_Ord_for_multisig_AccountId_t.
End Impl_core_cmp_Ord_for_multisig_AccountId_t.

Ltac Balance := exact u128.t.

Module  Env.
Section Env.
  Record t : Set := {
    caller : multisig.AccountId.t;
  }.
  
  Global Instance Get_caller : Notations.Dot "caller" := {
    Notations.dot :=
      Ref.map (fun x => x.(caller)) (fun v x => x <| caller := v |>);
  }.
  Global Instance Get_AF_caller : Notations.DoubleColon t "caller" := {
    Notations.double_colon (x : M.Val t) := x.["caller"];
  }.
End Env.
End Env.

Parameter MAX_OWNERS : M.Val u32.t.

Ltac TransactionId := exact u32.t.

Parameter WRONG_TRANSACTION_ID : M.Val (ref str.t).

Module  CallInput.
Section CallInput.
  Record t : Set := {
    x0 : ref (slice u8.t);
  }.
  
  Global Instance Get_0 : Notations.Dot "0" := {
    Notations.dot := Ref.map (fun x => x.(x0)) (fun v x => x <| x0 := v |>);
  }.
End CallInput.
End CallInput.

Module ConfirmationStatus.
  Inductive t : Set :=
  | Confirmed
  | ConfirmationsNeeded (_ : u32.t).
End ConfirmationStatus.

Module  Impl_core_clone_Clone_for_multisig_ConfirmationStatus_t.
Section Impl_core_clone_Clone_for_multisig_ConfirmationStatus_t.
  Definition Self : Set := multisig.ConfirmationStatus.t.
  
  (*
  Clone
  *)
  Parameter clone : (ref Self) -> M multisig.ConfirmationStatus.t.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_multisig_ConfirmationStatus_t.
End Impl_core_clone_Clone_for_multisig_ConfirmationStatus_t.

Module  Impl_core_marker_Copy_for_multisig_ConfirmationStatus_t.
Section Impl_core_marker_Copy_for_multisig_ConfirmationStatus_t.
  Definition Self : Set := multisig.ConfirmationStatus.t.
  
  Global Instance ℐ : core.marker.Copy.Trait Self := {
  }.
End Impl_core_marker_Copy_for_multisig_ConfirmationStatus_t.
End Impl_core_marker_Copy_for_multisig_ConfirmationStatus_t.

Module  Transaction.
Section Transaction.
  Record t : Set := {
    callee : multisig.AccountId.t;
    selector : array u8.t;
    input : alloc.vec.Vec.t u8.t alloc.vec.Vec.Default.A;
    transferred_value : ltac:(multisig.Balance);
    gas_limit : u64.t;
    allow_reentry : bool.t;
  }.
  
  Global Instance Get_callee : Notations.Dot "callee" := {
    Notations.dot :=
      Ref.map (fun x => x.(callee)) (fun v x => x <| callee := v |>);
  }.
  Global Instance Get_AF_callee : Notations.DoubleColon t "callee" := {
    Notations.double_colon (x : M.Val t) := x.["callee"];
  }.
  Global Instance Get_selector : Notations.Dot "selector" := {
    Notations.dot :=
      Ref.map (fun x => x.(selector)) (fun v x => x <| selector := v |>);
  }.
  Global Instance Get_AF_selector : Notations.DoubleColon t "selector" := {
    Notations.double_colon (x : M.Val t) := x.["selector"];
  }.
  Global Instance Get_input : Notations.Dot "input" := {
    Notations.dot :=
      Ref.map (fun x => x.(input)) (fun v x => x <| input := v |>);
  }.
  Global Instance Get_AF_input : Notations.DoubleColon t "input" := {
    Notations.double_colon (x : M.Val t) := x.["input"];
  }.
  Global Instance Get_transferred_value : Notations.Dot "transferred_value" := {
    Notations.dot :=
      Ref.map
        (fun x => x.(transferred_value))
        (fun v x => x <| transferred_value := v |>);
  }.
  Global Instance Get_AF_transferred_value :
    Notations.DoubleColon t "transferred_value" := {
    Notations.double_colon (x : M.Val t) := x.["transferred_value"];
  }.
  Global Instance Get_gas_limit : Notations.Dot "gas_limit" := {
    Notations.dot :=
      Ref.map (fun x => x.(gas_limit)) (fun v x => x <| gas_limit := v |>);
  }.
  Global Instance Get_AF_gas_limit : Notations.DoubleColon t "gas_limit" := {
    Notations.double_colon (x : M.Val t) := x.["gas_limit"];
  }.
  Global Instance Get_allow_reentry : Notations.Dot "allow_reentry" := {
    Notations.dot :=
      Ref.map
        (fun x => x.(allow_reentry))
        (fun v x => x <| allow_reentry := v |>);
  }.
  Global Instance Get_AF_allow_reentry :
    Notations.DoubleColon t "allow_reentry" := {
    Notations.double_colon (x : M.Val t) := x.["allow_reentry"];
  }.
End Transaction.
End Transaction.

Module  Impl_core_default_Default_for_multisig_Transaction_t.
Section Impl_core_default_Default_for_multisig_Transaction_t.
  Definition Self : Set := multisig.Transaction.t.
  
  (*
  Default
  *)
  Parameter default : M multisig.Transaction.t.
  
  Global Instance AssociatedFunction_default :
    Notations.DoubleColon Self "default" := {
    Notations.double_colon := default;
  }.
  
  Global Instance ℐ : core.default.Default.Trait Self := {
    core.default.Default.default := default;
  }.
End Impl_core_default_Default_for_multisig_Transaction_t.
End Impl_core_default_Default_for_multisig_Transaction_t.

Module Error.
  Inductive t : Set :=
  | TransactionFailed.
End Error.

Module  Impl_core_clone_Clone_for_multisig_Error_t.
Section Impl_core_clone_Clone_for_multisig_Error_t.
  Definition Self : Set := multisig.Error.t.
  
  (*
  Clone
  *)
  Parameter clone : (ref Self) -> M multisig.Error.t.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_multisig_Error_t.
End Impl_core_clone_Clone_for_multisig_Error_t.

Module  Impl_core_marker_Copy_for_multisig_Error_t.
Section Impl_core_marker_Copy_for_multisig_Error_t.
  Definition Self : Set := multisig.Error.t.
  
  Global Instance ℐ : core.marker.Copy.Trait Self := {
  }.
End Impl_core_marker_Copy_for_multisig_Error_t.
End Impl_core_marker_Copy_for_multisig_Error_t.

Module  Impl_core_marker_StructuralPartialEq_for_multisig_Error_t.
Section Impl_core_marker_StructuralPartialEq_for_multisig_Error_t.
  Definition Self : Set := multisig.Error.t.
  
  Global Instance ℐ : core.marker.StructuralPartialEq.Trait Self := {
  }.
End Impl_core_marker_StructuralPartialEq_for_multisig_Error_t.
End Impl_core_marker_StructuralPartialEq_for_multisig_Error_t.

Module  Impl_core_cmp_PartialEq_for_multisig_Error_t.
Section Impl_core_cmp_PartialEq_for_multisig_Error_t.
  Definition Self : Set := multisig.Error.t.
  
  (*
  PartialEq
  *)
  Parameter eq : (ref Self) -> (ref multisig.Error.t) -> M bool.t.
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ :
    core.cmp.PartialEq.Required.Trait Self
      (Rhs := core.cmp.PartialEq.Default.Rhs Self) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_for_multisig_Error_t.
End Impl_core_cmp_PartialEq_for_multisig_Error_t.

Module  Impl_core_marker_StructuralEq_for_multisig_Error_t.
Section Impl_core_marker_StructuralEq_for_multisig_Error_t.
  Definition Self : Set := multisig.Error.t.
  
  Global Instance ℐ : core.marker.StructuralEq.Trait Self := {
  }.
End Impl_core_marker_StructuralEq_for_multisig_Error_t.
End Impl_core_marker_StructuralEq_for_multisig_Error_t.

Module  Impl_core_cmp_Eq_for_multisig_Error_t.
Section Impl_core_cmp_Eq_for_multisig_Error_t.
  Definition Self : Set := multisig.Error.t.
  
  (*
  Eq
  *)
  Parameter assert_receiver_is_total_eq : (ref Self) -> M unit.
  
  Global Instance AssociatedFunction_assert_receiver_is_total_eq :
    Notations.DoubleColon Self "assert_receiver_is_total_eq" := {
    Notations.double_colon := assert_receiver_is_total_eq;
  }.
  
  Global Instance ℐ : core.cmp.Eq.Required.Trait Self := {
    core.cmp.Eq.assert_receiver_is_total_eq :=
      Datatypes.Some assert_receiver_is_total_eq;
  }.
End Impl_core_cmp_Eq_for_multisig_Error_t.
End Impl_core_cmp_Eq_for_multisig_Error_t.

Module  Transactions.
Section Transactions.
  Record t : Set := {
    transactions :
      alloc.vec.Vec.t ltac:(multisig.TransactionId) alloc.vec.Vec.Default.A;
    next_id : ltac:(multisig.TransactionId);
  }.
  
  Global Instance Get_transactions : Notations.Dot "transactions" := {
    Notations.dot :=
      Ref.map
        (fun x => x.(transactions))
        (fun v x => x <| transactions := v |>);
  }.
  Global Instance Get_AF_transactions :
    Notations.DoubleColon t "transactions" := {
    Notations.double_colon (x : M.Val t) := x.["transactions"];
  }.
  Global Instance Get_next_id : Notations.Dot "next_id" := {
    Notations.dot :=
      Ref.map (fun x => x.(next_id)) (fun v x => x <| next_id := v |>);
  }.
  Global Instance Get_AF_next_id : Notations.DoubleColon t "next_id" := {
    Notations.double_colon (x : M.Val t) := x.["next_id"];
  }.
End Transactions.
End Transactions.

Module  Impl_core_default_Default_for_multisig_Transactions_t.
Section Impl_core_default_Default_for_multisig_Transactions_t.
  Definition Self : Set := multisig.Transactions.t.
  
  (*
  Default
  *)
  Parameter default : M multisig.Transactions.t.
  
  Global Instance AssociatedFunction_default :
    Notations.DoubleColon Self "default" := {
    Notations.double_colon := default;
  }.
  
  Global Instance ℐ : core.default.Default.Trait Self := {
    core.default.Default.default := default;
  }.
End Impl_core_default_Default_for_multisig_Transactions_t.
End Impl_core_default_Default_for_multisig_Transactions_t.

Module  Confirmation.
Section Confirmation.
  Record t : Set := {
    transaction : ltac:(multisig.TransactionId);
    from : multisig.AccountId.t;
    status : multisig.ConfirmationStatus.t;
  }.
  
  Global Instance Get_transaction : Notations.Dot "transaction" := {
    Notations.dot :=
      Ref.map (fun x => x.(transaction)) (fun v x => x <| transaction := v |>);
  }.
  Global Instance Get_AF_transaction :
    Notations.DoubleColon t "transaction" := {
    Notations.double_colon (x : M.Val t) := x.["transaction"];
  }.
  Global Instance Get_from : Notations.Dot "from" := {
    Notations.dot := Ref.map (fun x => x.(from)) (fun v x => x <| from := v |>);
  }.
  Global Instance Get_AF_from : Notations.DoubleColon t "from" := {
    Notations.double_colon (x : M.Val t) := x.["from"];
  }.
  Global Instance Get_status : Notations.Dot "status" := {
    Notations.dot :=
      Ref.map (fun x => x.(status)) (fun v x => x <| status := v |>);
  }.
  Global Instance Get_AF_status : Notations.DoubleColon t "status" := {
    Notations.double_colon (x : M.Val t) := x.["status"];
  }.
End Confirmation.
End Confirmation.

Module  Revocation.
Section Revocation.
  Record t : Set := {
    transaction : ltac:(multisig.TransactionId);
    from : multisig.AccountId.t;
  }.
  
  Global Instance Get_transaction : Notations.Dot "transaction" := {
    Notations.dot :=
      Ref.map (fun x => x.(transaction)) (fun v x => x <| transaction := v |>);
  }.
  Global Instance Get_AF_transaction :
    Notations.DoubleColon t "transaction" := {
    Notations.double_colon (x : M.Val t) := x.["transaction"];
  }.
  Global Instance Get_from : Notations.Dot "from" := {
    Notations.dot := Ref.map (fun x => x.(from)) (fun v x => x <| from := v |>);
  }.
  Global Instance Get_AF_from : Notations.DoubleColon t "from" := {
    Notations.double_colon (x : M.Val t) := x.["from"];
  }.
End Revocation.
End Revocation.

Module  Submission.
Section Submission.
  Record t : Set := {
    transaction : ltac:(multisig.TransactionId);
  }.
  
  Global Instance Get_transaction : Notations.Dot "transaction" := {
    Notations.dot :=
      Ref.map (fun x => x.(transaction)) (fun v x => x <| transaction := v |>);
  }.
  Global Instance Get_AF_transaction :
    Notations.DoubleColon t "transaction" := {
    Notations.double_colon (x : M.Val t) := x.["transaction"];
  }.
End Submission.
End Submission.

Module  Cancellation.
Section Cancellation.
  Record t : Set := {
    transaction : ltac:(multisig.TransactionId);
  }.
  
  Global Instance Get_transaction : Notations.Dot "transaction" := {
    Notations.dot :=
      Ref.map (fun x => x.(transaction)) (fun v x => x <| transaction := v |>);
  }.
  Global Instance Get_AF_transaction :
    Notations.DoubleColon t "transaction" := {
    Notations.double_colon (x : M.Val t) := x.["transaction"];
  }.
End Cancellation.
End Cancellation.

Module  Execution.
Section Execution.
  Record t : Set := {
    transaction : ltac:(multisig.TransactionId);
    result :
      core.result.Result.t
        (core.option.Option.t (alloc.vec.Vec.t u8.t alloc.vec.Vec.Default.A))
        multisig.Error.t;
  }.
  
  Global Instance Get_transaction : Notations.Dot "transaction" := {
    Notations.dot :=
      Ref.map (fun x => x.(transaction)) (fun v x => x <| transaction := v |>);
  }.
  Global Instance Get_AF_transaction :
    Notations.DoubleColon t "transaction" := {
    Notations.double_colon (x : M.Val t) := x.["transaction"];
  }.
  Global Instance Get_result : Notations.Dot "result" := {
    Notations.dot :=
      Ref.map (fun x => x.(result)) (fun v x => x <| result := v |>);
  }.
  Global Instance Get_AF_result : Notations.DoubleColon t "result" := {
    Notations.double_colon (x : M.Val t) := x.["result"];
  }.
End Execution.
End Execution.

Module  OwnerAddition.
Section OwnerAddition.
  Record t : Set := {
    owner : multisig.AccountId.t;
  }.
  
  Global Instance Get_owner : Notations.Dot "owner" := {
    Notations.dot :=
      Ref.map (fun x => x.(owner)) (fun v x => x <| owner := v |>);
  }.
  Global Instance Get_AF_owner : Notations.DoubleColon t "owner" := {
    Notations.double_colon (x : M.Val t) := x.["owner"];
  }.
End OwnerAddition.
End OwnerAddition.

Module  OwnerRemoval.
Section OwnerRemoval.
  Record t : Set := {
    owner : multisig.AccountId.t;
  }.
  
  Global Instance Get_owner : Notations.Dot "owner" := {
    Notations.dot :=
      Ref.map (fun x => x.(owner)) (fun v x => x <| owner := v |>);
  }.
  Global Instance Get_AF_owner : Notations.DoubleColon t "owner" := {
    Notations.double_colon (x : M.Val t) := x.["owner"];
  }.
End OwnerRemoval.
End OwnerRemoval.

Module  RequirementChange.
Section RequirementChange.
  Record t : Set := {
    new_requirement : u32.t;
  }.
  
  Global Instance Get_new_requirement : Notations.Dot "new_requirement" := {
    Notations.dot :=
      Ref.map
        (fun x => x.(new_requirement))
        (fun v x => x <| new_requirement := v |>);
  }.
  Global Instance Get_AF_new_requirement :
    Notations.DoubleColon t "new_requirement" := {
    Notations.double_colon (x : M.Val t) := x.["new_requirement"];
  }.
End RequirementChange.
End RequirementChange.

Module Event.
  Inductive t : Set :=
  | Confirmation (_ : multisig.Confirmation.t)
  | Revocation (_ : multisig.Revocation.t)
  | Submission (_ : multisig.Submission.t)
  | Cancellation (_ : multisig.Cancellation.t)
  | Execution (_ : multisig.Execution.t)
  | OwnerAddition (_ : multisig.OwnerAddition.t)
  | OwnerRemoval (_ : multisig.OwnerRemoval.t)
  | RequirementChange (_ : multisig.RequirementChange.t).
End Event.

Module  Impl_multisig_Env_t.
Section Impl_multisig_Env_t.
  Definition Self : Set := multisig.Env.t.
  
  (*
      fn caller(&self) -> AccountId {
          self.caller
      }
  *)
  Parameter caller : (ref Self) -> M multisig.AccountId.t.
  
  Global Instance AssociatedFunction_caller :
    Notations.DoubleColon Self "caller" := {
    Notations.double_colon := caller;
  }.
  
  (*
      fn emit_event(&self, _event: Event) {
          unimplemented!()
      }
  *)
  Parameter emit_event : (ref Self) -> multisig.Event.t -> M unit.
  
  Global Instance AssociatedFunction_emit_event :
    Notations.DoubleColon Self "emit_event" := {
    Notations.double_colon := emit_event;
  }.
  
  (*
      fn transferred_value(&self) -> Balance {
          unimplemented!()
      }
  *)
  Parameter transferred_value : (ref Self) -> M ltac:(multisig.Balance).
  
  Global Instance AssociatedFunction_transferred_value :
    Notations.DoubleColon Self "transferred_value" := {
    Notations.double_colon := transferred_value;
  }.
  
  (*
      fn account_id(&self) -> AccountId {
          unimplemented!()
      }
  *)
  Parameter account_id : (ref Self) -> M multisig.AccountId.t.
  
  Global Instance AssociatedFunction_account_id :
    Notations.DoubleColon Self "account_id" := {
    Notations.double_colon := account_id;
  }.
End Impl_multisig_Env_t.
End Impl_multisig_Env_t.

Module  Multisig.
Section Multisig.
  Record t : Set := {
    confirmations :
      multisig.Mapping.t
        (ltac:(multisig.TransactionId) * multisig.AccountId.t)
        unit;
    confirmation_count : multisig.Mapping.t ltac:(multisig.TransactionId) u32.t;
    transactions :
      multisig.Mapping.t ltac:(multisig.TransactionId) multisig.Transaction.t;
    transaction_list : multisig.Transactions.t;
    owners : alloc.vec.Vec.t multisig.AccountId.t alloc.vec.Vec.Default.A;
    is_owner : multisig.Mapping.t multisig.AccountId.t unit;
    requirement : u32.t;
  }.
  
  Global Instance Get_confirmations : Notations.Dot "confirmations" := {
    Notations.dot :=
      Ref.map
        (fun x => x.(confirmations))
        (fun v x => x <| confirmations := v |>);
  }.
  Global Instance Get_AF_confirmations :
    Notations.DoubleColon t "confirmations" := {
    Notations.double_colon (x : M.Val t) := x.["confirmations"];
  }.
  Global Instance Get_confirmation_count :
    Notations.Dot "confirmation_count" := {
    Notations.dot :=
      Ref.map
        (fun x => x.(confirmation_count))
        (fun v x => x <| confirmation_count := v |>);
  }.
  Global Instance Get_AF_confirmation_count :
    Notations.DoubleColon t "confirmation_count" := {
    Notations.double_colon (x : M.Val t) := x.["confirmation_count"];
  }.
  Global Instance Get_transactions : Notations.Dot "transactions" := {
    Notations.dot :=
      Ref.map
        (fun x => x.(transactions))
        (fun v x => x <| transactions := v |>);
  }.
  Global Instance Get_AF_transactions :
    Notations.DoubleColon t "transactions" := {
    Notations.double_colon (x : M.Val t) := x.["transactions"];
  }.
  Global Instance Get_transaction_list : Notations.Dot "transaction_list" := {
    Notations.dot :=
      Ref.map
        (fun x => x.(transaction_list))
        (fun v x => x <| transaction_list := v |>);
  }.
  Global Instance Get_AF_transaction_list :
    Notations.DoubleColon t "transaction_list" := {
    Notations.double_colon (x : M.Val t) := x.["transaction_list"];
  }.
  Global Instance Get_owners : Notations.Dot "owners" := {
    Notations.dot :=
      Ref.map (fun x => x.(owners)) (fun v x => x <| owners := v |>);
  }.
  Global Instance Get_AF_owners : Notations.DoubleColon t "owners" := {
    Notations.double_colon (x : M.Val t) := x.["owners"];
  }.
  Global Instance Get_is_owner : Notations.Dot "is_owner" := {
    Notations.dot :=
      Ref.map (fun x => x.(is_owner)) (fun v x => x <| is_owner := v |>);
  }.
  Global Instance Get_AF_is_owner : Notations.DoubleColon t "is_owner" := {
    Notations.double_colon (x : M.Val t) := x.["is_owner"];
  }.
  Global Instance Get_requirement : Notations.Dot "requirement" := {
    Notations.dot :=
      Ref.map (fun x => x.(requirement)) (fun v x => x <| requirement := v |>);
  }.
  Global Instance Get_AF_requirement :
    Notations.DoubleColon t "requirement" := {
    Notations.double_colon (x : M.Val t) := x.["requirement"];
  }.
End Multisig.
End Multisig.

Module  Impl_core_default_Default_for_multisig_Multisig_t.
Section Impl_core_default_Default_for_multisig_Multisig_t.
  Definition Self : Set := multisig.Multisig.t.
  
  (*
  Default
  *)
  Parameter default : M multisig.Multisig.t.
  
  Global Instance AssociatedFunction_default :
    Notations.DoubleColon Self "default" := {
    Notations.double_colon := default;
  }.
  
  Global Instance ℐ : core.default.Default.Trait Self := {
    core.default.Default.default := default;
  }.
End Impl_core_default_Default_for_multisig_Multisig_t.
End Impl_core_default_Default_for_multisig_Multisig_t.

Module  Impl_multisig_Multisig_t.
Section Impl_multisig_Multisig_t.
  Definition Self : Set := multisig.Multisig.t.
  
  (*
      fn init_env() -> Env {
          unimplemented!()
      }
  *)
  Parameter init_env : M multisig.Env.t.
  
  Global Instance AssociatedFunction_init_env :
    Notations.DoubleColon Self "init_env" := {
    Notations.double_colon := init_env;
  }.
  
  (*
      fn env(&self) -> Env {
          Self::init_env()
      }
  *)
  Parameter env : (ref Self) -> M multisig.Env.t.
  
  Global Instance AssociatedFunction_env : Notations.DoubleColon Self "env" := {
    Notations.double_colon := env;
  }.
  
  (*
      pub fn new(requirement: u32, mut owners: Vec<AccountId>) -> Self {
          let mut contract = Multisig::default();
          owners.sort_unstable();
          owners.dedup();
          ensure_requirement_is_valid(owners.len() as u32, requirement);
  
          for owner in &owners {
              contract.is_owner.insert( *owner, ());
          }
  
          contract.owners = owners;
          contract.transaction_list = Default::default();
          contract.requirement = requirement;
          contract
      }
  *)
  Parameter new :
      u32.t ->
        (alloc.vec.Vec.t multisig.AccountId.t alloc.vec.Vec.Default.A) ->
        M Self.
  
  Global Instance AssociatedFunction_new : Notations.DoubleColon Self "new" := {
    Notations.double_colon := new;
  }.
  
  (*
      pub fn add_owner(&mut self, new_owner: AccountId) {
          self.ensure_from_wallet();
          self.ensure_no_owner(&new_owner);
          ensure_requirement_is_valid(self.owners.len() as u32 + 1, self.requirement);
          self.is_owner.insert(new_owner, ());
          self.owners.push(new_owner);
          self.env()
              .emit_event(Event::OwnerAddition(OwnerAddition { owner: new_owner }));
      }
  *)
  Parameter add_owner : (mut_ref Self) -> multisig.AccountId.t -> M unit.
  
  Global Instance AssociatedFunction_add_owner :
    Notations.DoubleColon Self "add_owner" := {
    Notations.double_colon := add_owner;
  }.
  
  (*
      pub fn remove_owner(&mut self, owner: AccountId) {
          self.ensure_from_wallet();
          self.ensure_owner(&owner);
          let len = self.owners.len() as u32 - 1;
          let requirement = u32::min(len, self.requirement);
          ensure_requirement_is_valid(len, requirement);
          let owner_index = self.owner_index(&owner) as usize;
          self.owners.swap_remove(owner_index);
          self.is_owner.remove(owner);
          self.requirement = requirement;
          self.clean_owner_confirmations(&owner);
          self.env()
              .emit_event(Event::OwnerRemoval(OwnerRemoval { owner }));
      }
  *)
  Parameter remove_owner : (mut_ref Self) -> multisig.AccountId.t -> M unit.
  
  Global Instance AssociatedFunction_remove_owner :
    Notations.DoubleColon Self "remove_owner" := {
    Notations.double_colon := remove_owner;
  }.
  
  (*
      pub fn replace_owner(&mut self, old_owner: AccountId, new_owner: AccountId) {
          self.ensure_from_wallet();
          self.ensure_owner(&old_owner);
          self.ensure_no_owner(&new_owner);
          let owner_index = self.owner_index(&old_owner);
          self.owners[owner_index as usize] = new_owner;
          self.is_owner.remove(old_owner);
          self.is_owner.insert(new_owner, ());
          self.clean_owner_confirmations(&old_owner);
          self.env()
              .emit_event(Event::OwnerRemoval(OwnerRemoval { owner: old_owner }));
          self.env()
              .emit_event(Event::OwnerAddition(OwnerAddition { owner: new_owner }));
      }
  *)
  Parameter replace_owner :
      (mut_ref Self) -> multisig.AccountId.t -> multisig.AccountId.t -> M unit.
  
  Global Instance AssociatedFunction_replace_owner :
    Notations.DoubleColon Self "replace_owner" := {
    Notations.double_colon := replace_owner;
  }.
  
  (*
      pub fn change_requirement(&mut self, new_requirement: u32) {
          self.ensure_from_wallet();
          ensure_requirement_is_valid(self.owners.len() as u32, new_requirement);
          self.requirement = new_requirement;
          self.env()
              .emit_event(Event::RequirementChange(RequirementChange {
                  new_requirement,
              }));
      }
  *)
  Parameter change_requirement : (mut_ref Self) -> u32.t -> M unit.
  
  Global Instance AssociatedFunction_change_requirement :
    Notations.DoubleColon Self "change_requirement" := {
    Notations.double_colon := change_requirement;
  }.
  
  (*
      pub fn submit_transaction(
          &mut self,
          transaction: Transaction,
      ) -> (TransactionId, ConfirmationStatus) {
          self.ensure_caller_is_owner();
          let trans_id = self.transaction_list.next_id;
          self.transaction_list.next_id =
              trans_id.checked_add(1).expect("Transaction ids exhausted.");
          self.transactions.insert(trans_id, transaction);
          self.transaction_list.transactions.push(trans_id);
          self.env().emit_event(Event::Submission(Submission {
              transaction: trans_id,
          }));
          (
              trans_id,
              self.confirm_by_caller(self.env().caller(), trans_id),
          )
      }
  *)
  Parameter submit_transaction :
      (mut_ref Self) ->
        multisig.Transaction.t ->
        M (ltac:(multisig.TransactionId) * multisig.ConfirmationStatus.t).
  
  Global Instance AssociatedFunction_submit_transaction :
    Notations.DoubleColon Self "submit_transaction" := {
    Notations.double_colon := submit_transaction;
  }.
  
  (*
      pub fn cancel_transaction(&mut self, trans_id: TransactionId) {
          self.ensure_from_wallet();
          if self.take_transaction(trans_id).is_some() {
              self.env().emit_event(Event::Cancellation(Cancellation {
                  transaction: trans_id,
              }));
          }
      }
  *)
  Parameter cancel_transaction :
      (mut_ref Self) -> ltac:(multisig.TransactionId) -> M unit.
  
  Global Instance AssociatedFunction_cancel_transaction :
    Notations.DoubleColon Self "cancel_transaction" := {
    Notations.double_colon := cancel_transaction;
  }.
  
  (*
      pub fn confirm_transaction(&mut self, trans_id: TransactionId) -> ConfirmationStatus {
          self.ensure_caller_is_owner();
          self.ensure_transaction_exists(trans_id);
          self.confirm_by_caller(self.env().caller(), trans_id)
      }
  *)
  Parameter confirm_transaction :
      (mut_ref Self) ->
        ltac:(multisig.TransactionId) ->
        M multisig.ConfirmationStatus.t.
  
  Global Instance AssociatedFunction_confirm_transaction :
    Notations.DoubleColon Self "confirm_transaction" := {
    Notations.double_colon := confirm_transaction;
  }.
  
  (*
      pub fn revoke_confirmation(&mut self, trans_id: TransactionId) {
          self.ensure_caller_is_owner();
          let caller = self.env().caller();
          if self.confirmations.contains(&(trans_id, caller)) {
              self.confirmations.remove((trans_id, caller));
              let mut confirmation_count = self
                  .confirmation_count
                  .get(&trans_id)
                  .expect("There is a entry in `self.confirmations`. Hence a count must exit.");
              // Will not underflow as there is at least one confirmation
              confirmation_count -= 1;
              self.confirmation_count.insert(trans_id, confirmation_count);
              self.env().emit_event(Event::Revocation(Revocation {
                  transaction: trans_id,
                  from: caller,
              }));
          }
      }
  *)
  Parameter revoke_confirmation :
      (mut_ref Self) -> ltac:(multisig.TransactionId) -> M unit.
  
  Global Instance AssociatedFunction_revoke_confirmation :
    Notations.DoubleColon Self "revoke_confirmation" := {
    Notations.double_colon := revoke_confirmation;
  }.
  
  (*
      pub fn invoke_transaction(&mut self, trans_id: TransactionId) -> Result<(), Error> {
          self.ensure_confirmed(trans_id);
          let t = self.take_transaction(trans_id).expect(WRONG_TRANSACTION_ID);
          assert!(self.env().transferred_value() == t.transferred_value);
          // let result = build_call()
          //     .call(t.callee)
          //     .gas_limit(t.gas_limit)
          //     .transferred_value(t.transferred_value)
          //     .call_flags(CallFlags::default().set_allow_reentry(t.allow_reentry))
          //     .exec_input(ExecutionInput::new(t.selector.into()).push_arg(CallInput(&t.input)))
          //     .returns::<()>()
          //     .try_invoke();
          let result: Result<Result<Vec<u8>, ()>, ()> = todo!();
  
          let result = match result {
              Ok(Ok(_)) => Ok(()),
              _ => Err(Error::TransactionFailed),
          };
  
          self.env().emit_event(Event::Execution(Execution {
              transaction: trans_id,
              result: result.map(|_| None),
          }));
          result
      }
  *)
  Parameter invoke_transaction :
      (mut_ref Self) ->
        ltac:(multisig.TransactionId) ->
        M (core.result.Result.t unit multisig.Error.t).
  
  Global Instance AssociatedFunction_invoke_transaction :
    Notations.DoubleColon Self "invoke_transaction" := {
    Notations.double_colon := invoke_transaction;
  }.
  
  (*
      pub fn eval_transaction(&mut self, trans_id: TransactionId) -> Result<Vec<u8>, Error> {
          self.ensure_confirmed(trans_id);
          let t = self.take_transaction(trans_id).expect(WRONG_TRANSACTION_ID);
          // let result = build_call()
          //     .call(t.callee)
          //     .gas_limit(t.gas_limit)
          //     .transferred_value(t.transferred_value)
          //     .call_flags(CallFlags::default().set_allow_reentry(t.allow_reentry))
          //     .exec_input(ExecutionInput::new(t.selector.into()).push_arg(CallInput(&t.input)))
          //     .returns::<Vec<u8>>()
          //     .try_invoke();
          let result: Result<Result<Vec<u8>, ()>, ()> = todo!();
  
          let result = match result {
              Ok(Ok(v)) => Ok(v),
              _ => Err(Error::TransactionFailed),
          };
  
          self.env().emit_event(Event::Execution(Execution {
              transaction: trans_id,
              result: result.clone().map(Some),
          }));
          result
      }
  *)
  Parameter eval_transaction :
      (mut_ref Self) ->
        ltac:(multisig.TransactionId) ->
        M
          (core.result.Result.t
            (alloc.vec.Vec.t u8.t alloc.vec.Vec.Default.A)
            multisig.Error.t).
  
  Global Instance AssociatedFunction_eval_transaction :
    Notations.DoubleColon Self "eval_transaction" := {
    Notations.double_colon := eval_transaction;
  }.
  
  (*
      fn confirm_by_caller(
          &mut self,
          confirmer: AccountId,
          transaction: TransactionId,
      ) -> ConfirmationStatus {
          let mut count = self.confirmation_count.get(&transaction).unwrap_or(0);
          let key = (transaction, confirmer);
          let new_confirmation = !self.confirmations.contains(&key);
          if new_confirmation {
              count += 1;
              self.confirmations.insert(key, ());
              self.confirmation_count.insert(transaction, count);
          }
          let status = {
              if count >= self.requirement {
                  ConfirmationStatus::Confirmed
              } else {
                  ConfirmationStatus::ConfirmationsNeeded(self.requirement - count)
              }
          };
          if new_confirmation {
              self.env().emit_event(Event::Confirmation(Confirmation {
                  transaction,
                  from: confirmer,
                  status,
              }));
          }
          status
      }
  *)
  Parameter confirm_by_caller :
      (mut_ref Self) ->
        multisig.AccountId.t ->
        ltac:(multisig.TransactionId) ->
        M multisig.ConfirmationStatus.t.
  
  Global Instance AssociatedFunction_confirm_by_caller :
    Notations.DoubleColon Self "confirm_by_caller" := {
    Notations.double_colon := confirm_by_caller;
  }.
  
  (*
      fn owner_index(&self, owner: &AccountId) -> u32 {
          self.owners.iter().position(|x| *x == *owner).expect(
              "This is only called after it was already verified that the id is
                 actually an owner.",
          ) as u32
      }
  *)
  Parameter owner_index : (ref Self) -> (ref multisig.AccountId.t) -> M u32.t.
  
  Global Instance AssociatedFunction_owner_index :
    Notations.DoubleColon Self "owner_index" := {
    Notations.double_colon := owner_index;
  }.
  
  (*
      fn take_transaction(&mut self, trans_id: TransactionId) -> Option<Transaction> {
          let transaction = self.transactions.get(&trans_id);
          if transaction.is_some() {
              self.transactions.remove(trans_id);
              let pos = self
                  .transaction_list
                  .transactions
                  .iter()
                  .position(|t| t == &trans_id)
                  .expect("The transaction exists hence it must also be in the list.");
              self.transaction_list.transactions.swap_remove(pos);
              for owner in self.owners.iter() {
                  self.confirmations.remove((trans_id, *owner));
              }
              self.confirmation_count.remove(trans_id);
          }
          transaction
      }
  *)
  Parameter take_transaction :
      (mut_ref Self) ->
        ltac:(multisig.TransactionId) ->
        M (core.option.Option.t multisig.Transaction.t).
  
  Global Instance AssociatedFunction_take_transaction :
    Notations.DoubleColon Self "take_transaction" := {
    Notations.double_colon := take_transaction;
  }.
  
  (*
      fn clean_owner_confirmations(&mut self, owner: &AccountId) {
          for trans_id in &self.transaction_list.transactions {
              let key = ( *trans_id, *owner);
              if self.confirmations.contains(&key) {
                  self.confirmations.remove(key);
                  let mut count = self.confirmation_count.get(trans_id).unwrap_or(0);
                  count -= 1;
                  self.confirmation_count.insert( *trans_id, count);
              }
          }
      }
  *)
  Parameter clean_owner_confirmations :
      (mut_ref Self) -> (ref multisig.AccountId.t) -> M unit.
  
  Global Instance AssociatedFunction_clean_owner_confirmations :
    Notations.DoubleColon Self "clean_owner_confirmations" := {
    Notations.double_colon := clean_owner_confirmations;
  }.
  
  (*
      fn ensure_confirmed(&self, trans_id: TransactionId) {
          assert!(
              self.confirmation_count
                  .get(&trans_id)
                  .expect(WRONG_TRANSACTION_ID)
                  >= self.requirement
          );
      }
  *)
  Parameter ensure_confirmed :
      (ref Self) -> ltac:(multisig.TransactionId) -> M unit.
  
  Global Instance AssociatedFunction_ensure_confirmed :
    Notations.DoubleColon Self "ensure_confirmed" := {
    Notations.double_colon := ensure_confirmed;
  }.
  
  (*
      fn ensure_transaction_exists(&self, trans_id: TransactionId) {
          self.transactions
              .get(&trans_id)
              .expect(WRONG_TRANSACTION_ID);
      }
  *)
  Parameter ensure_transaction_exists :
      (ref Self) -> ltac:(multisig.TransactionId) -> M unit.
  
  Global Instance AssociatedFunction_ensure_transaction_exists :
    Notations.DoubleColon Self "ensure_transaction_exists" := {
    Notations.double_colon := ensure_transaction_exists;
  }.
  
  (*
      fn ensure_caller_is_owner(&self) {
          self.ensure_owner(&self.env().caller());
      }
  *)
  Parameter ensure_caller_is_owner : (ref Self) -> M unit.
  
  Global Instance AssociatedFunction_ensure_caller_is_owner :
    Notations.DoubleColon Self "ensure_caller_is_owner" := {
    Notations.double_colon := ensure_caller_is_owner;
  }.
  
  (*
      fn ensure_from_wallet(&self) {
          assert_eq!(self.env().caller(), self.env().account_id());
      }
  *)
  Parameter ensure_from_wallet : (ref Self) -> M unit.
  
  Global Instance AssociatedFunction_ensure_from_wallet :
    Notations.DoubleColon Self "ensure_from_wallet" := {
    Notations.double_colon := ensure_from_wallet;
  }.
  
  (*
      fn ensure_owner(&self, owner: &AccountId) {
          assert!(self.is_owner.contains(owner));
      }
  *)
  Parameter ensure_owner : (ref Self) -> (ref multisig.AccountId.t) -> M unit.
  
  Global Instance AssociatedFunction_ensure_owner :
    Notations.DoubleColon Self "ensure_owner" := {
    Notations.double_colon := ensure_owner;
  }.
  
  (*
      fn ensure_no_owner(&self, owner: &AccountId) {
          assert!(!self.is_owner.contains(owner));
      }
  *)
  Parameter ensure_no_owner :
      (ref Self) -> (ref multisig.AccountId.t) -> M unit.
  
  Global Instance AssociatedFunction_ensure_no_owner :
    Notations.DoubleColon Self "ensure_no_owner" := {
    Notations.double_colon := ensure_no_owner;
  }.
End Impl_multisig_Multisig_t.
End Impl_multisig_Multisig_t.

(*
fn ensure_requirement_is_valid(owners: u32, requirement: u32) {
    assert!(0 < requirement && requirement <= owners && owners <= MAX_OWNERS);
}
*)
Parameter ensure_requirement_is_valid : u32.t -> u32.t -> M unit.
