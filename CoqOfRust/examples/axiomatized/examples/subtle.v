(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module  Choice.
Section Choice.
  Record t : Set := {
    x0 : u8.t;
  }.
  
  Global Instance Get_0 : Notations.Dot "0" := {
    Notations.dot := Ref.map (fun x => x.(x0)) (fun v x => x <| x0 := v |>);
  }.
End Choice.
End Choice.

Module  Impl_core_marker_Copy_for_subtle_Choice_t.
Section Impl_core_marker_Copy_for_subtle_Choice_t.
  Ltac Self := exact subtle.Choice.t.
  
  Global Instance ℐ : core.marker.Copy.Trait ltac:(Self) := {
  }.
End Impl_core_marker_Copy_for_subtle_Choice_t.
End Impl_core_marker_Copy_for_subtle_Choice_t.

Module  Impl_core_clone_Clone_for_subtle_Choice_t.
Section Impl_core_clone_Clone_for_subtle_Choice_t.
  Ltac Self := exact subtle.Choice.t.
  
  (*
  Clone
  *)
  Parameter clone : (M.Val (ref ltac:(Self))) -> M subtle.Choice.t.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon ltac:(Self) "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait ltac:(Self) := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_subtle_Choice_t.
End Impl_core_clone_Clone_for_subtle_Choice_t.

Module  Impl_core_fmt_Debug_for_subtle_Choice_t.
Section Impl_core_fmt_Debug_for_subtle_Choice_t.
  Ltac Self := exact subtle.Choice.t.
  
  (*
  Debug
  *)
  Parameter fmt :
      (M.Val (ref ltac:(Self))) ->
        (M.Val (mut_ref core.fmt.Formatter.t)) ->
        M ltac:(core.fmt.Result).
  
  Global Instance AssociatedFunction_fmt :
    Notations.DoubleColon ltac:(Self) "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait ltac:(Self) := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_subtle_Choice_t.
End Impl_core_fmt_Debug_for_subtle_Choice_t.

Module  Impl_subtle_Choice_t.
Section Impl_subtle_Choice_t.
  Ltac Self := exact subtle.Choice.t.
  
  (*
      pub fn unwrap_u8(&self) -> u8 {
          self.0
      }
  *)
  Parameter unwrap_u8 : (M.Val (ref ltac:(Self))) -> M u8.t.
  
  Global Instance AssociatedFunction_unwrap_u8 :
    Notations.DoubleColon ltac:(Self) "unwrap_u8" := {
    Notations.double_colon := unwrap_u8;
  }.
End Impl_subtle_Choice_t.
End Impl_subtle_Choice_t.

Module  Impl_core_convert_From_subtle_Choice_t_for_bool_t.
Section Impl_core_convert_From_subtle_Choice_t_for_bool_t.
  Ltac Self := exact bool.t.
  
  (*
      fn from(source: Choice) -> bool {
          debug_assert!((source.0 == 0u8) | (source.0 == 1u8));
          source.0 != 0
      }
  *)
  Parameter from : (M.Val subtle.Choice.t) -> M bool.t.
  
  Global Instance AssociatedFunction_from :
    Notations.DoubleColon ltac:(Self) "from" := {
    Notations.double_colon := from;
  }.
  
  Global Instance ℐ :
    core.convert.From.Trait ltac:(Self) (T := subtle.Choice.t) := {
    core.convert.From.from := from;
  }.
End Impl_core_convert_From_subtle_Choice_t_for_bool_t.
End Impl_core_convert_From_subtle_Choice_t_for_bool_t.

Module  Impl_core_ops_bit_BitAnd_for_subtle_Choice_t.
Section Impl_core_ops_bit_BitAnd_for_subtle_Choice_t.
  Ltac Self := exact subtle.Choice.t.
  
  (*
      type Output = Choice;
  *)
  Definition Output : Set := subtle.Choice.t.
  
  (*
      fn bitand(self, rhs: Choice) -> Choice {
          (self.0 & rhs.0).into()
      }
  *)
  Parameter bitand :
      (M.Val ltac:(Self)) -> (M.Val subtle.Choice.t) -> M subtle.Choice.t.
  
  Global Instance AssociatedFunction_bitand :
    Notations.DoubleColon ltac:(Self) "bitand" := {
    Notations.double_colon := bitand;
  }.
  
  Global Instance ℐ :
    core.ops.bit.BitAnd.Trait ltac:(Self)
      (Rhs := core.ops.bit.BitAnd.Default.Rhs ltac:(Self)) := {
    core.ops.bit.BitAnd.Output := Output;
    core.ops.bit.BitAnd.bitand := bitand;
  }.
End Impl_core_ops_bit_BitAnd_for_subtle_Choice_t.
End Impl_core_ops_bit_BitAnd_for_subtle_Choice_t.

Module  Impl_core_ops_bit_BitAndAssign_for_subtle_Choice_t.
Section Impl_core_ops_bit_BitAndAssign_for_subtle_Choice_t.
  Ltac Self := exact subtle.Choice.t.
  
  (*
      fn bitand_assign(&mut self, rhs: Choice) {
          *self = *self & rhs;
      }
  *)
  Parameter bitand_assign :
      (M.Val (mut_ref ltac:(Self))) -> (M.Val subtle.Choice.t) -> M unit.
  
  Global Instance AssociatedFunction_bitand_assign :
    Notations.DoubleColon ltac:(Self) "bitand_assign" := {
    Notations.double_colon := bitand_assign;
  }.
  
  Global Instance ℐ :
    core.ops.bit.BitAndAssign.Trait ltac:(Self)
      (Rhs := core.ops.bit.BitAndAssign.Default.Rhs ltac:(Self)) := {
    core.ops.bit.BitAndAssign.bitand_assign := bitand_assign;
  }.
End Impl_core_ops_bit_BitAndAssign_for_subtle_Choice_t.
End Impl_core_ops_bit_BitAndAssign_for_subtle_Choice_t.

Module  Impl_core_ops_bit_BitOr_for_subtle_Choice_t.
Section Impl_core_ops_bit_BitOr_for_subtle_Choice_t.
  Ltac Self := exact subtle.Choice.t.
  
  (*
      type Output = Choice;
  *)
  Definition Output : Set := subtle.Choice.t.
  
  (*
      fn bitor(self, rhs: Choice) -> Choice {
          (self.0 | rhs.0).into()
      }
  *)
  Parameter bitor :
      (M.Val ltac:(Self)) -> (M.Val subtle.Choice.t) -> M subtle.Choice.t.
  
  Global Instance AssociatedFunction_bitor :
    Notations.DoubleColon ltac:(Self) "bitor" := {
    Notations.double_colon := bitor;
  }.
  
  Global Instance ℐ :
    core.ops.bit.BitOr.Trait ltac:(Self)
      (Rhs := core.ops.bit.BitOr.Default.Rhs ltac:(Self)) := {
    core.ops.bit.BitOr.Output := Output;
    core.ops.bit.BitOr.bitor := bitor;
  }.
End Impl_core_ops_bit_BitOr_for_subtle_Choice_t.
End Impl_core_ops_bit_BitOr_for_subtle_Choice_t.

Module  Impl_core_ops_bit_BitOrAssign_for_subtle_Choice_t.
Section Impl_core_ops_bit_BitOrAssign_for_subtle_Choice_t.
  Ltac Self := exact subtle.Choice.t.
  
  (*
      fn bitor_assign(&mut self, rhs: Choice) {
          *self = *self | rhs;
      }
  *)
  Parameter bitor_assign :
      (M.Val (mut_ref ltac:(Self))) -> (M.Val subtle.Choice.t) -> M unit.
  
  Global Instance AssociatedFunction_bitor_assign :
    Notations.DoubleColon ltac:(Self) "bitor_assign" := {
    Notations.double_colon := bitor_assign;
  }.
  
  Global Instance ℐ :
    core.ops.bit.BitOrAssign.Trait ltac:(Self)
      (Rhs := core.ops.bit.BitOrAssign.Default.Rhs ltac:(Self)) := {
    core.ops.bit.BitOrAssign.bitor_assign := bitor_assign;
  }.
End Impl_core_ops_bit_BitOrAssign_for_subtle_Choice_t.
End Impl_core_ops_bit_BitOrAssign_for_subtle_Choice_t.

Module  Impl_core_ops_bit_BitXor_for_subtle_Choice_t.
Section Impl_core_ops_bit_BitXor_for_subtle_Choice_t.
  Ltac Self := exact subtle.Choice.t.
  
  (*
      type Output = Choice;
  *)
  Definition Output : Set := subtle.Choice.t.
  
  (*
      fn bitxor(self, rhs: Choice) -> Choice {
          (self.0 ^ rhs.0).into()
      }
  *)
  Parameter bitxor :
      (M.Val ltac:(Self)) -> (M.Val subtle.Choice.t) -> M subtle.Choice.t.
  
  Global Instance AssociatedFunction_bitxor :
    Notations.DoubleColon ltac:(Self) "bitxor" := {
    Notations.double_colon := bitxor;
  }.
  
  Global Instance ℐ :
    core.ops.bit.BitXor.Trait ltac:(Self)
      (Rhs := core.ops.bit.BitXor.Default.Rhs ltac:(Self)) := {
    core.ops.bit.BitXor.Output := Output;
    core.ops.bit.BitXor.bitxor := bitxor;
  }.
End Impl_core_ops_bit_BitXor_for_subtle_Choice_t.
End Impl_core_ops_bit_BitXor_for_subtle_Choice_t.

Module  Impl_core_ops_bit_BitXorAssign_for_subtle_Choice_t.
Section Impl_core_ops_bit_BitXorAssign_for_subtle_Choice_t.
  Ltac Self := exact subtle.Choice.t.
  
  (*
      fn bitxor_assign(&mut self, rhs: Choice) {
          *self = *self ^ rhs;
      }
  *)
  Parameter bitxor_assign :
      (M.Val (mut_ref ltac:(Self))) -> (M.Val subtle.Choice.t) -> M unit.
  
  Global Instance AssociatedFunction_bitxor_assign :
    Notations.DoubleColon ltac:(Self) "bitxor_assign" := {
    Notations.double_colon := bitxor_assign;
  }.
  
  Global Instance ℐ :
    core.ops.bit.BitXorAssign.Trait ltac:(Self)
      (Rhs := core.ops.bit.BitXorAssign.Default.Rhs ltac:(Self)) := {
    core.ops.bit.BitXorAssign.bitxor_assign := bitxor_assign;
  }.
End Impl_core_ops_bit_BitXorAssign_for_subtle_Choice_t.
End Impl_core_ops_bit_BitXorAssign_for_subtle_Choice_t.

Module  Impl_core_ops_bit_Not_for_subtle_Choice_t.
Section Impl_core_ops_bit_Not_for_subtle_Choice_t.
  Ltac Self := exact subtle.Choice.t.
  
  (*
      type Output = Choice;
  *)
  Definition Output : Set := subtle.Choice.t.
  
  (*
      fn not(self) -> Choice {
          (1u8 & (!self.0)).into()
      }
  *)
  Parameter not : (M.Val ltac:(Self)) -> M subtle.Choice.t.
  
  Global Instance AssociatedFunction_not :
    Notations.DoubleColon ltac:(Self) "not" := {
    Notations.double_colon := not;
  }.
  
  Global Instance ℐ : core.ops.bit.Not.Trait ltac:(Self) := {
    core.ops.bit.Not.Output := Output;
    core.ops.bit.Not.not := not;
  }.
End Impl_core_ops_bit_Not_for_subtle_Choice_t.
End Impl_core_ops_bit_Not_for_subtle_Choice_t.

(*
fn black_box(input: u8) -> u8 {
    debug_assert!((input == 0u8) | (input == 1u8));

    unsafe {
        // Optimization barrier
        //
        // Unsafe is ok, because:
        //   - &input is not NULL;
        //   - size of input is not zero;
        //   - u8 is neither Sync, nor Send;
        //   - u8 is Copy, so input is always live;
        //   - u8 type is always properly aligned.
        core::ptr::read_volatile(&input as *const u8)
    }
}
*)
Parameter black_box : (M.Val u8.t) -> M u8.t.

Module  Impl_core_convert_From_u8_t_for_subtle_Choice_t.
Section Impl_core_convert_From_u8_t_for_subtle_Choice_t.
  Ltac Self := exact subtle.Choice.t.
  
  (*
      fn from(input: u8) -> Choice {
          // Our goal is to prevent the compiler from inferring that the value held inside the
          // resulting `Choice` struct is really an `i1` instead of an `i8`.
          Choice(black_box(input))
      }
  *)
  Parameter from : (M.Val u8.t) -> M subtle.Choice.t.
  
  Global Instance AssociatedFunction_from :
    Notations.DoubleColon ltac:(Self) "from" := {
    Notations.double_colon := from;
  }.
  
  Global Instance ℐ : core.convert.From.Trait ltac:(Self) (T := u8.t) := {
    core.convert.From.from := from;
  }.
End Impl_core_convert_From_u8_t_for_subtle_Choice_t.
End Impl_core_convert_From_u8_t_for_subtle_Choice_t.

Module  ConstantTimeEq.
Section ConstantTimeEq.
  Class Trait (Self : Set) : Type := {
    ct_eq : (ref ltac:(Self)) -> (ref ltac:(Self)) -> M subtle.Choice.t;
  }.
  
End ConstantTimeEq.
End ConstantTimeEq.

Module  Impl_subtle_ConstantTimeEq_for_slice_T.
Section Impl_subtle_ConstantTimeEq_for_slice_T.
  Context {T : Set}.
  
  Context {ℋ_0 : subtle.ConstantTimeEq.Trait T}.
  
  Ltac Self := exact (slice T).
  
  (*
      fn ct_eq(&self, _rhs: &[T]) -> Choice {
          let len = self.len();
  
          // Short-circuit on the *lengths* of the slices, not their
          // contents.
          if len != _rhs.len() {
              return Choice::from(0);
          }
  
          // This loop shouldn't be shortcircuitable, since the compiler
          // shouldn't be able to reason about the value of the `u8`
          // unwrapped from the `ct_eq` result.
          let mut x = 1u8;
          for (ai, bi) in self.iter().zip(_rhs.iter()) {
              x &= ai.ct_eq(bi).unwrap_u8();
          }
  
          x.into()
      }
  *)
  Parameter ct_eq :
      (M.Val (ref ltac:(Self))) -> (M.Val (ref (slice T))) -> M subtle.Choice.t.
  
  Global Instance AssociatedFunction_ct_eq :
    Notations.DoubleColon ltac:(Self) "ct_eq" := {
    Notations.double_colon := ct_eq;
  }.
  
  Global Instance ℐ : subtle.ConstantTimeEq.Required.Trait ltac:(Self) := {
    subtle.ConstantTimeEq.ct_eq := ct_eq;
    subtle.ConstantTimeEq.ct_ne := Datatypes.None;
  }.
End Impl_subtle_ConstantTimeEq_for_slice_T.
End Impl_subtle_ConstantTimeEq_for_slice_T.

Module  Impl_subtle_ConstantTimeEq_for_subtle_Choice_t.
Section Impl_subtle_ConstantTimeEq_for_subtle_Choice_t.
  Ltac Self := exact subtle.Choice.t.
  
  (*
      fn ct_eq(&self, rhs: &Choice) -> Choice {
          !( *self ^ *rhs)
      }
  *)
  Parameter ct_eq :
      (M.Val (ref ltac:(Self))) ->
        (M.Val (ref subtle.Choice.t)) ->
        M subtle.Choice.t.
  
  Global Instance AssociatedFunction_ct_eq :
    Notations.DoubleColon ltac:(Self) "ct_eq" := {
    Notations.double_colon := ct_eq;
  }.
  
  Global Instance ℐ : subtle.ConstantTimeEq.Required.Trait ltac:(Self) := {
    subtle.ConstantTimeEq.ct_eq := ct_eq;
    subtle.ConstantTimeEq.ct_ne := Datatypes.None;
  }.
End Impl_subtle_ConstantTimeEq_for_subtle_Choice_t.
End Impl_subtle_ConstantTimeEq_for_subtle_Choice_t.

Module  Impl_subtle_ConstantTimeEq_for_u8_t.
Section Impl_subtle_ConstantTimeEq_for_u8_t.
  Ltac Self := exact u8.t.
  
  (*
              fn ct_eq(&self, other: &$t_u) -> Choice {
                  // x == 0 if and only if self == other
                  let x: $t_u = self ^ other;
  
                  // If x == 0, then x and -x are both equal to zero;
                  // otherwise, one or both will have its high bit set.
                  let y: $t_u = (x | x.wrapping_neg()) >> ($bit_width - 1);
  
                  // Result is the opposite of the high bit (now shifted to low).
                  ((y ^ (1 as $t_u)) as u8).into()
              }
  *)
  Parameter ct_eq :
      (M.Val (ref ltac:(Self))) -> (M.Val (ref u8.t)) -> M subtle.Choice.t.
  
  Global Instance AssociatedFunction_ct_eq :
    Notations.DoubleColon ltac:(Self) "ct_eq" := {
    Notations.double_colon := ct_eq;
  }.
  
  Global Instance ℐ : subtle.ConstantTimeEq.Required.Trait ltac:(Self) := {
    subtle.ConstantTimeEq.ct_eq := ct_eq;
    subtle.ConstantTimeEq.ct_ne := Datatypes.None;
  }.
End Impl_subtle_ConstantTimeEq_for_u8_t.
End Impl_subtle_ConstantTimeEq_for_u8_t.

Module  Impl_subtle_ConstantTimeEq_for_i8_t.
Section Impl_subtle_ConstantTimeEq_for_i8_t.
  Ltac Self := exact i8.t.
  
  (*
              fn ct_eq(&self, other: &$t_i) -> Choice {
                  // Bitcast to unsigned and call that implementation.
                  ( *self as $t_u).ct_eq(&( *other as $t_u))
              }
  *)
  Parameter ct_eq :
      (M.Val (ref ltac:(Self))) -> (M.Val (ref i8.t)) -> M subtle.Choice.t.
  
  Global Instance AssociatedFunction_ct_eq :
    Notations.DoubleColon ltac:(Self) "ct_eq" := {
    Notations.double_colon := ct_eq;
  }.
  
  Global Instance ℐ : subtle.ConstantTimeEq.Required.Trait ltac:(Self) := {
    subtle.ConstantTimeEq.ct_eq := ct_eq;
    subtle.ConstantTimeEq.ct_ne := Datatypes.None;
  }.
End Impl_subtle_ConstantTimeEq_for_i8_t.
End Impl_subtle_ConstantTimeEq_for_i8_t.

Module  Impl_subtle_ConstantTimeEq_for_u16_t.
Section Impl_subtle_ConstantTimeEq_for_u16_t.
  Ltac Self := exact u16.t.
  
  (*
              fn ct_eq(&self, other: &$t_u) -> Choice {
                  // x == 0 if and only if self == other
                  let x: $t_u = self ^ other;
  
                  // If x == 0, then x and -x are both equal to zero;
                  // otherwise, one or both will have its high bit set.
                  let y: $t_u = (x | x.wrapping_neg()) >> ($bit_width - 1);
  
                  // Result is the opposite of the high bit (now shifted to low).
                  ((y ^ (1 as $t_u)) as u8).into()
              }
  *)
  Parameter ct_eq :
      (M.Val (ref ltac:(Self))) -> (M.Val (ref u16.t)) -> M subtle.Choice.t.
  
  Global Instance AssociatedFunction_ct_eq :
    Notations.DoubleColon ltac:(Self) "ct_eq" := {
    Notations.double_colon := ct_eq;
  }.
  
  Global Instance ℐ : subtle.ConstantTimeEq.Required.Trait ltac:(Self) := {
    subtle.ConstantTimeEq.ct_eq := ct_eq;
    subtle.ConstantTimeEq.ct_ne := Datatypes.None;
  }.
End Impl_subtle_ConstantTimeEq_for_u16_t.
End Impl_subtle_ConstantTimeEq_for_u16_t.

Module  Impl_subtle_ConstantTimeEq_for_i16_t.
Section Impl_subtle_ConstantTimeEq_for_i16_t.
  Ltac Self := exact i16.t.
  
  (*
              fn ct_eq(&self, other: &$t_i) -> Choice {
                  // Bitcast to unsigned and call that implementation.
                  ( *self as $t_u).ct_eq(&( *other as $t_u))
              }
  *)
  Parameter ct_eq :
      (M.Val (ref ltac:(Self))) -> (M.Val (ref i16.t)) -> M subtle.Choice.t.
  
  Global Instance AssociatedFunction_ct_eq :
    Notations.DoubleColon ltac:(Self) "ct_eq" := {
    Notations.double_colon := ct_eq;
  }.
  
  Global Instance ℐ : subtle.ConstantTimeEq.Required.Trait ltac:(Self) := {
    subtle.ConstantTimeEq.ct_eq := ct_eq;
    subtle.ConstantTimeEq.ct_ne := Datatypes.None;
  }.
End Impl_subtle_ConstantTimeEq_for_i16_t.
End Impl_subtle_ConstantTimeEq_for_i16_t.

Module  Impl_subtle_ConstantTimeEq_for_u32_t.
Section Impl_subtle_ConstantTimeEq_for_u32_t.
  Ltac Self := exact u32.t.
  
  (*
              fn ct_eq(&self, other: &$t_u) -> Choice {
                  // x == 0 if and only if self == other
                  let x: $t_u = self ^ other;
  
                  // If x == 0, then x and -x are both equal to zero;
                  // otherwise, one or both will have its high bit set.
                  let y: $t_u = (x | x.wrapping_neg()) >> ($bit_width - 1);
  
                  // Result is the opposite of the high bit (now shifted to low).
                  ((y ^ (1 as $t_u)) as u8).into()
              }
  *)
  Parameter ct_eq :
      (M.Val (ref ltac:(Self))) -> (M.Val (ref u32.t)) -> M subtle.Choice.t.
  
  Global Instance AssociatedFunction_ct_eq :
    Notations.DoubleColon ltac:(Self) "ct_eq" := {
    Notations.double_colon := ct_eq;
  }.
  
  Global Instance ℐ : subtle.ConstantTimeEq.Required.Trait ltac:(Self) := {
    subtle.ConstantTimeEq.ct_eq := ct_eq;
    subtle.ConstantTimeEq.ct_ne := Datatypes.None;
  }.
End Impl_subtle_ConstantTimeEq_for_u32_t.
End Impl_subtle_ConstantTimeEq_for_u32_t.

Module  Impl_subtle_ConstantTimeEq_for_i32_t.
Section Impl_subtle_ConstantTimeEq_for_i32_t.
  Ltac Self := exact i32.t.
  
  (*
              fn ct_eq(&self, other: &$t_i) -> Choice {
                  // Bitcast to unsigned and call that implementation.
                  ( *self as $t_u).ct_eq(&( *other as $t_u))
              }
  *)
  Parameter ct_eq :
      (M.Val (ref ltac:(Self))) -> (M.Val (ref i32.t)) -> M subtle.Choice.t.
  
  Global Instance AssociatedFunction_ct_eq :
    Notations.DoubleColon ltac:(Self) "ct_eq" := {
    Notations.double_colon := ct_eq;
  }.
  
  Global Instance ℐ : subtle.ConstantTimeEq.Required.Trait ltac:(Self) := {
    subtle.ConstantTimeEq.ct_eq := ct_eq;
    subtle.ConstantTimeEq.ct_ne := Datatypes.None;
  }.
End Impl_subtle_ConstantTimeEq_for_i32_t.
End Impl_subtle_ConstantTimeEq_for_i32_t.

Module  Impl_subtle_ConstantTimeEq_for_u64_t.
Section Impl_subtle_ConstantTimeEq_for_u64_t.
  Ltac Self := exact u64.t.
  
  (*
              fn ct_eq(&self, other: &$t_u) -> Choice {
                  // x == 0 if and only if self == other
                  let x: $t_u = self ^ other;
  
                  // If x == 0, then x and -x are both equal to zero;
                  // otherwise, one or both will have its high bit set.
                  let y: $t_u = (x | x.wrapping_neg()) >> ($bit_width - 1);
  
                  // Result is the opposite of the high bit (now shifted to low).
                  ((y ^ (1 as $t_u)) as u8).into()
              }
  *)
  Parameter ct_eq :
      (M.Val (ref ltac:(Self))) -> (M.Val (ref u64.t)) -> M subtle.Choice.t.
  
  Global Instance AssociatedFunction_ct_eq :
    Notations.DoubleColon ltac:(Self) "ct_eq" := {
    Notations.double_colon := ct_eq;
  }.
  
  Global Instance ℐ : subtle.ConstantTimeEq.Required.Trait ltac:(Self) := {
    subtle.ConstantTimeEq.ct_eq := ct_eq;
    subtle.ConstantTimeEq.ct_ne := Datatypes.None;
  }.
End Impl_subtle_ConstantTimeEq_for_u64_t.
End Impl_subtle_ConstantTimeEq_for_u64_t.

Module  Impl_subtle_ConstantTimeEq_for_i64_t.
Section Impl_subtle_ConstantTimeEq_for_i64_t.
  Ltac Self := exact i64.t.
  
  (*
              fn ct_eq(&self, other: &$t_i) -> Choice {
                  // Bitcast to unsigned and call that implementation.
                  ( *self as $t_u).ct_eq(&( *other as $t_u))
              }
  *)
  Parameter ct_eq :
      (M.Val (ref ltac:(Self))) -> (M.Val (ref i64.t)) -> M subtle.Choice.t.
  
  Global Instance AssociatedFunction_ct_eq :
    Notations.DoubleColon ltac:(Self) "ct_eq" := {
    Notations.double_colon := ct_eq;
  }.
  
  Global Instance ℐ : subtle.ConstantTimeEq.Required.Trait ltac:(Self) := {
    subtle.ConstantTimeEq.ct_eq := ct_eq;
    subtle.ConstantTimeEq.ct_ne := Datatypes.None;
  }.
End Impl_subtle_ConstantTimeEq_for_i64_t.
End Impl_subtle_ConstantTimeEq_for_i64_t.

Module  Impl_subtle_ConstantTimeEq_for_usize_t.
Section Impl_subtle_ConstantTimeEq_for_usize_t.
  Ltac Self := exact usize.t.
  
  (*
              fn ct_eq(&self, other: &$t_u) -> Choice {
                  // x == 0 if and only if self == other
                  let x: $t_u = self ^ other;
  
                  // If x == 0, then x and -x are both equal to zero;
                  // otherwise, one or both will have its high bit set.
                  let y: $t_u = (x | x.wrapping_neg()) >> ($bit_width - 1);
  
                  // Result is the opposite of the high bit (now shifted to low).
                  ((y ^ (1 as $t_u)) as u8).into()
              }
  *)
  Parameter ct_eq :
      (M.Val (ref ltac:(Self))) -> (M.Val (ref usize.t)) -> M subtle.Choice.t.
  
  Global Instance AssociatedFunction_ct_eq :
    Notations.DoubleColon ltac:(Self) "ct_eq" := {
    Notations.double_colon := ct_eq;
  }.
  
  Global Instance ℐ : subtle.ConstantTimeEq.Required.Trait ltac:(Self) := {
    subtle.ConstantTimeEq.ct_eq := ct_eq;
    subtle.ConstantTimeEq.ct_ne := Datatypes.None;
  }.
End Impl_subtle_ConstantTimeEq_for_usize_t.
End Impl_subtle_ConstantTimeEq_for_usize_t.

Module  Impl_subtle_ConstantTimeEq_for_isize_t.
Section Impl_subtle_ConstantTimeEq_for_isize_t.
  Ltac Self := exact isize.t.
  
  (*
              fn ct_eq(&self, other: &$t_i) -> Choice {
                  // Bitcast to unsigned and call that implementation.
                  ( *self as $t_u).ct_eq(&( *other as $t_u))
              }
  *)
  Parameter ct_eq :
      (M.Val (ref ltac:(Self))) -> (M.Val (ref isize.t)) -> M subtle.Choice.t.
  
  Global Instance AssociatedFunction_ct_eq :
    Notations.DoubleColon ltac:(Self) "ct_eq" := {
    Notations.double_colon := ct_eq;
  }.
  
  Global Instance ℐ : subtle.ConstantTimeEq.Required.Trait ltac:(Self) := {
    subtle.ConstantTimeEq.ct_eq := ct_eq;
    subtle.ConstantTimeEq.ct_ne := Datatypes.None;
  }.
End Impl_subtle_ConstantTimeEq_for_isize_t.
End Impl_subtle_ConstantTimeEq_for_isize_t.

Module  ConditionallySelectable.
Section ConditionallySelectable.
  Class Trait (Self : Set) : Type := {
    ℒ_0 :: core.marker.Copy.Trait Self;
    conditional_select :
      (ref ltac:(Self)) ->
        (ref ltac:(Self)) ->
        subtle.Choice.t ->
        M ltac:(Self);
  }.
  
End ConditionallySelectable.
End ConditionallySelectable.

Module  Impl_subtle_ConditionallySelectable_for_u8_t.
Section Impl_subtle_ConditionallySelectable_for_u8_t.
  Ltac Self := exact u8.t.
  
  (*
              fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  a ^ (mask & (a ^ b))
              }
  *)
  Parameter conditional_select :
      (M.Val (ref ltac:(Self))) ->
        (M.Val (ref ltac:(Self))) ->
        (M.Val subtle.Choice.t) ->
        M ltac:(Self).
  
  Global Instance AssociatedFunction_conditional_select :
    Notations.DoubleColon ltac:(Self) "conditional_select" := {
    Notations.double_colon := conditional_select;
  }.
  
  (*
              fn conditional_assign(&mut self, other: &Self, choice: Choice) {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  *self ^= mask & ( *self ^ *other);
              }
  *)
  Parameter conditional_assign :
      (M.Val (mut_ref ltac:(Self))) ->
        (M.Val (ref ltac:(Self))) ->
        (M.Val subtle.Choice.t) ->
        M unit.
  
  Global Instance AssociatedFunction_conditional_assign :
    Notations.DoubleColon ltac:(Self) "conditional_assign" := {
    Notations.double_colon := conditional_assign;
  }.
  
  (*
              fn conditional_swap(a: &mut Self, b: &mut Self, choice: Choice) {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  let t = mask & ( *a ^ *b);
                  *a ^= t;
                  *b ^= t;
              }
  *)
  Parameter conditional_swap :
      (M.Val (mut_ref ltac:(Self))) ->
        (M.Val (mut_ref ltac:(Self))) ->
        (M.Val subtle.Choice.t) ->
        M unit.
  
  Global Instance AssociatedFunction_conditional_swap :
    Notations.DoubleColon ltac:(Self) "conditional_swap" := {
    Notations.double_colon := conditional_swap;
  }.
  
  Global Instance ℐ :
    subtle.ConditionallySelectable.Required.Trait ltac:(Self) := {
    subtle.ConditionallySelectable.conditional_select := conditional_select;
    subtle.ConditionallySelectable.conditional_assign :=
      Datatypes.Some conditional_assign;
    subtle.ConditionallySelectable.conditional_swap :=
      Datatypes.Some conditional_swap;
  }.
End Impl_subtle_ConditionallySelectable_for_u8_t.
End Impl_subtle_ConditionallySelectable_for_u8_t.

Module  Impl_subtle_ConditionallySelectable_for_i8_t.
Section Impl_subtle_ConditionallySelectable_for_i8_t.
  Ltac Self := exact i8.t.
  
  (*
              fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  a ^ (mask & (a ^ b))
              }
  *)
  Parameter conditional_select :
      (M.Val (ref ltac:(Self))) ->
        (M.Val (ref ltac:(Self))) ->
        (M.Val subtle.Choice.t) ->
        M ltac:(Self).
  
  Global Instance AssociatedFunction_conditional_select :
    Notations.DoubleColon ltac:(Self) "conditional_select" := {
    Notations.double_colon := conditional_select;
  }.
  
  (*
              fn conditional_assign(&mut self, other: &Self, choice: Choice) {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  *self ^= mask & ( *self ^ *other);
              }
  *)
  Parameter conditional_assign :
      (M.Val (mut_ref ltac:(Self))) ->
        (M.Val (ref ltac:(Self))) ->
        (M.Val subtle.Choice.t) ->
        M unit.
  
  Global Instance AssociatedFunction_conditional_assign :
    Notations.DoubleColon ltac:(Self) "conditional_assign" := {
    Notations.double_colon := conditional_assign;
  }.
  
  (*
              fn conditional_swap(a: &mut Self, b: &mut Self, choice: Choice) {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  let t = mask & ( *a ^ *b);
                  *a ^= t;
                  *b ^= t;
              }
  *)
  Parameter conditional_swap :
      (M.Val (mut_ref ltac:(Self))) ->
        (M.Val (mut_ref ltac:(Self))) ->
        (M.Val subtle.Choice.t) ->
        M unit.
  
  Global Instance AssociatedFunction_conditional_swap :
    Notations.DoubleColon ltac:(Self) "conditional_swap" := {
    Notations.double_colon := conditional_swap;
  }.
  
  Global Instance ℐ :
    subtle.ConditionallySelectable.Required.Trait ltac:(Self) := {
    subtle.ConditionallySelectable.conditional_select := conditional_select;
    subtle.ConditionallySelectable.conditional_assign :=
      Datatypes.Some conditional_assign;
    subtle.ConditionallySelectable.conditional_swap :=
      Datatypes.Some conditional_swap;
  }.
End Impl_subtle_ConditionallySelectable_for_i8_t.
End Impl_subtle_ConditionallySelectable_for_i8_t.

Module  Impl_subtle_ConditionallySelectable_for_u16_t.
Section Impl_subtle_ConditionallySelectable_for_u16_t.
  Ltac Self := exact u16.t.
  
  (*
              fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  a ^ (mask & (a ^ b))
              }
  *)
  Parameter conditional_select :
      (M.Val (ref ltac:(Self))) ->
        (M.Val (ref ltac:(Self))) ->
        (M.Val subtle.Choice.t) ->
        M ltac:(Self).
  
  Global Instance AssociatedFunction_conditional_select :
    Notations.DoubleColon ltac:(Self) "conditional_select" := {
    Notations.double_colon := conditional_select;
  }.
  
  (*
              fn conditional_assign(&mut self, other: &Self, choice: Choice) {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  *self ^= mask & ( *self ^ *other);
              }
  *)
  Parameter conditional_assign :
      (M.Val (mut_ref ltac:(Self))) ->
        (M.Val (ref ltac:(Self))) ->
        (M.Val subtle.Choice.t) ->
        M unit.
  
  Global Instance AssociatedFunction_conditional_assign :
    Notations.DoubleColon ltac:(Self) "conditional_assign" := {
    Notations.double_colon := conditional_assign;
  }.
  
  (*
              fn conditional_swap(a: &mut Self, b: &mut Self, choice: Choice) {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  let t = mask & ( *a ^ *b);
                  *a ^= t;
                  *b ^= t;
              }
  *)
  Parameter conditional_swap :
      (M.Val (mut_ref ltac:(Self))) ->
        (M.Val (mut_ref ltac:(Self))) ->
        (M.Val subtle.Choice.t) ->
        M unit.
  
  Global Instance AssociatedFunction_conditional_swap :
    Notations.DoubleColon ltac:(Self) "conditional_swap" := {
    Notations.double_colon := conditional_swap;
  }.
  
  Global Instance ℐ :
    subtle.ConditionallySelectable.Required.Trait ltac:(Self) := {
    subtle.ConditionallySelectable.conditional_select := conditional_select;
    subtle.ConditionallySelectable.conditional_assign :=
      Datatypes.Some conditional_assign;
    subtle.ConditionallySelectable.conditional_swap :=
      Datatypes.Some conditional_swap;
  }.
End Impl_subtle_ConditionallySelectable_for_u16_t.
End Impl_subtle_ConditionallySelectable_for_u16_t.

Module  Impl_subtle_ConditionallySelectable_for_i16_t.
Section Impl_subtle_ConditionallySelectable_for_i16_t.
  Ltac Self := exact i16.t.
  
  (*
              fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  a ^ (mask & (a ^ b))
              }
  *)
  Parameter conditional_select :
      (M.Val (ref ltac:(Self))) ->
        (M.Val (ref ltac:(Self))) ->
        (M.Val subtle.Choice.t) ->
        M ltac:(Self).
  
  Global Instance AssociatedFunction_conditional_select :
    Notations.DoubleColon ltac:(Self) "conditional_select" := {
    Notations.double_colon := conditional_select;
  }.
  
  (*
              fn conditional_assign(&mut self, other: &Self, choice: Choice) {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  *self ^= mask & ( *self ^ *other);
              }
  *)
  Parameter conditional_assign :
      (M.Val (mut_ref ltac:(Self))) ->
        (M.Val (ref ltac:(Self))) ->
        (M.Val subtle.Choice.t) ->
        M unit.
  
  Global Instance AssociatedFunction_conditional_assign :
    Notations.DoubleColon ltac:(Self) "conditional_assign" := {
    Notations.double_colon := conditional_assign;
  }.
  
  (*
              fn conditional_swap(a: &mut Self, b: &mut Self, choice: Choice) {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  let t = mask & ( *a ^ *b);
                  *a ^= t;
                  *b ^= t;
              }
  *)
  Parameter conditional_swap :
      (M.Val (mut_ref ltac:(Self))) ->
        (M.Val (mut_ref ltac:(Self))) ->
        (M.Val subtle.Choice.t) ->
        M unit.
  
  Global Instance AssociatedFunction_conditional_swap :
    Notations.DoubleColon ltac:(Self) "conditional_swap" := {
    Notations.double_colon := conditional_swap;
  }.
  
  Global Instance ℐ :
    subtle.ConditionallySelectable.Required.Trait ltac:(Self) := {
    subtle.ConditionallySelectable.conditional_select := conditional_select;
    subtle.ConditionallySelectable.conditional_assign :=
      Datatypes.Some conditional_assign;
    subtle.ConditionallySelectable.conditional_swap :=
      Datatypes.Some conditional_swap;
  }.
End Impl_subtle_ConditionallySelectable_for_i16_t.
End Impl_subtle_ConditionallySelectable_for_i16_t.

Module  Impl_subtle_ConditionallySelectable_for_u32_t.
Section Impl_subtle_ConditionallySelectable_for_u32_t.
  Ltac Self := exact u32.t.
  
  (*
              fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  a ^ (mask & (a ^ b))
              }
  *)
  Parameter conditional_select :
      (M.Val (ref ltac:(Self))) ->
        (M.Val (ref ltac:(Self))) ->
        (M.Val subtle.Choice.t) ->
        M ltac:(Self).
  
  Global Instance AssociatedFunction_conditional_select :
    Notations.DoubleColon ltac:(Self) "conditional_select" := {
    Notations.double_colon := conditional_select;
  }.
  
  (*
              fn conditional_assign(&mut self, other: &Self, choice: Choice) {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  *self ^= mask & ( *self ^ *other);
              }
  *)
  Parameter conditional_assign :
      (M.Val (mut_ref ltac:(Self))) ->
        (M.Val (ref ltac:(Self))) ->
        (M.Val subtle.Choice.t) ->
        M unit.
  
  Global Instance AssociatedFunction_conditional_assign :
    Notations.DoubleColon ltac:(Self) "conditional_assign" := {
    Notations.double_colon := conditional_assign;
  }.
  
  (*
              fn conditional_swap(a: &mut Self, b: &mut Self, choice: Choice) {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  let t = mask & ( *a ^ *b);
                  *a ^= t;
                  *b ^= t;
              }
  *)
  Parameter conditional_swap :
      (M.Val (mut_ref ltac:(Self))) ->
        (M.Val (mut_ref ltac:(Self))) ->
        (M.Val subtle.Choice.t) ->
        M unit.
  
  Global Instance AssociatedFunction_conditional_swap :
    Notations.DoubleColon ltac:(Self) "conditional_swap" := {
    Notations.double_colon := conditional_swap;
  }.
  
  Global Instance ℐ :
    subtle.ConditionallySelectable.Required.Trait ltac:(Self) := {
    subtle.ConditionallySelectable.conditional_select := conditional_select;
    subtle.ConditionallySelectable.conditional_assign :=
      Datatypes.Some conditional_assign;
    subtle.ConditionallySelectable.conditional_swap :=
      Datatypes.Some conditional_swap;
  }.
End Impl_subtle_ConditionallySelectable_for_u32_t.
End Impl_subtle_ConditionallySelectable_for_u32_t.

Module  Impl_subtle_ConditionallySelectable_for_i32_t.
Section Impl_subtle_ConditionallySelectable_for_i32_t.
  Ltac Self := exact i32.t.
  
  (*
              fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  a ^ (mask & (a ^ b))
              }
  *)
  Parameter conditional_select :
      (M.Val (ref ltac:(Self))) ->
        (M.Val (ref ltac:(Self))) ->
        (M.Val subtle.Choice.t) ->
        M ltac:(Self).
  
  Global Instance AssociatedFunction_conditional_select :
    Notations.DoubleColon ltac:(Self) "conditional_select" := {
    Notations.double_colon := conditional_select;
  }.
  
  (*
              fn conditional_assign(&mut self, other: &Self, choice: Choice) {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  *self ^= mask & ( *self ^ *other);
              }
  *)
  Parameter conditional_assign :
      (M.Val (mut_ref ltac:(Self))) ->
        (M.Val (ref ltac:(Self))) ->
        (M.Val subtle.Choice.t) ->
        M unit.
  
  Global Instance AssociatedFunction_conditional_assign :
    Notations.DoubleColon ltac:(Self) "conditional_assign" := {
    Notations.double_colon := conditional_assign;
  }.
  
  (*
              fn conditional_swap(a: &mut Self, b: &mut Self, choice: Choice) {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  let t = mask & ( *a ^ *b);
                  *a ^= t;
                  *b ^= t;
              }
  *)
  Parameter conditional_swap :
      (M.Val (mut_ref ltac:(Self))) ->
        (M.Val (mut_ref ltac:(Self))) ->
        (M.Val subtle.Choice.t) ->
        M unit.
  
  Global Instance AssociatedFunction_conditional_swap :
    Notations.DoubleColon ltac:(Self) "conditional_swap" := {
    Notations.double_colon := conditional_swap;
  }.
  
  Global Instance ℐ :
    subtle.ConditionallySelectable.Required.Trait ltac:(Self) := {
    subtle.ConditionallySelectable.conditional_select := conditional_select;
    subtle.ConditionallySelectable.conditional_assign :=
      Datatypes.Some conditional_assign;
    subtle.ConditionallySelectable.conditional_swap :=
      Datatypes.Some conditional_swap;
  }.
End Impl_subtle_ConditionallySelectable_for_i32_t.
End Impl_subtle_ConditionallySelectable_for_i32_t.

Module  Impl_subtle_ConditionallySelectable_for_u64_t.
Section Impl_subtle_ConditionallySelectable_for_u64_t.
  Ltac Self := exact u64.t.
  
  (*
              fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  a ^ (mask & (a ^ b))
              }
  *)
  Parameter conditional_select :
      (M.Val (ref ltac:(Self))) ->
        (M.Val (ref ltac:(Self))) ->
        (M.Val subtle.Choice.t) ->
        M ltac:(Self).
  
  Global Instance AssociatedFunction_conditional_select :
    Notations.DoubleColon ltac:(Self) "conditional_select" := {
    Notations.double_colon := conditional_select;
  }.
  
  (*
              fn conditional_assign(&mut self, other: &Self, choice: Choice) {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  *self ^= mask & ( *self ^ *other);
              }
  *)
  Parameter conditional_assign :
      (M.Val (mut_ref ltac:(Self))) ->
        (M.Val (ref ltac:(Self))) ->
        (M.Val subtle.Choice.t) ->
        M unit.
  
  Global Instance AssociatedFunction_conditional_assign :
    Notations.DoubleColon ltac:(Self) "conditional_assign" := {
    Notations.double_colon := conditional_assign;
  }.
  
  (*
              fn conditional_swap(a: &mut Self, b: &mut Self, choice: Choice) {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  let t = mask & ( *a ^ *b);
                  *a ^= t;
                  *b ^= t;
              }
  *)
  Parameter conditional_swap :
      (M.Val (mut_ref ltac:(Self))) ->
        (M.Val (mut_ref ltac:(Self))) ->
        (M.Val subtle.Choice.t) ->
        M unit.
  
  Global Instance AssociatedFunction_conditional_swap :
    Notations.DoubleColon ltac:(Self) "conditional_swap" := {
    Notations.double_colon := conditional_swap;
  }.
  
  Global Instance ℐ :
    subtle.ConditionallySelectable.Required.Trait ltac:(Self) := {
    subtle.ConditionallySelectable.conditional_select := conditional_select;
    subtle.ConditionallySelectable.conditional_assign :=
      Datatypes.Some conditional_assign;
    subtle.ConditionallySelectable.conditional_swap :=
      Datatypes.Some conditional_swap;
  }.
End Impl_subtle_ConditionallySelectable_for_u64_t.
End Impl_subtle_ConditionallySelectable_for_u64_t.

Module  Impl_subtle_ConditionallySelectable_for_i64_t.
Section Impl_subtle_ConditionallySelectable_for_i64_t.
  Ltac Self := exact i64.t.
  
  (*
              fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  a ^ (mask & (a ^ b))
              }
  *)
  Parameter conditional_select :
      (M.Val (ref ltac:(Self))) ->
        (M.Val (ref ltac:(Self))) ->
        (M.Val subtle.Choice.t) ->
        M ltac:(Self).
  
  Global Instance AssociatedFunction_conditional_select :
    Notations.DoubleColon ltac:(Self) "conditional_select" := {
    Notations.double_colon := conditional_select;
  }.
  
  (*
              fn conditional_assign(&mut self, other: &Self, choice: Choice) {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  *self ^= mask & ( *self ^ *other);
              }
  *)
  Parameter conditional_assign :
      (M.Val (mut_ref ltac:(Self))) ->
        (M.Val (ref ltac:(Self))) ->
        (M.Val subtle.Choice.t) ->
        M unit.
  
  Global Instance AssociatedFunction_conditional_assign :
    Notations.DoubleColon ltac:(Self) "conditional_assign" := {
    Notations.double_colon := conditional_assign;
  }.
  
  (*
              fn conditional_swap(a: &mut Self, b: &mut Self, choice: Choice) {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  let t = mask & ( *a ^ *b);
                  *a ^= t;
                  *b ^= t;
              }
  *)
  Parameter conditional_swap :
      (M.Val (mut_ref ltac:(Self))) ->
        (M.Val (mut_ref ltac:(Self))) ->
        (M.Val subtle.Choice.t) ->
        M unit.
  
  Global Instance AssociatedFunction_conditional_swap :
    Notations.DoubleColon ltac:(Self) "conditional_swap" := {
    Notations.double_colon := conditional_swap;
  }.
  
  Global Instance ℐ :
    subtle.ConditionallySelectable.Required.Trait ltac:(Self) := {
    subtle.ConditionallySelectable.conditional_select := conditional_select;
    subtle.ConditionallySelectable.conditional_assign :=
      Datatypes.Some conditional_assign;
    subtle.ConditionallySelectable.conditional_swap :=
      Datatypes.Some conditional_swap;
  }.
End Impl_subtle_ConditionallySelectable_for_i64_t.
End Impl_subtle_ConditionallySelectable_for_i64_t.

Module  Impl_subtle_ConditionallySelectable_for_subtle_Choice_t.
Section Impl_subtle_ConditionallySelectable_for_subtle_Choice_t.
  Ltac Self := exact subtle.Choice.t.
  
  (*
      fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {
          Choice(u8::conditional_select(&a.0, &b.0, choice))
      }
  *)
  Parameter conditional_select :
      (M.Val (ref ltac:(Self))) ->
        (M.Val (ref ltac:(Self))) ->
        (M.Val subtle.Choice.t) ->
        M ltac:(Self).
  
  Global Instance AssociatedFunction_conditional_select :
    Notations.DoubleColon ltac:(Self) "conditional_select" := {
    Notations.double_colon := conditional_select;
  }.
  
  Global Instance ℐ :
    subtle.ConditionallySelectable.Required.Trait ltac:(Self) := {
    subtle.ConditionallySelectable.conditional_select := conditional_select;
    subtle.ConditionallySelectable.conditional_assign := Datatypes.None;
    subtle.ConditionallySelectable.conditional_swap := Datatypes.None;
  }.
End Impl_subtle_ConditionallySelectable_for_subtle_Choice_t.
End Impl_subtle_ConditionallySelectable_for_subtle_Choice_t.

Module  ConditionallyNegatable.
Section ConditionallyNegatable.
  Class Trait (Self : Set) : Type := {
    conditional_negate : (mut_ref ltac:(Self)) -> subtle.Choice.t -> M unit;
  }.
  
End ConditionallyNegatable.
End ConditionallyNegatable.

Module  Impl_subtle_ConditionallyNegatable_for_T.
Section Impl_subtle_ConditionallyNegatable_for_T.
  Context {T : Set}.
  
  Context
    {ℋ_0 : subtle.ConditionallySelectable.Trait T}
    {ℋ_1 : core.ops.arith.Neg.Trait (ref T)}.
  
  Ltac Self := exact T.
  
  (*
      fn conditional_negate(&mut self, choice: Choice) {
          // Need to cast to eliminate mutability
          let self_neg: T = -(self as &T);
          self.conditional_assign(&self_neg, choice);
      }
  *)
  Parameter conditional_negate :
      (M.Val (mut_ref ltac:(Self))) -> (M.Val subtle.Choice.t) -> M unit.
  
  Global Instance AssociatedFunction_conditional_negate :
    Notations.DoubleColon ltac:(Self) "conditional_negate" := {
    Notations.double_colon := conditional_negate;
  }.
  
  Global Instance ℐ : subtle.ConditionallyNegatable.Trait ltac:(Self) := {
    subtle.ConditionallyNegatable.conditional_negate := conditional_negate;
  }.
End Impl_subtle_ConditionallyNegatable_for_T.
End Impl_subtle_ConditionallyNegatable_for_T.

Module  CtOption.
Section CtOption.
  Context (T : Set).
  
  Record t : Set := {
    value : T;
    is_some : subtle.Choice.t;
  }.
  
  Global Instance Get_value : Notations.Dot "value" := {
    Notations.dot :=
      Ref.map (fun x => x.(value)) (fun v x => x <| value := v |>);
  }.
  Global Instance Get_AF_value : Notations.DoubleColon t "value" := {
    Notations.double_colon (x : M.Val t) := x.["value"];
  }.
  Global Instance Get_is_some : Notations.Dot "is_some" := {
    Notations.dot :=
      Ref.map (fun x => x.(is_some)) (fun v x => x <| is_some := v |>);
  }.
  Global Instance Get_AF_is_some : Notations.DoubleColon t "is_some" := {
    Notations.double_colon (x : M.Val t) := x.["is_some"];
  }.
End CtOption.
End CtOption.

Module  Impl_core_clone_Clone_for_subtle_CtOption_t_T.
Section Impl_core_clone_Clone_for_subtle_CtOption_t_T.
  Context {T : Set}.
  
  Context {ℋ_0 : core.clone.Clone.Trait T}.
  
  Ltac Self := exact (subtle.CtOption.t T).
  
  (*
  Clone
  *)
  Parameter clone : (M.Val (ref ltac:(Self))) -> M (subtle.CtOption.t T).
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon ltac:(Self) "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait ltac:(Self) := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_subtle_CtOption_t_T.
End Impl_core_clone_Clone_for_subtle_CtOption_t_T.

Module  Impl_core_marker_Copy_for_subtle_CtOption_t_T.
Section Impl_core_marker_Copy_for_subtle_CtOption_t_T.
  Context {T : Set}.
  
  Context {ℋ_0 : core.marker.Copy.Trait T}.
  
  Ltac Self := exact (subtle.CtOption.t T).
  
  Global Instance ℐ : core.marker.Copy.Trait ltac:(Self) := {
  }.
End Impl_core_marker_Copy_for_subtle_CtOption_t_T.
End Impl_core_marker_Copy_for_subtle_CtOption_t_T.

Module  Impl_core_fmt_Debug_for_subtle_CtOption_t_T.
Section Impl_core_fmt_Debug_for_subtle_CtOption_t_T.
  Context {T : Set}.
  
  Context {ℋ_0 : core.fmt.Debug.Trait T}.
  
  Ltac Self := exact (subtle.CtOption.t T).
  
  (*
  Debug
  *)
  Parameter fmt :
      (M.Val (ref ltac:(Self))) ->
        (M.Val (mut_ref core.fmt.Formatter.t)) ->
        M ltac:(core.fmt.Result).
  
  Global Instance AssociatedFunction_fmt :
    Notations.DoubleColon ltac:(Self) "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait ltac:(Self) := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_subtle_CtOption_t_T.
End Impl_core_fmt_Debug_for_subtle_CtOption_t_T.

Module  Impl_core_convert_From_subtle_CtOption_t_T_for_core_option_Option_t_T.
Section Impl_core_convert_From_subtle_CtOption_t_T_for_core_option_Option_t_T.
  Context {T : Set}.
  
  Ltac Self := exact (core.option.Option.t T).
  
  (*
      fn from(source: CtOption<T>) -> Option<T> {
          if source.is_some().unwrap_u8() == 1u8 {
              Option::Some(source.value)
          } else {
              None
          }
      }
  *)
  Parameter from : (M.Val (subtle.CtOption.t T)) -> M (core.option.Option.t T).
  
  Global Instance AssociatedFunction_from :
    Notations.DoubleColon ltac:(Self) "from" := {
    Notations.double_colon := from;
  }.
  
  Global Instance ℐ :
    core.convert.From.Trait ltac:(Self) (T := subtle.CtOption.t T) := {
    core.convert.From.from := from;
  }.
End Impl_core_convert_From_subtle_CtOption_t_T_for_core_option_Option_t_T.
End Impl_core_convert_From_subtle_CtOption_t_T_for_core_option_Option_t_T.

Module  Impl_subtle_CtOption_t_T.
Section Impl_subtle_CtOption_t_T.
  Context {T : Set}.
  
  Ltac Self := exact (subtle.CtOption.t T).
  
  (*
      pub fn new(value: T, is_some: Choice) -> CtOption<T> {
          CtOption {
              value: value,
              is_some: is_some,
          }
      }
  *)
  Parameter new :
      (M.Val T) -> (M.Val subtle.Choice.t) -> M (subtle.CtOption.t T).
  
  Global Instance AssociatedFunction_new :
    Notations.DoubleColon ltac:(Self) "new" := {
    Notations.double_colon := new;
  }.
  
  (*
      pub fn expect(self, msg: &str) -> T {
          assert_eq!(self.is_some.unwrap_u8(), 1, "{}", msg);
  
          self.value
      }
  *)
  Parameter expect : (M.Val ltac:(Self)) -> (M.Val (ref str.t)) -> M T.
  
  Global Instance AssociatedFunction_expect :
    Notations.DoubleColon ltac:(Self) "expect" := {
    Notations.double_colon := expect;
  }.
  
  (*
      pub fn unwrap(self) -> T {
          assert_eq!(self.is_some.unwrap_u8(), 1);
  
          self.value
      }
  *)
  Parameter unwrap : (M.Val ltac:(Self)) -> M T.
  
  Global Instance AssociatedFunction_unwrap :
    Notations.DoubleColon ltac:(Self) "unwrap" := {
    Notations.double_colon := unwrap;
  }.
  
  (*
      pub fn unwrap_or(self, def: T) -> T
      where
          T: ConditionallySelectable,
      {
          T::conditional_select(&def, &self.value, self.is_some)
      }
  *)
  Parameter unwrap_or :
      forall {ℋ_0 : subtle.ConditionallySelectable.Trait T},
      (M.Val ltac:(Self)) -> (M.Val T) -> M T.
  
  Global Instance AssociatedFunction_unwrap_or
      {ℋ_0 : subtle.ConditionallySelectable.Trait T} :
    Notations.DoubleColon ltac:(Self) "unwrap_or" := {
    Notations.double_colon := unwrap_or;
  }.
  
  (*
      pub fn unwrap_or_else<F>(self, f: F) -> T
      where
          T: ConditionallySelectable,
          F: FnOnce() -> T,
      {
          T::conditional_select(&f(), &self.value, self.is_some)
      }
  *)
  Parameter unwrap_or_else :
      forall
        {F : Set}
        {ℋ_0 : subtle.ConditionallySelectable.Trait T}
        {ℋ_1 : core.ops.function.FnOnce.Trait F (Args := unit)},
      (M.Val ltac:(Self)) -> (M.Val F) -> M T.
  
  Global Instance AssociatedFunction_unwrap_or_else
      {F : Set}
      {ℋ_0 : subtle.ConditionallySelectable.Trait T}
      {ℋ_1 : core.ops.function.FnOnce.Trait F (Args := unit)} :
    Notations.DoubleColon ltac:(Self) "unwrap_or_else" := {
    Notations.double_colon := unwrap_or_else (F := F);
  }.
  
  (*
      pub fn is_some(&self) -> Choice {
          self.is_some
      }
  *)
  Parameter is_some : (M.Val (ref ltac:(Self))) -> M subtle.Choice.t.
  
  Global Instance AssociatedFunction_is_some :
    Notations.DoubleColon ltac:(Self) "is_some" := {
    Notations.double_colon := is_some;
  }.
  
  (*
      pub fn is_none(&self) -> Choice {
          !self.is_some
      }
  *)
  Parameter is_none : (M.Val (ref ltac:(Self))) -> M subtle.Choice.t.
  
  Global Instance AssociatedFunction_is_none :
    Notations.DoubleColon ltac:(Self) "is_none" := {
    Notations.double_colon := is_none;
  }.
  
  (*
      pub fn map<U, F>(self, f: F) -> CtOption<U>
      where
          T: Default + ConditionallySelectable,
          F: FnOnce(T) -> U,
      {
          CtOption::new(
              f(T::conditional_select(
                  &T::default(),
                  &self.value,
                  self.is_some,
              )),
              self.is_some,
          )
      }
  *)
  Parameter map :
      forall
        {U F : Set}
        {ℋ_0 : core.default.Default.Trait T}
        {ℋ_1 : subtle.ConditionallySelectable.Trait T}
        {ℋ_2 : core.ops.function.FnOnce.Trait F (Args := T)},
      (M.Val ltac:(Self)) -> (M.Val F) -> M (subtle.CtOption.t U).
  
  Global Instance AssociatedFunction_map
      {U F : Set}
      {ℋ_0 : core.default.Default.Trait T}
      {ℋ_1 : subtle.ConditionallySelectable.Trait T}
      {ℋ_2 : core.ops.function.FnOnce.Trait F (Args := T)} :
    Notations.DoubleColon ltac:(Self) "map" := {
    Notations.double_colon := map (U := U) (F := F);
  }.
  
  (*
      pub fn and_then<U, F>(self, f: F) -> CtOption<U>
      where
          T: Default + ConditionallySelectable,
          F: FnOnce(T) -> CtOption<U>,
      {
          let mut tmp = f(T::conditional_select(
              &T::default(),
              &self.value,
              self.is_some,
          ));
          tmp.is_some &= self.is_some;
  
          tmp
      }
  *)
  Parameter and_then :
      forall
        {U F : Set}
        {ℋ_0 : core.default.Default.Trait T}
        {ℋ_1 : subtle.ConditionallySelectable.Trait T}
        {ℋ_2 : core.ops.function.FnOnce.Trait F (Args := T)},
      (M.Val ltac:(Self)) -> (M.Val F) -> M (subtle.CtOption.t U).
  
  Global Instance AssociatedFunction_and_then
      {U F : Set}
      {ℋ_0 : core.default.Default.Trait T}
      {ℋ_1 : subtle.ConditionallySelectable.Trait T}
      {ℋ_2 : core.ops.function.FnOnce.Trait F (Args := T)} :
    Notations.DoubleColon ltac:(Self) "and_then" := {
    Notations.double_colon := and_then (U := U) (F := F);
  }.
  
  (*
      pub fn or_else<F>(self, f: F) -> CtOption<T>
      where
          T: ConditionallySelectable,
          F: FnOnce() -> CtOption<T>,
      {
          let is_none = self.is_none();
          let f = f();
  
          Self::conditional_select(&self, &f, is_none)
      }
  *)
  Parameter or_else :
      forall
        {F : Set}
        {ℋ_0 : subtle.ConditionallySelectable.Trait T}
        {ℋ_1 : core.ops.function.FnOnce.Trait F (Args := unit)},
      (M.Val ltac:(Self)) -> (M.Val F) -> M (subtle.CtOption.t T).
  
  Global Instance AssociatedFunction_or_else
      {F : Set}
      {ℋ_0 : subtle.ConditionallySelectable.Trait T}
      {ℋ_1 : core.ops.function.FnOnce.Trait F (Args := unit)} :
    Notations.DoubleColon ltac:(Self) "or_else" := {
    Notations.double_colon := or_else (F := F);
  }.
End Impl_subtle_CtOption_t_T.
End Impl_subtle_CtOption_t_T.

Module  Impl_subtle_ConditionallySelectable_for_subtle_CtOption_t_T.
Section Impl_subtle_ConditionallySelectable_for_subtle_CtOption_t_T.
  Context {T : Set}.
  
  Context {ℋ_0 : subtle.ConditionallySelectable.Trait T}.
  
  Ltac Self := exact (subtle.CtOption.t T).
  
  (*
      fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {
          CtOption::new(
              T::conditional_select(&a.value, &b.value, choice),
              Choice::conditional_select(&a.is_some, &b.is_some, choice),
          )
      }
  *)
  Parameter conditional_select :
      (M.Val (ref ltac:(Self))) ->
        (M.Val (ref ltac:(Self))) ->
        (M.Val subtle.Choice.t) ->
        M ltac:(Self).
  
  Global Instance AssociatedFunction_conditional_select :
    Notations.DoubleColon ltac:(Self) "conditional_select" := {
    Notations.double_colon := conditional_select;
  }.
  
  Global Instance ℐ :
    subtle.ConditionallySelectable.Required.Trait ltac:(Self) := {
    subtle.ConditionallySelectable.conditional_select := conditional_select;
    subtle.ConditionallySelectable.conditional_assign := Datatypes.None;
    subtle.ConditionallySelectable.conditional_swap := Datatypes.None;
  }.
End Impl_subtle_ConditionallySelectable_for_subtle_CtOption_t_T.
End Impl_subtle_ConditionallySelectable_for_subtle_CtOption_t_T.

Module  Impl_subtle_ConstantTimeEq_for_subtle_CtOption_t_T.
Section Impl_subtle_ConstantTimeEq_for_subtle_CtOption_t_T.
  Context {T : Set}.
  
  Context {ℋ_0 : subtle.ConstantTimeEq.Trait T}.
  
  Ltac Self := exact (subtle.CtOption.t T).
  
  (*
      fn ct_eq(&self, rhs: &CtOption<T>) -> Choice {
          let a = self.is_some();
          let b = rhs.is_some();
  
          (a & b & self.value.ct_eq(&rhs.value)) | (!a & !b)
      }
  *)
  Parameter ct_eq :
      (M.Val (ref ltac:(Self))) ->
        (M.Val (ref (subtle.CtOption.t T))) ->
        M subtle.Choice.t.
  
  Global Instance AssociatedFunction_ct_eq :
    Notations.DoubleColon ltac:(Self) "ct_eq" := {
    Notations.double_colon := ct_eq;
  }.
  
  Global Instance ℐ : subtle.ConstantTimeEq.Required.Trait ltac:(Self) := {
    subtle.ConstantTimeEq.ct_eq := ct_eq;
    subtle.ConstantTimeEq.ct_ne := Datatypes.None;
  }.
End Impl_subtle_ConstantTimeEq_for_subtle_CtOption_t_T.
End Impl_subtle_ConstantTimeEq_for_subtle_CtOption_t_T.

Module  ConstantTimeGreater.
Section ConstantTimeGreater.
  Class Trait (Self : Set) : Type := {
    ct_gt : (ref ltac:(Self)) -> (ref ltac:(Self)) -> M subtle.Choice.t;
  }.
  
End ConstantTimeGreater.
End ConstantTimeGreater.

Module  Impl_subtle_ConstantTimeGreater_for_u8_t.
Section Impl_subtle_ConstantTimeGreater_for_u8_t.
  Ltac Self := exact u8.t.
  
  (*
              fn ct_gt(&self, other: &$t_u) -> Choice {
                  let gtb = self & !other; // All the bits in self that are greater than their corresponding bits in other.
                  let mut ltb = !self & other; // All the bits in self that are less than their corresponding bits in other.
                  let mut pow = 1;
  
                  // Less-than operator is okay here because it's dependent on the bit-width.
                  while pow < $bit_width {
                      ltb |= ltb >> pow; // Bit-smear the highest set bit to the right.
                      pow += pow;
                  }
                  let mut bit = gtb & !ltb; // Select the highest set bit.
                  let mut pow = 1;
  
                  while pow < $bit_width {
                      bit |= bit >> pow; // Shift it to the right until we end up with either 0 or 1.
                      pow += pow;
                  }
                  // XXX We should possibly do the above flattening to 0 or 1 in the
                  //     Choice constructor rather than making it a debug error?
                  Choice::from((bit & 1) as u8)
              }
  *)
  Parameter ct_gt :
      (M.Val (ref ltac:(Self))) -> (M.Val (ref u8.t)) -> M subtle.Choice.t.
  
  Global Instance AssociatedFunction_ct_gt :
    Notations.DoubleColon ltac:(Self) "ct_gt" := {
    Notations.double_colon := ct_gt;
  }.
  
  Global Instance ℐ : subtle.ConstantTimeGreater.Trait ltac:(Self) := {
    subtle.ConstantTimeGreater.ct_gt := ct_gt;
  }.
End Impl_subtle_ConstantTimeGreater_for_u8_t.
End Impl_subtle_ConstantTimeGreater_for_u8_t.

Module  Impl_subtle_ConstantTimeGreater_for_u16_t.
Section Impl_subtle_ConstantTimeGreater_for_u16_t.
  Ltac Self := exact u16.t.
  
  (*
              fn ct_gt(&self, other: &$t_u) -> Choice {
                  let gtb = self & !other; // All the bits in self that are greater than their corresponding bits in other.
                  let mut ltb = !self & other; // All the bits in self that are less than their corresponding bits in other.
                  let mut pow = 1;
  
                  // Less-than operator is okay here because it's dependent on the bit-width.
                  while pow < $bit_width {
                      ltb |= ltb >> pow; // Bit-smear the highest set bit to the right.
                      pow += pow;
                  }
                  let mut bit = gtb & !ltb; // Select the highest set bit.
                  let mut pow = 1;
  
                  while pow < $bit_width {
                      bit |= bit >> pow; // Shift it to the right until we end up with either 0 or 1.
                      pow += pow;
                  }
                  // XXX We should possibly do the above flattening to 0 or 1 in the
                  //     Choice constructor rather than making it a debug error?
                  Choice::from((bit & 1) as u8)
              }
  *)
  Parameter ct_gt :
      (M.Val (ref ltac:(Self))) -> (M.Val (ref u16.t)) -> M subtle.Choice.t.
  
  Global Instance AssociatedFunction_ct_gt :
    Notations.DoubleColon ltac:(Self) "ct_gt" := {
    Notations.double_colon := ct_gt;
  }.
  
  Global Instance ℐ : subtle.ConstantTimeGreater.Trait ltac:(Self) := {
    subtle.ConstantTimeGreater.ct_gt := ct_gt;
  }.
End Impl_subtle_ConstantTimeGreater_for_u16_t.
End Impl_subtle_ConstantTimeGreater_for_u16_t.

Module  Impl_subtle_ConstantTimeGreater_for_u32_t.
Section Impl_subtle_ConstantTimeGreater_for_u32_t.
  Ltac Self := exact u32.t.
  
  (*
              fn ct_gt(&self, other: &$t_u) -> Choice {
                  let gtb = self & !other; // All the bits in self that are greater than their corresponding bits in other.
                  let mut ltb = !self & other; // All the bits in self that are less than their corresponding bits in other.
                  let mut pow = 1;
  
                  // Less-than operator is okay here because it's dependent on the bit-width.
                  while pow < $bit_width {
                      ltb |= ltb >> pow; // Bit-smear the highest set bit to the right.
                      pow += pow;
                  }
                  let mut bit = gtb & !ltb; // Select the highest set bit.
                  let mut pow = 1;
  
                  while pow < $bit_width {
                      bit |= bit >> pow; // Shift it to the right until we end up with either 0 or 1.
                      pow += pow;
                  }
                  // XXX We should possibly do the above flattening to 0 or 1 in the
                  //     Choice constructor rather than making it a debug error?
                  Choice::from((bit & 1) as u8)
              }
  *)
  Parameter ct_gt :
      (M.Val (ref ltac:(Self))) -> (M.Val (ref u32.t)) -> M subtle.Choice.t.
  
  Global Instance AssociatedFunction_ct_gt :
    Notations.DoubleColon ltac:(Self) "ct_gt" := {
    Notations.double_colon := ct_gt;
  }.
  
  Global Instance ℐ : subtle.ConstantTimeGreater.Trait ltac:(Self) := {
    subtle.ConstantTimeGreater.ct_gt := ct_gt;
  }.
End Impl_subtle_ConstantTimeGreater_for_u32_t.
End Impl_subtle_ConstantTimeGreater_for_u32_t.

Module  Impl_subtle_ConstantTimeGreater_for_u64_t.
Section Impl_subtle_ConstantTimeGreater_for_u64_t.
  Ltac Self := exact u64.t.
  
  (*
              fn ct_gt(&self, other: &$t_u) -> Choice {
                  let gtb = self & !other; // All the bits in self that are greater than their corresponding bits in other.
                  let mut ltb = !self & other; // All the bits in self that are less than their corresponding bits in other.
                  let mut pow = 1;
  
                  // Less-than operator is okay here because it's dependent on the bit-width.
                  while pow < $bit_width {
                      ltb |= ltb >> pow; // Bit-smear the highest set bit to the right.
                      pow += pow;
                  }
                  let mut bit = gtb & !ltb; // Select the highest set bit.
                  let mut pow = 1;
  
                  while pow < $bit_width {
                      bit |= bit >> pow; // Shift it to the right until we end up with either 0 or 1.
                      pow += pow;
                  }
                  // XXX We should possibly do the above flattening to 0 or 1 in the
                  //     Choice constructor rather than making it a debug error?
                  Choice::from((bit & 1) as u8)
              }
  *)
  Parameter ct_gt :
      (M.Val (ref ltac:(Self))) -> (M.Val (ref u64.t)) -> M subtle.Choice.t.
  
  Global Instance AssociatedFunction_ct_gt :
    Notations.DoubleColon ltac:(Self) "ct_gt" := {
    Notations.double_colon := ct_gt;
  }.
  
  Global Instance ℐ : subtle.ConstantTimeGreater.Trait ltac:(Self) := {
    subtle.ConstantTimeGreater.ct_gt := ct_gt;
  }.
End Impl_subtle_ConstantTimeGreater_for_u64_t.
End Impl_subtle_ConstantTimeGreater_for_u64_t.

Module  ConstantTimeLess.
Section ConstantTimeLess.
  Class Trait (Self : Set) : Type := {
    ℒ_0 :: subtle.ConstantTimeEq.Trait Self;
    ℒ_1 :: subtle.ConstantTimeGreater.Trait Self;
  }.
  
End ConstantTimeLess.
End ConstantTimeLess.

Module  Impl_subtle_ConstantTimeLess_for_u8_t.
Section Impl_subtle_ConstantTimeLess_for_u8_t.
  Ltac Self := exact u8.t.
  
  Global Instance ℐ : subtle.ConstantTimeLess.Required.Trait ltac:(Self) := {
    subtle.ConstantTimeLess.ct_lt := Datatypes.None;
  }.
End Impl_subtle_ConstantTimeLess_for_u8_t.
End Impl_subtle_ConstantTimeLess_for_u8_t.

Module  Impl_subtle_ConstantTimeLess_for_u16_t.
Section Impl_subtle_ConstantTimeLess_for_u16_t.
  Ltac Self := exact u16.t.
  
  Global Instance ℐ : subtle.ConstantTimeLess.Required.Trait ltac:(Self) := {
    subtle.ConstantTimeLess.ct_lt := Datatypes.None;
  }.
End Impl_subtle_ConstantTimeLess_for_u16_t.
End Impl_subtle_ConstantTimeLess_for_u16_t.

Module  Impl_subtle_ConstantTimeLess_for_u32_t.
Section Impl_subtle_ConstantTimeLess_for_u32_t.
  Ltac Self := exact u32.t.
  
  Global Instance ℐ : subtle.ConstantTimeLess.Required.Trait ltac:(Self) := {
    subtle.ConstantTimeLess.ct_lt := Datatypes.None;
  }.
End Impl_subtle_ConstantTimeLess_for_u32_t.
End Impl_subtle_ConstantTimeLess_for_u32_t.

Module  Impl_subtle_ConstantTimeLess_for_u64_t.
Section Impl_subtle_ConstantTimeLess_for_u64_t.
  Ltac Self := exact u64.t.
  
  Global Instance ℐ : subtle.ConstantTimeLess.Required.Trait ltac:(Self) := {
    subtle.ConstantTimeLess.ct_lt := Datatypes.None;
  }.
End Impl_subtle_ConstantTimeLess_for_u64_t.
End Impl_subtle_ConstantTimeLess_for_u64_t.
