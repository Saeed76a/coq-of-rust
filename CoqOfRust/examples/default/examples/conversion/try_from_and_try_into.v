(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module  EvenNumber.
Section EvenNumber.
  Record t : Set := {
    x0 : i32.t;
  }.
  
  Global Instance Get_0 : Notations.Dot "0" := {
    Notations.dot := Ref.map (fun x => x.(x0)) (fun v x => x <| x0 := v |>);
  }.
End EvenNumber.
End EvenNumber.

Module  Impl_core_fmt_Debug_for_try_from_and_try_into_EvenNumber_t.
Section Impl_core_fmt_Debug_for_try_from_and_try_into_EvenNumber_t.
  Ltac Self := exact try_from_and_try_into.EvenNumber.t.
  
  (*
  Debug
  *)
  Definition fmt
      (self : ref ltac:(Self))
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self : M.Val (ref ltac:(Self)) := M.alloc self in
    let* f : M.Val (mut_ref core.fmt.Formatter.t) := M.alloc f in
    let* α0 : mut_ref core.fmt.Formatter.t := M.read f in
    let* α1 : ref str.t := M.read (mk_str "EvenNumber") in
    let* α2 : ref try_from_and_try_into.EvenNumber.t := M.read self in
    let* α3 : M.Val (ref i32.t) := M.alloc (borrow (deref α2).["0"]) in
    let* α4 : M.Val (ref (ref i32.t)) := M.alloc (borrow α3) in
    let* α5 : ref type not implemented :=
      M.read (pointer_coercion "Unsize" α4) in
    core.fmt.Formatter.t::["debug_tuple_field1_finish"] α0 α1 α5.
  
  Global Instance AssociatedFunction_fmt :
    Notations.DoubleColon ltac:(Self) "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait ltac:(Self) := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_try_from_and_try_into_EvenNumber_t.
End Impl_core_fmt_Debug_for_try_from_and_try_into_EvenNumber_t.

Module  Impl_core_marker_StructuralPartialEq_for_try_from_and_try_into_EvenNumber_t.
Section Impl_core_marker_StructuralPartialEq_for_try_from_and_try_into_EvenNumber_t.
  Ltac Self := exact try_from_and_try_into.EvenNumber.t.
  
  Global Instance ℐ : core.marker.StructuralPartialEq.Trait ltac:(Self) := {
  }.
End Impl_core_marker_StructuralPartialEq_for_try_from_and_try_into_EvenNumber_t.
End Impl_core_marker_StructuralPartialEq_for_try_from_and_try_into_EvenNumber_t.

Module  Impl_core_cmp_PartialEq_for_try_from_and_try_into_EvenNumber_t.
Section Impl_core_cmp_PartialEq_for_try_from_and_try_into_EvenNumber_t.
  Ltac Self := exact try_from_and_try_into.EvenNumber.t.
  
  (*
  PartialEq
  *)
  Definition eq
      (self : ref ltac:(Self))
      (other : ref try_from_and_try_into.EvenNumber.t)
      : M bool.t :=
    let* self : M.Val (ref ltac:(Self)) := M.alloc self in
    let* other : M.Val (ref try_from_and_try_into.EvenNumber.t) :=
      M.alloc other in
    let* α0 : ref try_from_and_try_into.EvenNumber.t := M.read self in
    let* α1 : i32.t := M.read (deref α0).["0"] in
    let* α2 : ref try_from_and_try_into.EvenNumber.t := M.read other in
    let* α3 : i32.t := M.read (deref α2).["0"] in
    M.pure (BinOp.Pure.eq α1 α3).
  
  Global Instance AssociatedFunction_eq :
    Notations.DoubleColon ltac:(Self) "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ :
    core.cmp.PartialEq.Required.Trait ltac:(Self)
      (Rhs := core.cmp.PartialEq.Default.Rhs ltac:(Self)) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_for_try_from_and_try_into_EvenNumber_t.
End Impl_core_cmp_PartialEq_for_try_from_and_try_into_EvenNumber_t.

Module  Impl_core_convert_TryFrom_i32_t_for_try_from_and_try_into_EvenNumber_t.
Section Impl_core_convert_TryFrom_i32_t_for_try_from_and_try_into_EvenNumber_t.
  Ltac Self := exact try_from_and_try_into.EvenNumber.t.
  
  (*
      type Error = ();
  *)
  Definition Error : Set := unit.
  
  (*
      fn try_from(value: i32) -> Result<Self, Self::Error> {
          if value % 2 == 0 {
              Ok(EvenNumber(value))
          } else {
              Err(())
          }
      }
  *)
  Definition try_from
      (value : i32.t)
      : M (core.result.Result.t ltac:(Self) Error.t) :=
    let* value : M.Val i32.t := M.alloc value in
    let* α0 : i32.t := M.read value in
    let* α1 : i32.t := BinOp.Panic.rem α0 (Integer.of_Z 2) in
    let* α2 :
        M.Val (core.result.Result.t try_from_and_try_into.EvenNumber.t unit) :=
      if (use (BinOp.Pure.eq α1 (Integer.of_Z 0)) : bool) then
        let* α0 : i32.t := M.read value in
        M.alloc
          (core.result.Result.Ok (try_from_and_try_into.EvenNumber.Build_t α0))
      else
        M.alloc (core.result.Result.Err tt) in
    M.read α2.
  
  Global Instance AssociatedFunction_try_from :
    Notations.DoubleColon ltac:(Self) "try_from" := {
    Notations.double_colon := try_from;
  }.
  
  Global Instance ℐ : core.convert.TryFrom.Trait ltac:(Self) (T := i32.t) := {
    core.convert.TryFrom.Error := Error;
    core.convert.TryFrom.try_from := try_from;
  }.
End Impl_core_convert_TryFrom_i32_t_for_try_from_and_try_into_EvenNumber_t.
End Impl_core_convert_TryFrom_i32_t_for_try_from_and_try_into_EvenNumber_t.

(*
fn main() {
    // TryFrom

    assert_eq!(EvenNumber::try_from(8), Ok(EvenNumber(8)));
    assert_eq!(EvenNumber::try_from(5), Err(()));

    // TryInto

    let result: Result<EvenNumber, ()> = 8i32.try_into();
    assert_eq!(result, Ok(EvenNumber(8)));
    let result: Result<EvenNumber, ()> = 5i32.try_into();
    assert_eq!(result, Err(()));
}
*)
(* #[allow(dead_code)] - function was ignored by the compiler *)
Definition main : M unit :=
  let* _ : M.Val unit :=
    let* α0 : core.result.Result.t try_from_and_try_into.EvenNumber.t unit :=
      (core.convert.TryFrom.try_from
          (Self := try_from_and_try_into.EvenNumber.t)
          (Trait := ltac:(refine _)))
        (Integer.of_Z 8) in
    let* α1 :
        M.Val (core.result.Result.t try_from_and_try_into.EvenNumber.t unit) :=
      M.alloc α0 in
    let* α2 :
        M.Val (core.result.Result.t try_from_and_try_into.EvenNumber.t unit) :=
      M.alloc
        (core.result.Result.Ok
          (try_from_and_try_into.EvenNumber.Build_t (Integer.of_Z 8))) in
    match (borrow α1, borrow α2) with
    | (left_val, right_val) =>
      let* right_val := M.alloc right_val in
      let* left_val := M.alloc left_val in
      let* α0 :
          ref (core.result.Result.t try_from_and_try_into.EvenNumber.t unit) :=
        M.read left_val in
      let* α1 :
          ref (core.result.Result.t try_from_and_try_into.EvenNumber.t unit) :=
        M.read right_val in
      let* α2 : bool.t :=
        (core.cmp.PartialEq.eq
            (Self :=
              core.result.Result.t try_from_and_try_into.EvenNumber.t unit)
            (Trait := ltac:(refine _)))
          α0
          α1 in
      if (use (UnOp.not α2) : bool) then
        let* kind : M.Val core.panicking.AssertKind.t :=
          M.alloc core.panicking.AssertKind.Eq in
        let* _ : M.Val never.t :=
          let* α0 : core.panicking.AssertKind.t := M.read kind in
          let* α1 :
              ref
                (core.result.Result.t
                  try_from_and_try_into.EvenNumber.t
                  unit) :=
            M.read left_val in
          let* α2 :
              ref
                (core.result.Result.t
                  try_from_and_try_into.EvenNumber.t
                  unit) :=
            M.read right_val in
          let* α3 : never.t :=
            core.panicking.assert_failed α0 α1 α2 core.option.Option.None in
          M.alloc α3 in
        let* α0 : M.Val unit := M.alloc tt in
        let* α1 := M.read α0 in
        let* α2 : unit := never_to_any α1 in
        M.alloc α2
      else
        M.alloc tt
    end in
  let* _ : M.Val unit :=
    let* α0 : core.result.Result.t try_from_and_try_into.EvenNumber.t unit :=
      (core.convert.TryFrom.try_from
          (Self := try_from_and_try_into.EvenNumber.t)
          (Trait := ltac:(refine _)))
        (Integer.of_Z 5) in
    let* α1 :
        M.Val (core.result.Result.t try_from_and_try_into.EvenNumber.t unit) :=
      M.alloc α0 in
    let* α2 :
        M.Val (core.result.Result.t try_from_and_try_into.EvenNumber.t unit) :=
      M.alloc (core.result.Result.Err tt) in
    match (borrow α1, borrow α2) with
    | (left_val, right_val) =>
      let* right_val := M.alloc right_val in
      let* left_val := M.alloc left_val in
      let* α0 :
          ref (core.result.Result.t try_from_and_try_into.EvenNumber.t unit) :=
        M.read left_val in
      let* α1 :
          ref (core.result.Result.t try_from_and_try_into.EvenNumber.t unit) :=
        M.read right_val in
      let* α2 : bool.t :=
        (core.cmp.PartialEq.eq
            (Self :=
              core.result.Result.t try_from_and_try_into.EvenNumber.t unit)
            (Trait := ltac:(refine _)))
          α0
          α1 in
      if (use (UnOp.not α2) : bool) then
        let* kind : M.Val core.panicking.AssertKind.t :=
          M.alloc core.panicking.AssertKind.Eq in
        let* _ : M.Val never.t :=
          let* α0 : core.panicking.AssertKind.t := M.read kind in
          let* α1 :
              ref
                (core.result.Result.t
                  try_from_and_try_into.EvenNumber.t
                  unit) :=
            M.read left_val in
          let* α2 :
              ref
                (core.result.Result.t
                  try_from_and_try_into.EvenNumber.t
                  unit) :=
            M.read right_val in
          let* α3 : never.t :=
            core.panicking.assert_failed α0 α1 α2 core.option.Option.None in
          M.alloc α3 in
        let* α0 : M.Val unit := M.alloc tt in
        let* α1 := M.read α0 in
        let* α2 : unit := never_to_any α1 in
        M.alloc α2
      else
        M.alloc tt
    end in
  let* result :
      M.Val (core.result.Result.t try_from_and_try_into.EvenNumber.t unit) :=
    let* α0 : core.result.Result.t try_from_and_try_into.EvenNumber.t unit :=
      (core.convert.TryInto.try_into (Self := i32.t) (Trait := ltac:(refine _)))
        (Integer.of_Z 8) in
    M.alloc α0 in
  let* _ : M.Val unit :=
    let* α0 :
        M.Val (core.result.Result.t try_from_and_try_into.EvenNumber.t unit) :=
      M.alloc
        (core.result.Result.Ok
          (try_from_and_try_into.EvenNumber.Build_t (Integer.of_Z 8))) in
    match (borrow result, borrow α0) with
    | (left_val, right_val) =>
      let* right_val := M.alloc right_val in
      let* left_val := M.alloc left_val in
      let* α0 :
          ref (core.result.Result.t try_from_and_try_into.EvenNumber.t unit) :=
        M.read left_val in
      let* α1 :
          ref (core.result.Result.t try_from_and_try_into.EvenNumber.t unit) :=
        M.read right_val in
      let* α2 : bool.t :=
        (core.cmp.PartialEq.eq
            (Self :=
              core.result.Result.t try_from_and_try_into.EvenNumber.t unit)
            (Trait := ltac:(refine _)))
          α0
          α1 in
      if (use (UnOp.not α2) : bool) then
        let* kind : M.Val core.panicking.AssertKind.t :=
          M.alloc core.panicking.AssertKind.Eq in
        let* _ : M.Val never.t :=
          let* α0 : core.panicking.AssertKind.t := M.read kind in
          let* α1 :
              ref
                (core.result.Result.t
                  try_from_and_try_into.EvenNumber.t
                  unit) :=
            M.read left_val in
          let* α2 :
              ref
                (core.result.Result.t
                  try_from_and_try_into.EvenNumber.t
                  unit) :=
            M.read right_val in
          let* α3 : never.t :=
            core.panicking.assert_failed α0 α1 α2 core.option.Option.None in
          M.alloc α3 in
        let* α0 : M.Val unit := M.alloc tt in
        let* α1 := M.read α0 in
        let* α2 : unit := never_to_any α1 in
        M.alloc α2
      else
        M.alloc tt
    end in
  let* result :
      M.Val (core.result.Result.t try_from_and_try_into.EvenNumber.t unit) :=
    let* α0 : core.result.Result.t try_from_and_try_into.EvenNumber.t unit :=
      (core.convert.TryInto.try_into (Self := i32.t) (Trait := ltac:(refine _)))
        (Integer.of_Z 5) in
    M.alloc α0 in
  let* _ : M.Val unit :=
    let* α0 :
        M.Val (core.result.Result.t try_from_and_try_into.EvenNumber.t unit) :=
      M.alloc (core.result.Result.Err tt) in
    match (borrow result, borrow α0) with
    | (left_val, right_val) =>
      let* right_val := M.alloc right_val in
      let* left_val := M.alloc left_val in
      let* α0 :
          ref (core.result.Result.t try_from_and_try_into.EvenNumber.t unit) :=
        M.read left_val in
      let* α1 :
          ref (core.result.Result.t try_from_and_try_into.EvenNumber.t unit) :=
        M.read right_val in
      let* α2 : bool.t :=
        (core.cmp.PartialEq.eq
            (Self :=
              core.result.Result.t try_from_and_try_into.EvenNumber.t unit)
            (Trait := ltac:(refine _)))
          α0
          α1 in
      if (use (UnOp.not α2) : bool) then
        let* kind : M.Val core.panicking.AssertKind.t :=
          M.alloc core.panicking.AssertKind.Eq in
        let* _ : M.Val never.t :=
          let* α0 : core.panicking.AssertKind.t := M.read kind in
          let* α1 :
              ref
                (core.result.Result.t
                  try_from_and_try_into.EvenNumber.t
                  unit) :=
            M.read left_val in
          let* α2 :
              ref
                (core.result.Result.t
                  try_from_and_try_into.EvenNumber.t
                  unit) :=
            M.read right_val in
          let* α3 : never.t :=
            core.panicking.assert_failed α0 α1 α2 core.option.Option.None in
          M.alloc α3 in
        let* α0 : M.Val unit := M.alloc tt in
        let* α1 := M.read α0 in
        let* α2 : unit := never_to_any α1 in
        M.alloc α2
      else
        M.alloc tt
    end in
  let* α0 : M.Val unit := M.alloc tt in
  M.read α0.
