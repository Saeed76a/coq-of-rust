(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module  EvenNumber.
Section EvenNumber.
  Record t : Set := {
    x0 : i32.t;
  }.
  
  Global Instance Get_0 : Notations.Dot "0" := {
    Notations.dot := Ref.map (fun x => x.(x0)) (fun v x => x <| x0 := v |>);
  }.
End EvenNumber.
End EvenNumber.

Module  Impl_core_fmt_Debug_for_try_from_and_try_into_EvenNumber_t.
Section Impl_core_fmt_Debug_for_try_from_and_try_into_EvenNumber_t.
  Ltac Self := exact try_from_and_try_into.EvenNumber.t.
  
  (*
  Debug
  *)
  Definition fmt
      (self : M.Val (ref ltac:(Self)))
      (f : M.Val (mut_ref core.fmt.Formatter.t))
      : M (M.Val ltac:(core.fmt.Result)) :=
    M.function_body
      (let* α0 : ltac:(refine (M.Val core.fmt.Formatter.t)) := deref f in
      let* α1 : ltac:(refine (M.Val (mut_ref core.fmt.Formatter.t))) :=
        borrow_mut α0 in
      let* α2 : ltac:(refine (M.Val str.t)) := deref (mk_str "EvenNumber") in
      let* α3 : ltac:(refine (M.Val (ref str.t))) := borrow α2 in
      let* α4 : ltac:(refine (M.Val try_from_and_try_into.EvenNumber.t)) :=
        deref self in
      let* α5 : ltac:(refine (M.Val (ref i32.t))) := borrow α4.["0"] in
      let* α6 : ltac:(refine (M.Val (ref (ref i32.t)))) := borrow α5 in
      let* α7 : ltac:(refine (M.Val (ref type not implemented))) :=
        pointer_coercion "Unsize" α6 in
      core.fmt.Formatter.t::["debug_tuple_field1_finish"] α1 α3 α7).
  
  Global Instance AssociatedFunction_fmt :
    Notations.DoubleColon ltac:(Self) "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait ltac:(Self) := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_try_from_and_try_into_EvenNumber_t.
End Impl_core_fmt_Debug_for_try_from_and_try_into_EvenNumber_t.

Module  Impl_core_marker_StructuralPartialEq_for_try_from_and_try_into_EvenNumber_t.
Section Impl_core_marker_StructuralPartialEq_for_try_from_and_try_into_EvenNumber_t.
  Ltac Self := exact try_from_and_try_into.EvenNumber.t.
  
  Global Instance ℐ : core.marker.StructuralPartialEq.Trait ltac:(Self) := {
  }.
End Impl_core_marker_StructuralPartialEq_for_try_from_and_try_into_EvenNumber_t.
End Impl_core_marker_StructuralPartialEq_for_try_from_and_try_into_EvenNumber_t.

Module  Impl_core_cmp_PartialEq_for_try_from_and_try_into_EvenNumber_t.
Section Impl_core_cmp_PartialEq_for_try_from_and_try_into_EvenNumber_t.
  Ltac Self := exact try_from_and_try_into.EvenNumber.t.
  
  (*
  PartialEq
  *)
  Definition eq
      (self : M.Val (ref ltac:(Self)))
      (other : M.Val (ref try_from_and_try_into.EvenNumber.t))
      : M (M.Val bool.t) :=
    M.function_body
      (let* α0 : ltac:(refine (M.Val try_from_and_try_into.EvenNumber.t)) :=
        deref self in
      let* α1 : ltac:(refine (M.Val try_from_and_try_into.EvenNumber.t)) :=
        deref other in
      BinOp.eq α0.["0"] α1.["0"]).
  
  Global Instance AssociatedFunction_eq :
    Notations.DoubleColon ltac:(Self) "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ :
    core.cmp.PartialEq.Required.Trait ltac:(Self)
      (Rhs := core.cmp.PartialEq.Default.Rhs ltac:(Self)) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_for_try_from_and_try_into_EvenNumber_t.
End Impl_core_cmp_PartialEq_for_try_from_and_try_into_EvenNumber_t.

Module  Impl_core_convert_TryFrom_i32_t_for_try_from_and_try_into_EvenNumber_t.
Section Impl_core_convert_TryFrom_i32_t_for_try_from_and_try_into_EvenNumber_t.
  Ltac Self := exact try_from_and_try_into.EvenNumber.t.
  
  (*
      type Error = ();
  *)
  Definition Error : Set := unit.
  
  (*
      fn try_from(value: i32) -> Result<Self, Self::Error> {
          if value % 2 == 0 {
              Ok(EvenNumber(value))
          } else {
              Err(())
          }
      }
  *)
  Definition try_from
      (value : M.Val i32.t)
      : M (M.Val (core.result.Result.t ltac:(Self) Error.t)) :=
    M.function_body
      (let* α0 : ltac:(refine (M.Val i32.t)) := M.alloc 2 in
      let* α1 : ltac:(refine (M.Val i32.t)) := BinOp.rem value α0 in
      let* α2 : ltac:(refine (M.Val i32.t)) := M.alloc 0 in
      let* α3 : ltac:(refine (M.Val bool.t)) := BinOp.eq α1 α2 in
      let* α4 : ltac:(refine (M.Val bool.t)) := use α3 in
      let* α5 := M.read α4 in
      if (α5 : bool) then
        let* α0 := M.read value in
        M.alloc
          (core.result.Result.Ok (try_from_and_try_into.EvenNumber.Build_t α0))
      else
        M.alloc (core.result.Result.Err tt)).
  
  Global Instance AssociatedFunction_try_from :
    Notations.DoubleColon ltac:(Self) "try_from" := {
    Notations.double_colon := try_from;
  }.
  
  Global Instance ℐ : core.convert.TryFrom.Trait ltac:(Self) (T := i32.t) := {
    core.convert.TryFrom.Error := Error;
    core.convert.TryFrom.try_from := try_from;
  }.
End Impl_core_convert_TryFrom_i32_t_for_try_from_and_try_into_EvenNumber_t.
End Impl_core_convert_TryFrom_i32_t_for_try_from_and_try_into_EvenNumber_t.

(*
fn main() {
    // TryFrom

    assert_eq!(EvenNumber::try_from(8), Ok(EvenNumber(8)));
    assert_eq!(EvenNumber::try_from(5), Err(()));

    // TryInto

    let result: Result<EvenNumber, ()> = 8i32.try_into();
    assert_eq!(result, Ok(EvenNumber(8)));
    let result: Result<EvenNumber, ()> = 5i32.try_into();
    assert_eq!(result, Err(()));
}
*)
(* #[allow(dead_code)] - function was ignored by the compiler *)
Definition main : M (M.Val unit) :=
  M.function_body
    (let* _ : ltac:(refine (M.Val unit)) :=
      let* α0 : ltac:(refine (M.Val i32.t)) := M.alloc 8 in
      let* α1 :
          ltac:(refine
            (M.Val
              (core.result.Result.t
                try_from_and_try_into.EvenNumber.t
                unit))) :=
        (core.convert.TryFrom.try_from
            (Self := try_from_and_try_into.EvenNumber.t)
            (Trait := ltac:(refine _)))
          α0 in
      let* α2 :
          ltac:(refine
            (M.Val
              (ref
                (core.result.Result.t
                  try_from_and_try_into.EvenNumber.t
                  unit)))) :=
        borrow α1 in
      let* α3 := M.read α2 in
      let* α4 : ltac:(refine (M.Val i32.t)) := M.alloc 8 in
      let* α5 := M.read α4 in
      let* α6 :
          ltac:(refine
            (M.Val
              (core.result.Result.t
                try_from_and_try_into.EvenNumber.t
                unit))) :=
        M.alloc
          (core.result.Result.Ok
            (try_from_and_try_into.EvenNumber.Build_t α5)) in
      let* α7 :
          ltac:(refine
            (M.Val
              (ref
                (core.result.Result.t
                  try_from_and_try_into.EvenNumber.t
                  unit)))) :=
        borrow α6 in
      let* α8 := M.read α7 in
      let* α9 :
          ltac:(refine
            (M.Val
              ((ref
                (core.result.Result.t try_from_and_try_into.EvenNumber.t unit))
              *
              (ref
                (core.result.Result.t
                  try_from_and_try_into.EvenNumber.t
                  unit))))) :=
        M.alloc (α3, α8) in
      let* α10 := M.read α9 in
      match α10 with
      | (left_val, right_val) =>
        let* right_val := M.alloc right_val in
        let* left_val := M.alloc left_val in
        let* α0 :
            ltac:(refine
              (M.Val
                (core.result.Result.t
                  try_from_and_try_into.EvenNumber.t
                  unit))) :=
          deref left_val in
        let* α1 :
            ltac:(refine
              (M.Val
                (ref
                  (core.result.Result.t
                    try_from_and_try_into.EvenNumber.t
                    unit)))) :=
          borrow α0 in
        let* α2 :
            ltac:(refine
              (M.Val
                (core.result.Result.t
                  try_from_and_try_into.EvenNumber.t
                  unit))) :=
          deref right_val in
        let* α3 :
            ltac:(refine
              (M.Val
                (ref
                  (core.result.Result.t
                    try_from_and_try_into.EvenNumber.t
                    unit)))) :=
          borrow α2 in
        let* α4 : ltac:(refine (M.Val bool.t)) :=
          (core.cmp.PartialEq.eq
              (Self :=
                core.result.Result.t try_from_and_try_into.EvenNumber.t unit)
              (Trait := ltac:(refine _)))
            α1
            α3 in
        let* α5 : ltac:(refine (M.Val bool.t)) := UnOp.not α4 in
        let* α6 : ltac:(refine (M.Val bool.t)) := use α5 in
        let* α7 := M.read α6 in
        if (α7 : bool) then
          let* kind : ltac:(refine (M.Val core.panicking.AssertKind.t)) :=
            M.alloc core.panicking.AssertKind.Eq in
          let* _ : ltac:(refine (M.Val never.t)) :=
            let* α0 :
                ltac:(refine
                  (M.Val
                    (core.result.Result.t
                      try_from_and_try_into.EvenNumber.t
                      unit))) :=
              deref left_val in
            let* α1 :
                ltac:(refine
                  (M.Val
                    (ref
                      (core.result.Result.t
                        try_from_and_try_into.EvenNumber.t
                        unit)))) :=
              borrow α0 in
            let* α2 :
                ltac:(refine
                  (M.Val
                    (core.result.Result.t
                      try_from_and_try_into.EvenNumber.t
                      unit))) :=
              deref right_val in
            let* α3 :
                ltac:(refine
                  (M.Val
                    (ref
                      (core.result.Result.t
                        try_from_and_try_into.EvenNumber.t
                        unit)))) :=
              borrow α2 in
            let* α4 :
                ltac:(refine
                  (M.Val (core.option.Option.t core.fmt.Arguments.t))) :=
              M.alloc core.option.Option.None in
            core.panicking.assert_failed kind α1 α3 α4 in
          let* α0 : ltac:(refine (M.Val unit)) := M.alloc tt in
          never_to_any α0
        else
          M.alloc tt
      end in
    let* _ : ltac:(refine (M.Val unit)) :=
      let* α0 : ltac:(refine (M.Val i32.t)) := M.alloc 5 in
      let* α1 :
          ltac:(refine
            (M.Val
              (core.result.Result.t
                try_from_and_try_into.EvenNumber.t
                unit))) :=
        (core.convert.TryFrom.try_from
            (Self := try_from_and_try_into.EvenNumber.t)
            (Trait := ltac:(refine _)))
          α0 in
      let* α2 :
          ltac:(refine
            (M.Val
              (ref
                (core.result.Result.t
                  try_from_and_try_into.EvenNumber.t
                  unit)))) :=
        borrow α1 in
      let* α3 := M.read α2 in
      let* α4 :
          ltac:(refine
            (M.Val
              (core.result.Result.t
                try_from_and_try_into.EvenNumber.t
                unit))) :=
        M.alloc (core.result.Result.Err tt) in
      let* α5 :
          ltac:(refine
            (M.Val
              (ref
                (core.result.Result.t
                  try_from_and_try_into.EvenNumber.t
                  unit)))) :=
        borrow α4 in
      let* α6 := M.read α5 in
      let* α7 :
          ltac:(refine
            (M.Val
              ((ref
                (core.result.Result.t try_from_and_try_into.EvenNumber.t unit))
              *
              (ref
                (core.result.Result.t
                  try_from_and_try_into.EvenNumber.t
                  unit))))) :=
        M.alloc (α3, α6) in
      let* α8 := M.read α7 in
      match α8 with
      | (left_val, right_val) =>
        let* right_val := M.alloc right_val in
        let* left_val := M.alloc left_val in
        let* α0 :
            ltac:(refine
              (M.Val
                (core.result.Result.t
                  try_from_and_try_into.EvenNumber.t
                  unit))) :=
          deref left_val in
        let* α1 :
            ltac:(refine
              (M.Val
                (ref
                  (core.result.Result.t
                    try_from_and_try_into.EvenNumber.t
                    unit)))) :=
          borrow α0 in
        let* α2 :
            ltac:(refine
              (M.Val
                (core.result.Result.t
                  try_from_and_try_into.EvenNumber.t
                  unit))) :=
          deref right_val in
        let* α3 :
            ltac:(refine
              (M.Val
                (ref
                  (core.result.Result.t
                    try_from_and_try_into.EvenNumber.t
                    unit)))) :=
          borrow α2 in
        let* α4 : ltac:(refine (M.Val bool.t)) :=
          (core.cmp.PartialEq.eq
              (Self :=
                core.result.Result.t try_from_and_try_into.EvenNumber.t unit)
              (Trait := ltac:(refine _)))
            α1
            α3 in
        let* α5 : ltac:(refine (M.Val bool.t)) := UnOp.not α4 in
        let* α6 : ltac:(refine (M.Val bool.t)) := use α5 in
        let* α7 := M.read α6 in
        if (α7 : bool) then
          let* kind : ltac:(refine (M.Val core.panicking.AssertKind.t)) :=
            M.alloc core.panicking.AssertKind.Eq in
          let* _ : ltac:(refine (M.Val never.t)) :=
            let* α0 :
                ltac:(refine
                  (M.Val
                    (core.result.Result.t
                      try_from_and_try_into.EvenNumber.t
                      unit))) :=
              deref left_val in
            let* α1 :
                ltac:(refine
                  (M.Val
                    (ref
                      (core.result.Result.t
                        try_from_and_try_into.EvenNumber.t
                        unit)))) :=
              borrow α0 in
            let* α2 :
                ltac:(refine
                  (M.Val
                    (core.result.Result.t
                      try_from_and_try_into.EvenNumber.t
                      unit))) :=
              deref right_val in
            let* α3 :
                ltac:(refine
                  (M.Val
                    (ref
                      (core.result.Result.t
                        try_from_and_try_into.EvenNumber.t
                        unit)))) :=
              borrow α2 in
            let* α4 :
                ltac:(refine
                  (M.Val (core.option.Option.t core.fmt.Arguments.t))) :=
              M.alloc core.option.Option.None in
            core.panicking.assert_failed kind α1 α3 α4 in
          let* α0 : ltac:(refine (M.Val unit)) := M.alloc tt in
          never_to_any α0
        else
          M.alloc tt
      end in
    let* result :
        ltac:(refine
          (M.Val
            (core.result.Result.t try_from_and_try_into.EvenNumber.t unit))) :=
      let* α0 : ltac:(refine (M.Val i32.t)) := M.alloc 8 in
      let* α1 :
          ltac:(refine
            (M.Val
              (core.result.Result.t
                try_from_and_try_into.EvenNumber.t
                unit))) :=
        (core.convert.TryInto.try_into
            (Self := i32.t)
            (Trait := ltac:(refine _)))
          α0 in
      M.copy α1 in
    let* _ : ltac:(refine (M.Val unit)) :=
      let* α0 :
          ltac:(refine
            (M.Val
              (ref
                (core.result.Result.t
                  try_from_and_try_into.EvenNumber.t
                  unit)))) :=
        borrow result in
      let* α1 := M.read α0 in
      let* α2 : ltac:(refine (M.Val i32.t)) := M.alloc 8 in
      let* α3 := M.read α2 in
      let* α4 :
          ltac:(refine
            (M.Val
              (core.result.Result.t
                try_from_and_try_into.EvenNumber.t
                unit))) :=
        M.alloc
          (core.result.Result.Ok
            (try_from_and_try_into.EvenNumber.Build_t α3)) in
      let* α5 :
          ltac:(refine
            (M.Val
              (ref
                (core.result.Result.t
                  try_from_and_try_into.EvenNumber.t
                  unit)))) :=
        borrow α4 in
      let* α6 := M.read α5 in
      let* α7 :
          ltac:(refine
            (M.Val
              ((ref
                (core.result.Result.t try_from_and_try_into.EvenNumber.t unit))
              *
              (ref
                (core.result.Result.t
                  try_from_and_try_into.EvenNumber.t
                  unit))))) :=
        M.alloc (α1, α6) in
      let* α8 := M.read α7 in
      match α8 with
      | (left_val, right_val) =>
        let* right_val := M.alloc right_val in
        let* left_val := M.alloc left_val in
        let* α0 :
            ltac:(refine
              (M.Val
                (core.result.Result.t
                  try_from_and_try_into.EvenNumber.t
                  unit))) :=
          deref left_val in
        let* α1 :
            ltac:(refine
              (M.Val
                (ref
                  (core.result.Result.t
                    try_from_and_try_into.EvenNumber.t
                    unit)))) :=
          borrow α0 in
        let* α2 :
            ltac:(refine
              (M.Val
                (core.result.Result.t
                  try_from_and_try_into.EvenNumber.t
                  unit))) :=
          deref right_val in
        let* α3 :
            ltac:(refine
              (M.Val
                (ref
                  (core.result.Result.t
                    try_from_and_try_into.EvenNumber.t
                    unit)))) :=
          borrow α2 in
        let* α4 : ltac:(refine (M.Val bool.t)) :=
          (core.cmp.PartialEq.eq
              (Self :=
                core.result.Result.t try_from_and_try_into.EvenNumber.t unit)
              (Trait := ltac:(refine _)))
            α1
            α3 in
        let* α5 : ltac:(refine (M.Val bool.t)) := UnOp.not α4 in
        let* α6 : ltac:(refine (M.Val bool.t)) := use α5 in
        let* α7 := M.read α6 in
        if (α7 : bool) then
          let* kind : ltac:(refine (M.Val core.panicking.AssertKind.t)) :=
            M.alloc core.panicking.AssertKind.Eq in
          let* _ : ltac:(refine (M.Val never.t)) :=
            let* α0 :
                ltac:(refine
                  (M.Val
                    (core.result.Result.t
                      try_from_and_try_into.EvenNumber.t
                      unit))) :=
              deref left_val in
            let* α1 :
                ltac:(refine
                  (M.Val
                    (ref
                      (core.result.Result.t
                        try_from_and_try_into.EvenNumber.t
                        unit)))) :=
              borrow α0 in
            let* α2 :
                ltac:(refine
                  (M.Val
                    (core.result.Result.t
                      try_from_and_try_into.EvenNumber.t
                      unit))) :=
              deref right_val in
            let* α3 :
                ltac:(refine
                  (M.Val
                    (ref
                      (core.result.Result.t
                        try_from_and_try_into.EvenNumber.t
                        unit)))) :=
              borrow α2 in
            let* α4 :
                ltac:(refine
                  (M.Val (core.option.Option.t core.fmt.Arguments.t))) :=
              M.alloc core.option.Option.None in
            core.panicking.assert_failed kind α1 α3 α4 in
          let* α0 : ltac:(refine (M.Val unit)) := M.alloc tt in
          never_to_any α0
        else
          M.alloc tt
      end in
    let* result :
        ltac:(refine
          (M.Val
            (core.result.Result.t try_from_and_try_into.EvenNumber.t unit))) :=
      let* α0 : ltac:(refine (M.Val i32.t)) := M.alloc 5 in
      let* α1 :
          ltac:(refine
            (M.Val
              (core.result.Result.t
                try_from_and_try_into.EvenNumber.t
                unit))) :=
        (core.convert.TryInto.try_into
            (Self := i32.t)
            (Trait := ltac:(refine _)))
          α0 in
      M.copy α1 in
    let* _ : ltac:(refine (M.Val unit)) :=
      let* α0 :
          ltac:(refine
            (M.Val
              (ref
                (core.result.Result.t
                  try_from_and_try_into.EvenNumber.t
                  unit)))) :=
        borrow result in
      let* α1 := M.read α0 in
      let* α2 :
          ltac:(refine
            (M.Val
              (core.result.Result.t
                try_from_and_try_into.EvenNumber.t
                unit))) :=
        M.alloc (core.result.Result.Err tt) in
      let* α3 :
          ltac:(refine
            (M.Val
              (ref
                (core.result.Result.t
                  try_from_and_try_into.EvenNumber.t
                  unit)))) :=
        borrow α2 in
      let* α4 := M.read α3 in
      let* α5 :
          ltac:(refine
            (M.Val
              ((ref
                (core.result.Result.t try_from_and_try_into.EvenNumber.t unit))
              *
              (ref
                (core.result.Result.t
                  try_from_and_try_into.EvenNumber.t
                  unit))))) :=
        M.alloc (α1, α4) in
      let* α6 := M.read α5 in
      match α6 with
      | (left_val, right_val) =>
        let* right_val := M.alloc right_val in
        let* left_val := M.alloc left_val in
        let* α0 :
            ltac:(refine
              (M.Val
                (core.result.Result.t
                  try_from_and_try_into.EvenNumber.t
                  unit))) :=
          deref left_val in
        let* α1 :
            ltac:(refine
              (M.Val
                (ref
                  (core.result.Result.t
                    try_from_and_try_into.EvenNumber.t
                    unit)))) :=
          borrow α0 in
        let* α2 :
            ltac:(refine
              (M.Val
                (core.result.Result.t
                  try_from_and_try_into.EvenNumber.t
                  unit))) :=
          deref right_val in
        let* α3 :
            ltac:(refine
              (M.Val
                (ref
                  (core.result.Result.t
                    try_from_and_try_into.EvenNumber.t
                    unit)))) :=
          borrow α2 in
        let* α4 : ltac:(refine (M.Val bool.t)) :=
          (core.cmp.PartialEq.eq
              (Self :=
                core.result.Result.t try_from_and_try_into.EvenNumber.t unit)
              (Trait := ltac:(refine _)))
            α1
            α3 in
        let* α5 : ltac:(refine (M.Val bool.t)) := UnOp.not α4 in
        let* α6 : ltac:(refine (M.Val bool.t)) := use α5 in
        let* α7 := M.read α6 in
        if (α7 : bool) then
          let* kind : ltac:(refine (M.Val core.panicking.AssertKind.t)) :=
            M.alloc core.panicking.AssertKind.Eq in
          let* _ : ltac:(refine (M.Val never.t)) :=
            let* α0 :
                ltac:(refine
                  (M.Val
                    (core.result.Result.t
                      try_from_and_try_into.EvenNumber.t
                      unit))) :=
              deref left_val in
            let* α1 :
                ltac:(refine
                  (M.Val
                    (ref
                      (core.result.Result.t
                        try_from_and_try_into.EvenNumber.t
                        unit)))) :=
              borrow α0 in
            let* α2 :
                ltac:(refine
                  (M.Val
                    (core.result.Result.t
                      try_from_and_try_into.EvenNumber.t
                      unit))) :=
              deref right_val in
            let* α3 :
                ltac:(refine
                  (M.Val
                    (ref
                      (core.result.Result.t
                        try_from_and_try_into.EvenNumber.t
                        unit)))) :=
              borrow α2 in
            let* α4 :
                ltac:(refine
                  (M.Val (core.option.Option.t core.fmt.Arguments.t))) :=
              M.alloc core.option.Option.None in
            core.panicking.assert_failed kind α1 α3 α4 in
          let* α0 : ltac:(refine (M.Val unit)) := M.alloc tt in
          never_to_any α0
        else
          M.alloc tt
      end in
    M.alloc tt).
