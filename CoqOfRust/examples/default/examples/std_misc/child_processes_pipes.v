(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Definition PANGRAM : ref str.t :=
  M.run (M.pure (mk_str "the quick brown fox jumped over the lazy dog
")).

(*
fn main() {
    // Spawn the `wc` command
    let process = match Command::new("wc")
        .stdin(Stdio::piped())
        .stdout(Stdio::piped())
        .spawn()
    {
        Err(why) => panic!("couldn't spawn wc: {}", why),
        Ok(process) => process,
    };

    // Write a string to the `stdin` of `wc`.
    //
    // `stdin` has type `Option<ChildStdin>`, but since we know this instance
    // must have one, we can directly `unwrap` it.
    match process.stdin.unwrap().write_all(PANGRAM.as_bytes()) {
        Err(why) => panic!("couldn't write to wc stdin: {}", why),
        Ok(_) => println!("sent pangram to wc"),
    }

    // Because `stdin` does not live after the above calls, it is `drop`ed,
    // and the pipe is closed.
    //
    // This is very important, otherwise `wc` wouldn't start processing the
    // input we just sent.

    // The `stdout` field also has type `Option<ChildStdout>` so must be unwrapped.
    let mut s = String::new();
    match process.stdout.unwrap().read_to_string(&mut s) {
        Err(why) => panic!("couldn't read wc stdout: {}", why),
        Ok(_) => print!("wc responded with:\n{}", s),
    }
}
*)
(* #[allow(dead_code)] - function was ignored by the compiler *)
Definition main : M unit :=
  let* process : M.Val std.process.Child.t :=
    let* α0 : ref str.t := M.read (mk_str "wc") in
    let* α1 : std.process.Command.t := std.process.Command.t::["new"] α0 in
    let* α2 : M.Val std.process.Command.t := M.alloc α1 in
    let* α3 : std.process.Stdio.t := std.process.Stdio.t::["piped"] in
    let* α4 : mut_ref std.process.Command.t :=
      std.process.Command.t::["stdin"] (borrow_mut α2) α3 in
    let* α5 : std.process.Stdio.t := std.process.Stdio.t::["piped"] in
    let* α6 : mut_ref std.process.Command.t :=
      std.process.Command.t::["stdout"] α4 α5 in
    let* α7 : core.result.Result.t std.process.Child.t std.io.error.Error.t :=
      std.process.Command.t::["spawn"] α6 in
    let* α8 : M.Val std.process.Child.t :=
      match α7 with
      | core.result.Result.Err why =>
        let* why := M.alloc why in
        let* α0 : M.Val (array (ref str.t)) :=
          M.alloc [ mk_str "couldn't spawn wc: " ] in
        let* α1 : M.Val (ref (array (ref str.t))) := M.alloc (borrow α0) in
        let* α2 : ref (slice (ref str.t)) :=
          M.read (pointer_coercion "Unsize" α1) in
        let* α3 : core.fmt.rt.Argument.t :=
          core.fmt.rt.Argument.t::["new_display"] (borrow why) in
        let* α4 : M.Val core.fmt.rt.Argument.t := M.alloc α3 in
        let* α5 : M.Val (array core.fmt.rt.Argument.t) := M.alloc [ α4 ] in
        let* α6 : M.Val (ref (array core.fmt.rt.Argument.t)) :=
          M.alloc (borrow α5) in
        let* α7 : ref (slice core.fmt.rt.Argument.t) :=
          M.read (pointer_coercion "Unsize" α6) in
        let* α8 : core.fmt.Arguments.t :=
          core.fmt.Arguments.t::["new_v1"] α2 α7 in
        let* α9 : never.t := core.panicking.panic_fmt α8 in
        let* α10 : std.process.Child.t := never_to_any α9 in
        M.alloc α10
      | core.result.Result.Ok process =>
        let* process := M.alloc process in
        M.pure process
      end in
    M.copy α8 in
  let* _ : M.Val unit :=
    let* α0 : core.option.Option.t std.process.ChildStdin.t :=
      M.read process.["stdin"] in
    let* α1 : std.process.ChildStdin.t :=
      (core.option.Option.t std.process.ChildStdin.t)::["unwrap"] α0 in
    let* α2 : M.Val std.process.ChildStdin.t := M.alloc α1 in
    let* α3 : ref (ref str.t) := M.read child_processes_pipes.PANGRAM in
    let* α4 : ref str.t := M.read (deref α3) in
    let* α5 : ref (slice u8.t) := str.t::["as_bytes"] α4 in
    let* α6 : core.result.Result.t unit std.io.error.Error.t :=
      (std.io.Write.write_all
          (Self := std.process.ChildStdin.t)
          (Trait := ltac:(refine _)))
        (borrow_mut α2)
        α5 in
    match α6 with
    | core.result.Result.Err why =>
      let* why := M.alloc why in
      let* α0 : M.Val (array (ref str.t)) :=
        M.alloc [ mk_str "couldn't write to wc stdin: " ] in
      let* α1 : M.Val (ref (array (ref str.t))) := M.alloc (borrow α0) in
      let* α2 : ref (slice (ref str.t)) :=
        M.read (pointer_coercion "Unsize" α1) in
      let* α3 : core.fmt.rt.Argument.t :=
        core.fmt.rt.Argument.t::["new_display"] (borrow why) in
      let* α4 : M.Val core.fmt.rt.Argument.t := M.alloc α3 in
      let* α5 : M.Val (array core.fmt.rt.Argument.t) := M.alloc [ α4 ] in
      let* α6 : M.Val (ref (array core.fmt.rt.Argument.t)) :=
        M.alloc (borrow α5) in
      let* α7 : ref (slice core.fmt.rt.Argument.t) :=
        M.read (pointer_coercion "Unsize" α6) in
      let* α8 : core.fmt.Arguments.t :=
        core.fmt.Arguments.t::["new_v1"] α2 α7 in
      let* α9 : never.t := core.panicking.panic_fmt α8 in
      let* α10 : unit := never_to_any α9 in
      M.alloc α10
    | core.result.Result.Ok _ =>
      let* _ : M.Val unit :=
        let* α0 : M.Val (array (ref str.t)) :=
          M.alloc [ mk_str "sent pangram to wc
" ] in
        let* α1 : M.Val (ref (array (ref str.t))) := M.alloc (borrow α0) in
        let* α2 : ref (slice (ref str.t)) :=
          M.read (pointer_coercion "Unsize" α1) in
        let* α3 : core.fmt.Arguments.t :=
          core.fmt.Arguments.t::["new_const"] α2 in
        let* α4 : unit := std.io.stdio._print α3 in
        M.alloc α4 in
      M.alloc tt
    end in
  let* s : M.Val alloc.string.String.t :=
    let* α0 : alloc.string.String.t := alloc.string.String.t::["new"] in
    M.alloc α0 in
  let* α0 : core.option.Option.t std.process.ChildStdout.t :=
    M.read process.["stdout"] in
  let* α1 : std.process.ChildStdout.t :=
    (core.option.Option.t std.process.ChildStdout.t)::["unwrap"] α0 in
  let* α2 : M.Val std.process.ChildStdout.t := M.alloc α1 in
  let* α3 : core.result.Result.t usize.t std.io.error.Error.t :=
    (std.io.Read.read_to_string
        (Self := std.process.ChildStdout.t)
        (Trait := ltac:(refine _)))
      (borrow_mut α2)
      (borrow_mut s) in
  let* α0 : M.Val unit :=
    match α3 with
    | core.result.Result.Err why =>
      let* why := M.alloc why in
      let* α0 : M.Val (array (ref str.t)) :=
        M.alloc [ mk_str "couldn't read wc stdout: " ] in
      let* α1 : M.Val (ref (array (ref str.t))) := M.alloc (borrow α0) in
      let* α2 : ref (slice (ref str.t)) :=
        M.read (pointer_coercion "Unsize" α1) in
      let* α3 : core.fmt.rt.Argument.t :=
        core.fmt.rt.Argument.t::["new_display"] (borrow why) in
      let* α4 : M.Val core.fmt.rt.Argument.t := M.alloc α3 in
      let* α5 : M.Val (array core.fmt.rt.Argument.t) := M.alloc [ α4 ] in
      let* α6 : M.Val (ref (array core.fmt.rt.Argument.t)) :=
        M.alloc (borrow α5) in
      let* α7 : ref (slice core.fmt.rt.Argument.t) :=
        M.read (pointer_coercion "Unsize" α6) in
      let* α8 : core.fmt.Arguments.t :=
        core.fmt.Arguments.t::["new_v1"] α2 α7 in
      let* α9 : never.t := core.panicking.panic_fmt α8 in
      let* α10 : unit := never_to_any α9 in
      M.alloc α10
    | core.result.Result.Ok _ =>
      let* _ : M.Val unit :=
        let* α0 : M.Val (array (ref str.t)) :=
          M.alloc [ mk_str "wc responded with:
" ] in
        let* α1 : M.Val (ref (array (ref str.t))) := M.alloc (borrow α0) in
        let* α2 : ref (slice (ref str.t)) :=
          M.read (pointer_coercion "Unsize" α1) in
        let* α3 : core.fmt.rt.Argument.t :=
          core.fmt.rt.Argument.t::["new_display"] (borrow s) in
        let* α4 : M.Val core.fmt.rt.Argument.t := M.alloc α3 in
        let* α5 : M.Val (array core.fmt.rt.Argument.t) := M.alloc [ α4 ] in
        let* α6 : M.Val (ref (array core.fmt.rt.Argument.t)) :=
          M.alloc (borrow α5) in
        let* α7 : ref (slice core.fmt.rt.Argument.t) :=
          M.read (pointer_coercion "Unsize" α6) in
        let* α8 : core.fmt.Arguments.t :=
          core.fmt.Arguments.t::["new_v1"] α2 α7 in
        let* α9 : unit := std.io.stdio._print α8 in
        M.alloc α9 in
      M.alloc tt
    end in
  M.read α0.
