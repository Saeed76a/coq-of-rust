(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Definition LOREM_IPSUM : ref str.t :=
  M.run
    (M.pure
      (mk_str
        "Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod
tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam,
quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo
consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse
cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non
proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
")).

(*
fn main() {
    let path = Path::new("lorem_ipsum.txt");
    let display = path.display();

    // Open a file in write-only mode, returns `io::Result<File>`
    let mut file = match File::create(&path) {
        Err(why) => panic!("couldn't create {}: {}", display, why),
        Ok(file) => file,
    };

    // Write the `LOREM_IPSUM` string to `file`, returns `io::Result<()>`
    match file.write_all(LOREM_IPSUM.as_bytes()) {
        Err(why) => panic!("couldn't write to {}: {}", display, why),
        Ok(_) => println!("successfully wrote to {}", display),
    }
}
*)
(* #[allow(dead_code)] - function was ignored by the compiler *)
Definition main : M unit :=
  M.function_body
    (let* path : M.Val (ref std.path.Path.t) :=
      let* α0 : M.Val str.t := deref (mk_str "lorem_ipsum.txt") in
      let* α1 : M.Val (ref str.t) := borrow α0 in
      let* α2 := M.read α1 in
      let* α3 := std.path.Path.t::["new"] α2 in
      M.alloc α3 in
    let* display : M.Val std.path.Display.t :=
      let* α0 : M.Val std.path.Path.t := deref path in
      let* α1 : M.Val (ref std.path.Path.t) := borrow α0 in
      let* α2 := M.read α1 in
      let* α3 := std.path.Path.t::["display"] α2 in
      M.alloc α3 in
    let* file : M.Val std.fs.File.t :=
      let* α0 : M.Val (ref (ref std.path.Path.t)) := borrow path in
      let* α1 := M.read α0 in
      let* α2 := std.fs.File.t::["create"] α1 in
      let* α3 :
          M.Val (core.result.Result.t std.fs.File.t std.io.error.Error.t) :=
        M.alloc α2 in
      let* α4 := M.read α3 in
      let* α5 : M.Val std.fs.File.t :=
        match α4 with
        | core.result.Result.Err why =>
          let* why := M.alloc why in
          let* α0 : M.Val (array (ref str.t)) :=
            M.alloc [ mk_str "couldn't create "; mk_str ": " ] in
          let* α1 : M.Val (ref (array (ref str.t))) := borrow α0 in
          let* α2 : M.Val (ref (slice (ref str.t))) :=
            pointer_coercion "Unsize" α1 in
          let* α3 := M.read α2 in
          let* α4 : M.Val (ref std.path.Display.t) := borrow display in
          let* α5 := M.read α4 in
          let* α6 := core.fmt.rt.Argument.t::["new_display"] α5 in
          let* α7 : M.Val core.fmt.rt.Argument.t := M.alloc α6 in
          let* α8 : M.Val (ref std.io.error.Error.t) := borrow why in
          let* α9 := M.read α8 in
          let* α10 := core.fmt.rt.Argument.t::["new_display"] α9 in
          let* α11 : M.Val core.fmt.rt.Argument.t := M.alloc α10 in
          let* α12 : M.Val (array core.fmt.rt.Argument.t) :=
            M.alloc [ α7; α11 ] in
          let* α13 : M.Val (ref (array core.fmt.rt.Argument.t)) := borrow α12 in
          let* α14 : M.Val (ref (slice core.fmt.rt.Argument.t)) :=
            pointer_coercion "Unsize" α13 in
          let* α15 := M.read α14 in
          let* α16 := core.fmt.Arguments.t::["new_v1"] α3 α15 in
          let* α17 := core.panicking.panic_fmt α16 in
          let* α18 : M.Val never.t := M.alloc α17 in
          never_to_any α18
        | core.result.Result.Ok file =>
          let* file := M.alloc file in
          M.pure file
        end in
      M.copy α5 in
    let* α0 : M.Val (mut_ref std.fs.File.t) := borrow_mut file in
    let* α1 := M.read α0 in
    let* α2 : M.Val (ref str.t) := deref file_io_create.LOREM_IPSUM in
    let* α3 : M.Val str.t := deref α2 in
    let* α4 : M.Val (ref str.t) := borrow α3 in
    let* α5 := M.read α4 in
    let* α6 := str.t::["as_bytes"] α5 in
    let* α7 : M.Val (ref (slice u8.t)) := M.alloc α6 in
    let* α8 : M.Val (slice u8.t) := deref α7 in
    let* α9 : M.Val (ref (slice u8.t)) := borrow α8 in
    let* α10 := M.read α9 in
    let* α11 :=
      (std.io.Write.write_all
          (Self := std.fs.File.t)
          (Trait := ltac:(refine _)))
        α1
        α10 in
    let* α12 : M.Val (core.result.Result.t unit std.io.error.Error.t) :=
      M.alloc α11 in
    let* α13 := M.read α12 in
    match α13 with
    | core.result.Result.Err why =>
      let* why := M.alloc why in
      let* α0 : M.Val (array (ref str.t)) :=
        M.alloc [ mk_str "couldn't write to "; mk_str ": " ] in
      let* α1 : M.Val (ref (array (ref str.t))) := borrow α0 in
      let* α2 : M.Val (ref (slice (ref str.t))) :=
        pointer_coercion "Unsize" α1 in
      let* α3 := M.read α2 in
      let* α4 : M.Val (ref std.path.Display.t) := borrow display in
      let* α5 := M.read α4 in
      let* α6 := core.fmt.rt.Argument.t::["new_display"] α5 in
      let* α7 : M.Val core.fmt.rt.Argument.t := M.alloc α6 in
      let* α8 : M.Val (ref std.io.error.Error.t) := borrow why in
      let* α9 := M.read α8 in
      let* α10 := core.fmt.rt.Argument.t::["new_display"] α9 in
      let* α11 : M.Val core.fmt.rt.Argument.t := M.alloc α10 in
      let* α12 : M.Val (array core.fmt.rt.Argument.t) := M.alloc [ α7; α11 ] in
      let* α13 : M.Val (ref (array core.fmt.rt.Argument.t)) := borrow α12 in
      let* α14 : M.Val (ref (slice core.fmt.rt.Argument.t)) :=
        pointer_coercion "Unsize" α13 in
      let* α15 := M.read α14 in
      let* α16 := core.fmt.Arguments.t::["new_v1"] α3 α15 in
      let* α17 := core.panicking.panic_fmt α16 in
      let* α18 : M.Val never.t := M.alloc α17 in
      never_to_any α18
    | core.result.Result.Ok _ =>
      let* _ : M.Val unit :=
        let* α0 : M.Val (array (ref str.t)) :=
          M.alloc [ mk_str "successfully wrote to "; mk_str "
" ] in
        let* α1 : M.Val (ref (array (ref str.t))) := borrow α0 in
        let* α2 : M.Val (ref (slice (ref str.t))) :=
          pointer_coercion "Unsize" α1 in
        let* α3 := M.read α2 in
        let* α4 : M.Val (ref std.path.Display.t) := borrow display in
        let* α5 := M.read α4 in
        let* α6 := core.fmt.rt.Argument.t::["new_display"] α5 in
        let* α7 : M.Val core.fmt.rt.Argument.t := M.alloc α6 in
        let* α8 : M.Val (array core.fmt.rt.Argument.t) := M.alloc [ α7 ] in
        let* α9 : M.Val (ref (array core.fmt.rt.Argument.t)) := borrow α8 in
        let* α10 : M.Val (ref (slice core.fmt.rt.Argument.t)) :=
          pointer_coercion "Unsize" α9 in
        let* α11 := M.read α10 in
        let* α12 := core.fmt.Arguments.t::["new_v1"] α3 α11 in
        let* α13 := std.io.stdio._print α12 in
        M.alloc α13 in
      M.alloc tt
    end).
