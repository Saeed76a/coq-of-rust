(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module  Mapping.
Section Mapping.
  Context (K V : Set).
  
  Record t : Set := {
    _key : core.marker.PhantomData.t K;
    _value : core.marker.PhantomData.t V;
  }.
  
  Global Instance Get__key : Notations.Dot "_key" := {
    Notations.dot := Ref.map (fun x => x.(_key)) (fun v x => x <| _key := v |>);
  }.
  Global Instance Get_AF__key : Notations.DoubleColon t "_key" := {
    Notations.double_colon (x : M.Val t) := x.["_key"];
  }.
  Global Instance Get__value : Notations.Dot "_value" := {
    Notations.dot :=
      Ref.map (fun x => x.(_value)) (fun v x => x <| _value := v |>);
  }.
  Global Instance Get_AF__value : Notations.DoubleColon t "_value" := {
    Notations.double_colon (x : M.Val t) := x.["_value"];
  }.
End Mapping.
End Mapping.

Module  Impl_core_default_Default_for_erc1155_Mapping_t_K_V.
Section Impl_core_default_Default_for_erc1155_Mapping_t_K_V.
  Context {K V : Set}.
  
  Context
    {ℋ_0 : core.default.Default.Trait K}
    {ℋ_1 : core.default.Default.Trait V}.
  
  Definition Self : Set := erc1155.Mapping.t K V.
  
  (*
  Default
  *)
  Definition default : M (erc1155.Mapping.t K V) :=
    let* α0 : core.marker.PhantomData.t K :=
      M.call
        (core.default.Default.default
          (Self := core.marker.PhantomData.t K)
          (Trait := ltac:(refine _))) in
    let* α1 : core.marker.PhantomData.t V :=
      M.call
        (core.default.Default.default
          (Self := core.marker.PhantomData.t V)
          (Trait := ltac:(refine _))) in
    M.pure {| erc1155.Mapping._key := α0; erc1155.Mapping._value := α1; |}.
  
  Global Instance AssociatedFunction_default :
    Notations.DoubleColon Self "default" := {
    Notations.double_colon := default;
  }.
  
  Global Instance ℐ : core.default.Default.Trait Self := {
    core.default.Default.default := default;
  }.
End Impl_core_default_Default_for_erc1155_Mapping_t_K_V.
End Impl_core_default_Default_for_erc1155_Mapping_t_K_V.

Module  Impl_erc1155_Mapping_t_K_V.
Section Impl_erc1155_Mapping_t_K_V.
  Context {K V : Set}.
  
  Definition Self : Set := erc1155.Mapping.t K V.
  
  (*
      fn contains(&self, _key: &K) -> bool {
          unimplemented!()
      }
  *)
  Definition contains (self : ref Self) (_key : ref K) : M bool.t :=
    let* self := M.alloc self in
    let* _key := M.alloc _key in
    let* α0 : ref str.t := M.read (mk_str "not implemented") in
    let* α1 : never.t := M.call (core.panicking.panic α0) in
    never_to_any α1.
  
  Global Instance AssociatedFunction_contains :
    Notations.DoubleColon Self "contains" := {
    Notations.double_colon := contains;
  }.
  
  (*
      fn get(&self, _key: &K) -> Option<V> {
          unimplemented!()
      }
  *)
  Definition get
      (self : ref Self)
      (_key : ref K)
      : M (core.option.Option.t V) :=
    let* self := M.alloc self in
    let* _key := M.alloc _key in
    let* α0 : ref str.t := M.read (mk_str "not implemented") in
    let* α1 : never.t := M.call (core.panicking.panic α0) in
    never_to_any α1.
  
  Global Instance AssociatedFunction_get : Notations.DoubleColon Self "get" := {
    Notations.double_colon := get;
  }.
  
  (*
      fn insert(&mut self, _key: K, _value: V) -> Option<u32> {
          unimplemented!()
      }
  *)
  Definition insert
      (self : mut_ref Self)
      (_key : K)
      (_value : V)
      : M (core.option.Option.t u32.t) :=
    let* self := M.alloc self in
    let* _key := M.alloc _key in
    let* _value := M.alloc _value in
    let* α0 : ref str.t := M.read (mk_str "not implemented") in
    let* α1 : never.t := M.call (core.panicking.panic α0) in
    never_to_any α1.
  
  Global Instance AssociatedFunction_insert :
    Notations.DoubleColon Self "insert" := {
    Notations.double_colon := insert;
  }.
  
  (*
      fn remove(&self, _key: K) {
          unimplemented!()
      }
  *)
  Definition remove (self : ref Self) (_key : K) : M unit :=
    let* self := M.alloc self in
    let* _key := M.alloc _key in
    let* α0 : ref str.t := M.read (mk_str "not implemented") in
    let* α1 : never.t := M.call (core.panicking.panic α0) in
    never_to_any α1.
  
  Global Instance AssociatedFunction_remove :
    Notations.DoubleColon Self "remove" := {
    Notations.double_colon := remove;
  }.
  
  (*
      fn size(&self, _key: K) -> Option<u32> {
          unimplemented!()
      }
  *)
  Definition size
      (self : ref Self)
      (_key : K)
      : M (core.option.Option.t u32.t) :=
    let* self := M.alloc self in
    let* _key := M.alloc _key in
    let* α0 : ref str.t := M.read (mk_str "not implemented") in
    let* α1 : never.t := M.call (core.panicking.panic α0) in
    never_to_any α1.
  
  Global Instance AssociatedFunction_size :
    Notations.DoubleColon Self "size" := {
    Notations.double_colon := size;
  }.
  
  (*
      fn take(&self, _key: K) -> Option<V> {
          unimplemented!()
      }
  *)
  Definition take (self : ref Self) (_key : K) : M (core.option.Option.t V) :=
    let* self := M.alloc self in
    let* _key := M.alloc _key in
    let* α0 : ref str.t := M.read (mk_str "not implemented") in
    let* α1 : never.t := M.call (core.panicking.panic α0) in
    never_to_any α1.
  
  Global Instance AssociatedFunction_take :
    Notations.DoubleColon Self "take" := {
    Notations.double_colon := take;
  }.
End Impl_erc1155_Mapping_t_K_V.
End Impl_erc1155_Mapping_t_K_V.

Module  AccountId.
Section AccountId.
  Record t : Set := {
    x0 : u128.t;
  }.
  
  Global Instance Get_0 : Notations.Dot "0" := {
    Notations.dot := Ref.map (fun x => x.(x0)) (fun v x => x <| x0 := v |>);
  }.
End AccountId.
End AccountId.

Module  Impl_core_default_Default_for_erc1155_AccountId_t.
Section Impl_core_default_Default_for_erc1155_AccountId_t.
  Definition Self : Set := erc1155.AccountId.t.
  
  (*
  Default
  *)
  Definition default : M erc1155.AccountId.t :=
    let* α0 : u128.t :=
      M.call
        (core.default.Default.default
          (Self := u128.t)
          (Trait := ltac:(refine _))) in
    M.pure (erc1155.AccountId.Build_t α0).
  
  Global Instance AssociatedFunction_default :
    Notations.DoubleColon Self "default" := {
    Notations.double_colon := default;
  }.
  
  Global Instance ℐ : core.default.Default.Trait Self := {
    core.default.Default.default := default;
  }.
End Impl_core_default_Default_for_erc1155_AccountId_t.
End Impl_core_default_Default_for_erc1155_AccountId_t.

Module  Impl_core_clone_Clone_for_erc1155_AccountId_t.
Section Impl_core_clone_Clone_for_erc1155_AccountId_t.
  Definition Self : Set := erc1155.AccountId.t.
  
  (*
  Clone
  *)
  Definition clone (self : ref Self) : M erc1155.AccountId.t :=
    let* self := M.alloc self in
    let _ : unit := tt in
    let* α0 : ref erc1155.AccountId.t := M.read self in
    M.read (deref α0).
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_erc1155_AccountId_t.
End Impl_core_clone_Clone_for_erc1155_AccountId_t.

Module  Impl_core_marker_Copy_for_erc1155_AccountId_t.
Section Impl_core_marker_Copy_for_erc1155_AccountId_t.
  Definition Self : Set := erc1155.AccountId.t.
  
  Global Instance ℐ : core.marker.Copy.Trait Self := {
  }.
End Impl_core_marker_Copy_for_erc1155_AccountId_t.
End Impl_core_marker_Copy_for_erc1155_AccountId_t.

Module  Impl_core_marker_StructuralPartialEq_for_erc1155_AccountId_t.
Section Impl_core_marker_StructuralPartialEq_for_erc1155_AccountId_t.
  Definition Self : Set := erc1155.AccountId.t.
  
  Global Instance ℐ : core.marker.StructuralPartialEq.Trait Self := {
  }.
End Impl_core_marker_StructuralPartialEq_for_erc1155_AccountId_t.
End Impl_core_marker_StructuralPartialEq_for_erc1155_AccountId_t.

Module  Impl_core_cmp_PartialEq_for_erc1155_AccountId_t.
Section Impl_core_cmp_PartialEq_for_erc1155_AccountId_t.
  Definition Self : Set := erc1155.AccountId.t.
  
  (*
  PartialEq
  *)
  Definition eq
      (self : ref Self)
      (other : ref erc1155.AccountId.t)
      : M bool.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    let* α0 : ref erc1155.AccountId.t := M.read self in
    let* α1 : u128.t := M.read (deref α0).["0"] in
    let* α2 : ref erc1155.AccountId.t := M.read other in
    let* α3 : u128.t := M.read (deref α2).["0"] in
    M.pure (BinOp.Pure.eq α1 α3).
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ :
    core.cmp.PartialEq.Required.Trait Self
      (Rhs := core.cmp.PartialEq.Default.Rhs Self) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_for_erc1155_AccountId_t.
End Impl_core_cmp_PartialEq_for_erc1155_AccountId_t.

Module  Impl_core_convert_From_array_u8_t_for_erc1155_AccountId_t.
Section Impl_core_convert_From_array_u8_t_for_erc1155_AccountId_t.
  Definition Self : Set := erc1155.AccountId.t.
  
  (*
      fn from(_v: [u8; 32]) -> Self {
          unimplemented!()
      }
  *)
  Definition from (_v : array u8.t) : M Self :=
    let* _v := M.alloc _v in
    let* α0 : ref str.t := M.read (mk_str "not implemented") in
    let* α1 : never.t := M.call (core.panicking.panic α0) in
    never_to_any α1.
  
  Global Instance AssociatedFunction_from :
    Notations.DoubleColon Self "from" := {
    Notations.double_colon := from;
  }.
  
  Global Instance ℐ : core.convert.From.Trait Self (T := array u8.t) := {
    core.convert.From.from := from;
  }.
End Impl_core_convert_From_array_u8_t_for_erc1155_AccountId_t.
End Impl_core_convert_From_array_u8_t_for_erc1155_AccountId_t.

Ltac Balance := exact u128.t.

Module  Env.
Section Env.
  Record t : Set := {
    caller : erc1155.AccountId.t;
  }.
  
  Global Instance Get_caller : Notations.Dot "caller" := {
    Notations.dot :=
      Ref.map (fun x => x.(caller)) (fun v x => x <| caller := v |>);
  }.
  Global Instance Get_AF_caller : Notations.DoubleColon t "caller" := {
    Notations.double_colon (x : M.Val t) := x.["caller"];
  }.
End Env.
End Env.

(*
fn zero_address() -> AccountId {
    [0u8; 32].into()
}
*)
Definition zero_address : M erc1155.AccountId.t :=
  M.call
    ((core.convert.Into.into (Self := array u8.t) (Trait := ltac:(refine _)))
      (repeat (Integer.of_Z 0) 32)).

Definition ON_ERC_1155_RECEIVED_SELECTOR : M.Val (array u8.t) :=
  M.run
    (M.alloc
      [ Integer.of_Z 242; Integer.of_Z 58; Integer.of_Z 110; Integer.of_Z 97 ]).

Definition _ON_ERC_1155_BATCH_RECEIVED_SELECTOR : M.Val (array u8.t) :=
  M.run
    (M.alloc
      [ Integer.of_Z 188; Integer.of_Z 25; Integer.of_Z 124; Integer.of_Z 129
      ]).

Ltac TokenId := exact u128.t.

Module Error.
  Inductive t : Set :=
  | UnexistentToken
  | ZeroAddressTransfer
  | NotApproved
  | InsufficientBalance
  | SelfApproval
  | BatchTransferMismatch.
End Error.

Module  Impl_core_marker_StructuralPartialEq_for_erc1155_Error_t.
Section Impl_core_marker_StructuralPartialEq_for_erc1155_Error_t.
  Definition Self : Set := erc1155.Error.t.
  
  Global Instance ℐ : core.marker.StructuralPartialEq.Trait Self := {
  }.
End Impl_core_marker_StructuralPartialEq_for_erc1155_Error_t.
End Impl_core_marker_StructuralPartialEq_for_erc1155_Error_t.

Module  Impl_core_cmp_PartialEq_for_erc1155_Error_t.
Section Impl_core_cmp_PartialEq_for_erc1155_Error_t.
  Definition Self : Set := erc1155.Error.t.
  
  (*
  PartialEq
  *)
  Definition eq (self : ref Self) (other : ref erc1155.Error.t) : M bool.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    let* __self_tag : M.Val isize.t :=
      let* α0 : ref erc1155.Error.t := M.read self in
      let* α1 : isize.t := M.call (core.intrinsics.discriminant_value α0) in
      M.alloc α1 in
    let* __arg1_tag : M.Val isize.t :=
      let* α0 : ref erc1155.Error.t := M.read other in
      let* α1 : isize.t := M.call (core.intrinsics.discriminant_value α0) in
      M.alloc α1 in
    let* α0 : isize.t := M.read __self_tag in
    let* α1 : isize.t := M.read __arg1_tag in
    let* α0 : M.Val bool.t := M.alloc (BinOp.Pure.eq α0 α1) in
    M.read α0.
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ :
    core.cmp.PartialEq.Required.Trait Self
      (Rhs := core.cmp.PartialEq.Default.Rhs Self) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_for_erc1155_Error_t.
End Impl_core_cmp_PartialEq_for_erc1155_Error_t.

Module  Impl_core_marker_StructuralEq_for_erc1155_Error_t.
Section Impl_core_marker_StructuralEq_for_erc1155_Error_t.
  Definition Self : Set := erc1155.Error.t.
  
  Global Instance ℐ : core.marker.StructuralEq.Trait Self := {
  }.
End Impl_core_marker_StructuralEq_for_erc1155_Error_t.
End Impl_core_marker_StructuralEq_for_erc1155_Error_t.

Module  Impl_core_cmp_Eq_for_erc1155_Error_t.
Section Impl_core_cmp_Eq_for_erc1155_Error_t.
  Definition Self : Set := erc1155.Error.t.
  
  (*
  Eq
  *)
  Definition assert_receiver_is_total_eq (self : ref Self) : M unit :=
    let* self := M.alloc self in
    M.pure tt.
  
  Global Instance AssociatedFunction_assert_receiver_is_total_eq :
    Notations.DoubleColon Self "assert_receiver_is_total_eq" := {
    Notations.double_colon := assert_receiver_is_total_eq;
  }.
  
  Global Instance ℐ : core.cmp.Eq.Required.Trait Self := {
    core.cmp.Eq.assert_receiver_is_total_eq :=
      Datatypes.Some assert_receiver_is_total_eq;
  }.
End Impl_core_cmp_Eq_for_erc1155_Error_t.
End Impl_core_cmp_Eq_for_erc1155_Error_t.

Ltac Result T := exact (core.result.Result.t T erc1155.Error.t).

Module  Erc1155.
Section Erc1155.
  Class Trait (Self : Set) : Type := {
    safe_transfer_from :
      (mut_ref Self) ->
        erc1155.AccountId.t ->
        erc1155.AccountId.t ->
        ltac:(erc1155.TokenId) ->
        ltac:(erc1155.Balance) ->
        (alloc.vec.Vec.t u8.t alloc.vec.Vec.Default.A) ->
        M ltac:(erc1155.Result unit);
    safe_batch_transfer_from :
      (mut_ref Self) ->
        erc1155.AccountId.t ->
        erc1155.AccountId.t ->
        (alloc.vec.Vec.t ltac:(erc1155.TokenId) alloc.vec.Vec.Default.A) ->
        (alloc.vec.Vec.t ltac:(erc1155.Balance) alloc.vec.Vec.Default.A) ->
        (alloc.vec.Vec.t u8.t alloc.vec.Vec.Default.A) ->
        M ltac:(erc1155.Result unit);
    balance_of :
      (ref Self) ->
        erc1155.AccountId.t ->
        ltac:(erc1155.TokenId) ->
        M ltac:(erc1155.Balance);
    balance_of_batch :
      (ref Self) ->
        (alloc.vec.Vec.t erc1155.AccountId.t alloc.vec.Vec.Default.A) ->
        (alloc.vec.Vec.t ltac:(erc1155.TokenId) alloc.vec.Vec.Default.A) ->
        M (alloc.vec.Vec.t ltac:(erc1155.Balance) alloc.vec.Vec.Default.A);
    set_approval_for_all :
      (mut_ref Self) ->
        erc1155.AccountId.t ->
        bool.t ->
        M ltac:(erc1155.Result unit);
    is_approved_for_all :
      (ref Self) -> erc1155.AccountId.t -> erc1155.AccountId.t -> M bool.t;
  }.
  
End Erc1155.
End Erc1155.

Module  Erc1155TokenReceiver.
Section Erc1155TokenReceiver.
  Class Trait (Self : Set) : Type := {
    on_received :
      (mut_ref Self) ->
        erc1155.AccountId.t ->
        erc1155.AccountId.t ->
        ltac:(erc1155.TokenId) ->
        ltac:(erc1155.Balance) ->
        (alloc.vec.Vec.t u8.t alloc.vec.Vec.Default.A) ->
        M (alloc.vec.Vec.t u8.t alloc.vec.Vec.Default.A);
    on_batch_received :
      (mut_ref Self) ->
        erc1155.AccountId.t ->
        erc1155.AccountId.t ->
        (alloc.vec.Vec.t ltac:(erc1155.TokenId) alloc.vec.Vec.Default.A) ->
        (alloc.vec.Vec.t ltac:(erc1155.Balance) alloc.vec.Vec.Default.A) ->
        (alloc.vec.Vec.t u8.t alloc.vec.Vec.Default.A) ->
        M (alloc.vec.Vec.t u8.t alloc.vec.Vec.Default.A);
  }.
  
End Erc1155TokenReceiver.
End Erc1155TokenReceiver.

Ltac Owner := exact erc1155.AccountId.t.

Ltac Operator := exact erc1155.AccountId.t.

Module  TransferSingle.
Section TransferSingle.
  Record t : Set := {
    operator : core.option.Option.t erc1155.AccountId.t;
    from : core.option.Option.t erc1155.AccountId.t;
    to : core.option.Option.t erc1155.AccountId.t;
    token_id : ltac:(erc1155.TokenId);
    value : ltac:(erc1155.Balance);
  }.
  
  Global Instance Get_operator : Notations.Dot "operator" := {
    Notations.dot :=
      Ref.map (fun x => x.(operator)) (fun v x => x <| operator := v |>);
  }.
  Global Instance Get_AF_operator : Notations.DoubleColon t "operator" := {
    Notations.double_colon (x : M.Val t) := x.["operator"];
  }.
  Global Instance Get_from : Notations.Dot "from" := {
    Notations.dot := Ref.map (fun x => x.(from)) (fun v x => x <| from := v |>);
  }.
  Global Instance Get_AF_from : Notations.DoubleColon t "from" := {
    Notations.double_colon (x : M.Val t) := x.["from"];
  }.
  Global Instance Get_to : Notations.Dot "to" := {
    Notations.dot := Ref.map (fun x => x.(to)) (fun v x => x <| to := v |>);
  }.
  Global Instance Get_AF_to : Notations.DoubleColon t "to" := {
    Notations.double_colon (x : M.Val t) := x.["to"];
  }.
  Global Instance Get_token_id : Notations.Dot "token_id" := {
    Notations.dot :=
      Ref.map (fun x => x.(token_id)) (fun v x => x <| token_id := v |>);
  }.
  Global Instance Get_AF_token_id : Notations.DoubleColon t "token_id" := {
    Notations.double_colon (x : M.Val t) := x.["token_id"];
  }.
  Global Instance Get_value : Notations.Dot "value" := {
    Notations.dot :=
      Ref.map (fun x => x.(value)) (fun v x => x <| value := v |>);
  }.
  Global Instance Get_AF_value : Notations.DoubleColon t "value" := {
    Notations.double_colon (x : M.Val t) := x.["value"];
  }.
End TransferSingle.
End TransferSingle.

Module  ApprovalForAll.
Section ApprovalForAll.
  Record t : Set := {
    owner : erc1155.AccountId.t;
    operator : erc1155.AccountId.t;
    approved : bool.t;
  }.
  
  Global Instance Get_owner : Notations.Dot "owner" := {
    Notations.dot :=
      Ref.map (fun x => x.(owner)) (fun v x => x <| owner := v |>);
  }.
  Global Instance Get_AF_owner : Notations.DoubleColon t "owner" := {
    Notations.double_colon (x : M.Val t) := x.["owner"];
  }.
  Global Instance Get_operator : Notations.Dot "operator" := {
    Notations.dot :=
      Ref.map (fun x => x.(operator)) (fun v x => x <| operator := v |>);
  }.
  Global Instance Get_AF_operator : Notations.DoubleColon t "operator" := {
    Notations.double_colon (x : M.Val t) := x.["operator"];
  }.
  Global Instance Get_approved : Notations.Dot "approved" := {
    Notations.dot :=
      Ref.map (fun x => x.(approved)) (fun v x => x <| approved := v |>);
  }.
  Global Instance Get_AF_approved : Notations.DoubleColon t "approved" := {
    Notations.double_colon (x : M.Val t) := x.["approved"];
  }.
End ApprovalForAll.
End ApprovalForAll.

Module  Uri.
Section Uri.
  Record t : Set := {
    value : alloc.string.String.t;
    token_id : ltac:(erc1155.TokenId);
  }.
  
  Global Instance Get_value : Notations.Dot "value" := {
    Notations.dot :=
      Ref.map (fun x => x.(value)) (fun v x => x <| value := v |>);
  }.
  Global Instance Get_AF_value : Notations.DoubleColon t "value" := {
    Notations.double_colon (x : M.Val t) := x.["value"];
  }.
  Global Instance Get_token_id : Notations.Dot "token_id" := {
    Notations.dot :=
      Ref.map (fun x => x.(token_id)) (fun v x => x <| token_id := v |>);
  }.
  Global Instance Get_AF_token_id : Notations.DoubleColon t "token_id" := {
    Notations.double_colon (x : M.Val t) := x.["token_id"];
  }.
End Uri.
End Uri.

Module Event.
  Inductive t : Set :=
  | TransferSingle (_ : erc1155.TransferSingle.t)
  | ApprovalForAll (_ : erc1155.ApprovalForAll.t)
  | Uri (_ : erc1155.Uri.t).
End Event.

Module  Impl_erc1155_Env_t.
Section Impl_erc1155_Env_t.
  Definition Self : Set := erc1155.Env.t.
  
  (*
      fn caller(&self) -> AccountId {
          self.caller
      }
  *)
  Definition caller (self : ref Self) : M erc1155.AccountId.t :=
    let* self := M.alloc self in
    let* α0 : ref erc1155.Env.t := M.read self in
    M.read (deref α0).["caller"].
  
  Global Instance AssociatedFunction_caller :
    Notations.DoubleColon Self "caller" := {
    Notations.double_colon := caller;
  }.
  
  (*
      fn emit_event(&self, _event: Event) {
          unimplemented!()
      }
  *)
  Definition emit_event (self : ref Self) (_event : erc1155.Event.t) : M unit :=
    let* self := M.alloc self in
    let* _event := M.alloc _event in
    let* α0 : ref str.t := M.read (mk_str "not implemented") in
    let* α1 : never.t := M.call (core.panicking.panic α0) in
    never_to_any α1.
  
  Global Instance AssociatedFunction_emit_event :
    Notations.DoubleColon Self "emit_event" := {
    Notations.double_colon := emit_event;
  }.
End Impl_erc1155_Env_t.
End Impl_erc1155_Env_t.

Module  Contract.
Section Contract.
  Record t : Set := {
    balances :
      erc1155.Mapping.t
        (erc1155.AccountId.t * ltac:(erc1155.TokenId))
        ltac:(erc1155.Balance);
    approvals :
      erc1155.Mapping.t (ltac:(erc1155.Owner) * ltac:(erc1155.Operator)) unit;
    token_id_nonce : ltac:(erc1155.TokenId);
  }.
  
  Global Instance Get_balances : Notations.Dot "balances" := {
    Notations.dot :=
      Ref.map (fun x => x.(balances)) (fun v x => x <| balances := v |>);
  }.
  Global Instance Get_AF_balances : Notations.DoubleColon t "balances" := {
    Notations.double_colon (x : M.Val t) := x.["balances"];
  }.
  Global Instance Get_approvals : Notations.Dot "approvals" := {
    Notations.dot :=
      Ref.map (fun x => x.(approvals)) (fun v x => x <| approvals := v |>);
  }.
  Global Instance Get_AF_approvals : Notations.DoubleColon t "approvals" := {
    Notations.double_colon (x : M.Val t) := x.["approvals"];
  }.
  Global Instance Get_token_id_nonce : Notations.Dot "token_id_nonce" := {
    Notations.dot :=
      Ref.map
        (fun x => x.(token_id_nonce))
        (fun v x => x <| token_id_nonce := v |>);
  }.
  Global Instance Get_AF_token_id_nonce :
    Notations.DoubleColon t "token_id_nonce" := {
    Notations.double_colon (x : M.Val t) := x.["token_id_nonce"];
  }.
End Contract.
End Contract.

Module  Impl_core_default_Default_for_erc1155_Contract_t.
Section Impl_core_default_Default_for_erc1155_Contract_t.
  Definition Self : Set := erc1155.Contract.t.
  
  (*
  Default
  *)
  Definition default : M erc1155.Contract.t :=
    let* α0 : erc1155.Mapping.t (erc1155.AccountId.t * u128.t) u128.t :=
      M.call
        (core.default.Default.default
          (Self := erc1155.Mapping.t (erc1155.AccountId.t * u128.t) u128.t)
          (Trait := ltac:(refine _))) in
    let* α1 :
        erc1155.Mapping.t (erc1155.AccountId.t * erc1155.AccountId.t) unit :=
      M.call
        (core.default.Default.default
          (Self :=
            erc1155.Mapping.t (erc1155.AccountId.t * erc1155.AccountId.t) unit)
          (Trait := ltac:(refine _))) in
    let* α2 : u128.t :=
      M.call
        (core.default.Default.default
          (Self := u128.t)
          (Trait := ltac:(refine _))) in
    M.pure
      {|
        erc1155.Contract.balances := α0;
        erc1155.Contract.approvals := α1;
        erc1155.Contract.token_id_nonce := α2;
      |}.
  
  Global Instance AssociatedFunction_default :
    Notations.DoubleColon Self "default" := {
    Notations.double_colon := default;
  }.
  
  Global Instance ℐ : core.default.Default.Trait Self := {
    core.default.Default.default := default;
  }.
End Impl_core_default_Default_for_erc1155_Contract_t.
End Impl_core_default_Default_for_erc1155_Contract_t.

Module  Impl_erc1155_Contract_t.
Section Impl_erc1155_Contract_t.
  Definition Self : Set := erc1155.Contract.t.
  
  (*
      fn init_env() -> Env {
          unimplemented!()
      }
  *)
  Definition init_env : M erc1155.Env.t :=
    let* α0 : ref str.t := M.read (mk_str "not implemented") in
    let* α1 : never.t := M.call (core.panicking.panic α0) in
    never_to_any α1.
  
  Global Instance AssociatedFunction_init_env :
    Notations.DoubleColon Self "init_env" := {
    Notations.double_colon := init_env;
  }.
  
  (*
      fn env(&self) -> Env {
          Self::init_env()
      }
  *)
  Definition env (self : ref Self) : M erc1155.Env.t :=
    let* self := M.alloc self in
    M.call erc1155.Contract.t::["init_env"].
  
  Global Instance AssociatedFunction_env : Notations.DoubleColon Self "env" := {
    Notations.double_colon := env;
  }.
  
  (*
      pub fn new() -> Self {
          Default::default()
      }
  *)
  Definition new : M Self :=
    M.call
      (core.default.Default.default
        (Self := erc1155.Contract.t)
        (Trait := ltac:(refine _))).
  
  Global Instance AssociatedFunction_new : Notations.DoubleColon Self "new" := {
    Notations.double_colon := new;
  }.
  
  (*
      pub fn create(&mut self, value: Balance) -> TokenId {
          let caller = self.env().caller();
  
          // Given that TokenId is a `u128` the likelihood of this overflowing is pretty
          // slim.
          self.token_id_nonce += 1;
          self.balances.insert((caller, self.token_id_nonce), value);
  
          // Emit transfer event but with mint semantics
          self.env().emit_event(Event::TransferSingle(TransferSingle {
              operator: Some(caller),
              from: None,
              to: if value == 0 { None } else { Some(caller) },
              token_id: self.token_id_nonce,
              value,
          }));
  
          self.token_id_nonce
      }
  *)
  Definition create
      (self : mut_ref Self)
      (value : ltac:(erc1155.Balance))
      : M ltac:(erc1155.TokenId) :=
    let* self := M.alloc self in
    let* value := M.alloc value in
    let* caller : M.Val erc1155.AccountId.t :=
      let* α0 : mut_ref erc1155.Contract.t := M.read self in
      let* α1 : erc1155.Env.t :=
        M.call (erc1155.Contract.t::["env"] (borrow (deref α0))) in
      let* α2 : M.Val erc1155.Env.t := M.alloc α1 in
      let* α3 : erc1155.AccountId.t :=
        M.call (erc1155.Env.t::["caller"] (borrow α2)) in
      M.alloc α3 in
    let* _ : M.Val unit :=
      let* β : M.Val u128.t :=
        let* α0 : mut_ref erc1155.Contract.t := M.read self in
        M.pure (deref α0).["token_id_nonce"] in
      let* α0 := M.read β in
      let* α1 := BinOp.Panic.add α0 (Integer.of_Z 1) in
      assign β α1 in
    let* _ : M.Val (core.option.Option.t u32.t) :=
      let* α0 : mut_ref erc1155.Contract.t := M.read self in
      let* α1 : erc1155.AccountId.t := M.read caller in
      let* α2 : mut_ref erc1155.Contract.t := M.read self in
      let* α3 : u128.t := M.read (deref α2).["token_id_nonce"] in
      let* α4 : u128.t := M.read value in
      let* α5 : core.option.Option.t u32.t :=
        M.call
          ((erc1155.Mapping.t (erc1155.AccountId.t * u128.t) u128.t)::["insert"]
            (borrow_mut (deref α0).["balances"])
            (α1, α3)
            α4) in
      M.alloc α5 in
    let* _ : M.Val unit :=
      let* α0 : mut_ref erc1155.Contract.t := M.read self in
      let* α1 : erc1155.Env.t :=
        M.call (erc1155.Contract.t::["env"] (borrow (deref α0))) in
      let* α2 : M.Val erc1155.Env.t := M.alloc α1 in
      let* α3 : erc1155.AccountId.t := M.read caller in
      let* α4 : u128.t := M.read value in
      let* α5 : M.Val bool.t := M.alloc (BinOp.Pure.eq α4 (Integer.of_Z 0)) in
      let* α6 : bool.t := M.read (use α5) in
      let* α7 : M.Val (core.option.Option.t erc1155.AccountId.t) :=
        if α6 then
          M.alloc core.option.Option.None
        else
          let* α0 : erc1155.AccountId.t := M.read caller in
          M.alloc (core.option.Option.Some α0) in
      let* α8 : core.option.Option.t erc1155.AccountId.t := M.read α7 in
      let* α9 : mut_ref erc1155.Contract.t := M.read self in
      let* α10 : u128.t := M.read (deref α9).["token_id_nonce"] in
      let* α11 : u128.t := M.read value in
      let* α12 : unit :=
        M.call
          (erc1155.Env.t::["emit_event"]
            (borrow α2)
            (erc1155.Event.TransferSingle
              {|
                erc1155.TransferSingle.operator := core.option.Option.Some α3;
                erc1155.TransferSingle.from := core.option.Option.None;
                erc1155.TransferSingle.to := α8;
                erc1155.TransferSingle.token_id := α10;
                erc1155.TransferSingle.value := α11;
              |})) in
      M.alloc α12 in
    let* α0 : mut_ref erc1155.Contract.t := M.read self in
    M.read (deref α0).["token_id_nonce"].
  
  Global Instance AssociatedFunction_create :
    Notations.DoubleColon Self "create" := {
    Notations.double_colon := create;
  }.
  
  (*
      pub fn mint(&mut self, token_id: TokenId, value: Balance) -> Result<()> {
          ensure!(token_id <= self.token_id_nonce, Error::UnexistentToken);
  
          let caller = self.env().caller();
          self.balances.insert((caller, token_id), value);
  
          // Emit transfer event but with mint semantics
          self.env().emit_event(Event::TransferSingle(TransferSingle {
              operator: Some(caller),
              from: None,
              to: Some(caller),
              token_id,
              value,
          }));
  
          Ok(())
      }
  *)
  Definition mint
      (self : mut_ref Self)
      (token_id : ltac:(erc1155.TokenId))
      (value : ltac:(erc1155.Balance))
      : M ltac:(erc1155.Result unit) :=
    let* self := M.alloc self in
    let* token_id := M.alloc token_id in
    let* value := M.alloc value in
    let return_ := M.return_ (R := ltac:(erc1155.Result unit)) in
    M.catch_return
      (let* _ : M.Val unit :=
        let* α0 : u128.t := M.read token_id in
        let* α1 : mut_ref erc1155.Contract.t := M.read self in
        let* α2 : u128.t := M.read (deref α1).["token_id_nonce"] in
        let* α3 : M.Val bool.t := M.alloc (UnOp.not (BinOp.Pure.le α0 α2)) in
        let* α4 : bool.t := M.read (use α3) in
        if α4 then
          let* _ : M.Val never.t :=
            let* α0 : erc1155.Error.t :=
              M.call
                ((core.convert.Into.into
                    (Self := erc1155.Error.t)
                    (Trait := ltac:(refine _)))
                  erc1155.Error.UnexistentToken) in
            return_ (core.result.Result.Err α0) in
          let* α0 : M.Val unit := M.alloc tt in
          let* α1 := M.read α0 in
          let* α2 : unit := never_to_any α1 in
          M.alloc α2
        else
          M.alloc tt in
      let* caller : M.Val erc1155.AccountId.t :=
        let* α0 : mut_ref erc1155.Contract.t := M.read self in
        let* α1 : erc1155.Env.t :=
          M.call (erc1155.Contract.t::["env"] (borrow (deref α0))) in
        let* α2 : M.Val erc1155.Env.t := M.alloc α1 in
        let* α3 : erc1155.AccountId.t :=
          M.call (erc1155.Env.t::["caller"] (borrow α2)) in
        M.alloc α3 in
      let* _ : M.Val (core.option.Option.t u32.t) :=
        let* α0 : mut_ref erc1155.Contract.t := M.read self in
        let* α1 : erc1155.AccountId.t := M.read caller in
        let* α2 : u128.t := M.read token_id in
        let* α3 : u128.t := M.read value in
        let* α4 : core.option.Option.t u32.t :=
          M.call
            ((erc1155.Mapping.t
                  (erc1155.AccountId.t * u128.t)
                  u128.t)::["insert"]
              (borrow_mut (deref α0).["balances"])
              (α1, α2)
              α3) in
        M.alloc α4 in
      let* _ : M.Val unit :=
        let* α0 : mut_ref erc1155.Contract.t := M.read self in
        let* α1 : erc1155.Env.t :=
          M.call (erc1155.Contract.t::["env"] (borrow (deref α0))) in
        let* α2 : M.Val erc1155.Env.t := M.alloc α1 in
        let* α3 : erc1155.AccountId.t := M.read caller in
        let* α4 : erc1155.AccountId.t := M.read caller in
        let* α5 : u128.t := M.read token_id in
        let* α6 : u128.t := M.read value in
        let* α7 : unit :=
          M.call
            (erc1155.Env.t::["emit_event"]
              (borrow α2)
              (erc1155.Event.TransferSingle
                {|
                  erc1155.TransferSingle.operator := core.option.Option.Some α3;
                  erc1155.TransferSingle.from := core.option.Option.None;
                  erc1155.TransferSingle.to := core.option.Option.Some α4;
                  erc1155.TransferSingle.token_id := α5;
                  erc1155.TransferSingle.value := α6;
                |})) in
        M.alloc α7 in
      let* α0 : M.Val (core.result.Result.t unit erc1155.Error.t) :=
        M.alloc (core.result.Result.Ok tt) in
      M.read α0).
  
  Global Instance AssociatedFunction_mint :
    Notations.DoubleColon Self "mint" := {
    Notations.double_colon := mint;
  }.
  
  (*
      fn perform_transfer(
          &mut self,
          from: AccountId,
          to: AccountId,
          token_id: TokenId,
          value: Balance,
      ) {
          let mut sender_balance = self
              .balances
              .get(&(from, token_id))
              .expect("Caller should have ensured that `from` holds `token_id`.");
          sender_balance -= value;
          self.balances.insert((from, token_id), sender_balance);
  
          let mut recipient_balance = self.balances.get(&(to, token_id)).unwrap_or(0 as u128);
          recipient_balance += value;
          self.balances.insert((to, token_id), recipient_balance);
  
          let caller = self.env().caller();
          self.env().emit_event(Event::TransferSingle(TransferSingle {
              operator: Some(caller),
              from: Some(from),
              to: Some(to),
              token_id,
              value,
          }));
      }
  *)
  Definition perform_transfer
      (self : mut_ref Self)
      (from : erc1155.AccountId.t)
      (to : erc1155.AccountId.t)
      (token_id : ltac:(erc1155.TokenId))
      (value : ltac:(erc1155.Balance))
      : M unit :=
    let* self := M.alloc self in
    let* from := M.alloc from in
    let* to := M.alloc to in
    let* token_id := M.alloc token_id in
    let* value := M.alloc value in
    let* sender_balance : M.Val u128.t :=
      let* α0 : mut_ref erc1155.Contract.t := M.read self in
      let* α1 : erc1155.AccountId.t := M.read from in
      let* α2 : u128.t := M.read token_id in
      let* α3 : M.Val (erc1155.AccountId.t * u128.t) := M.alloc (α1, α2) in
      let* α4 : core.option.Option.t u128.t :=
        M.call
          ((erc1155.Mapping.t (erc1155.AccountId.t * u128.t) u128.t)::["get"]
            (borrow (deref α0).["balances"])
            (borrow α3)) in
      let* α5 : ref str.t :=
        M.read
          (mk_str "Caller should have ensured that `from` holds `token_id`.") in
      let* α6 : u128.t :=
        M.call ((core.option.Option.t u128.t)::["expect"] α4 α5) in
      M.alloc α6 in
    let* _ : M.Val unit :=
      let β : M.Val u128.t := sender_balance in
      let* α0 := M.read β in
      let* α1 : u128.t := M.read value in
      let* α2 := BinOp.Panic.sub α0 α1 in
      assign β α2 in
    let* _ : M.Val (core.option.Option.t u32.t) :=
      let* α0 : mut_ref erc1155.Contract.t := M.read self in
      let* α1 : erc1155.AccountId.t := M.read from in
      let* α2 : u128.t := M.read token_id in
      let* α3 : u128.t := M.read sender_balance in
      let* α4 : core.option.Option.t u32.t :=
        M.call
          ((erc1155.Mapping.t (erc1155.AccountId.t * u128.t) u128.t)::["insert"]
            (borrow_mut (deref α0).["balances"])
            (α1, α2)
            α3) in
      M.alloc α4 in
    let* recipient_balance : M.Val u128.t :=
      let* α0 : mut_ref erc1155.Contract.t := M.read self in
      let* α1 : erc1155.AccountId.t := M.read to in
      let* α2 : u128.t := M.read token_id in
      let* α3 : M.Val (erc1155.AccountId.t * u128.t) := M.alloc (α1, α2) in
      let* α4 : core.option.Option.t u128.t :=
        M.call
          ((erc1155.Mapping.t (erc1155.AccountId.t * u128.t) u128.t)::["get"]
            (borrow (deref α0).["balances"])
            (borrow α3)) in
      let* α5 : M.Val u128.t := M.alloc (Integer.of_Z 0) in
      let* α6 : u128.t := M.read (use α5) in
      let* α7 : u128.t :=
        M.call ((core.option.Option.t u128.t)::["unwrap_or"] α4 α6) in
      M.alloc α7 in
    let* _ : M.Val unit :=
      let β : M.Val u128.t := recipient_balance in
      let* α0 := M.read β in
      let* α1 : u128.t := M.read value in
      let* α2 := BinOp.Panic.add α0 α1 in
      assign β α2 in
    let* _ : M.Val (core.option.Option.t u32.t) :=
      let* α0 : mut_ref erc1155.Contract.t := M.read self in
      let* α1 : erc1155.AccountId.t := M.read to in
      let* α2 : u128.t := M.read token_id in
      let* α3 : u128.t := M.read recipient_balance in
      let* α4 : core.option.Option.t u32.t :=
        M.call
          ((erc1155.Mapping.t (erc1155.AccountId.t * u128.t) u128.t)::["insert"]
            (borrow_mut (deref α0).["balances"])
            (α1, α2)
            α3) in
      M.alloc α4 in
    let* caller : M.Val erc1155.AccountId.t :=
      let* α0 : mut_ref erc1155.Contract.t := M.read self in
      let* α1 : erc1155.Env.t :=
        M.call (erc1155.Contract.t::["env"] (borrow (deref α0))) in
      let* α2 : M.Val erc1155.Env.t := M.alloc α1 in
      let* α3 : erc1155.AccountId.t :=
        M.call (erc1155.Env.t::["caller"] (borrow α2)) in
      M.alloc α3 in
    let* _ : M.Val unit :=
      let* α0 : mut_ref erc1155.Contract.t := M.read self in
      let* α1 : erc1155.Env.t :=
        M.call (erc1155.Contract.t::["env"] (borrow (deref α0))) in
      let* α2 : M.Val erc1155.Env.t := M.alloc α1 in
      let* α3 : erc1155.AccountId.t := M.read caller in
      let* α4 : erc1155.AccountId.t := M.read from in
      let* α5 : erc1155.AccountId.t := M.read to in
      let* α6 : u128.t := M.read token_id in
      let* α7 : u128.t := M.read value in
      let* α8 : unit :=
        M.call
          (erc1155.Env.t::["emit_event"]
            (borrow α2)
            (erc1155.Event.TransferSingle
              {|
                erc1155.TransferSingle.operator := core.option.Option.Some α3;
                erc1155.TransferSingle.from := core.option.Option.Some α4;
                erc1155.TransferSingle.to := core.option.Option.Some α5;
                erc1155.TransferSingle.token_id := α6;
                erc1155.TransferSingle.value := α7;
              |})) in
      M.alloc α8 in
    let* α0 : M.Val unit := M.alloc tt in
    M.read α0.
  
  Global Instance AssociatedFunction_perform_transfer :
    Notations.DoubleColon Self "perform_transfer" := {
    Notations.double_colon := perform_transfer;
  }.
  
  (*
      fn transfer_acceptance_check(
          &mut self,
          caller: AccountId,
          from: AccountId,
          to: AccountId,
          token_id: TokenId,
          value: Balance,
          data: Vec<u8>,
      ) {
          // This is disabled during tests due to the use of `invoke_contract()` not
          // being supported (tests end up panicking).
          #[cfg(not(test))]
          {
              use ink::env::call::{build_call, ExecutionInput, Selector};
  
              // If our recipient is a smart contract we need to see if they accept or
              // reject this transfer. If they reject it we need to revert the call.
              let result = build_call::<Environment>()
                  .call(to)
                  .gas_limit(5000)
                  .exec_input(
                      ExecutionInput::new(Selector::new(ON_ERC_1155_RECEIVED_SELECTOR))
                          .push_arg(caller)
                          .push_arg(from)
                          .push_arg(token_id)
                          .push_arg(value)
                          .push_arg(data),
                  )
                  .returns::<Vec<u8>>()
                  .params()
                  .try_invoke();
  
              match result {
                  Ok(v) => {
                      ink::env::debug_println!(
                          "Received return value \"{:?}\" from contract {:?}",
                          v.clone()
                              .expect("Call should be valid, don't expect a `LangError`."),
                          from
                      );
                      assert_eq!(
                          v.clone()
                              .expect("Call should be valid, don't expect a `LangError`."),
                          &ON_ERC_1155_RECEIVED_SELECTOR[..],
                          "The recipient contract at {to:?} does not accept token transfers.\n
                              Expected: {ON_ERC_1155_RECEIVED_SELECTOR:?}, Got {v:?}"
                      )
                  }
                  Err(e) => {
                      match e {
                          ink::env::Error::CodeNotFound | ink::env::Error::NotCallable => {
                              // Our recipient wasn't a smart contract, so there's
                              // nothing more for
                              // us to do
                              ink::env::debug_println!(
                                  "Recipient at {:?} from is not a smart contract ({:?})",
                                  from,
                                  e
                              );
                          }
                          _ => {
                              // We got some sort of error from the call to our
                              // recipient smart
                              // contract, and as such we must revert this call
                              panic!("Got error \"{e:?}\" while trying to call {from:?}")
                          }
                      }
                  }
              }
          }
      }
  *)
  Definition transfer_acceptance_check
      (self : mut_ref Self)
      (caller : erc1155.AccountId.t)
      (from : erc1155.AccountId.t)
      (to : erc1155.AccountId.t)
      (token_id : ltac:(erc1155.TokenId))
      (value : ltac:(erc1155.Balance))
      (data : alloc.vec.Vec.t u8.t alloc.vec.Vec.Default.A)
      : M unit :=
    let* self := M.alloc self in
    let* caller := M.alloc caller in
    let* from := M.alloc from in
    let* to := M.alloc to in
    let* token_id := M.alloc token_id in
    let* value := M.alloc value in
    let* data := M.alloc data in
    M.pure tt.
  
  Global Instance AssociatedFunction_transfer_acceptance_check :
    Notations.DoubleColon Self "transfer_acceptance_check" := {
    Notations.double_colon := transfer_acceptance_check;
  }.
End Impl_erc1155_Contract_t.
End Impl_erc1155_Contract_t.

Module  Impl_erc1155_Erc1155_for_erc1155_Contract_t.
Section Impl_erc1155_Erc1155_for_erc1155_Contract_t.
  Definition Self : Set := erc1155.Contract.t.
  
  (*
      fn is_approved_for_all(&self, owner: AccountId, operator: AccountId) -> bool {
          self.approvals.contains(&(owner, operator))
      }
  *)
  Definition is_approved_for_all
      (self : ref Self)
      (owner : erc1155.AccountId.t)
      (operator : erc1155.AccountId.t)
      : M bool.t :=
    let* self := M.alloc self in
    let* owner := M.alloc owner in
    let* operator := M.alloc operator in
    let* α0 : ref erc1155.Contract.t := M.read self in
    let* α1 : erc1155.AccountId.t := M.read owner in
    let* α2 : erc1155.AccountId.t := M.read operator in
    let* α3 : M.Val (erc1155.AccountId.t * erc1155.AccountId.t) :=
      M.alloc (α1, α2) in
    M.call
      ((erc1155.Mapping.t
            (erc1155.AccountId.t * erc1155.AccountId.t)
            unit)::["contains"]
        (borrow (deref α0).["approvals"])
        (borrow α3)).
  
  Global Instance AssociatedFunction_is_approved_for_all :
    Notations.DoubleColon Self "is_approved_for_all" := {
    Notations.double_colon := is_approved_for_all;
  }.
  
  (*
      fn balance_of(&self, owner: AccountId, token_id: TokenId) -> Balance {
          self.balances.get(&(owner, token_id)).unwrap_or(0 as u128)
      }
  *)
  Definition balance_of
      (self : ref Self)
      (owner : erc1155.AccountId.t)
      (token_id : ltac:(erc1155.TokenId))
      : M ltac:(erc1155.Balance) :=
    let* self := M.alloc self in
    let* owner := M.alloc owner in
    let* token_id := M.alloc token_id in
    let* α0 : ref erc1155.Contract.t := M.read self in
    let* α1 : erc1155.AccountId.t := M.read owner in
    let* α2 : u128.t := M.read token_id in
    let* α3 : M.Val (erc1155.AccountId.t * u128.t) := M.alloc (α1, α2) in
    let* α4 : core.option.Option.t u128.t :=
      M.call
        ((erc1155.Mapping.t (erc1155.AccountId.t * u128.t) u128.t)::["get"]
          (borrow (deref α0).["balances"])
          (borrow α3)) in
    let* α5 : M.Val u128.t := M.alloc (Integer.of_Z 0) in
    let* α6 : u128.t := M.read (use α5) in
    M.call ((core.option.Option.t u128.t)::["unwrap_or"] α4 α6).
  
  Global Instance AssociatedFunction_balance_of :
    Notations.DoubleColon Self "balance_of" := {
    Notations.double_colon := balance_of;
  }.
  
  (*
      fn safe_transfer_from(
          &mut self,
          from: AccountId,
          to: AccountId,
          token_id: TokenId,
          value: Balance,
          data: Vec<u8>,
      ) -> Result<()> {
          let caller = self.env().caller();
          if caller != from {
              ensure!(self.is_approved_for_all(from, caller), Error::NotApproved);
          }
  
          ensure!(to != zero_address(), Error::ZeroAddressTransfer);
  
          let balance = self.balance_of(from, token_id);
          ensure!(balance >= value, Error::InsufficientBalance);
  
          self.perform_transfer(from, to, token_id, value);
          self.transfer_acceptance_check(caller, from, to, token_id, value, data);
  
          Ok(())
      }
  *)
  Definition safe_transfer_from
      (self : mut_ref Self)
      (from : erc1155.AccountId.t)
      (to : erc1155.AccountId.t)
      (token_id : ltac:(erc1155.TokenId))
      (value : ltac:(erc1155.Balance))
      (data : alloc.vec.Vec.t u8.t alloc.vec.Vec.Default.A)
      : M ltac:(erc1155.Result unit) :=
    let* self := M.alloc self in
    let* from := M.alloc from in
    let* to := M.alloc to in
    let* token_id := M.alloc token_id in
    let* value := M.alloc value in
    let* data := M.alloc data in
    let return_ := M.return_ (R := ltac:(erc1155.Result unit)) in
    M.catch_return
      (let* caller : M.Val erc1155.AccountId.t :=
        let* α0 : mut_ref erc1155.Contract.t := M.read self in
        let* α1 : erc1155.Env.t :=
          M.call (erc1155.Contract.t::["env"] (borrow (deref α0))) in
        let* α2 : M.Val erc1155.Env.t := M.alloc α1 in
        let* α3 : erc1155.AccountId.t :=
          M.call (erc1155.Env.t::["caller"] (borrow α2)) in
        M.alloc α3 in
      let* _ : M.Val unit :=
        let* α0 : bool.t :=
          M.call
            ((core.cmp.PartialEq.ne
                (Self := erc1155.AccountId.t)
                (Trait := ltac:(refine _)))
              (borrow caller)
              (borrow from)) in
        let* α1 : M.Val bool.t := M.alloc α0 in
        let* α2 : bool.t := M.read (use α1) in
        if α2 then
          let* _ : M.Val unit :=
            let* α0 : mut_ref erc1155.Contract.t := M.read self in
            let* α1 : erc1155.AccountId.t := M.read from in
            let* α2 : erc1155.AccountId.t := M.read caller in
            let* α3 : bool.t :=
              M.call (is_approved_for_all (borrow (deref α0)) α1 α2) in
            let* α4 : M.Val bool.t := M.alloc (UnOp.not α3) in
            let* α5 : bool.t := M.read (use α4) in
            if α5 then
              let* _ : M.Val never.t :=
                let* α0 : erc1155.Error.t :=
                  M.call
                    ((core.convert.Into.into
                        (Self := erc1155.Error.t)
                        (Trait := ltac:(refine _)))
                      erc1155.Error.NotApproved) in
                return_ (core.result.Result.Err α0) in
              let* α0 : M.Val unit := M.alloc tt in
              let* α1 := M.read α0 in
              let* α2 : unit := never_to_any α1 in
              M.alloc α2
            else
              M.alloc tt in
          M.alloc tt
        else
          M.alloc tt in
      let* _ : M.Val unit :=
        let* α0 : erc1155.AccountId.t := M.call erc1155.zero_address in
        let* α1 : M.Val erc1155.AccountId.t := M.alloc α0 in
        let* α2 : bool.t :=
          M.call
            ((core.cmp.PartialEq.ne
                (Self := erc1155.AccountId.t)
                (Trait := ltac:(refine _)))
              (borrow to)
              (borrow α1)) in
        let* α3 : M.Val bool.t := M.alloc (UnOp.not α2) in
        let* α4 : bool.t := M.read (use α3) in
        if α4 then
          let* _ : M.Val never.t :=
            let* α0 : erc1155.Error.t :=
              M.call
                ((core.convert.Into.into
                    (Self := erc1155.Error.t)
                    (Trait := ltac:(refine _)))
                  erc1155.Error.ZeroAddressTransfer) in
            return_ (core.result.Result.Err α0) in
          let* α0 : M.Val unit := M.alloc tt in
          let* α1 := M.read α0 in
          let* α2 : unit := never_to_any α1 in
          M.alloc α2
        else
          M.alloc tt in
      let* balance : M.Val u128.t :=
        let* α0 : mut_ref erc1155.Contract.t := M.read self in
        let* α1 : erc1155.AccountId.t := M.read from in
        let* α2 : u128.t := M.read token_id in
        let* α3 : u128.t := M.call (balance_of (borrow (deref α0)) α1 α2) in
        M.alloc α3 in
      let* _ : M.Val unit :=
        let* α0 : u128.t := M.read balance in
        let* α1 : u128.t := M.read value in
        let* α2 : M.Val bool.t := M.alloc (UnOp.not (BinOp.Pure.ge α0 α1)) in
        let* α3 : bool.t := M.read (use α2) in
        if α3 then
          let* _ : M.Val never.t :=
            let* α0 : erc1155.Error.t :=
              M.call
                ((core.convert.Into.into
                    (Self := erc1155.Error.t)
                    (Trait := ltac:(refine _)))
                  erc1155.Error.InsufficientBalance) in
            return_ (core.result.Result.Err α0) in
          let* α0 : M.Val unit := M.alloc tt in
          let* α1 := M.read α0 in
          let* α2 : unit := never_to_any α1 in
          M.alloc α2
        else
          M.alloc tt in
      let* _ : M.Val unit :=
        let* α0 : mut_ref erc1155.Contract.t := M.read self in
        let* α1 : erc1155.AccountId.t := M.read from in
        let* α2 : erc1155.AccountId.t := M.read to in
        let* α3 : u128.t := M.read token_id in
        let* α4 : u128.t := M.read value in
        let* α5 : unit :=
          M.call (erc1155.Contract.t::["perform_transfer"] α0 α1 α2 α3 α4) in
        M.alloc α5 in
      let* _ : M.Val unit :=
        let* α0 : mut_ref erc1155.Contract.t := M.read self in
        let* α1 : erc1155.AccountId.t := M.read caller in
        let* α2 : erc1155.AccountId.t := M.read from in
        let* α3 : erc1155.AccountId.t := M.read to in
        let* α4 : u128.t := M.read token_id in
        let* α5 : u128.t := M.read value in
        let* α6 : alloc.vec.Vec.t u8.t alloc.alloc.Global.t := M.read data in
        let* α7 : unit :=
          M.call
            (erc1155.Contract.t::["transfer_acceptance_check"]
              α0
              α1
              α2
              α3
              α4
              α5
              α6) in
        M.alloc α7 in
      let* α0 : M.Val (core.result.Result.t unit erc1155.Error.t) :=
        M.alloc (core.result.Result.Ok tt) in
      M.read α0).
  
  Global Instance AssociatedFunction_safe_transfer_from :
    Notations.DoubleColon Self "safe_transfer_from" := {
    Notations.double_colon := safe_transfer_from;
  }.
  
  (*
      fn safe_batch_transfer_from(
          &mut self,
          from: AccountId,
          to: AccountId,
          token_ids: Vec<TokenId>,
          values: Vec<Balance>,
          data: Vec<u8>,
      ) -> Result<()> {
          let caller = self.env().caller();
          if caller != from {
              ensure!(self.is_approved_for_all(from, caller), Error::NotApproved);
          }
  
          ensure!(to != zero_address(), Error::ZeroAddressTransfer);
          ensure!(!token_ids.is_empty(), Error::BatchTransferMismatch);
          ensure!(
              token_ids.len() == values.len(),
              Error::BatchTransferMismatch,
          );
  
          let transfers = token_ids.iter().zip(values.iter());
          for (&id, &v) in transfers.clone() {
              let balance = self.balance_of(from, id);
              ensure!(balance >= v, Error::InsufficientBalance);
          }
  
          for (&id, &v) in transfers {
              self.perform_transfer(from, to, id, v);
          }
  
          // Can use the any token ID/value here, we really just care about knowing if
          // `to` is a smart contract which accepts transfers
          self.transfer_acceptance_check(caller, from, to, token_ids[0], values[0], data);
  
          Ok(())
      }
  *)
  Definition safe_batch_transfer_from
      (self : mut_ref Self)
      (from : erc1155.AccountId.t)
      (to : erc1155.AccountId.t)
      (token_ids
        :
        alloc.vec.Vec.t ltac:(erc1155.TokenId) alloc.vec.Vec.Default.A)
      (values : alloc.vec.Vec.t ltac:(erc1155.Balance) alloc.vec.Vec.Default.A)
      (data : alloc.vec.Vec.t u8.t alloc.vec.Vec.Default.A)
      : M ltac:(erc1155.Result unit) :=
    let* self := M.alloc self in
    let* from := M.alloc from in
    let* to := M.alloc to in
    let* token_ids := M.alloc token_ids in
    let* values := M.alloc values in
    let* data := M.alloc data in
    let return_ := M.return_ (R := ltac:(erc1155.Result unit)) in
    M.catch_return
      (let* caller : M.Val erc1155.AccountId.t :=
        let* α0 : mut_ref erc1155.Contract.t := M.read self in
        let* α1 : erc1155.Env.t :=
          M.call (erc1155.Contract.t::["env"] (borrow (deref α0))) in
        let* α2 : M.Val erc1155.Env.t := M.alloc α1 in
        let* α3 : erc1155.AccountId.t :=
          M.call (erc1155.Env.t::["caller"] (borrow α2)) in
        M.alloc α3 in
      let* _ : M.Val unit :=
        let* α0 : bool.t :=
          M.call
            ((core.cmp.PartialEq.ne
                (Self := erc1155.AccountId.t)
                (Trait := ltac:(refine _)))
              (borrow caller)
              (borrow from)) in
        let* α1 : M.Val bool.t := M.alloc α0 in
        let* α2 : bool.t := M.read (use α1) in
        if α2 then
          let* _ : M.Val unit :=
            let* α0 : mut_ref erc1155.Contract.t := M.read self in
            let* α1 : erc1155.AccountId.t := M.read from in
            let* α2 : erc1155.AccountId.t := M.read caller in
            let* α3 : bool.t :=
              M.call (is_approved_for_all (borrow (deref α0)) α1 α2) in
            let* α4 : M.Val bool.t := M.alloc (UnOp.not α3) in
            let* α5 : bool.t := M.read (use α4) in
            if α5 then
              let* _ : M.Val never.t :=
                let* α0 : erc1155.Error.t :=
                  M.call
                    ((core.convert.Into.into
                        (Self := erc1155.Error.t)
                        (Trait := ltac:(refine _)))
                      erc1155.Error.NotApproved) in
                return_ (core.result.Result.Err α0) in
              let* α0 : M.Val unit := M.alloc tt in
              let* α1 := M.read α0 in
              let* α2 : unit := never_to_any α1 in
              M.alloc α2
            else
              M.alloc tt in
          M.alloc tt
        else
          M.alloc tt in
      let* _ : M.Val unit :=
        let* α0 : erc1155.AccountId.t := M.call erc1155.zero_address in
        let* α1 : M.Val erc1155.AccountId.t := M.alloc α0 in
        let* α2 : bool.t :=
          M.call
            ((core.cmp.PartialEq.ne
                (Self := erc1155.AccountId.t)
                (Trait := ltac:(refine _)))
              (borrow to)
              (borrow α1)) in
        let* α3 : M.Val bool.t := M.alloc (UnOp.not α2) in
        let* α4 : bool.t := M.read (use α3) in
        if α4 then
          let* _ : M.Val never.t :=
            let* α0 : erc1155.Error.t :=
              M.call
                ((core.convert.Into.into
                    (Self := erc1155.Error.t)
                    (Trait := ltac:(refine _)))
                  erc1155.Error.ZeroAddressTransfer) in
            return_ (core.result.Result.Err α0) in
          let* α0 : M.Val unit := M.alloc tt in
          let* α1 := M.read α0 in
          let* α2 : unit := never_to_any α1 in
          M.alloc α2
        else
          M.alloc tt in
      let* _ : M.Val unit :=
        let* α0 : bool.t :=
          M.call
            ((alloc.vec.Vec.t u128.t alloc.alloc.Global.t)::["is_empty"]
              (borrow token_ids)) in
        let* α1 : M.Val bool.t := M.alloc (UnOp.not (UnOp.not α0)) in
        let* α2 : bool.t := M.read (use α1) in
        if α2 then
          let* _ : M.Val never.t :=
            let* α0 : erc1155.Error.t :=
              M.call
                ((core.convert.Into.into
                    (Self := erc1155.Error.t)
                    (Trait := ltac:(refine _)))
                  erc1155.Error.BatchTransferMismatch) in
            return_ (core.result.Result.Err α0) in
          let* α0 : M.Val unit := M.alloc tt in
          let* α1 := M.read α0 in
          let* α2 : unit := never_to_any α1 in
          M.alloc α2
        else
          M.alloc tt in
      let* _ : M.Val unit :=
        let* α0 : usize.t :=
          M.call
            ((alloc.vec.Vec.t u128.t alloc.alloc.Global.t)::["len"]
              (borrow token_ids)) in
        let* α1 : usize.t :=
          M.call
            ((alloc.vec.Vec.t u128.t alloc.alloc.Global.t)::["len"]
              (borrow values)) in
        let* α2 : M.Val bool.t := M.alloc (UnOp.not (BinOp.Pure.eq α0 α1)) in
        let* α3 : bool.t := M.read (use α2) in
        if α3 then
          let* _ : M.Val never.t :=
            let* α0 : erc1155.Error.t :=
              M.call
                ((core.convert.Into.into
                    (Self := erc1155.Error.t)
                    (Trait := ltac:(refine _)))
                  erc1155.Error.BatchTransferMismatch) in
            return_ (core.result.Result.Err α0) in
          let* α0 : M.Val unit := M.alloc tt in
          let* α1 := M.read α0 in
          let* α2 : unit := never_to_any α1 in
          M.alloc α2
        else
          M.alloc tt in
      let* transfers :
          M.Val
            (core.iter.adapters.zip.Zip.t
              (core.slice.iter.Iter.t u128.t)
              (core.slice.iter.Iter.t u128.t)) :=
        let* α0 : ref (slice u128.t) :=
          M.call
            ((core.ops.deref.Deref.deref
                (Self := alloc.vec.Vec.t u128.t alloc.alloc.Global.t)
                (Trait := ltac:(refine _)))
              (borrow token_ids)) in
        let* α1 : core.slice.iter.Iter.t u128.t :=
          M.call ((slice u128.t)::["iter"] α0) in
        let* α2 : ref (slice u128.t) :=
          M.call
            ((core.ops.deref.Deref.deref
                (Self := alloc.vec.Vec.t u128.t alloc.alloc.Global.t)
                (Trait := ltac:(refine _)))
              (borrow values)) in
        let* α3 : core.slice.iter.Iter.t u128.t :=
          M.call ((slice u128.t)::["iter"] α2) in
        let* α4 :
            core.iter.adapters.zip.Zip.t
              (core.slice.iter.Iter.t u128.t)
              (core.slice.iter.Iter.t u128.t) :=
          M.call
            ((core.iter.traits.iterator.Iterator.zip
                (Self := core.slice.iter.Iter.t u128.t)
                (Trait := ltac:(refine _)))
              α1
              α3) in
        M.alloc α4 in
      let* _ : M.Val unit :=
        let* α0 :
            core.iter.adapters.zip.Zip.t
              (core.slice.iter.Iter.t u128.t)
              (core.slice.iter.Iter.t u128.t) :=
          M.call
            ((core.clone.Clone.clone
                (Self :=
                  core.iter.adapters.zip.Zip.t
                    (core.slice.iter.Iter.t u128.t)
                    (core.slice.iter.Iter.t u128.t))
                (Trait := ltac:(refine _)))
              (borrow transfers)) in
        let* α1 :
            core.iter.adapters.zip.Zip.t
              (core.slice.iter.Iter.t u128.t)
              (core.slice.iter.Iter.t u128.t) :=
          M.call
            ((core.iter.traits.collect.IntoIterator.into_iter
                (Self :=
                  core.iter.adapters.zip.Zip.t
                    (core.slice.iter.Iter.t u128.t)
                    (core.slice.iter.Iter.t u128.t))
                (Trait := ltac:(refine _)))
              α0) in
        let* α2 : M.Val unit :=
          match α1 with
          | iter =>
            let* iter := M.alloc iter in
            loop
              (let* _ : M.Val unit :=
                let* α0 : core.option.Option.t ((ref u128.t) * (ref u128.t)) :=
                  M.call
                    ((core.iter.traits.iterator.Iterator.next
                        (Self :=
                          core.iter.adapters.zip.Zip.t
                            (core.slice.iter.Iter.t u128.t)
                            (core.slice.iter.Iter.t u128.t))
                        (Trait := ltac:(refine _)))
                      (borrow_mut iter)) in
                match α0 with
                | core.option.Option.None  =>
                  let* α0 : M.Val never.t := Break in
                  let* α1 := M.read α0 in
                  let* α2 : unit := never_to_any α1 in
                  M.alloc α2
                | core.option.Option.Some (id, v) =>
                  let* id := M.alloc id in
                  let* v := M.alloc v in
                  let* balance : M.Val u128.t :=
                    let* α0 : mut_ref erc1155.Contract.t := M.read self in
                    let* α1 : erc1155.AccountId.t := M.read from in
                    let* α2 : u128.t := M.read id in
                    let* α3 : u128.t :=
                      M.call (balance_of (borrow (deref α0)) α1 α2) in
                    M.alloc α3 in
                  let* _ : M.Val unit :=
                    let* α0 : u128.t := M.read balance in
                    let* α1 : u128.t := M.read v in
                    let* α2 : M.Val bool.t :=
                      M.alloc (UnOp.not (BinOp.Pure.ge α0 α1)) in
                    let* α3 : bool.t := M.read (use α2) in
                    if α3 then
                      let* _ : M.Val never.t :=
                        let* α0 : erc1155.Error.t :=
                          M.call
                            ((core.convert.Into.into
                                (Self := erc1155.Error.t)
                                (Trait := ltac:(refine _)))
                              erc1155.Error.InsufficientBalance) in
                        return_ (core.result.Result.Err α0) in
                      let* α0 : M.Val unit := M.alloc tt in
                      let* α1 := M.read α0 in
                      let* α2 : unit := never_to_any α1 in
                      M.alloc α2
                    else
                      M.alloc tt in
                  M.alloc tt
                end in
              M.alloc tt)
          end in
        M.pure (use α2) in
      let* _ : M.Val unit :=
        let* α0 :
            core.iter.adapters.zip.Zip.t
              (core.slice.iter.Iter.t u128.t)
              (core.slice.iter.Iter.t u128.t) :=
          M.read transfers in
        let* α1 :
            core.iter.adapters.zip.Zip.t
              (core.slice.iter.Iter.t u128.t)
              (core.slice.iter.Iter.t u128.t) :=
          M.call
            ((core.iter.traits.collect.IntoIterator.into_iter
                (Self :=
                  core.iter.adapters.zip.Zip.t
                    (core.slice.iter.Iter.t u128.t)
                    (core.slice.iter.Iter.t u128.t))
                (Trait := ltac:(refine _)))
              α0) in
        let* α2 : M.Val unit :=
          match α1 with
          | iter =>
            let* iter := M.alloc iter in
            loop
              (let* _ : M.Val unit :=
                let* α0 : core.option.Option.t ((ref u128.t) * (ref u128.t)) :=
                  M.call
                    ((core.iter.traits.iterator.Iterator.next
                        (Self :=
                          core.iter.adapters.zip.Zip.t
                            (core.slice.iter.Iter.t u128.t)
                            (core.slice.iter.Iter.t u128.t))
                        (Trait := ltac:(refine _)))
                      (borrow_mut iter)) in
                match α0 with
                | core.option.Option.None  =>
                  let* α0 : M.Val never.t := Break in
                  let* α1 := M.read α0 in
                  let* α2 : unit := never_to_any α1 in
                  M.alloc α2
                | core.option.Option.Some (id, v) =>
                  let* id := M.alloc id in
                  let* v := M.alloc v in
                  let* _ : M.Val unit :=
                    let* α0 : mut_ref erc1155.Contract.t := M.read self in
                    let* α1 : erc1155.AccountId.t := M.read from in
                    let* α2 : erc1155.AccountId.t := M.read to in
                    let* α3 : u128.t := M.read id in
                    let* α4 : u128.t := M.read v in
                    let* α5 : unit :=
                      M.call
                        (erc1155.Contract.t::["perform_transfer"]
                          α0
                          α1
                          α2
                          α3
                          α4) in
                    M.alloc α5 in
                  M.alloc tt
                end in
              M.alloc tt)
          end in
        M.pure (use α2) in
      let* _ : M.Val unit :=
        let* α0 : mut_ref erc1155.Contract.t := M.read self in
        let* α1 : erc1155.AccountId.t := M.read caller in
        let* α2 : erc1155.AccountId.t := M.read from in
        let* α3 : erc1155.AccountId.t := M.read to in
        let* α4 : ref u128.t :=
          M.call
            ((core.ops.index.Index.index
                (Self := alloc.vec.Vec.t u128.t alloc.alloc.Global.t)
                (Trait := ltac:(refine _)))
              (borrow token_ids)
              (Integer.of_Z 0)) in
        let* α5 : u128.t := M.read (deref α4) in
        let* α6 : ref u128.t :=
          M.call
            ((core.ops.index.Index.index
                (Self := alloc.vec.Vec.t u128.t alloc.alloc.Global.t)
                (Trait := ltac:(refine _)))
              (borrow values)
              (Integer.of_Z 0)) in
        let* α7 : u128.t := M.read (deref α6) in
        let* α8 : alloc.vec.Vec.t u8.t alloc.alloc.Global.t := M.read data in
        let* α9 : unit :=
          M.call
            (erc1155.Contract.t::["transfer_acceptance_check"]
              α0
              α1
              α2
              α3
              α5
              α7
              α8) in
        M.alloc α9 in
      let* α0 : M.Val (core.result.Result.t unit erc1155.Error.t) :=
        M.alloc (core.result.Result.Ok tt) in
      M.read α0).
  
  Global Instance AssociatedFunction_safe_batch_transfer_from :
    Notations.DoubleColon Self "safe_batch_transfer_from" := {
    Notations.double_colon := safe_batch_transfer_from;
  }.
  
  (*
      fn balance_of_batch(&self, owners: Vec<AccountId>, token_ids: Vec<TokenId>) -> Vec<Balance> {
          let mut output = Vec::new();
          for o in &owners {
              for t in &token_ids {
                  let amount = self.balance_of( *o, *t);
                  output.push(amount);
              }
          }
          output
      }
  *)
  Definition balance_of_batch
      (self : ref Self)
      (owners : alloc.vec.Vec.t erc1155.AccountId.t alloc.vec.Vec.Default.A)
      (token_ids
        :
        alloc.vec.Vec.t ltac:(erc1155.TokenId) alloc.vec.Vec.Default.A)
      : M (alloc.vec.Vec.t ltac:(erc1155.Balance) alloc.vec.Vec.Default.A) :=
    let* self := M.alloc self in
    let* owners := M.alloc owners in
    let* token_ids := M.alloc token_ids in
    let* output : M.Val (alloc.vec.Vec.t u128.t alloc.alloc.Global.t) :=
      let* α0 : alloc.vec.Vec.t u128.t alloc.alloc.Global.t :=
        M.call (alloc.vec.Vec.t u128.t alloc.alloc.Global.t)::["new"] in
      M.alloc α0 in
    let* _ : M.Val unit :=
      let* α0 : core.slice.iter.Iter.t erc1155.AccountId.t :=
        M.call
          ((core.iter.traits.collect.IntoIterator.into_iter
              (Self :=
                ref (alloc.vec.Vec.t erc1155.AccountId.t alloc.alloc.Global.t))
              (Trait := ltac:(refine _)))
            (borrow owners)) in
      let* α1 : M.Val unit :=
        match α0 with
        | iter =>
          let* iter := M.alloc iter in
          loop
            (let* _ : M.Val unit :=
              let* α0 : core.option.Option.t (ref erc1155.AccountId.t) :=
                M.call
                  ((core.iter.traits.iterator.Iterator.next
                      (Self := core.slice.iter.Iter.t erc1155.AccountId.t)
                      (Trait := ltac:(refine _)))
                    (borrow_mut iter)) in
              match α0 with
              | core.option.Option.None  =>
                let* α0 : M.Val never.t := Break in
                let* α1 := M.read α0 in
                let* α2 : unit := never_to_any α1 in
                M.alloc α2
              | core.option.Option.Some o =>
                let* o := M.alloc o in
                let* α0 : core.slice.iter.Iter.t u128.t :=
                  M.call
                    ((core.iter.traits.collect.IntoIterator.into_iter
                        (Self :=
                          ref (alloc.vec.Vec.t u128.t alloc.alloc.Global.t))
                        (Trait := ltac:(refine _)))
                      (borrow token_ids)) in
                let* α1 : M.Val unit :=
                  match α0 with
                  | iter =>
                    let* iter := M.alloc iter in
                    loop
                      (let* _ : M.Val unit :=
                        let* α0 : core.option.Option.t (ref u128.t) :=
                          M.call
                            ((core.iter.traits.iterator.Iterator.next
                                (Self := core.slice.iter.Iter.t u128.t)
                                (Trait := ltac:(refine _)))
                              (borrow_mut iter)) in
                        match α0 with
                        | core.option.Option.None  =>
                          let* α0 : M.Val never.t := Break in
                          let* α1 := M.read α0 in
                          let* α2 : unit := never_to_any α1 in
                          M.alloc α2
                        | core.option.Option.Some t =>
                          let* t := M.alloc t in
                          let* amount : M.Val u128.t :=
                            let* α0 : ref erc1155.Contract.t := M.read self in
                            let* α1 : ref erc1155.AccountId.t := M.read o in
                            let* α2 : erc1155.AccountId.t :=
                              M.read (deref α1) in
                            let* α3 : ref u128.t := M.read t in
                            let* α4 : u128.t := M.read (deref α3) in
                            let* α5 : u128.t := M.call (balance_of α0 α2 α4) in
                            M.alloc α5 in
                          let* _ : M.Val unit :=
                            let* α0 : u128.t := M.read amount in
                            let* α1 : unit :=
                              M.call
                                ((alloc.vec.Vec.t
                                      u128.t
                                      alloc.alloc.Global.t)::["push"]
                                  (borrow_mut output)
                                  α0) in
                            M.alloc α1 in
                          M.alloc tt
                        end in
                      M.alloc tt)
                  end in
                M.pure (use α1)
              end in
            M.alloc tt)
        end in
      M.pure (use α1) in
    M.read output.
  
  Global Instance AssociatedFunction_balance_of_batch :
    Notations.DoubleColon Self "balance_of_batch" := {
    Notations.double_colon := balance_of_batch;
  }.
  
  (*
      fn set_approval_for_all(&mut self, operator: AccountId, approved: bool) -> Result<()> {
          let caller = self.env().caller();
          ensure!(operator != caller, Error::SelfApproval);
  
          if approved {
              self.approvals.insert((caller, operator), ());
          } else {
              self.approvals.remove((caller, operator));
          }
  
          self.env().emit_event(Event::ApprovalForAll(ApprovalForAll {
              owner: caller,
              operator,
              approved,
          }));
  
          Ok(())
      }
  *)
  Definition set_approval_for_all
      (self : mut_ref Self)
      (operator : erc1155.AccountId.t)
      (approved : bool.t)
      : M ltac:(erc1155.Result unit) :=
    let* self := M.alloc self in
    let* operator := M.alloc operator in
    let* approved := M.alloc approved in
    let return_ := M.return_ (R := ltac:(erc1155.Result unit)) in
    M.catch_return
      (let* caller : M.Val erc1155.AccountId.t :=
        let* α0 : mut_ref erc1155.Contract.t := M.read self in
        let* α1 : erc1155.Env.t :=
          M.call (erc1155.Contract.t::["env"] (borrow (deref α0))) in
        let* α2 : M.Val erc1155.Env.t := M.alloc α1 in
        let* α3 : erc1155.AccountId.t :=
          M.call (erc1155.Env.t::["caller"] (borrow α2)) in
        M.alloc α3 in
      let* _ : M.Val unit :=
        let* α0 : bool.t :=
          M.call
            ((core.cmp.PartialEq.ne
                (Self := erc1155.AccountId.t)
                (Trait := ltac:(refine _)))
              (borrow operator)
              (borrow caller)) in
        let* α1 : M.Val bool.t := M.alloc (UnOp.not α0) in
        let* α2 : bool.t := M.read (use α1) in
        if α2 then
          let* _ : M.Val never.t :=
            let* α0 : erc1155.Error.t :=
              M.call
                ((core.convert.Into.into
                    (Self := erc1155.Error.t)
                    (Trait := ltac:(refine _)))
                  erc1155.Error.SelfApproval) in
            return_ (core.result.Result.Err α0) in
          let* α0 : M.Val unit := M.alloc tt in
          let* α1 := M.read α0 in
          let* α2 : unit := never_to_any α1 in
          M.alloc α2
        else
          M.alloc tt in
      let* _ : M.Val unit :=
        let* α0 : bool.t := M.read (use approved) in
        if α0 then
          let* _ : M.Val (core.option.Option.t u32.t) :=
            let* α0 : mut_ref erc1155.Contract.t := M.read self in
            let* α1 : erc1155.AccountId.t := M.read caller in
            let* α2 : erc1155.AccountId.t := M.read operator in
            let* α3 : core.option.Option.t u32.t :=
              M.call
                ((erc1155.Mapping.t
                      (erc1155.AccountId.t * erc1155.AccountId.t)
                      unit)::["insert"]
                  (borrow_mut (deref α0).["approvals"])
                  (α1, α2)
                  tt) in
            M.alloc α3 in
          M.alloc tt
        else
          let* _ : M.Val unit :=
            let* α0 : mut_ref erc1155.Contract.t := M.read self in
            let* α1 : erc1155.AccountId.t := M.read caller in
            let* α2 : erc1155.AccountId.t := M.read operator in
            let* α3 : unit :=
              M.call
                ((erc1155.Mapping.t
                      (erc1155.AccountId.t * erc1155.AccountId.t)
                      unit)::["remove"]
                  (borrow (deref α0).["approvals"])
                  (α1, α2)) in
            M.alloc α3 in
          M.alloc tt in
      let* _ : M.Val unit :=
        let* α0 : mut_ref erc1155.Contract.t := M.read self in
        let* α1 : erc1155.Env.t :=
          M.call (erc1155.Contract.t::["env"] (borrow (deref α0))) in
        let* α2 : M.Val erc1155.Env.t := M.alloc α1 in
        let* α3 : erc1155.AccountId.t := M.read caller in
        let* α4 : erc1155.AccountId.t := M.read operator in
        let* α5 : bool.t := M.read approved in
        let* α6 : unit :=
          M.call
            (erc1155.Env.t::["emit_event"]
              (borrow α2)
              (erc1155.Event.ApprovalForAll
                {|
                  erc1155.ApprovalForAll.owner := α3;
                  erc1155.ApprovalForAll.operator := α4;
                  erc1155.ApprovalForAll.approved := α5;
                |})) in
        M.alloc α6 in
      let* α0 : M.Val (core.result.Result.t unit erc1155.Error.t) :=
        M.alloc (core.result.Result.Ok tt) in
      M.read α0).
  
  Global Instance AssociatedFunction_set_approval_for_all :
    Notations.DoubleColon Self "set_approval_for_all" := {
    Notations.double_colon := set_approval_for_all;
  }.
  
  Global Instance ℐ : erc1155.Erc1155.Trait Self := {
    erc1155.Erc1155.is_approved_for_all := is_approved_for_all;
    erc1155.Erc1155.balance_of := balance_of;
    erc1155.Erc1155.safe_transfer_from := safe_transfer_from;
    erc1155.Erc1155.safe_batch_transfer_from := safe_batch_transfer_from;
    erc1155.Erc1155.balance_of_batch := balance_of_batch;
    erc1155.Erc1155.set_approval_for_all := set_approval_for_all;
  }.
End Impl_erc1155_Erc1155_for_erc1155_Contract_t.
End Impl_erc1155_Erc1155_for_erc1155_Contract_t.

Module  Impl_erc1155_Erc1155TokenReceiver_for_erc1155_Contract_t.
Section Impl_erc1155_Erc1155TokenReceiver_for_erc1155_Contract_t.
  Definition Self : Set := erc1155.Contract.t.
  
  (*
      fn on_received(
          &mut self,
          _operator: AccountId,
          _from: AccountId,
          _token_id: TokenId,
          _value: Balance,
          _data: Vec<u8>,
      ) -> Vec<u8> {
          // The ERC-1155 standard dictates that if a contract does not accept token
          // transfers directly to the contract, then the contract must
          // revert.
          //
          // This prevents a user from unintentionally transferring tokens to a smart
          // contract and getting their funds stuck without any sort of
          // recovery mechanism.
          //
          // Note that the choice of whether or not to accept tokens is implementation
          // specific, and we've decided to not accept them in this
          // implementation.
          unimplemented!("This smart contract does not accept token transfer.")
      }
  *)
  Definition on_received
      (self : mut_ref Self)
      (_operator : erc1155.AccountId.t)
      (_from : erc1155.AccountId.t)
      (_token_id : ltac:(erc1155.TokenId))
      (_value : ltac:(erc1155.Balance))
      (_data : alloc.vec.Vec.t u8.t alloc.vec.Vec.Default.A)
      : M (alloc.vec.Vec.t u8.t alloc.vec.Vec.Default.A) :=
    let* self := M.alloc self in
    let* _operator := M.alloc _operator in
    let* _from := M.alloc _from in
    let* _token_id := M.alloc _token_id in
    let* _value := M.alloc _value in
    let* _data := M.alloc _data in
    let* α0 : ref str.t :=
      M.read
        (mk_str
          "not implemented: This smart contract does not accept token transfer.") in
    let* α1 : M.Val (array (ref str.t)) := M.alloc [ α0 ] in
    let* α2 : M.Val (ref (array (ref str.t))) := M.alloc (borrow α1) in
    let* α3 : ref (slice (ref str.t)) :=
      M.read (pointer_coercion "Unsize" α2) in
    let* α4 : M.Val (array core.fmt.rt.Argument.t) := M.alloc [ ] in
    let* α5 : M.Val (ref (array core.fmt.rt.Argument.t)) :=
      M.alloc (borrow α4) in
    let* α6 : ref (slice core.fmt.rt.Argument.t) :=
      M.read (pointer_coercion "Unsize" α5) in
    let* α7 : core.fmt.Arguments.t :=
      M.call (core.fmt.Arguments.t::["new_v1"] α3 α6) in
    let* α8 : never.t := M.call (core.panicking.panic_fmt α7) in
    never_to_any α8.
  
  Global Instance AssociatedFunction_on_received :
    Notations.DoubleColon Self "on_received" := {
    Notations.double_colon := on_received;
  }.
  
  (*
      fn on_batch_received(
          &mut self,
          _operator: AccountId,
          _from: AccountId,
          _token_ids: Vec<TokenId>,
          _values: Vec<Balance>,
          _data: Vec<u8>,
      ) -> Vec<u8> {
          // The ERC-1155 standard dictates that if a contract does not accept token
          // transfers directly to the contract, then the contract must
          // revert.
          //
          // This prevents a user from unintentionally transferring tokens to a smart
          // contract and getting their funds stuck without any sort of
          // recovery mechanism.
          //
          // Note that the choice of whether or not to accept tokens is implementation
          // specific, and we've decided to not accept them in this
          // implementation.
          unimplemented!("This smart contract does not accept batch token transfers.")
      }
  *)
  Definition on_batch_received
      (self : mut_ref Self)
      (_operator : erc1155.AccountId.t)
      (_from : erc1155.AccountId.t)
      (_token_ids
        :
        alloc.vec.Vec.t ltac:(erc1155.TokenId) alloc.vec.Vec.Default.A)
      (_values : alloc.vec.Vec.t ltac:(erc1155.Balance) alloc.vec.Vec.Default.A)
      (_data : alloc.vec.Vec.t u8.t alloc.vec.Vec.Default.A)
      : M (alloc.vec.Vec.t u8.t alloc.vec.Vec.Default.A) :=
    let* self := M.alloc self in
    let* _operator := M.alloc _operator in
    let* _from := M.alloc _from in
    let* _token_ids := M.alloc _token_ids in
    let* _values := M.alloc _values in
    let* _data := M.alloc _data in
    let* α0 : ref str.t :=
      M.read
        (mk_str
          "not implemented: This smart contract does not accept batch token transfers.") in
    let* α1 : M.Val (array (ref str.t)) := M.alloc [ α0 ] in
    let* α2 : M.Val (ref (array (ref str.t))) := M.alloc (borrow α1) in
    let* α3 : ref (slice (ref str.t)) :=
      M.read (pointer_coercion "Unsize" α2) in
    let* α4 : M.Val (array core.fmt.rt.Argument.t) := M.alloc [ ] in
    let* α5 : M.Val (ref (array core.fmt.rt.Argument.t)) :=
      M.alloc (borrow α4) in
    let* α6 : ref (slice core.fmt.rt.Argument.t) :=
      M.read (pointer_coercion "Unsize" α5) in
    let* α7 : core.fmt.Arguments.t :=
      M.call (core.fmt.Arguments.t::["new_v1"] α3 α6) in
    let* α8 : never.t := M.call (core.panicking.panic_fmt α7) in
    never_to_any α8.
  
  Global Instance AssociatedFunction_on_batch_received :
    Notations.DoubleColon Self "on_batch_received" := {
    Notations.double_colon := on_batch_received;
  }.
  
  Global Instance ℐ : erc1155.Erc1155TokenReceiver.Trait Self := {
    erc1155.Erc1155TokenReceiver.on_received := on_received;
    erc1155.Erc1155TokenReceiver.on_batch_received := on_batch_received;
  }.
End Impl_erc1155_Erc1155TokenReceiver_for_erc1155_Contract_t.
End Impl_erc1155_Erc1155TokenReceiver_for_erc1155_Contract_t.
