(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module  Mapping.
Section Mapping.
  Context (K V : Set).
  
  Record t : Set := {
    _key : core.marker.PhantomData.t K;
    _value : core.marker.PhantomData.t V;
  }.
  
  Global Instance Get__key : Notations.Dot "_key" := {
    Notations.dot := Ref.map (fun x => x.(_key)) (fun v x => x <| _key := v |>);
  }.
  Global Instance Get_AF__key : Notations.DoubleColon t "_key" := {
    Notations.double_colon (x : M.Val t) := x.["_key"];
  }.
  Global Instance Get__value : Notations.Dot "_value" := {
    Notations.dot :=
      Ref.map (fun x => x.(_value)) (fun v x => x <| _value := v |>);
  }.
  Global Instance Get_AF__value : Notations.DoubleColon t "_value" := {
    Notations.double_colon (x : M.Val t) := x.["_value"];
  }.
End Mapping.
End Mapping.

Module  Impl_core_default_Default_for_erc721_Mapping_t_K_V.
Section Impl_core_default_Default_for_erc721_Mapping_t_K_V.
  Context {K V : Set}.
  
  Context
    {ℋ_0 : core.default.Default.Trait K}
    {ℋ_1 : core.default.Default.Trait V}.
  
  Ltac Self := exact (erc721.Mapping.t K V).
  
  (*
  Default
  *)
  Definition default : M (erc721.Mapping.t K V) :=
    let* α0 : core.marker.PhantomData.t K :=
      M.call
        (core.default.Default.default
          (Self := core.marker.PhantomData.t K)
          (Trait := ltac:(refine _))) in
    let* α1 : core.marker.PhantomData.t V :=
      M.call
        (core.default.Default.default
          (Self := core.marker.PhantomData.t V)
          (Trait := ltac:(refine _))) in
    M.pure {| erc721.Mapping._key := α0; erc721.Mapping._value := α1; |}.
  
  Global Instance AssociatedFunction_default :
    Notations.DoubleColon ltac:(Self) "default" := {
    Notations.double_colon := default;
  }.
  
  Global Instance ℐ : core.default.Default.Trait ltac:(Self) := {
    core.default.Default.default := default;
  }.
End Impl_core_default_Default_for_erc721_Mapping_t_K_V.
End Impl_core_default_Default_for_erc721_Mapping_t_K_V.

Module  Impl_erc721_Mapping_t_K_V.
Section Impl_erc721_Mapping_t_K_V.
  Context {K V : Set}.
  
  Ltac Self := exact (erc721.Mapping.t K V).
  
  (*
      fn contains(&self, _key: &K) -> bool {
          unimplemented!()
      }
  *)
  Definition contains (self : ref ltac:(Self)) (_key : ref K) : M bool.t :=
    let* self : M.Val (ref ltac:(Self)) := M.alloc self in
    let* _key : M.Val (ref K) := M.alloc _key in
    let* α0 : ref str.t := M.read (mk_str "not implemented") in
    let* α1 : never.t := M.call (core.panicking.panic α0) in
    never_to_any α1.
  
  Global Instance AssociatedFunction_contains :
    Notations.DoubleColon ltac:(Self) "contains" := {
    Notations.double_colon := contains;
  }.
  
  (*
      fn get(&self, _key: &K) -> Option<V> {
          unimplemented!()
      }
  *)
  Definition get
      (self : ref ltac:(Self))
      (_key : ref K)
      : M (core.option.Option.t V) :=
    let* self : M.Val (ref ltac:(Self)) := M.alloc self in
    let* _key : M.Val (ref K) := M.alloc _key in
    let* α0 : ref str.t := M.read (mk_str "not implemented") in
    let* α1 : never.t := M.call (core.panicking.panic α0) in
    never_to_any α1.
  
  Global Instance AssociatedFunction_get :
    Notations.DoubleColon ltac:(Self) "get" := {
    Notations.double_colon := get;
  }.
  
  (*
      fn insert(&mut self, _key: K, _value: V) -> Option<u32> {
          unimplemented!()
      }
  *)
  Definition insert
      (self : mut_ref ltac:(Self))
      (_key : K)
      (_value : V)
      : M (core.option.Option.t u32.t) :=
    let* self : M.Val (mut_ref ltac:(Self)) := M.alloc self in
    let* _key : M.Val K := M.alloc _key in
    let* _value : M.Val V := M.alloc _value in
    let* α0 : ref str.t := M.read (mk_str "not implemented") in
    let* α1 : never.t := M.call (core.panicking.panic α0) in
    never_to_any α1.
  
  Global Instance AssociatedFunction_insert :
    Notations.DoubleColon ltac:(Self) "insert" := {
    Notations.double_colon := insert;
  }.
  
  (*
      fn remove(&self, _key: K) {
          unimplemented!()
      }
  *)
  Definition remove (self : ref ltac:(Self)) (_key : K) : M unit :=
    let* self : M.Val (ref ltac:(Self)) := M.alloc self in
    let* _key : M.Val K := M.alloc _key in
    let* α0 : ref str.t := M.read (mk_str "not implemented") in
    let* α1 : never.t := M.call (core.panicking.panic α0) in
    never_to_any α1.
  
  Global Instance AssociatedFunction_remove :
    Notations.DoubleColon ltac:(Self) "remove" := {
    Notations.double_colon := remove;
  }.
  
  (*
      fn size(&self, _key: K) -> Option<u32> {
          unimplemented!()
      }
  *)
  Definition size
      (self : ref ltac:(Self))
      (_key : K)
      : M (core.option.Option.t u32.t) :=
    let* self : M.Val (ref ltac:(Self)) := M.alloc self in
    let* _key : M.Val K := M.alloc _key in
    let* α0 : ref str.t := M.read (mk_str "not implemented") in
    let* α1 : never.t := M.call (core.panicking.panic α0) in
    never_to_any α1.
  
  Global Instance AssociatedFunction_size :
    Notations.DoubleColon ltac:(Self) "size" := {
    Notations.double_colon := size;
  }.
  
  (*
      fn take(&self, _key: K) -> Option<V> {
          unimplemented!()
      }
  *)
  Definition take
      (self : ref ltac:(Self))
      (_key : K)
      : M (core.option.Option.t V) :=
    let* self : M.Val (ref ltac:(Self)) := M.alloc self in
    let* _key : M.Val K := M.alloc _key in
    let* α0 : ref str.t := M.read (mk_str "not implemented") in
    let* α1 : never.t := M.call (core.panicking.panic α0) in
    never_to_any α1.
  
  Global Instance AssociatedFunction_take :
    Notations.DoubleColon ltac:(Self) "take" := {
    Notations.double_colon := take;
  }.
End Impl_erc721_Mapping_t_K_V.
End Impl_erc721_Mapping_t_K_V.

Module  AccountId.
Section AccountId.
  Record t : Set := {
    x0 : u128.t;
  }.
  
  Global Instance Get_0 : Notations.Dot "0" := {
    Notations.dot := Ref.map (fun x => x.(x0)) (fun v x => x <| x0 := v |>);
  }.
End AccountId.
End AccountId.

Module  Impl_core_default_Default_for_erc721_AccountId_t.
Section Impl_core_default_Default_for_erc721_AccountId_t.
  Ltac Self := exact erc721.AccountId.t.
  
  (*
  Default
  *)
  Definition default : M erc721.AccountId.t :=
    let* α0 : u128.t :=
      M.call
        (core.default.Default.default
          (Self := u128.t)
          (Trait := ltac:(refine _))) in
    M.pure (erc721.AccountId.Build_t α0).
  
  Global Instance AssociatedFunction_default :
    Notations.DoubleColon ltac:(Self) "default" := {
    Notations.double_colon := default;
  }.
  
  Global Instance ℐ : core.default.Default.Trait ltac:(Self) := {
    core.default.Default.default := default;
  }.
End Impl_core_default_Default_for_erc721_AccountId_t.
End Impl_core_default_Default_for_erc721_AccountId_t.

Module  Impl_core_clone_Clone_for_erc721_AccountId_t.
Section Impl_core_clone_Clone_for_erc721_AccountId_t.
  Ltac Self := exact erc721.AccountId.t.
  
  (*
  Clone
  *)
  Definition clone (self : ref ltac:(Self)) : M erc721.AccountId.t :=
    let* self : M.Val (ref ltac:(Self)) := M.alloc self in
    let* _ : M.Val unit := M.alloc tt in
    let* α0 : ref erc721.AccountId.t := M.read self in
    M.read (deref α0).
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon ltac:(Self) "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait ltac:(Self) := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_erc721_AccountId_t.
End Impl_core_clone_Clone_for_erc721_AccountId_t.

Module  Impl_core_marker_Copy_for_erc721_AccountId_t.
Section Impl_core_marker_Copy_for_erc721_AccountId_t.
  Ltac Self := exact erc721.AccountId.t.
  
  Global Instance ℐ : core.marker.Copy.Trait ltac:(Self) := {
  }.
End Impl_core_marker_Copy_for_erc721_AccountId_t.
End Impl_core_marker_Copy_for_erc721_AccountId_t.

Module  Impl_core_marker_StructuralPartialEq_for_erc721_AccountId_t.
Section Impl_core_marker_StructuralPartialEq_for_erc721_AccountId_t.
  Ltac Self := exact erc721.AccountId.t.
  
  Global Instance ℐ : core.marker.StructuralPartialEq.Trait ltac:(Self) := {
  }.
End Impl_core_marker_StructuralPartialEq_for_erc721_AccountId_t.
End Impl_core_marker_StructuralPartialEq_for_erc721_AccountId_t.

Module  Impl_core_cmp_PartialEq_for_erc721_AccountId_t.
Section Impl_core_cmp_PartialEq_for_erc721_AccountId_t.
  Ltac Self := exact erc721.AccountId.t.
  
  (*
  PartialEq
  *)
  Definition eq
      (self : ref ltac:(Self))
      (other : ref erc721.AccountId.t)
      : M bool.t :=
    let* self : M.Val (ref ltac:(Self)) := M.alloc self in
    let* other : M.Val (ref erc721.AccountId.t) := M.alloc other in
    let* α0 : ref erc721.AccountId.t := M.read self in
    let* α1 : u128.t := M.read (deref α0).["0"] in
    let* α2 : ref erc721.AccountId.t := M.read other in
    let* α3 : u128.t := M.read (deref α2).["0"] in
    M.pure (BinOp.Pure.eq α1 α3).
  
  Global Instance AssociatedFunction_eq :
    Notations.DoubleColon ltac:(Self) "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ :
    core.cmp.PartialEq.Required.Trait ltac:(Self)
      (Rhs := core.cmp.PartialEq.Default.Rhs ltac:(Self)) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_for_erc721_AccountId_t.
End Impl_core_cmp_PartialEq_for_erc721_AccountId_t.

Module  Impl_core_convert_From_array_u8_t_for_erc721_AccountId_t.
Section Impl_core_convert_From_array_u8_t_for_erc721_AccountId_t.
  Ltac Self := exact erc721.AccountId.t.
  
  (*
      fn from(_value: [u8; 32]) -> Self {
          unimplemented!()
      }
  *)
  Definition from (_value : array u8.t) : M ltac:(Self) :=
    let* _value : M.Val (array u8.t) := M.alloc _value in
    let* α0 : ref str.t := M.read (mk_str "not implemented") in
    let* α1 : never.t := M.call (core.panicking.panic α0) in
    never_to_any α1.
  
  Global Instance AssociatedFunction_from :
    Notations.DoubleColon ltac:(Self) "from" := {
    Notations.double_colon := from;
  }.
  
  Global Instance ℐ : core.convert.From.Trait ltac:(Self) (T := array u8.t) := {
    core.convert.From.from := from;
  }.
End Impl_core_convert_From_array_u8_t_for_erc721_AccountId_t.
End Impl_core_convert_From_array_u8_t_for_erc721_AccountId_t.

Ltac Balance := exact u128.t.

Module  Env.
Section Env.
  Record t : Set := {
    caller : erc721.AccountId.t;
  }.
  
  Global Instance Get_caller : Notations.Dot "caller" := {
    Notations.dot :=
      Ref.map (fun x => x.(caller)) (fun v x => x <| caller := v |>);
  }.
  Global Instance Get_AF_caller : Notations.DoubleColon t "caller" := {
    Notations.double_colon (x : M.Val t) := x.["caller"];
  }.
End Env.
End Env.

Ltac TokenId := exact u32.t.

Module  Erc721.
Section Erc721.
  Record t : Set := {
    token_owner : erc721.Mapping.t ltac:(erc721.TokenId) erc721.AccountId.t;
    token_approvals : erc721.Mapping.t ltac:(erc721.TokenId) erc721.AccountId.t;
    owned_tokens_count : erc721.Mapping.t erc721.AccountId.t u32.t;
    operator_approvals :
      erc721.Mapping.t (erc721.AccountId.t * erc721.AccountId.t) unit;
  }.
  
  Global Instance Get_token_owner : Notations.Dot "token_owner" := {
    Notations.dot :=
      Ref.map (fun x => x.(token_owner)) (fun v x => x <| token_owner := v |>);
  }.
  Global Instance Get_AF_token_owner :
    Notations.DoubleColon t "token_owner" := {
    Notations.double_colon (x : M.Val t) := x.["token_owner"];
  }.
  Global Instance Get_token_approvals : Notations.Dot "token_approvals" := {
    Notations.dot :=
      Ref.map
        (fun x => x.(token_approvals))
        (fun v x => x <| token_approvals := v |>);
  }.
  Global Instance Get_AF_token_approvals :
    Notations.DoubleColon t "token_approvals" := {
    Notations.double_colon (x : M.Val t) := x.["token_approvals"];
  }.
  Global Instance Get_owned_tokens_count :
    Notations.Dot "owned_tokens_count" := {
    Notations.dot :=
      Ref.map
        (fun x => x.(owned_tokens_count))
        (fun v x => x <| owned_tokens_count := v |>);
  }.
  Global Instance Get_AF_owned_tokens_count :
    Notations.DoubleColon t "owned_tokens_count" := {
    Notations.double_colon (x : M.Val t) := x.["owned_tokens_count"];
  }.
  Global Instance Get_operator_approvals :
    Notations.Dot "operator_approvals" := {
    Notations.dot :=
      Ref.map
        (fun x => x.(operator_approvals))
        (fun v x => x <| operator_approvals := v |>);
  }.
  Global Instance Get_AF_operator_approvals :
    Notations.DoubleColon t "operator_approvals" := {
    Notations.double_colon (x : M.Val t) := x.["operator_approvals"];
  }.
End Erc721.
End Erc721.

Module  Impl_core_default_Default_for_erc721_Erc721_t.
Section Impl_core_default_Default_for_erc721_Erc721_t.
  Ltac Self := exact erc721.Erc721.t.
  
  (*
  Default
  *)
  Definition default : M erc721.Erc721.t :=
    let* α0 : erc721.Mapping.t u32.t erc721.AccountId.t :=
      M.call
        (core.default.Default.default
          (Self := erc721.Mapping.t u32.t erc721.AccountId.t)
          (Trait := ltac:(refine _))) in
    let* α1 : erc721.Mapping.t u32.t erc721.AccountId.t :=
      M.call
        (core.default.Default.default
          (Self := erc721.Mapping.t u32.t erc721.AccountId.t)
          (Trait := ltac:(refine _))) in
    let* α2 : erc721.Mapping.t erc721.AccountId.t u32.t :=
      M.call
        (core.default.Default.default
          (Self := erc721.Mapping.t erc721.AccountId.t u32.t)
          (Trait := ltac:(refine _))) in
    let* α3 : erc721.Mapping.t (erc721.AccountId.t * erc721.AccountId.t) unit :=
      M.call
        (core.default.Default.default
          (Self :=
            erc721.Mapping.t (erc721.AccountId.t * erc721.AccountId.t) unit)
          (Trait := ltac:(refine _))) in
    M.pure
      {|
        erc721.Erc721.token_owner := α0;
        erc721.Erc721.token_approvals := α1;
        erc721.Erc721.owned_tokens_count := α2;
        erc721.Erc721.operator_approvals := α3;
      |}.
  
  Global Instance AssociatedFunction_default :
    Notations.DoubleColon ltac:(Self) "default" := {
    Notations.double_colon := default;
  }.
  
  Global Instance ℐ : core.default.Default.Trait ltac:(Self) := {
    core.default.Default.default := default;
  }.
End Impl_core_default_Default_for_erc721_Erc721_t.
End Impl_core_default_Default_for_erc721_Erc721_t.

Module Error.
  Inductive t : Set :=
  | NotOwner
  | NotApproved
  | TokenExists
  | TokenNotFound
  | CannotInsert
  | CannotFetchValue
  | NotAllowed.
End Error.

Module  Impl_core_fmt_Debug_for_erc721_Error_t.
Section Impl_core_fmt_Debug_for_erc721_Error_t.
  Ltac Self := exact erc721.Error.t.
  
  (*
  Debug
  *)
  Definition fmt
      (self : ref ltac:(Self))
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self : M.Val (ref ltac:(Self)) := M.alloc self in
    let* f : M.Val (mut_ref core.fmt.Formatter.t) := M.alloc f in
    let* α0 : mut_ref core.fmt.Formatter.t := M.read f in
    let* α1 : ref erc721.Error.t := M.read self in
    let* α2 : M.Val (ref str.t) :=
      match α1 with
      | erc721.Error.NotOwner  =>
        let* α0 : ref str.t := M.read (mk_str "NotOwner") in
        M.alloc α0
      | erc721.Error.NotApproved  =>
        let* α0 : ref str.t := M.read (mk_str "NotApproved") in
        M.alloc α0
      | erc721.Error.TokenExists  =>
        let* α0 : ref str.t := M.read (mk_str "TokenExists") in
        M.alloc α0
      | erc721.Error.TokenNotFound  =>
        let* α0 : ref str.t := M.read (mk_str "TokenNotFound") in
        M.alloc α0
      | erc721.Error.CannotInsert  =>
        let* α0 : ref str.t := M.read (mk_str "CannotInsert") in
        M.alloc α0
      | erc721.Error.CannotFetchValue  =>
        let* α0 : ref str.t := M.read (mk_str "CannotFetchValue") in
        M.alloc α0
      | erc721.Error.NotAllowed  =>
        let* α0 : ref str.t := M.read (mk_str "NotAllowed") in
        M.alloc α0
      end in
    let* α3 : ref str.t := M.read α2 in
    M.call (core.fmt.Formatter.t::["write_str"] α0 α3).
  
  Global Instance AssociatedFunction_fmt :
    Notations.DoubleColon ltac:(Self) "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait ltac:(Self) := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_erc721_Error_t.
End Impl_core_fmt_Debug_for_erc721_Error_t.

Module  Impl_core_marker_StructuralPartialEq_for_erc721_Error_t.
Section Impl_core_marker_StructuralPartialEq_for_erc721_Error_t.
  Ltac Self := exact erc721.Error.t.
  
  Global Instance ℐ : core.marker.StructuralPartialEq.Trait ltac:(Self) := {
  }.
End Impl_core_marker_StructuralPartialEq_for_erc721_Error_t.
End Impl_core_marker_StructuralPartialEq_for_erc721_Error_t.

Module  Impl_core_cmp_PartialEq_for_erc721_Error_t.
Section Impl_core_cmp_PartialEq_for_erc721_Error_t.
  Ltac Self := exact erc721.Error.t.
  
  (*
  PartialEq
  *)
  Definition eq
      (self : ref ltac:(Self))
      (other : ref erc721.Error.t)
      : M bool.t :=
    let* self : M.Val (ref ltac:(Self)) := M.alloc self in
    let* other : M.Val (ref erc721.Error.t) := M.alloc other in
    let* __self_tag : M.Val isize.t :=
      let* α0 : ref erc721.Error.t := M.read self in
      let* α1 : isize.t := M.call (core.intrinsics.discriminant_value α0) in
      M.alloc α1 in
    let* __arg1_tag : M.Val isize.t :=
      let* α0 : ref erc721.Error.t := M.read other in
      let* α1 : isize.t := M.call (core.intrinsics.discriminant_value α0) in
      M.alloc α1 in
    let* α0 : isize.t := M.read __self_tag in
    let* α1 : isize.t := M.read __arg1_tag in
    let* α0 : M.Val bool.t := M.alloc (BinOp.Pure.eq α0 α1) in
    M.read α0.
  
  Global Instance AssociatedFunction_eq :
    Notations.DoubleColon ltac:(Self) "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ :
    core.cmp.PartialEq.Required.Trait ltac:(Self)
      (Rhs := core.cmp.PartialEq.Default.Rhs ltac:(Self)) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_for_erc721_Error_t.
End Impl_core_cmp_PartialEq_for_erc721_Error_t.

Module  Impl_core_marker_StructuralEq_for_erc721_Error_t.
Section Impl_core_marker_StructuralEq_for_erc721_Error_t.
  Ltac Self := exact erc721.Error.t.
  
  Global Instance ℐ : core.marker.StructuralEq.Trait ltac:(Self) := {
  }.
End Impl_core_marker_StructuralEq_for_erc721_Error_t.
End Impl_core_marker_StructuralEq_for_erc721_Error_t.

Module  Impl_core_cmp_Eq_for_erc721_Error_t.
Section Impl_core_cmp_Eq_for_erc721_Error_t.
  Ltac Self := exact erc721.Error.t.
  
  (*
  Eq
  *)
  Definition assert_receiver_is_total_eq (self : ref ltac:(Self)) : M unit :=
    let* self : M.Val (ref ltac:(Self)) := M.alloc self in
    M.pure tt.
  
  Global Instance AssociatedFunction_assert_receiver_is_total_eq :
    Notations.DoubleColon ltac:(Self) "assert_receiver_is_total_eq" := {
    Notations.double_colon := assert_receiver_is_total_eq;
  }.
  
  Global Instance ℐ : core.cmp.Eq.Required.Trait ltac:(Self) := {
    core.cmp.Eq.assert_receiver_is_total_eq :=
      Datatypes.Some assert_receiver_is_total_eq;
  }.
End Impl_core_cmp_Eq_for_erc721_Error_t.
End Impl_core_cmp_Eq_for_erc721_Error_t.

Module  Impl_core_clone_Clone_for_erc721_Error_t.
Section Impl_core_clone_Clone_for_erc721_Error_t.
  Ltac Self := exact erc721.Error.t.
  
  (*
  Clone
  *)
  Definition clone (self : ref ltac:(Self)) : M erc721.Error.t :=
    let* self : M.Val (ref ltac:(Self)) := M.alloc self in
    let* α0 : ref erc721.Error.t := M.read self in
    M.read (deref α0).
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon ltac:(Self) "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait ltac:(Self) := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_erc721_Error_t.
End Impl_core_clone_Clone_for_erc721_Error_t.

Module  Impl_core_marker_Copy_for_erc721_Error_t.
Section Impl_core_marker_Copy_for_erc721_Error_t.
  Ltac Self := exact erc721.Error.t.
  
  Global Instance ℐ : core.marker.Copy.Trait ltac:(Self) := {
  }.
End Impl_core_marker_Copy_for_erc721_Error_t.
End Impl_core_marker_Copy_for_erc721_Error_t.

Module  Transfer.
Section Transfer.
  Record t : Set := {
    from : core.option.Option.t erc721.AccountId.t;
    to : core.option.Option.t erc721.AccountId.t;
    id : ltac:(erc721.TokenId);
  }.
  
  Global Instance Get_from : Notations.Dot "from" := {
    Notations.dot := Ref.map (fun x => x.(from)) (fun v x => x <| from := v |>);
  }.
  Global Instance Get_AF_from : Notations.DoubleColon t "from" := {
    Notations.double_colon (x : M.Val t) := x.["from"];
  }.
  Global Instance Get_to : Notations.Dot "to" := {
    Notations.dot := Ref.map (fun x => x.(to)) (fun v x => x <| to := v |>);
  }.
  Global Instance Get_AF_to : Notations.DoubleColon t "to" := {
    Notations.double_colon (x : M.Val t) := x.["to"];
  }.
  Global Instance Get_id : Notations.Dot "id" := {
    Notations.dot := Ref.map (fun x => x.(id)) (fun v x => x <| id := v |>);
  }.
  Global Instance Get_AF_id : Notations.DoubleColon t "id" := {
    Notations.double_colon (x : M.Val t) := x.["id"];
  }.
End Transfer.
End Transfer.

Module  Approval.
Section Approval.
  Record t : Set := {
    from : erc721.AccountId.t;
    to : erc721.AccountId.t;
    id : ltac:(erc721.TokenId);
  }.
  
  Global Instance Get_from : Notations.Dot "from" := {
    Notations.dot := Ref.map (fun x => x.(from)) (fun v x => x <| from := v |>);
  }.
  Global Instance Get_AF_from : Notations.DoubleColon t "from" := {
    Notations.double_colon (x : M.Val t) := x.["from"];
  }.
  Global Instance Get_to : Notations.Dot "to" := {
    Notations.dot := Ref.map (fun x => x.(to)) (fun v x => x <| to := v |>);
  }.
  Global Instance Get_AF_to : Notations.DoubleColon t "to" := {
    Notations.double_colon (x : M.Val t) := x.["to"];
  }.
  Global Instance Get_id : Notations.Dot "id" := {
    Notations.dot := Ref.map (fun x => x.(id)) (fun v x => x <| id := v |>);
  }.
  Global Instance Get_AF_id : Notations.DoubleColon t "id" := {
    Notations.double_colon (x : M.Val t) := x.["id"];
  }.
End Approval.
End Approval.

Module  ApprovalForAll.
Section ApprovalForAll.
  Record t : Set := {
    owner : erc721.AccountId.t;
    operator : erc721.AccountId.t;
    approved : bool.t;
  }.
  
  Global Instance Get_owner : Notations.Dot "owner" := {
    Notations.dot :=
      Ref.map (fun x => x.(owner)) (fun v x => x <| owner := v |>);
  }.
  Global Instance Get_AF_owner : Notations.DoubleColon t "owner" := {
    Notations.double_colon (x : M.Val t) := x.["owner"];
  }.
  Global Instance Get_operator : Notations.Dot "operator" := {
    Notations.dot :=
      Ref.map (fun x => x.(operator)) (fun v x => x <| operator := v |>);
  }.
  Global Instance Get_AF_operator : Notations.DoubleColon t "operator" := {
    Notations.double_colon (x : M.Val t) := x.["operator"];
  }.
  Global Instance Get_approved : Notations.Dot "approved" := {
    Notations.dot :=
      Ref.map (fun x => x.(approved)) (fun v x => x <| approved := v |>);
  }.
  Global Instance Get_AF_approved : Notations.DoubleColon t "approved" := {
    Notations.double_colon (x : M.Val t) := x.["approved"];
  }.
End ApprovalForAll.
End ApprovalForAll.

Module Event.
  Inductive t : Set :=
  | Transfer (_ : erc721.Transfer.t)
  | Approval (_ : erc721.Approval.t)
  | ApprovalForAll (_ : erc721.ApprovalForAll.t).
End Event.

Module  Impl_erc721_Env_t.
Section Impl_erc721_Env_t.
  Ltac Self := exact erc721.Env.t.
  
  (*
      fn caller(&self) -> AccountId {
          self.caller
      }
  *)
  Definition caller (self : ref ltac:(Self)) : M erc721.AccountId.t :=
    let* self : M.Val (ref ltac:(Self)) := M.alloc self in
    let* α0 : ref erc721.Env.t := M.read self in
    M.read (deref α0).["caller"].
  
  Global Instance AssociatedFunction_caller :
    Notations.DoubleColon ltac:(Self) "caller" := {
    Notations.double_colon := caller;
  }.
  
  (*
      fn emit_event(&self, _event: Event) {
          unimplemented!()
      }
  *)
  Definition emit_event
      (self : ref ltac:(Self))
      (_event : erc721.Event.t)
      : M unit :=
    let* self : M.Val (ref ltac:(Self)) := M.alloc self in
    let* _event : M.Val erc721.Event.t := M.alloc _event in
    let* α0 : ref str.t := M.read (mk_str "not implemented") in
    let* α1 : never.t := M.call (core.panicking.panic α0) in
    never_to_any α1.
  
  Global Instance AssociatedFunction_emit_event :
    Notations.DoubleColon ltac:(Self) "emit_event" := {
    Notations.double_colon := emit_event;
  }.
End Impl_erc721_Env_t.
End Impl_erc721_Env_t.

Module  Impl_erc721_Erc721_t.
Section Impl_erc721_Erc721_t.
  Ltac Self := exact erc721.Erc721.t.
  
  (*
      fn init_env() -> Env {
          unimplemented!()
      }
  *)
  Definition init_env : M erc721.Env.t :=
    let* α0 : ref str.t := M.read (mk_str "not implemented") in
    let* α1 : never.t := M.call (core.panicking.panic α0) in
    never_to_any α1.
  
  Global Instance AssociatedFunction_init_env :
    Notations.DoubleColon ltac:(Self) "init_env" := {
    Notations.double_colon := init_env;
  }.
  
  (*
      fn env(&self) -> Env {
          Self::init_env()
      }
  *)
  Definition env (self : ref ltac:(Self)) : M erc721.Env.t :=
    let* self : M.Val (ref ltac:(Self)) := M.alloc self in
    M.call erc721.Erc721.t::["init_env"].
  
  Global Instance AssociatedFunction_env :
    Notations.DoubleColon ltac:(Self) "env" := {
    Notations.double_colon := env;
  }.
  
  (*
      pub fn new() -> Self {
          Default::default()
      }
  *)
  Definition new : M ltac:(Self) :=
    M.call
      (core.default.Default.default
        (Self := erc721.Erc721.t)
        (Trait := ltac:(refine _))).
  
  Global Instance AssociatedFunction_new :
    Notations.DoubleColon ltac:(Self) "new" := {
    Notations.double_colon := new;
  }.
  
  (*
      pub fn balance_of(&self, owner: AccountId) -> u32 {
          self.balance_of_or_zero(&owner)
      }
  *)
  Definition balance_of
      (self : ref ltac:(Self))
      (owner : erc721.AccountId.t)
      : M u32.t :=
    let* self : M.Val (ref ltac:(Self)) := M.alloc self in
    let* owner : M.Val erc721.AccountId.t := M.alloc owner in
    let* α0 : ref erc721.Erc721.t := M.read self in
    M.call (erc721.Erc721.t::["balance_of_or_zero"] α0 (borrow owner)).
  
  Global Instance AssociatedFunction_balance_of :
    Notations.DoubleColon ltac:(Self) "balance_of" := {
    Notations.double_colon := balance_of;
  }.
  
  (*
      pub fn owner_of(&self, id: TokenId) -> Option<AccountId> {
          self.token_owner.get(&id)
      }
  *)
  Definition owner_of
      (self : ref ltac:(Self))
      (id : ltac:(erc721.TokenId))
      : M (core.option.Option.t erc721.AccountId.t) :=
    let* self : M.Val (ref ltac:(Self)) := M.alloc self in
    let* id : M.Val ltac:(erc721.TokenId) := M.alloc id in
    let* α0 : ref erc721.Erc721.t := M.read self in
    M.call
      ((erc721.Mapping.t u32.t erc721.AccountId.t)::["get"]
        (borrow (deref α0).["token_owner"])
        (borrow id)).
  
  Global Instance AssociatedFunction_owner_of :
    Notations.DoubleColon ltac:(Self) "owner_of" := {
    Notations.double_colon := owner_of;
  }.
  
  (*
      pub fn get_approved(&self, id: TokenId) -> Option<AccountId> {
          self.token_approvals.get(&id)
      }
  *)
  Definition get_approved
      (self : ref ltac:(Self))
      (id : ltac:(erc721.TokenId))
      : M (core.option.Option.t erc721.AccountId.t) :=
    let* self : M.Val (ref ltac:(Self)) := M.alloc self in
    let* id : M.Val ltac:(erc721.TokenId) := M.alloc id in
    let* α0 : ref erc721.Erc721.t := M.read self in
    M.call
      ((erc721.Mapping.t u32.t erc721.AccountId.t)::["get"]
        (borrow (deref α0).["token_approvals"])
        (borrow id)).
  
  Global Instance AssociatedFunction_get_approved :
    Notations.DoubleColon ltac:(Self) "get_approved" := {
    Notations.double_colon := get_approved;
  }.
  
  (*
      pub fn is_approved_for_all(&self, owner: AccountId, operator: AccountId) -> bool {
          self.approved_for_all(owner, operator)
      }
  *)
  Definition is_approved_for_all
      (self : ref ltac:(Self))
      (owner : erc721.AccountId.t)
      (operator : erc721.AccountId.t)
      : M bool.t :=
    let* self : M.Val (ref ltac:(Self)) := M.alloc self in
    let* owner : M.Val erc721.AccountId.t := M.alloc owner in
    let* operator : M.Val erc721.AccountId.t := M.alloc operator in
    let* α0 : ref erc721.Erc721.t := M.read self in
    let* α1 : erc721.AccountId.t := M.read owner in
    let* α2 : erc721.AccountId.t := M.read operator in
    M.call (erc721.Erc721.t::["approved_for_all"] α0 α1 α2).
  
  Global Instance AssociatedFunction_is_approved_for_all :
    Notations.DoubleColon ltac:(Self) "is_approved_for_all" := {
    Notations.double_colon := is_approved_for_all;
  }.
  
  (*
      pub fn set_approval_for_all(&mut self, to: AccountId, approved: bool) -> Result<(), Error> {
          self.approve_for_all(to, approved)?;
          Ok(())
      }
  *)
  Definition set_approval_for_all
      (self : mut_ref ltac:(Self))
      (to : erc721.AccountId.t)
      (approved : bool.t)
      : M (core.result.Result.t unit erc721.Error.t) :=
    let* self : M.Val (mut_ref ltac:(Self)) := M.alloc self in
    let* to : M.Val erc721.AccountId.t := M.alloc to in
    let* approved : M.Val bool.t := M.alloc approved in
    let return_ := M.return_ (R := core.result.Result.t unit erc721.Error.t) in
    M.catch_return
      (let* _ : M.Val unit :=
        let* α0 : mut_ref erc721.Erc721.t := M.read self in
        let* α1 : erc721.AccountId.t := M.read to in
        let* α2 : bool.t := M.read approved in
        let* α3 : core.result.Result.t unit erc721.Error.t :=
          M.call (erc721.Erc721.t::["approve_for_all"] α0 α1 α2) in
        let* α4 :
            core.ops.control_flow.ControlFlow.t
              (core.result.Result.t core.convert.Infallible.t erc721.Error.t)
              unit :=
          M.call
            ((core.ops.try_trait.Try.branch
                (Self := core.result.Result.t unit erc721.Error.t)
                (Trait := ltac:(refine _)))
              α3) in
        match α4 with
        | core.ops.control_flow.ControlFlow.Break residual =>
          let* residual := M.alloc residual in
          let* α0 :
              core.result.Result.t core.convert.Infallible.t erc721.Error.t :=
            M.read residual in
          let* α1 : core.result.Result.t unit erc721.Error.t :=
            M.call
              ((core.ops.try_trait.FromResidual.from_residual
                  (Self := core.result.Result.t unit erc721.Error.t)
                  (Trait := ltac:(refine _)))
                α0) in
          let* α2 : M.Val never.t := return_ α1 in
          let* α3 := M.read α2 in
          let* α4 : unit := never_to_any α3 in
          M.alloc α4
        | core.ops.control_flow.ControlFlow.Continue val =>
          let* val := M.alloc val in
          M.pure val
        end in
      let* α0 : M.Val (core.result.Result.t unit erc721.Error.t) :=
        M.alloc (core.result.Result.Ok tt) in
      M.read α0).
  
  Global Instance AssociatedFunction_set_approval_for_all :
    Notations.DoubleColon ltac:(Self) "set_approval_for_all" := {
    Notations.double_colon := set_approval_for_all;
  }.
  
  (*
      pub fn approve(&mut self, to: AccountId, id: TokenId) -> Result<(), Error> {
          self.approve_for(&to, id)?;
          Ok(())
      }
  *)
  Definition approve
      (self : mut_ref ltac:(Self))
      (to : erc721.AccountId.t)
      (id : ltac:(erc721.TokenId))
      : M (core.result.Result.t unit erc721.Error.t) :=
    let* self : M.Val (mut_ref ltac:(Self)) := M.alloc self in
    let* to : M.Val erc721.AccountId.t := M.alloc to in
    let* id : M.Val ltac:(erc721.TokenId) := M.alloc id in
    let return_ := M.return_ (R := core.result.Result.t unit erc721.Error.t) in
    M.catch_return
      (let* _ : M.Val unit :=
        let* α0 : mut_ref erc721.Erc721.t := M.read self in
        let* α1 : u32.t := M.read id in
        let* α2 : core.result.Result.t unit erc721.Error.t :=
          M.call (erc721.Erc721.t::["approve_for"] α0 (borrow to) α1) in
        let* α3 :
            core.ops.control_flow.ControlFlow.t
              (core.result.Result.t core.convert.Infallible.t erc721.Error.t)
              unit :=
          M.call
            ((core.ops.try_trait.Try.branch
                (Self := core.result.Result.t unit erc721.Error.t)
                (Trait := ltac:(refine _)))
              α2) in
        match α3 with
        | core.ops.control_flow.ControlFlow.Break residual =>
          let* residual := M.alloc residual in
          let* α0 :
              core.result.Result.t core.convert.Infallible.t erc721.Error.t :=
            M.read residual in
          let* α1 : core.result.Result.t unit erc721.Error.t :=
            M.call
              ((core.ops.try_trait.FromResidual.from_residual
                  (Self := core.result.Result.t unit erc721.Error.t)
                  (Trait := ltac:(refine _)))
                α0) in
          let* α2 : M.Val never.t := return_ α1 in
          let* α3 := M.read α2 in
          let* α4 : unit := never_to_any α3 in
          M.alloc α4
        | core.ops.control_flow.ControlFlow.Continue val =>
          let* val := M.alloc val in
          M.pure val
        end in
      let* α0 : M.Val (core.result.Result.t unit erc721.Error.t) :=
        M.alloc (core.result.Result.Ok tt) in
      M.read α0).
  
  Global Instance AssociatedFunction_approve :
    Notations.DoubleColon ltac:(Self) "approve" := {
    Notations.double_colon := approve;
  }.
  
  (*
      pub fn transfer(&mut self, destination: AccountId, id: TokenId) -> Result<(), Error> {
          let caller = self.env().caller();
          self.transfer_token_from(&caller, &destination, id)?;
          Ok(())
      }
  *)
  Definition transfer
      (self : mut_ref ltac:(Self))
      (destination : erc721.AccountId.t)
      (id : ltac:(erc721.TokenId))
      : M (core.result.Result.t unit erc721.Error.t) :=
    let* self : M.Val (mut_ref ltac:(Self)) := M.alloc self in
    let* destination : M.Val erc721.AccountId.t := M.alloc destination in
    let* id : M.Val ltac:(erc721.TokenId) := M.alloc id in
    let return_ := M.return_ (R := core.result.Result.t unit erc721.Error.t) in
    M.catch_return
      (let* caller : M.Val erc721.AccountId.t :=
        let* α0 : mut_ref erc721.Erc721.t := M.read self in
        let* α1 : erc721.Env.t :=
          M.call (erc721.Erc721.t::["env"] (borrow (deref α0))) in
        let* α2 : M.Val erc721.Env.t := M.alloc α1 in
        let* α3 : erc721.AccountId.t :=
          M.call (erc721.Env.t::["caller"] (borrow α2)) in
        M.alloc α3 in
      let* _ : M.Val unit :=
        let* α0 : mut_ref erc721.Erc721.t := M.read self in
        let* α1 : u32.t := M.read id in
        let* α2 : core.result.Result.t unit erc721.Error.t :=
          M.call
            (erc721.Erc721.t::["transfer_token_from"]
              α0
              (borrow caller)
              (borrow destination)
              α1) in
        let* α3 :
            core.ops.control_flow.ControlFlow.t
              (core.result.Result.t core.convert.Infallible.t erc721.Error.t)
              unit :=
          M.call
            ((core.ops.try_trait.Try.branch
                (Self := core.result.Result.t unit erc721.Error.t)
                (Trait := ltac:(refine _)))
              α2) in
        match α3 with
        | core.ops.control_flow.ControlFlow.Break residual =>
          let* residual := M.alloc residual in
          let* α0 :
              core.result.Result.t core.convert.Infallible.t erc721.Error.t :=
            M.read residual in
          let* α1 : core.result.Result.t unit erc721.Error.t :=
            M.call
              ((core.ops.try_trait.FromResidual.from_residual
                  (Self := core.result.Result.t unit erc721.Error.t)
                  (Trait := ltac:(refine _)))
                α0) in
          let* α2 : M.Val never.t := return_ α1 in
          let* α3 := M.read α2 in
          let* α4 : unit := never_to_any α3 in
          M.alloc α4
        | core.ops.control_flow.ControlFlow.Continue val =>
          let* val := M.alloc val in
          M.pure val
        end in
      let* α0 : M.Val (core.result.Result.t unit erc721.Error.t) :=
        M.alloc (core.result.Result.Ok tt) in
      M.read α0).
  
  Global Instance AssociatedFunction_transfer :
    Notations.DoubleColon ltac:(Self) "transfer" := {
    Notations.double_colon := transfer;
  }.
  
  (*
      pub fn transfer_from(
          &mut self,
          from: AccountId,
          to: AccountId,
          id: TokenId,
      ) -> Result<(), Error> {
          self.transfer_token_from(&from, &to, id)?;
          Ok(())
      }
  *)
  Definition transfer_from
      (self : mut_ref ltac:(Self))
      (from : erc721.AccountId.t)
      (to : erc721.AccountId.t)
      (id : ltac:(erc721.TokenId))
      : M (core.result.Result.t unit erc721.Error.t) :=
    let* self : M.Val (mut_ref ltac:(Self)) := M.alloc self in
    let* from : M.Val erc721.AccountId.t := M.alloc from in
    let* to : M.Val erc721.AccountId.t := M.alloc to in
    let* id : M.Val ltac:(erc721.TokenId) := M.alloc id in
    let return_ := M.return_ (R := core.result.Result.t unit erc721.Error.t) in
    M.catch_return
      (let* _ : M.Val unit :=
        let* α0 : mut_ref erc721.Erc721.t := M.read self in
        let* α1 : u32.t := M.read id in
        let* α2 : core.result.Result.t unit erc721.Error.t :=
          M.call
            (erc721.Erc721.t::["transfer_token_from"]
              α0
              (borrow from)
              (borrow to)
              α1) in
        let* α3 :
            core.ops.control_flow.ControlFlow.t
              (core.result.Result.t core.convert.Infallible.t erc721.Error.t)
              unit :=
          M.call
            ((core.ops.try_trait.Try.branch
                (Self := core.result.Result.t unit erc721.Error.t)
                (Trait := ltac:(refine _)))
              α2) in
        match α3 with
        | core.ops.control_flow.ControlFlow.Break residual =>
          let* residual := M.alloc residual in
          let* α0 :
              core.result.Result.t core.convert.Infallible.t erc721.Error.t :=
            M.read residual in
          let* α1 : core.result.Result.t unit erc721.Error.t :=
            M.call
              ((core.ops.try_trait.FromResidual.from_residual
                  (Self := core.result.Result.t unit erc721.Error.t)
                  (Trait := ltac:(refine _)))
                α0) in
          let* α2 : M.Val never.t := return_ α1 in
          let* α3 := M.read α2 in
          let* α4 : unit := never_to_any α3 in
          M.alloc α4
        | core.ops.control_flow.ControlFlow.Continue val =>
          let* val := M.alloc val in
          M.pure val
        end in
      let* α0 : M.Val (core.result.Result.t unit erc721.Error.t) :=
        M.alloc (core.result.Result.Ok tt) in
      M.read α0).
  
  Global Instance AssociatedFunction_transfer_from :
    Notations.DoubleColon ltac:(Self) "transfer_from" := {
    Notations.double_colon := transfer_from;
  }.
  
  (*
      pub fn mint(&mut self, id: TokenId) -> Result<(), Error> {
          let caller = self.env().caller();
          self.add_token_to(&caller, id)?;
          self.env().emit_event(Event::Transfer(Transfer {
              from: Some(AccountId::from([0x0; 32])),
              to: Some(caller),
              id,
          }));
          Ok(())
      }
  *)
  Definition mint
      (self : mut_ref ltac:(Self))
      (id : ltac:(erc721.TokenId))
      : M (core.result.Result.t unit erc721.Error.t) :=
    let* self : M.Val (mut_ref ltac:(Self)) := M.alloc self in
    let* id : M.Val ltac:(erc721.TokenId) := M.alloc id in
    let return_ := M.return_ (R := core.result.Result.t unit erc721.Error.t) in
    M.catch_return
      (let* caller : M.Val erc721.AccountId.t :=
        let* α0 : mut_ref erc721.Erc721.t := M.read self in
        let* α1 : erc721.Env.t :=
          M.call (erc721.Erc721.t::["env"] (borrow (deref α0))) in
        let* α2 : M.Val erc721.Env.t := M.alloc α1 in
        let* α3 : erc721.AccountId.t :=
          M.call (erc721.Env.t::["caller"] (borrow α2)) in
        M.alloc α3 in
      let* _ : M.Val unit :=
        let* α0 : mut_ref erc721.Erc721.t := M.read self in
        let* α1 : u32.t := M.read id in
        let* α2 : core.result.Result.t unit erc721.Error.t :=
          M.call (erc721.Erc721.t::["add_token_to"] α0 (borrow caller) α1) in
        let* α3 :
            core.ops.control_flow.ControlFlow.t
              (core.result.Result.t core.convert.Infallible.t erc721.Error.t)
              unit :=
          M.call
            ((core.ops.try_trait.Try.branch
                (Self := core.result.Result.t unit erc721.Error.t)
                (Trait := ltac:(refine _)))
              α2) in
        match α3 with
        | core.ops.control_flow.ControlFlow.Break residual =>
          let* residual := M.alloc residual in
          let* α0 :
              core.result.Result.t core.convert.Infallible.t erc721.Error.t :=
            M.read residual in
          let* α1 : core.result.Result.t unit erc721.Error.t :=
            M.call
              ((core.ops.try_trait.FromResidual.from_residual
                  (Self := core.result.Result.t unit erc721.Error.t)
                  (Trait := ltac:(refine _)))
                α0) in
          let* α2 : M.Val never.t := return_ α1 in
          let* α3 := M.read α2 in
          let* α4 : unit := never_to_any α3 in
          M.alloc α4
        | core.ops.control_flow.ControlFlow.Continue val =>
          let* val := M.alloc val in
          M.pure val
        end in
      let* _ : M.Val unit :=
        let* α0 : mut_ref erc721.Erc721.t := M.read self in
        let* α1 : erc721.Env.t :=
          M.call (erc721.Erc721.t::["env"] (borrow (deref α0))) in
        let* α2 : M.Val erc721.Env.t := M.alloc α1 in
        let* α3 : erc721.AccountId.t :=
          M.call
            ((core.convert.From.from
                (Self := erc721.AccountId.t)
                (Trait := ltac:(refine _)))
              (repeat (Integer.of_Z 0) 32)) in
        let* α4 : erc721.AccountId.t := M.read caller in
        let* α5 : u32.t := M.read id in
        let* α6 : unit :=
          M.call
            (erc721.Env.t::["emit_event"]
              (borrow α2)
              (erc721.Event.Transfer
                {|
                  erc721.Transfer.from := core.option.Option.Some α3;
                  erc721.Transfer.to := core.option.Option.Some α4;
                  erc721.Transfer.id := α5;
                |})) in
        M.alloc α6 in
      let* α0 : M.Val (core.result.Result.t unit erc721.Error.t) :=
        M.alloc (core.result.Result.Ok tt) in
      M.read α0).
  
  Global Instance AssociatedFunction_mint :
    Notations.DoubleColon ltac:(Self) "mint" := {
    Notations.double_colon := mint;
  }.
  
  (*
      pub fn burn(&mut self, id: TokenId) -> Result<(), Error> {
          let caller = self.env().caller();
          let Self {
              token_owner,
              owned_tokens_count,
              ..
          } = self;
  
          let owner = token_owner.get(&id).ok_or(Error::TokenNotFound)?;
          if owner != caller {
              return Err(Error::NotOwner);
          };
  
          let count = owned_tokens_count
              .get(&caller)
              .map(|c| c - 1)
              .ok_or(Error::CannotFetchValue)?;
          owned_tokens_count.insert(caller, count);
          token_owner.remove(id);
  
          self.env().emit_event(Event::Transfer(Transfer {
              from: Some(caller),
              to: Some(AccountId::from([0x0; 32])),
              id,
          }));
  
          Ok(())
      }
  *)
  Definition burn
      (self : mut_ref ltac:(Self))
      (id : ltac:(erc721.TokenId))
      : M (core.result.Result.t unit erc721.Error.t) :=
    let* self : M.Val (mut_ref ltac:(Self)) := M.alloc self in
    let* id : M.Val ltac:(erc721.TokenId) := M.alloc id in
    let return_ := M.return_ (R := core.result.Result.t unit erc721.Error.t) in
    M.catch_return
      (let* caller : M.Val erc721.AccountId.t :=
        let* α0 : mut_ref erc721.Erc721.t := M.read self in
        let* α1 : erc721.Env.t :=
          M.call (erc721.Erc721.t::["env"] (borrow (deref α0))) in
        let* α2 : M.Val erc721.Env.t := M.alloc α1 in
        let* α3 : erc721.AccountId.t :=
          M.call (erc721.Env.t::["caller"] (borrow α2)) in
        M.alloc α3 in
      let* '{|
            erc721.Erc721.token_owner := token_owner;
            erc721.Erc721.owned_tokens_count := owned_tokens_count;
          |} :
          M.Val (mut_ref erc721.Erc721.t) :=
        M.copy self in
      let* owner : M.Val erc721.AccountId.t :=
        let* α0 : mut_ref (erc721.Mapping.t u32.t erc721.AccountId.t) :=
          M.read token_owner in
        let* α1 : core.option.Option.t erc721.AccountId.t :=
          M.call
            ((erc721.Mapping.t u32.t erc721.AccountId.t)::["get"]
              (borrow (deref α0))
              (borrow id)) in
        let* α2 : core.result.Result.t erc721.AccountId.t erc721.Error.t :=
          M.call
            ((core.option.Option.t erc721.AccountId.t)::["ok_or"]
              α1
              erc721.Error.TokenNotFound) in
        let* α3 :
            core.ops.control_flow.ControlFlow.t
              (core.result.Result.t core.convert.Infallible.t erc721.Error.t)
              erc721.AccountId.t :=
          M.call
            ((core.ops.try_trait.Try.branch
                (Self := core.result.Result.t erc721.AccountId.t erc721.Error.t)
                (Trait := ltac:(refine _)))
              α2) in
        let* α4 : M.Val erc721.AccountId.t :=
          match α3 with
          | core.ops.control_flow.ControlFlow.Break residual =>
            let* residual := M.alloc residual in
            let* α0 :
                core.result.Result.t core.convert.Infallible.t erc721.Error.t :=
              M.read residual in
            let* α1 : core.result.Result.t unit erc721.Error.t :=
              M.call
                ((core.ops.try_trait.FromResidual.from_residual
                    (Self := core.result.Result.t unit erc721.Error.t)
                    (Trait := ltac:(refine _)))
                  α0) in
            let* α2 : M.Val never.t := return_ α1 in
            let* α3 := M.read α2 in
            let* α4 : erc721.AccountId.t := never_to_any α3 in
            M.alloc α4
          | core.ops.control_flow.ControlFlow.Continue val =>
            let* val := M.alloc val in
            M.pure val
          end in
        M.copy α4 in
      let* _ : M.Val unit :=
        let* α0 : bool.t :=
          M.call
            ((core.cmp.PartialEq.ne
                (Self := erc721.AccountId.t)
                (Trait := ltac:(refine _)))
              (borrow owner)
              (borrow caller)) in
        if (use α0 : bool) then
          let* _ : M.Val never.t :=
            return_ (core.result.Result.Err erc721.Error.NotOwner) in
          let* α0 : M.Val unit := M.alloc tt in
          let* α1 := M.read α0 in
          let* α2 : unit := never_to_any α1 in
          M.alloc α2
        else
          M.alloc tt in
      let* count : M.Val u32.t :=
        let* α0 : mut_ref (erc721.Mapping.t erc721.AccountId.t u32.t) :=
          M.read owned_tokens_count in
        let* α1 : core.option.Option.t u32.t :=
          M.call
            ((erc721.Mapping.t erc721.AccountId.t u32.t)::["get"]
              (borrow (deref α0))
              (borrow caller)) in
        let* α2 : type not implemented :=
          M.read
            (let* α0 : u32.t := M.read c in
            let* α1 : u32.t := BinOp.Panic.sub α0 (Integer.of_Z 1) in
            M.alloc α1) in
        let* α3 : core.option.Option.t u32.t :=
          M.call ((core.option.Option.t u32.t)::["map"] α1 α2) in
        let* α4 : core.result.Result.t u32.t erc721.Error.t :=
          M.call
            ((core.option.Option.t u32.t)::["ok_or"]
              α3
              erc721.Error.CannotFetchValue) in
        let* α5 :
            core.ops.control_flow.ControlFlow.t
              (core.result.Result.t core.convert.Infallible.t erc721.Error.t)
              u32.t :=
          M.call
            ((core.ops.try_trait.Try.branch
                (Self := core.result.Result.t u32.t erc721.Error.t)
                (Trait := ltac:(refine _)))
              α4) in
        let* α6 : M.Val u32.t :=
          match α5 with
          | core.ops.control_flow.ControlFlow.Break residual =>
            let* residual := M.alloc residual in
            let* α0 :
                core.result.Result.t core.convert.Infallible.t erc721.Error.t :=
              M.read residual in
            let* α1 : core.result.Result.t unit erc721.Error.t :=
              M.call
                ((core.ops.try_trait.FromResidual.from_residual
                    (Self := core.result.Result.t unit erc721.Error.t)
                    (Trait := ltac:(refine _)))
                  α0) in
            let* α2 : M.Val never.t := return_ α1 in
            let* α3 := M.read α2 in
            let* α4 : u32.t := never_to_any α3 in
            M.alloc α4
          | core.ops.control_flow.ControlFlow.Continue val =>
            let* val := M.alloc val in
            M.pure val
          end in
        M.copy α6 in
      let* _ : M.Val (core.option.Option.t u32.t) :=
        let* α0 : mut_ref (erc721.Mapping.t erc721.AccountId.t u32.t) :=
          M.read owned_tokens_count in
        let* α1 : erc721.AccountId.t := M.read caller in
        let* α2 : u32.t := M.read count in
        let* α3 : core.option.Option.t u32.t :=
          M.call
            ((erc721.Mapping.t erc721.AccountId.t u32.t)::["insert"]
              α0
              α1
              α2) in
        M.alloc α3 in
      let* _ : M.Val unit :=
        let* α0 : mut_ref (erc721.Mapping.t u32.t erc721.AccountId.t) :=
          M.read token_owner in
        let* α1 : u32.t := M.read id in
        let* α2 : unit :=
          M.call
            ((erc721.Mapping.t u32.t erc721.AccountId.t)::["remove"]
              (borrow (deref α0))
              α1) in
        M.alloc α2 in
      let* _ : M.Val unit :=
        let* α0 : mut_ref erc721.Erc721.t := M.read self in
        let* α1 : erc721.Env.t :=
          M.call (erc721.Erc721.t::["env"] (borrow (deref α0))) in
        let* α2 : M.Val erc721.Env.t := M.alloc α1 in
        let* α3 : erc721.AccountId.t := M.read caller in
        let* α4 : erc721.AccountId.t :=
          M.call
            ((core.convert.From.from
                (Self := erc721.AccountId.t)
                (Trait := ltac:(refine _)))
              (repeat (Integer.of_Z 0) 32)) in
        let* α5 : u32.t := M.read id in
        let* α6 : unit :=
          M.call
            (erc721.Env.t::["emit_event"]
              (borrow α2)
              (erc721.Event.Transfer
                {|
                  erc721.Transfer.from := core.option.Option.Some α3;
                  erc721.Transfer.to := core.option.Option.Some α4;
                  erc721.Transfer.id := α5;
                |})) in
        M.alloc α6 in
      let* α0 : M.Val (core.result.Result.t unit erc721.Error.t) :=
        M.alloc (core.result.Result.Ok tt) in
      M.read α0).
  
  Global Instance AssociatedFunction_burn :
    Notations.DoubleColon ltac:(Self) "burn" := {
    Notations.double_colon := burn;
  }.
  
  (*
      fn transfer_token_from(
          &mut self,
          from: &AccountId,
          to: &AccountId,
          id: TokenId,
      ) -> Result<(), Error> {
          let caller = self.env().caller();
          if !self.exists(id) {
              return Err(Error::TokenNotFound);
          };
          if !self.approved_or_owner(Some(caller), id) {
              return Err(Error::NotApproved);
          };
          self.clear_approval(id);
          self.remove_token_from(from, id)?;
          self.add_token_to(to, id)?;
          self.env().emit_event(Event::Transfer(Transfer {
              from: Some( *from),
              to: Some( *to),
              id,
          }));
          Ok(())
      }
  *)
  Definition transfer_token_from
      (self : mut_ref ltac:(Self))
      (from : ref erc721.AccountId.t)
      (to : ref erc721.AccountId.t)
      (id : ltac:(erc721.TokenId))
      : M (core.result.Result.t unit erc721.Error.t) :=
    let* self : M.Val (mut_ref ltac:(Self)) := M.alloc self in
    let* from : M.Val (ref erc721.AccountId.t) := M.alloc from in
    let* to : M.Val (ref erc721.AccountId.t) := M.alloc to in
    let* id : M.Val ltac:(erc721.TokenId) := M.alloc id in
    let return_ := M.return_ (R := core.result.Result.t unit erc721.Error.t) in
    M.catch_return
      (let* caller : M.Val erc721.AccountId.t :=
        let* α0 : mut_ref erc721.Erc721.t := M.read self in
        let* α1 : erc721.Env.t :=
          M.call (erc721.Erc721.t::["env"] (borrow (deref α0))) in
        let* α2 : M.Val erc721.Env.t := M.alloc α1 in
        let* α3 : erc721.AccountId.t :=
          M.call (erc721.Env.t::["caller"] (borrow α2)) in
        M.alloc α3 in
      let* _ : M.Val unit :=
        let* α0 : mut_ref erc721.Erc721.t := M.read self in
        let* α1 : u32.t := M.read id in
        let* α2 : bool.t :=
          M.call (erc721.Erc721.t::["exists"] (borrow (deref α0)) α1) in
        if (use (UnOp.not α2) : bool) then
          let* _ : M.Val never.t :=
            return_ (core.result.Result.Err erc721.Error.TokenNotFound) in
          let* α0 : M.Val unit := M.alloc tt in
          let* α1 := M.read α0 in
          let* α2 : unit := never_to_any α1 in
          M.alloc α2
        else
          M.alloc tt in
      let* _ : M.Val unit :=
        let* α0 : mut_ref erc721.Erc721.t := M.read self in
        let* α1 : erc721.AccountId.t := M.read caller in
        let* α2 : u32.t := M.read id in
        let* α3 : bool.t :=
          M.call
            (erc721.Erc721.t::["approved_or_owner"]
              (borrow (deref α0))
              (core.option.Option.Some α1)
              α2) in
        if (use (UnOp.not α3) : bool) then
          let* _ : M.Val never.t :=
            return_ (core.result.Result.Err erc721.Error.NotApproved) in
          let* α0 : M.Val unit := M.alloc tt in
          let* α1 := M.read α0 in
          let* α2 : unit := never_to_any α1 in
          M.alloc α2
        else
          M.alloc tt in
      let* _ : M.Val unit :=
        let* α0 : mut_ref erc721.Erc721.t := M.read self in
        let* α1 : u32.t := M.read id in
        let* α2 : unit := M.call (erc721.Erc721.t::["clear_approval"] α0 α1) in
        M.alloc α2 in
      let* _ : M.Val unit :=
        let* α0 : mut_ref erc721.Erc721.t := M.read self in
        let* α1 : ref erc721.AccountId.t := M.read from in
        let* α2 : u32.t := M.read id in
        let* α3 : core.result.Result.t unit erc721.Error.t :=
          M.call (erc721.Erc721.t::["remove_token_from"] α0 α1 α2) in
        let* α4 :
            core.ops.control_flow.ControlFlow.t
              (core.result.Result.t core.convert.Infallible.t erc721.Error.t)
              unit :=
          M.call
            ((core.ops.try_trait.Try.branch
                (Self := core.result.Result.t unit erc721.Error.t)
                (Trait := ltac:(refine _)))
              α3) in
        match α4 with
        | core.ops.control_flow.ControlFlow.Break residual =>
          let* residual := M.alloc residual in
          let* α0 :
              core.result.Result.t core.convert.Infallible.t erc721.Error.t :=
            M.read residual in
          let* α1 : core.result.Result.t unit erc721.Error.t :=
            M.call
              ((core.ops.try_trait.FromResidual.from_residual
                  (Self := core.result.Result.t unit erc721.Error.t)
                  (Trait := ltac:(refine _)))
                α0) in
          let* α2 : M.Val never.t := return_ α1 in
          let* α3 := M.read α2 in
          let* α4 : unit := never_to_any α3 in
          M.alloc α4
        | core.ops.control_flow.ControlFlow.Continue val =>
          let* val := M.alloc val in
          M.pure val
        end in
      let* _ : M.Val unit :=
        let* α0 : mut_ref erc721.Erc721.t := M.read self in
        let* α1 : ref erc721.AccountId.t := M.read to in
        let* α2 : u32.t := M.read id in
        let* α3 : core.result.Result.t unit erc721.Error.t :=
          M.call (erc721.Erc721.t::["add_token_to"] α0 α1 α2) in
        let* α4 :
            core.ops.control_flow.ControlFlow.t
              (core.result.Result.t core.convert.Infallible.t erc721.Error.t)
              unit :=
          M.call
            ((core.ops.try_trait.Try.branch
                (Self := core.result.Result.t unit erc721.Error.t)
                (Trait := ltac:(refine _)))
              α3) in
        match α4 with
        | core.ops.control_flow.ControlFlow.Break residual =>
          let* residual := M.alloc residual in
          let* α0 :
              core.result.Result.t core.convert.Infallible.t erc721.Error.t :=
            M.read residual in
          let* α1 : core.result.Result.t unit erc721.Error.t :=
            M.call
              ((core.ops.try_trait.FromResidual.from_residual
                  (Self := core.result.Result.t unit erc721.Error.t)
                  (Trait := ltac:(refine _)))
                α0) in
          let* α2 : M.Val never.t := return_ α1 in
          let* α3 := M.read α2 in
          let* α4 : unit := never_to_any α3 in
          M.alloc α4
        | core.ops.control_flow.ControlFlow.Continue val =>
          let* val := M.alloc val in
          M.pure val
        end in
      let* _ : M.Val unit :=
        let* α0 : mut_ref erc721.Erc721.t := M.read self in
        let* α1 : erc721.Env.t :=
          M.call (erc721.Erc721.t::["env"] (borrow (deref α0))) in
        let* α2 : M.Val erc721.Env.t := M.alloc α1 in
        let* α3 : ref erc721.AccountId.t := M.read from in
        let* α4 : erc721.AccountId.t := M.read (deref α3) in
        let* α5 : ref erc721.AccountId.t := M.read to in
        let* α6 : erc721.AccountId.t := M.read (deref α5) in
        let* α7 : u32.t := M.read id in
        let* α8 : unit :=
          M.call
            (erc721.Env.t::["emit_event"]
              (borrow α2)
              (erc721.Event.Transfer
                {|
                  erc721.Transfer.from := core.option.Option.Some α4;
                  erc721.Transfer.to := core.option.Option.Some α6;
                  erc721.Transfer.id := α7;
                |})) in
        M.alloc α8 in
      let* α0 : M.Val (core.result.Result.t unit erc721.Error.t) :=
        M.alloc (core.result.Result.Ok tt) in
      M.read α0).
  
  Global Instance AssociatedFunction_transfer_token_from :
    Notations.DoubleColon ltac:(Self) "transfer_token_from" := {
    Notations.double_colon := transfer_token_from;
  }.
  
  (*
      fn remove_token_from(&mut self, from: &AccountId, id: TokenId) -> Result<(), Error> {
          let Self {
              token_owner,
              owned_tokens_count,
              ..
          } = self;
  
          if !token_owner.contains(&id) {
              return Err(Error::TokenNotFound);
          }
  
          let count = owned_tokens_count
              .get(from)
              .map(|c| c - 1)
              .ok_or(Error::CannotFetchValue)?;
          owned_tokens_count.insert( *from, count);
          token_owner.remove(id);
  
          Ok(())
      }
  *)
  Definition remove_token_from
      (self : mut_ref ltac:(Self))
      (from : ref erc721.AccountId.t)
      (id : ltac:(erc721.TokenId))
      : M (core.result.Result.t unit erc721.Error.t) :=
    let* self : M.Val (mut_ref ltac:(Self)) := M.alloc self in
    let* from : M.Val (ref erc721.AccountId.t) := M.alloc from in
    let* id : M.Val ltac:(erc721.TokenId) := M.alloc id in
    let return_ := M.return_ (R := core.result.Result.t unit erc721.Error.t) in
    M.catch_return
      (let* '{|
            erc721.Erc721.token_owner := token_owner;
            erc721.Erc721.owned_tokens_count := owned_tokens_count;
          |} :
          M.Val (mut_ref erc721.Erc721.t) :=
        M.copy self in
      let* _ : M.Val unit :=
        let* α0 : mut_ref (erc721.Mapping.t u32.t erc721.AccountId.t) :=
          M.read token_owner in
        let* α1 : bool.t :=
          M.call
            ((erc721.Mapping.t u32.t erc721.AccountId.t)::["contains"]
              (borrow (deref α0))
              (borrow id)) in
        if (use (UnOp.not α1) : bool) then
          let* _ : M.Val never.t :=
            return_ (core.result.Result.Err erc721.Error.TokenNotFound) in
          let* α0 : M.Val unit := M.alloc tt in
          let* α1 := M.read α0 in
          let* α2 : unit := never_to_any α1 in
          M.alloc α2
        else
          M.alloc tt in
      let* count : M.Val u32.t :=
        let* α0 : mut_ref (erc721.Mapping.t erc721.AccountId.t u32.t) :=
          M.read owned_tokens_count in
        let* α1 : ref erc721.AccountId.t := M.read from in
        let* α2 : core.option.Option.t u32.t :=
          M.call
            ((erc721.Mapping.t erc721.AccountId.t u32.t)::["get"]
              (borrow (deref α0))
              α1) in
        let* α3 : type not implemented :=
          M.read
            (let* α0 : u32.t := M.read c in
            let* α1 : u32.t := BinOp.Panic.sub α0 (Integer.of_Z 1) in
            M.alloc α1) in
        let* α4 : core.option.Option.t u32.t :=
          M.call ((core.option.Option.t u32.t)::["map"] α2 α3) in
        let* α5 : core.result.Result.t u32.t erc721.Error.t :=
          M.call
            ((core.option.Option.t u32.t)::["ok_or"]
              α4
              erc721.Error.CannotFetchValue) in
        let* α6 :
            core.ops.control_flow.ControlFlow.t
              (core.result.Result.t core.convert.Infallible.t erc721.Error.t)
              u32.t :=
          M.call
            ((core.ops.try_trait.Try.branch
                (Self := core.result.Result.t u32.t erc721.Error.t)
                (Trait := ltac:(refine _)))
              α5) in
        let* α7 : M.Val u32.t :=
          match α6 with
          | core.ops.control_flow.ControlFlow.Break residual =>
            let* residual := M.alloc residual in
            let* α0 :
                core.result.Result.t core.convert.Infallible.t erc721.Error.t :=
              M.read residual in
            let* α1 : core.result.Result.t unit erc721.Error.t :=
              M.call
                ((core.ops.try_trait.FromResidual.from_residual
                    (Self := core.result.Result.t unit erc721.Error.t)
                    (Trait := ltac:(refine _)))
                  α0) in
            let* α2 : M.Val never.t := return_ α1 in
            let* α3 := M.read α2 in
            let* α4 : u32.t := never_to_any α3 in
            M.alloc α4
          | core.ops.control_flow.ControlFlow.Continue val =>
            let* val := M.alloc val in
            M.pure val
          end in
        M.copy α7 in
      let* _ : M.Val (core.option.Option.t u32.t) :=
        let* α0 : mut_ref (erc721.Mapping.t erc721.AccountId.t u32.t) :=
          M.read owned_tokens_count in
        let* α1 : ref erc721.AccountId.t := M.read from in
        let* α2 : erc721.AccountId.t := M.read (deref α1) in
        let* α3 : u32.t := M.read count in
        let* α4 : core.option.Option.t u32.t :=
          M.call
            ((erc721.Mapping.t erc721.AccountId.t u32.t)::["insert"]
              α0
              α2
              α3) in
        M.alloc α4 in
      let* _ : M.Val unit :=
        let* α0 : mut_ref (erc721.Mapping.t u32.t erc721.AccountId.t) :=
          M.read token_owner in
        let* α1 : u32.t := M.read id in
        let* α2 : unit :=
          M.call
            ((erc721.Mapping.t u32.t erc721.AccountId.t)::["remove"]
              (borrow (deref α0))
              α1) in
        M.alloc α2 in
      let* α0 : M.Val (core.result.Result.t unit erc721.Error.t) :=
        M.alloc (core.result.Result.Ok tt) in
      M.read α0).
  
  Global Instance AssociatedFunction_remove_token_from :
    Notations.DoubleColon ltac:(Self) "remove_token_from" := {
    Notations.double_colon := remove_token_from;
  }.
  
  (*
      fn add_token_to(&mut self, to: &AccountId, id: TokenId) -> Result<(), Error> {
          let Self {
              token_owner,
              owned_tokens_count,
              ..
          } = self;
  
          if token_owner.contains(&id) {
              return Err(Error::TokenExists);
          }
  
          if *to == AccountId::from([0x0; 32]) {
              return Err(Error::NotAllowed);
          };
  
          let count = owned_tokens_count.get(to).map(|c| c + 1).unwrap_or(1);
  
          owned_tokens_count.insert( *to, count);
          token_owner.insert(id, *to);
  
          Ok(())
      }
  *)
  Definition add_token_to
      (self : mut_ref ltac:(Self))
      (to : ref erc721.AccountId.t)
      (id : ltac:(erc721.TokenId))
      : M (core.result.Result.t unit erc721.Error.t) :=
    let* self : M.Val (mut_ref ltac:(Self)) := M.alloc self in
    let* to : M.Val (ref erc721.AccountId.t) := M.alloc to in
    let* id : M.Val ltac:(erc721.TokenId) := M.alloc id in
    let return_ := M.return_ (R := core.result.Result.t unit erc721.Error.t) in
    M.catch_return
      (let* '{|
            erc721.Erc721.token_owner := token_owner;
            erc721.Erc721.owned_tokens_count := owned_tokens_count;
          |} :
          M.Val (mut_ref erc721.Erc721.t) :=
        M.copy self in
      let* _ : M.Val unit :=
        let* α0 : mut_ref (erc721.Mapping.t u32.t erc721.AccountId.t) :=
          M.read token_owner in
        let* α1 : bool.t :=
          M.call
            ((erc721.Mapping.t u32.t erc721.AccountId.t)::["contains"]
              (borrow (deref α0))
              (borrow id)) in
        if (use α1 : bool) then
          let* _ : M.Val never.t :=
            return_ (core.result.Result.Err erc721.Error.TokenExists) in
          let* α0 : M.Val unit := M.alloc tt in
          let* α1 := M.read α0 in
          let* α2 : unit := never_to_any α1 in
          M.alloc α2
        else
          M.alloc tt in
      let* _ : M.Val unit :=
        let* α0 : ref erc721.AccountId.t := M.read to in
        let* α1 : erc721.AccountId.t :=
          M.call
            ((core.convert.From.from
                (Self := erc721.AccountId.t)
                (Trait := ltac:(refine _)))
              (repeat (Integer.of_Z 0) 32)) in
        let* α2 : M.Val erc721.AccountId.t := M.alloc α1 in
        let* α3 : bool.t :=
          M.call
            ((core.cmp.PartialEq.eq
                (Self := erc721.AccountId.t)
                (Trait := ltac:(refine _)))
              α0
              (borrow α2)) in
        if (use α3 : bool) then
          let* _ : M.Val never.t :=
            return_ (core.result.Result.Err erc721.Error.NotAllowed) in
          let* α0 : M.Val unit := M.alloc tt in
          let* α1 := M.read α0 in
          let* α2 : unit := never_to_any α1 in
          M.alloc α2
        else
          M.alloc tt in
      let* count : M.Val u32.t :=
        let* α0 : mut_ref (erc721.Mapping.t erc721.AccountId.t u32.t) :=
          M.read owned_tokens_count in
        let* α1 : ref erc721.AccountId.t := M.read to in
        let* α2 : core.option.Option.t u32.t :=
          M.call
            ((erc721.Mapping.t erc721.AccountId.t u32.t)::["get"]
              (borrow (deref α0))
              α1) in
        let* α3 : type not implemented :=
          M.read
            (let* α0 : u32.t := M.read c in
            let* α1 : u32.t := BinOp.Panic.add α0 (Integer.of_Z 1) in
            M.alloc α1) in
        let* α4 : core.option.Option.t u32.t :=
          M.call ((core.option.Option.t u32.t)::["map"] α2 α3) in
        let* α5 : u32.t :=
          M.call
            ((core.option.Option.t u32.t)::["unwrap_or"] α4 (Integer.of_Z 1)) in
        M.alloc α5 in
      let* _ : M.Val (core.option.Option.t u32.t) :=
        let* α0 : mut_ref (erc721.Mapping.t erc721.AccountId.t u32.t) :=
          M.read owned_tokens_count in
        let* α1 : ref erc721.AccountId.t := M.read to in
        let* α2 : erc721.AccountId.t := M.read (deref α1) in
        let* α3 : u32.t := M.read count in
        let* α4 : core.option.Option.t u32.t :=
          M.call
            ((erc721.Mapping.t erc721.AccountId.t u32.t)::["insert"]
              α0
              α2
              α3) in
        M.alloc α4 in
      let* _ : M.Val (core.option.Option.t u32.t) :=
        let* α0 : mut_ref (erc721.Mapping.t u32.t erc721.AccountId.t) :=
          M.read token_owner in
        let* α1 : u32.t := M.read id in
        let* α2 : ref erc721.AccountId.t := M.read to in
        let* α3 : erc721.AccountId.t := M.read (deref α2) in
        let* α4 : core.option.Option.t u32.t :=
          M.call
            ((erc721.Mapping.t u32.t erc721.AccountId.t)::["insert"]
              α0
              α1
              α3) in
        M.alloc α4 in
      let* α0 : M.Val (core.result.Result.t unit erc721.Error.t) :=
        M.alloc (core.result.Result.Ok tt) in
      M.read α0).
  
  Global Instance AssociatedFunction_add_token_to :
    Notations.DoubleColon ltac:(Self) "add_token_to" := {
    Notations.double_colon := add_token_to;
  }.
  
  (*
      fn approve_for_all(&mut self, to: AccountId, approved: bool) -> Result<(), Error> {
          let caller = self.env().caller();
          if to == caller {
              return Err(Error::NotAllowed);
          }
          self.env().emit_event(Event::ApprovalForAll(ApprovalForAll {
              owner: caller,
              operator: to,
              approved,
          }));
  
          if approved {
              self.operator_approvals.insert((caller, to), ());
          } else {
              self.operator_approvals.remove((caller, to));
          }
  
          Ok(())
      }
  *)
  Definition approve_for_all
      (self : mut_ref ltac:(Self))
      (to : erc721.AccountId.t)
      (approved : bool.t)
      : M (core.result.Result.t unit erc721.Error.t) :=
    let* self : M.Val (mut_ref ltac:(Self)) := M.alloc self in
    let* to : M.Val erc721.AccountId.t := M.alloc to in
    let* approved : M.Val bool.t := M.alloc approved in
    let return_ := M.return_ (R := core.result.Result.t unit erc721.Error.t) in
    M.catch_return
      (let* caller : M.Val erc721.AccountId.t :=
        let* α0 : mut_ref erc721.Erc721.t := M.read self in
        let* α1 : erc721.Env.t :=
          M.call (erc721.Erc721.t::["env"] (borrow (deref α0))) in
        let* α2 : M.Val erc721.Env.t := M.alloc α1 in
        let* α3 : erc721.AccountId.t :=
          M.call (erc721.Env.t::["caller"] (borrow α2)) in
        M.alloc α3 in
      let* _ : M.Val unit :=
        let* α0 : bool.t :=
          M.call
            ((core.cmp.PartialEq.eq
                (Self := erc721.AccountId.t)
                (Trait := ltac:(refine _)))
              (borrow to)
              (borrow caller)) in
        if (use α0 : bool) then
          let* _ : M.Val never.t :=
            return_ (core.result.Result.Err erc721.Error.NotAllowed) in
          let* α0 : M.Val unit := M.alloc tt in
          let* α1 := M.read α0 in
          let* α2 : unit := never_to_any α1 in
          M.alloc α2
        else
          M.alloc tt in
      let* _ : M.Val unit :=
        let* α0 : mut_ref erc721.Erc721.t := M.read self in
        let* α1 : erc721.Env.t :=
          M.call (erc721.Erc721.t::["env"] (borrow (deref α0))) in
        let* α2 : M.Val erc721.Env.t := M.alloc α1 in
        let* α3 : erc721.AccountId.t := M.read caller in
        let* α4 : erc721.AccountId.t := M.read to in
        let* α5 : bool.t := M.read approved in
        let* α6 : unit :=
          M.call
            (erc721.Env.t::["emit_event"]
              (borrow α2)
              (erc721.Event.ApprovalForAll
                {|
                  erc721.ApprovalForAll.owner := α3;
                  erc721.ApprovalForAll.operator := α4;
                  erc721.ApprovalForAll.approved := α5;
                |})) in
        M.alloc α6 in
      let* _ : M.Val unit :=
        let* α0 : bool.t := M.read approved in
        if (use α0 : bool) then
          let* _ : M.Val (core.option.Option.t u32.t) :=
            let* α0 : mut_ref erc721.Erc721.t := M.read self in
            let* α1 : erc721.AccountId.t := M.read caller in
            let* α2 : erc721.AccountId.t := M.read to in
            let* α3 : core.option.Option.t u32.t :=
              M.call
                ((erc721.Mapping.t
                      (erc721.AccountId.t * erc721.AccountId.t)
                      unit)::["insert"]
                  (borrow_mut (deref α0).["operator_approvals"])
                  (α1, α2)
                  tt) in
            M.alloc α3 in
          M.alloc tt
        else
          let* _ : M.Val unit :=
            let* α0 : mut_ref erc721.Erc721.t := M.read self in
            let* α1 : erc721.AccountId.t := M.read caller in
            let* α2 : erc721.AccountId.t := M.read to in
            let* α3 : unit :=
              M.call
                ((erc721.Mapping.t
                      (erc721.AccountId.t * erc721.AccountId.t)
                      unit)::["remove"]
                  (borrow (deref α0).["operator_approvals"])
                  (α1, α2)) in
            M.alloc α3 in
          M.alloc tt in
      let* α0 : M.Val (core.result.Result.t unit erc721.Error.t) :=
        M.alloc (core.result.Result.Ok tt) in
      M.read α0).
  
  Global Instance AssociatedFunction_approve_for_all :
    Notations.DoubleColon ltac:(Self) "approve_for_all" := {
    Notations.double_colon := approve_for_all;
  }.
  
  (*
      fn approve_for(&mut self, to: &AccountId, id: TokenId) -> Result<(), Error> {
          let caller = self.env().caller();
          let owner = self.owner_of(id);
          if !(owner == Some(caller)
              || self.approved_for_all(owner.expect("Error with AccountId"), caller))
          {
              return Err(Error::NotAllowed);
          };
  
          if *to == AccountId::from([0x0; 32]) {
              return Err(Error::NotAllowed);
          };
  
          if self.token_approvals.contains(&id) {
              return Err(Error::CannotInsert);
          } else {
              self.token_approvals.insert(id, *to);
          }
  
          self.env().emit_event(Event::Approval(Approval {
              from: caller,
              to: *to,
              id,
          }));
  
          Ok(())
      }
  *)
  Definition approve_for
      (self : mut_ref ltac:(Self))
      (to : ref erc721.AccountId.t)
      (id : ltac:(erc721.TokenId))
      : M (core.result.Result.t unit erc721.Error.t) :=
    let* self : M.Val (mut_ref ltac:(Self)) := M.alloc self in
    let* to : M.Val (ref erc721.AccountId.t) := M.alloc to in
    let* id : M.Val ltac:(erc721.TokenId) := M.alloc id in
    let return_ := M.return_ (R := core.result.Result.t unit erc721.Error.t) in
    M.catch_return
      (let* caller : M.Val erc721.AccountId.t :=
        let* α0 : mut_ref erc721.Erc721.t := M.read self in
        let* α1 : erc721.Env.t :=
          M.call (erc721.Erc721.t::["env"] (borrow (deref α0))) in
        let* α2 : M.Val erc721.Env.t := M.alloc α1 in
        let* α3 : erc721.AccountId.t :=
          M.call (erc721.Env.t::["caller"] (borrow α2)) in
        M.alloc α3 in
      let* owner : M.Val (core.option.Option.t erc721.AccountId.t) :=
        let* α0 : mut_ref erc721.Erc721.t := M.read self in
        let* α1 : u32.t := M.read id in
        let* α2 : core.option.Option.t erc721.AccountId.t :=
          M.call (erc721.Erc721.t::["owner_of"] (borrow (deref α0)) α1) in
        M.alloc α2 in
      let* _ : M.Val unit :=
        let* α0 : erc721.AccountId.t := M.read caller in
        let* α1 : M.Val (core.option.Option.t erc721.AccountId.t) :=
          M.alloc (core.option.Option.Some α0) in
        let* α2 : bool.t :=
          M.call
            ((core.cmp.PartialEq.eq
                (Self := core.option.Option.t erc721.AccountId.t)
                (Trait := ltac:(refine _)))
              (borrow owner)
              (borrow α1)) in
        let* α3 : mut_ref erc721.Erc721.t := M.read self in
        let* α4 : core.option.Option.t erc721.AccountId.t := M.read owner in
        let* α5 : ref str.t := M.read (mk_str "Error with AccountId") in
        let* α6 : erc721.AccountId.t :=
          M.call
            ((core.option.Option.t erc721.AccountId.t)::["expect"] α4 α5) in
        let* α7 : erc721.AccountId.t := M.read caller in
        let* α8 : bool.t :=
          M.call
            (erc721.Erc721.t::["approved_for_all"] (borrow (deref α3)) α6 α7) in
        if (use (UnOp.not (BinOp.or α2 α8)) : bool) then
          let* _ : M.Val never.t :=
            return_ (core.result.Result.Err erc721.Error.NotAllowed) in
          let* α0 : M.Val unit := M.alloc tt in
          let* α1 := M.read α0 in
          let* α2 : unit := never_to_any α1 in
          M.alloc α2
        else
          M.alloc tt in
      let* _ : M.Val unit :=
        let* α0 : ref erc721.AccountId.t := M.read to in
        let* α1 : erc721.AccountId.t :=
          M.call
            ((core.convert.From.from
                (Self := erc721.AccountId.t)
                (Trait := ltac:(refine _)))
              (repeat (Integer.of_Z 0) 32)) in
        let* α2 : M.Val erc721.AccountId.t := M.alloc α1 in
        let* α3 : bool.t :=
          M.call
            ((core.cmp.PartialEq.eq
                (Self := erc721.AccountId.t)
                (Trait := ltac:(refine _)))
              α0
              (borrow α2)) in
        if (use α3 : bool) then
          let* _ : M.Val never.t :=
            return_ (core.result.Result.Err erc721.Error.NotAllowed) in
          let* α0 : M.Val unit := M.alloc tt in
          let* α1 := M.read α0 in
          let* α2 : unit := never_to_any α1 in
          M.alloc α2
        else
          M.alloc tt in
      let* _ : M.Val unit :=
        let* α0 : mut_ref erc721.Erc721.t := M.read self in
        let* α1 : bool.t :=
          M.call
            ((erc721.Mapping.t u32.t erc721.AccountId.t)::["contains"]
              (borrow (deref α0).["token_approvals"])
              (borrow id)) in
        if (use α1 : bool) then
          let* _ : M.Val never.t :=
            return_ (core.result.Result.Err erc721.Error.CannotInsert) in
          let* α0 : M.Val unit := M.alloc tt in
          let* α1 := M.read α0 in
          let* α2 : unit := never_to_any α1 in
          M.alloc α2
        else
          let* _ : M.Val (core.option.Option.t u32.t) :=
            let* α0 : mut_ref erc721.Erc721.t := M.read self in
            let* α1 : u32.t := M.read id in
            let* α2 : ref erc721.AccountId.t := M.read to in
            let* α3 : erc721.AccountId.t := M.read (deref α2) in
            let* α4 : core.option.Option.t u32.t :=
              M.call
                ((erc721.Mapping.t u32.t erc721.AccountId.t)::["insert"]
                  (borrow_mut (deref α0).["token_approvals"])
                  α1
                  α3) in
            M.alloc α4 in
          M.alloc tt in
      let* _ : M.Val unit :=
        let* α0 : mut_ref erc721.Erc721.t := M.read self in
        let* α1 : erc721.Env.t :=
          M.call (erc721.Erc721.t::["env"] (borrow (deref α0))) in
        let* α2 : M.Val erc721.Env.t := M.alloc α1 in
        let* α3 : erc721.AccountId.t := M.read caller in
        let* α4 : ref erc721.AccountId.t := M.read to in
        let* α5 : erc721.AccountId.t := M.read (deref α4) in
        let* α6 : u32.t := M.read id in
        let* α7 : unit :=
          M.call
            (erc721.Env.t::["emit_event"]
              (borrow α2)
              (erc721.Event.Approval
                {|
                  erc721.Approval.from := α3;
                  erc721.Approval.to := α5;
                  erc721.Approval.id := α6;
                |})) in
        M.alloc α7 in
      let* α0 : M.Val (core.result.Result.t unit erc721.Error.t) :=
        M.alloc (core.result.Result.Ok tt) in
      M.read α0).
  
  Global Instance AssociatedFunction_approve_for :
    Notations.DoubleColon ltac:(Self) "approve_for" := {
    Notations.double_colon := approve_for;
  }.
  
  (*
      fn clear_approval(&mut self, id: TokenId) {
          self.token_approvals.remove(id);
      }
  *)
  Definition clear_approval
      (self : mut_ref ltac:(Self))
      (id : ltac:(erc721.TokenId))
      : M unit :=
    let* self : M.Val (mut_ref ltac:(Self)) := M.alloc self in
    let* id : M.Val ltac:(erc721.TokenId) := M.alloc id in
    let* _ : M.Val unit :=
      let* α0 : mut_ref erc721.Erc721.t := M.read self in
      let* α1 : u32.t := M.read id in
      let* α2 : unit :=
        M.call
          ((erc721.Mapping.t u32.t erc721.AccountId.t)::["remove"]
            (borrow (deref α0).["token_approvals"])
            α1) in
      M.alloc α2 in
    let* α0 : M.Val unit := M.alloc tt in
    M.read α0.
  
  Global Instance AssociatedFunction_clear_approval :
    Notations.DoubleColon ltac:(Self) "clear_approval" := {
    Notations.double_colon := clear_approval;
  }.
  
  (*
      fn balance_of_or_zero(&self, of: &AccountId) -> u32 {
          self.owned_tokens_count.get(of).unwrap_or(0)
      }
  *)
  Definition balance_of_or_zero
      (self : ref ltac:(Self))
      (of : ref erc721.AccountId.t)
      : M u32.t :=
    let* self : M.Val (ref ltac:(Self)) := M.alloc self in
    let* of : M.Val (ref erc721.AccountId.t) := M.alloc of in
    let* α0 : ref erc721.Erc721.t := M.read self in
    let* α1 : ref erc721.AccountId.t := M.read of in
    let* α2 : core.option.Option.t u32.t :=
      M.call
        ((erc721.Mapping.t erc721.AccountId.t u32.t)::["get"]
          (borrow (deref α0).["owned_tokens_count"])
          α1) in
    M.call ((core.option.Option.t u32.t)::["unwrap_or"] α2 (Integer.of_Z 0)).
  
  Global Instance AssociatedFunction_balance_of_or_zero :
    Notations.DoubleColon ltac:(Self) "balance_of_or_zero" := {
    Notations.double_colon := balance_of_or_zero;
  }.
  
  (*
      fn approved_for_all(&self, owner: AccountId, operator: AccountId) -> bool {
          self.operator_approvals.contains(&(owner, operator))
      }
  *)
  Definition approved_for_all
      (self : ref ltac:(Self))
      (owner : erc721.AccountId.t)
      (operator : erc721.AccountId.t)
      : M bool.t :=
    let* self : M.Val (ref ltac:(Self)) := M.alloc self in
    let* owner : M.Val erc721.AccountId.t := M.alloc owner in
    let* operator : M.Val erc721.AccountId.t := M.alloc operator in
    let* α0 : ref erc721.Erc721.t := M.read self in
    let* α1 : erc721.AccountId.t := M.read owner in
    let* α2 : erc721.AccountId.t := M.read operator in
    let* α3 : M.Val (erc721.AccountId.t * erc721.AccountId.t) :=
      M.alloc (α1, α2) in
    M.call
      ((erc721.Mapping.t
            (erc721.AccountId.t * erc721.AccountId.t)
            unit)::["contains"]
        (borrow (deref α0).["operator_approvals"])
        (borrow α3)).
  
  Global Instance AssociatedFunction_approved_for_all :
    Notations.DoubleColon ltac:(Self) "approved_for_all" := {
    Notations.double_colon := approved_for_all;
  }.
  
  (*
      fn approved_or_owner(&self, from: Option<AccountId>, id: TokenId) -> bool {
          let owner = self.owner_of(id);
          from != Some(AccountId::from([0x0; 32]))
              && (from == owner
                  || from == self.token_approvals.get(&id)
                  || self.approved_for_all(
                      owner.expect("Error with AccountId"),
                      from.expect("Error with AccountId"),
                  ))
      }
  *)
  Definition approved_or_owner
      (self : ref ltac:(Self))
      (from : core.option.Option.t erc721.AccountId.t)
      (id : ltac:(erc721.TokenId))
      : M bool.t :=
    let* self : M.Val (ref ltac:(Self)) := M.alloc self in
    let* from : M.Val (core.option.Option.t erc721.AccountId.t) :=
      M.alloc from in
    let* id : M.Val ltac:(erc721.TokenId) := M.alloc id in
    let* owner : M.Val (core.option.Option.t erc721.AccountId.t) :=
      let* α0 : ref erc721.Erc721.t := M.read self in
      let* α1 : u32.t := M.read id in
      let* α2 : core.option.Option.t erc721.AccountId.t :=
        M.call (erc721.Erc721.t::["owner_of"] α0 α1) in
      M.alloc α2 in
    let* α0 : erc721.AccountId.t :=
      M.call
        ((core.convert.From.from
            (Self := erc721.AccountId.t)
            (Trait := ltac:(refine _)))
          (repeat (Integer.of_Z 0) 32)) in
    let* α1 : M.Val (core.option.Option.t erc721.AccountId.t) :=
      M.alloc (core.option.Option.Some α0) in
    let* α2 : bool.t :=
      M.call
        ((core.cmp.PartialEq.ne
            (Self := core.option.Option.t erc721.AccountId.t)
            (Trait := ltac:(refine _)))
          (borrow from)
          (borrow α1)) in
    let* α3 : bool.t :=
      M.call
        ((core.cmp.PartialEq.eq
            (Self := core.option.Option.t erc721.AccountId.t)
            (Trait := ltac:(refine _)))
          (borrow from)
          (borrow owner)) in
    let* α4 : ref erc721.Erc721.t := M.read self in
    let* α5 : core.option.Option.t erc721.AccountId.t :=
      M.call
        ((erc721.Mapping.t u32.t erc721.AccountId.t)::["get"]
          (borrow (deref α4).["token_approvals"])
          (borrow id)) in
    let* α6 : M.Val (core.option.Option.t erc721.AccountId.t) := M.alloc α5 in
    let* α7 : bool.t :=
      M.call
        ((core.cmp.PartialEq.eq
            (Self := core.option.Option.t erc721.AccountId.t)
            (Trait := ltac:(refine _)))
          (borrow from)
          (borrow α6)) in
    let* α8 : ref erc721.Erc721.t := M.read self in
    let* α9 : core.option.Option.t erc721.AccountId.t := M.read owner in
    let* α10 : ref str.t := M.read (mk_str "Error with AccountId") in
    let* α11 : erc721.AccountId.t :=
      M.call ((core.option.Option.t erc721.AccountId.t)::["expect"] α9 α10) in
    let* α12 : core.option.Option.t erc721.AccountId.t := M.read from in
    let* α13 : ref str.t := M.read (mk_str "Error with AccountId") in
    let* α14 : erc721.AccountId.t :=
      M.call ((core.option.Option.t erc721.AccountId.t)::["expect"] α12 α13) in
    let* α15 : bool.t :=
      M.call (erc721.Erc721.t::["approved_for_all"] α8 α11 α14) in
    let* α0 : M.Val bool.t :=
      M.alloc (BinOp.and α2 (BinOp.or (BinOp.or α3 α7) α15)) in
    M.read α0.
  
  Global Instance AssociatedFunction_approved_or_owner :
    Notations.DoubleColon ltac:(Self) "approved_or_owner" := {
    Notations.double_colon := approved_or_owner;
  }.
  
  (*
      fn exists(&self, id: TokenId) -> bool {
          self.token_owner.contains(&id)
      }
  *)
  Definition exists
      (self : ref ltac:(Self))
      (id : ltac:(erc721.TokenId))
      : M bool.t :=
    let* self : M.Val (ref ltac:(Self)) := M.alloc self in
    let* id : M.Val ltac:(erc721.TokenId) := M.alloc id in
    let* α0 : ref erc721.Erc721.t := M.read self in
    M.call
      ((erc721.Mapping.t u32.t erc721.AccountId.t)::["contains"]
        (borrow (deref α0).["token_owner"])
        (borrow id)).
  
  Global Instance AssociatedFunction_exists :
    Notations.DoubleColon ltac:(Self) "exists" := {
    Notations.double_colon := exists;
  }.
End Impl_erc721_Erc721_t.
End Impl_erc721_Erc721_t.
