(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.



Module  Impl_core_default_Default_for_multisig_Mapping_K_V.
Section Impl_core_default_Default_for_multisig_Mapping_K_V.
  Context {K V : Set}.
  
  Definition Self : Ty.t := Ty.apply (Ty.path "multisig::Mapping") [K; V].
  
  (*
  Default
  *)
  Definition default (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [] =>
      let* Œ±0 :
          Ty.function [] (Ty.apply (Ty.path "core::marker::PhantomData") [K]) :=
        ltac:(M.get_method (fun ‚Ñê =>
          core.default.Default.default
            (Self := Ty.apply (Ty.path "core::marker::PhantomData") [K])
            (Trait := ‚Ñê))) in
      let* Œ±1 : Ty.apply (Ty.path "core::marker::PhantomData") [K] :=
        M.call Œ±0 in
      let* Œ±2 :
          Ty.function [] (Ty.apply (Ty.path "core::marker::PhantomData") [V]) :=
        ltac:(M.get_method (fun ‚Ñê =>
          core.default.Default.default
            (Self := Ty.apply (Ty.path "core::marker::PhantomData") [V])
            (Trait := ‚Ñê))) in
      let* Œ±3 : Ty.apply (Ty.path "core::marker::PhantomData") [V] :=
        M.call Œ±2 in
      M.pure {| multisig.Mapping._key := Œ±1; multisig.Mapping._value := Œ±3; |}
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_default : Instance.t := {
    Notations.double_colon := default;
  }.
  
  Definition ‚Ñê : Instance.t := [("default", default)].
End Impl_core_default_Default_for_multisig_Mapping_K_V.
End Impl_core_default_Default_for_multisig_Mapping_K_V.

Module  Impl_multisig_Mapping_K_V.
Section Impl_multisig_Mapping_K_V.
  Context {K V : Set}.
  
  Definition Self : Set := Ty.apply (Ty.path "multisig::Mapping") [K; V].
  
  (*
      fn contains(&self, _key: &K) -> bool {
          unimplemented!()
      }
  *)
  Definition contains (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self; _key] =>
      let* self := M.alloc self in
      let* _key := M.alloc _key in
      let* Œ±0 : Ty.apply (Ty.path "ref") [Ty.path "str"] :=
        M.read (mk_str "not implemented") in
      let* Œ±1 : Ty.path "never" := M.call (core.panicking.panic Œ±0) in
      never_to_any Œ±1
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_contains : Instance.t := {
    Notations.double_colon := contains;
  }.
  
  (*
      fn get(&self, _key: &K) -> Option<V> {
          unimplemented!()
      }
  *)
  Definition get (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self; _key] =>
      let* self := M.alloc self in
      let* _key := M.alloc _key in
      let* Œ±0 : Ty.apply (Ty.path "ref") [Ty.path "str"] :=
        M.read (mk_str "not implemented") in
      let* Œ±1 : Ty.path "never" := M.call (core.panicking.panic Œ±0) in
      never_to_any Œ±1
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_get : Instance.t := {
    Notations.double_colon := get;
  }.
  
  (*
      fn insert(&mut self, _key: K, _value: V) -> Option<u32> {
          unimplemented!()
      }
  *)
  Definition insert (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self; _key; _value] =>
      let* self := M.alloc self in
      let* _key := M.alloc _key in
      let* _value := M.alloc _value in
      let* Œ±0 : Ty.apply (Ty.path "ref") [Ty.path "str"] :=
        M.read (mk_str "not implemented") in
      let* Œ±1 : Ty.path "never" := M.call (core.panicking.panic Œ±0) in
      never_to_any Œ±1
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_insert : Instance.t := {
    Notations.double_colon := insert;
  }.
  
  (*
      fn remove(&self, _key: K) {
          unimplemented!()
      }
  *)
  Definition remove (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self; _key] =>
      let* self := M.alloc self in
      let* _key := M.alloc _key in
      let* Œ±0 : Ty.apply (Ty.path "ref") [Ty.path "str"] :=
        M.read (mk_str "not implemented") in
      let* Œ±1 : Ty.path "never" := M.call (core.panicking.panic Œ±0) in
      never_to_any Œ±1
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_remove : Instance.t := {
    Notations.double_colon := remove;
  }.
  
  (*
      fn size(&self, _key: K) -> Option<u32> {
          unimplemented!()
      }
  *)
  Definition size (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self; _key] =>
      let* self := M.alloc self in
      let* _key := M.alloc _key in
      let* Œ±0 : Ty.apply (Ty.path "ref") [Ty.path "str"] :=
        M.read (mk_str "not implemented") in
      let* Œ±1 : Ty.path "never" := M.call (core.panicking.panic Œ±0) in
      never_to_any Œ±1
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_size : Instance.t := {
    Notations.double_colon := size;
  }.
  
  (*
      fn take(&self, _key: K) -> Option<V> {
          unimplemented!()
      }
  *)
  Definition take (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self; _key] =>
      let* self := M.alloc self in
      let* _key := M.alloc _key in
      let* Œ±0 : Ty.apply (Ty.path "ref") [Ty.path "str"] :=
        M.read (mk_str "not implemented") in
      let* Œ±1 : Ty.path "never" := M.call (core.panicking.panic Œ±0) in
      never_to_any Œ±1
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_take : Instance.t := {
    Notations.double_colon := take;
  }.
End Impl_multisig_Mapping_K_V.
End Impl_multisig_Mapping_K_V.



Module  Impl_core_default_Default_for_multisig_AccountId.
Section Impl_core_default_Default_for_multisig_AccountId.
  Definition Self : Ty.t := Ty.apply (Ty.path "multisig::AccountId") [].
  
  (*
  Default
  *)
  Definition default (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [] =>
      let* Œ±0 : Ty.function [] (Ty.path "u128") :=
        ltac:(M.get_method (fun ‚Ñê =>
          core.default.Default.default
            (Self := Ty.path "u128")
            (Trait := ‚Ñê))) in
      let* Œ±1 : Ty.path "u128" := M.call Œ±0 in
      M.pure (multisig.AccountId.Build_t Œ±1)
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_default : Instance.t := {
    Notations.double_colon := default;
  }.
  
  Definition ‚Ñê : Instance.t := [("default", default)].
End Impl_core_default_Default_for_multisig_AccountId.
End Impl_core_default_Default_for_multisig_AccountId.

Module  Impl_core_fmt_Debug_for_multisig_AccountId.
Section Impl_core_fmt_Debug_for_multisig_AccountId.
  Definition Self : Ty.t := Ty.apply (Ty.path "multisig::AccountId") [].
  
  (*
  Debug
  *)
  Definition fmt (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self; f] =>
      let* self := M.alloc self in
      let* f := M.alloc f in
      let* Œ±0 :
          Ty.apply
            (Ty.path "mut_ref")
            [Ty.apply (Ty.path "core::fmt::Formatter") []] :=
        M.read f in
      let* Œ±1 : Ty.apply (Ty.path "ref") [Ty.path "str"] :=
        M.read (mk_str "AccountId") in
      let* Œ±2 :
          Ty.apply
            (Ty.path "ref")
            [Ty.apply (Ty.path "multisig::AccountId") []] :=
        M.read self in
      let* Œ±3 : Ty.apply (Ty.path "ref") [Ty.path "u128"] :=
        M.alloc (borrow (multisig.AccountId.Get_0 (deref Œ±2))) in
      M.call
        ((Ty.apply
              (Ty.path "core::fmt::Formatter")
              [])::["debug_tuple_field1_finish"]
          Œ±0
          Œ±1
          (pointer_coercion "Unsize" (borrow Œ±3)))
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_fmt : Instance.t := {
    Notations.double_colon := fmt;
  }.
  
  Definition ‚Ñê : Instance.t := [("fmt", fmt)].
End Impl_core_fmt_Debug_for_multisig_AccountId.
End Impl_core_fmt_Debug_for_multisig_AccountId.

Module  Impl_core_clone_Clone_for_multisig_AccountId.
Section Impl_core_clone_Clone_for_multisig_AccountId.
  Definition Self : Ty.t := Ty.apply (Ty.path "multisig::AccountId") [].
  
  (*
  Clone
  *)
  Definition clone (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self] =>
      let* self := M.alloc self in
      let* Œ±0 : Ty.apply (Ty.path "multisig::AccountId") [] :=
        match_operator
          (DeclaredButUndefinedVariable
            (A :=
              Ty.apply
                (Ty.path "core::clone::AssertParamIsClone")
                [Ty.path "u128"]))
          [
            fun Œ≥ =>
              (let* Œ±0 :
                  Ty.apply
                    (Ty.path "ref")
                    [Ty.apply (Ty.path "multisig::AccountId") []] :=
                M.read self in
              M.pure (deref Œ±0)) :
              Ty.apply (Ty.path "multisig::AccountId") []
          ] in
      M.read Œ±0
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_clone : Instance.t := {
    Notations.double_colon := clone;
  }.
  
  Definition ‚Ñê : Instance.t := [("clone", clone); ("clone_from", clone_from)].
End Impl_core_clone_Clone_for_multisig_AccountId.
End Impl_core_clone_Clone_for_multisig_AccountId.

Module  Impl_core_marker_Copy_for_multisig_AccountId.
Section Impl_core_marker_Copy_for_multisig_AccountId.
  Definition Self : Ty.t := Ty.apply (Ty.path "multisig::AccountId") [].
  
  Definition ‚Ñê : Instance.t := [].
End Impl_core_marker_Copy_for_multisig_AccountId.
End Impl_core_marker_Copy_for_multisig_AccountId.

Module  Impl_core_marker_StructuralPartialEq_for_multisig_AccountId.
Section Impl_core_marker_StructuralPartialEq_for_multisig_AccountId.
  Definition Self : Ty.t := Ty.apply (Ty.path "multisig::AccountId") [].
  
  Definition ‚Ñê : Instance.t := [].
End Impl_core_marker_StructuralPartialEq_for_multisig_AccountId.
End Impl_core_marker_StructuralPartialEq_for_multisig_AccountId.

Module  Impl_core_cmp_PartialEq_for_multisig_AccountId.
Section Impl_core_cmp_PartialEq_for_multisig_AccountId.
  Definition Self : Ty.t := Ty.apply (Ty.path "multisig::AccountId") [].
  
  (*
  PartialEq
  *)
  Definition eq (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self; other] =>
      let* self := M.alloc self in
      let* other := M.alloc other in
      let* Œ±0 :
          Ty.apply
            (Ty.path "ref")
            [Ty.apply (Ty.path "multisig::AccountId") []] :=
        M.read self in
      let* Œ±1 : Ty.path "u128" :=
        M.read (multisig.AccountId.Get_0 (deref Œ±0)) in
      let* Œ±2 :
          Ty.apply
            (Ty.path "ref")
            [Ty.apply (Ty.path "multisig::AccountId") []] :=
        M.read other in
      let* Œ±3 : Ty.path "u128" :=
        M.read (multisig.AccountId.Get_0 (deref Œ±2)) in
      M.pure (BinOp.Pure.eq Œ±1 Œ±3)
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_eq : Instance.t := {
    Notations.double_colon := eq;
  }.
  
  Definition ‚Ñê : Instance.t := [("eq", eq); ("ne", ne)].
End Impl_core_cmp_PartialEq_for_multisig_AccountId.
End Impl_core_cmp_PartialEq_for_multisig_AccountId.

Module  Impl_core_marker_StructuralEq_for_multisig_AccountId.
Section Impl_core_marker_StructuralEq_for_multisig_AccountId.
  Definition Self : Ty.t := Ty.apply (Ty.path "multisig::AccountId") [].
  
  Definition ‚Ñê : Instance.t := [].
End Impl_core_marker_StructuralEq_for_multisig_AccountId.
End Impl_core_marker_StructuralEq_for_multisig_AccountId.

Module  Impl_core_cmp_Eq_for_multisig_AccountId.
Section Impl_core_cmp_Eq_for_multisig_AccountId.
  Definition Self : Ty.t := Ty.apply (Ty.path "multisig::AccountId") [].
  
  (*
  Eq
  *)
  Definition assert_receiver_is_total_eq
      (ùúè : list Ty.t)
      (Œ± : list Value.t)
      : M :=
    match ùúè, Œ± with
    | [], [self] =>
      let* self := M.alloc self in
      let* Œ±0 : Ty.tuple :=
        match_operator
          (DeclaredButUndefinedVariable
            (A :=
              Ty.apply (Ty.path "core::cmp::AssertParamIsEq") [Ty.path "u128"]))
          [ fun Œ≥ => (M.alloc tt) : Ty.path "unit" ] in
      M.read Œ±0
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_assert_receiver_is_total_eq : Instance.t := {
    Notations.double_colon := assert_receiver_is_total_eq;
  }.
  
  Definition ‚Ñê : Instance.t := [("assert_receiver_is_total_eq",
      assert_receiver_is_total_eq)].
End Impl_core_cmp_Eq_for_multisig_AccountId.
End Impl_core_cmp_Eq_for_multisig_AccountId.

Module  Impl_core_cmp_PartialOrd_for_multisig_AccountId.
Section Impl_core_cmp_PartialOrd_for_multisig_AccountId.
  Definition Self : Ty.t := Ty.apply (Ty.path "multisig::AccountId") [].
  
  (*
  PartialOrd
  *)
  Definition partial_cmp (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self; other] =>
      let* self := M.alloc self in
      let* other := M.alloc other in
      let* Œ±0 :
          Ty.function
            [Ty.apply (Ty.path "ref") [Ty.path "u128"];
              Ty.apply (Ty.path "ref") [Ty.path "u128"]]
            (Ty.apply
              (Ty.path "core::option::Option")
              [Ty.apply (Ty.path "core::cmp::Ordering") []]) :=
        ltac:(M.get_method (fun ‚Ñê =>
          core.cmp.PartialOrd.partial_cmp
            (Self := Ty.path "u128")
            (Rhs := Ty.path "u128")
            (Trait := ‚Ñê))) in
      let* Œ±1 :
          Ty.apply
            (Ty.path "ref")
            [Ty.apply (Ty.path "multisig::AccountId") []] :=
        M.read self in
      let* Œ±2 :
          Ty.apply
            (Ty.path "ref")
            [Ty.apply (Ty.path "multisig::AccountId") []] :=
        M.read other in
      M.call
        (Œ±0
          (borrow (multisig.AccountId.Get_0 (deref Œ±1)))
          (borrow (multisig.AccountId.Get_0 (deref Œ±2))))
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_partial_cmp : Instance.t := {
    Notations.double_colon := partial_cmp;
  }.
  
  Definition ‚Ñê : Instance.t := [("partial_cmp", partial_cmp);
    ("lt", lt);
    ("le", le);
    ("gt", gt);
    ("ge", ge)].
End Impl_core_cmp_PartialOrd_for_multisig_AccountId.
End Impl_core_cmp_PartialOrd_for_multisig_AccountId.

Module  Impl_core_cmp_Ord_for_multisig_AccountId.
Section Impl_core_cmp_Ord_for_multisig_AccountId.
  Definition Self : Ty.t := Ty.apply (Ty.path "multisig::AccountId") [].
  
  (*
  Ord
  *)
  Definition cmp (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self; other] =>
      let* self := M.alloc self in
      let* other := M.alloc other in
      let* Œ±0 :
          Ty.function
            [Ty.apply (Ty.path "ref") [Ty.path "u128"];
              Ty.apply (Ty.path "ref") [Ty.path "u128"]]
            (Ty.apply (Ty.path "core::cmp::Ordering") []) :=
        ltac:(M.get_method (fun ‚Ñê =>
          core.cmp.Ord.cmp (Self := Ty.path "u128") (Trait := ‚Ñê))) in
      let* Œ±1 :
          Ty.apply
            (Ty.path "ref")
            [Ty.apply (Ty.path "multisig::AccountId") []] :=
        M.read self in
      let* Œ±2 :
          Ty.apply
            (Ty.path "ref")
            [Ty.apply (Ty.path "multisig::AccountId") []] :=
        M.read other in
      M.call
        (Œ±0
          (borrow (multisig.AccountId.Get_0 (deref Œ±1)))
          (borrow (multisig.AccountId.Get_0 (deref Œ±2))))
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_cmp : Instance.t := {
    Notations.double_colon := cmp;
  }.
  
  Definition ‚Ñê : Instance.t := [("cmp", cmp);
    ("max", max);
    ("min", min);
    ("clamp", clamp)].
End Impl_core_cmp_Ord_for_multisig_AccountId.
End Impl_core_cmp_Ord_for_multisig_AccountId.

Axiom Balance : Ty.path "u128".



Definition MAX_OWNERS : Ty.path "u32" :=
  M.run (M.alloc ((Integer.of_Z 50) : Ty.path "u32")).

Axiom TransactionId : Ty.path "u32".

Definition WRONG_TRANSACTION_ID : Ty.apply (Ty.path "ref") [Ty.path "str"] :=
  M.run
    (M.pure (mk_str "The user specified an invalid transaction id. Abort.")).





Module  Impl_core_clone_Clone_for_multisig_ConfirmationStatus.
Section Impl_core_clone_Clone_for_multisig_ConfirmationStatus.
  Definition Self : Ty.t :=
    Ty.apply (Ty.path "multisig::ConfirmationStatus") [].
  
  (*
  Clone
  *)
  Definition clone (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self] =>
      let* self := M.alloc self in
      let* Œ±0 : Ty.apply (Ty.path "multisig::ConfirmationStatus") [] :=
        match_operator
          (DeclaredButUndefinedVariable
            (A :=
              Ty.apply
                (Ty.path "core::clone::AssertParamIsClone")
                [Ty.path "u32"]))
          [
            fun Œ≥ =>
              (let* Œ±0 :
                  Ty.apply
                    (Ty.path "ref")
                    [Ty.apply (Ty.path "multisig::ConfirmationStatus") []] :=
                M.read self in
              M.pure (deref Œ±0)) :
              Ty.apply (Ty.path "multisig::ConfirmationStatus") []
          ] in
      M.read Œ±0
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_clone : Instance.t := {
    Notations.double_colon := clone;
  }.
  
  Definition ‚Ñê : Instance.t := [("clone", clone); ("clone_from", clone_from)].
End Impl_core_clone_Clone_for_multisig_ConfirmationStatus.
End Impl_core_clone_Clone_for_multisig_ConfirmationStatus.

Module  Impl_core_marker_Copy_for_multisig_ConfirmationStatus.
Section Impl_core_marker_Copy_for_multisig_ConfirmationStatus.
  Definition Self : Ty.t :=
    Ty.apply (Ty.path "multisig::ConfirmationStatus") [].
  
  Definition ‚Ñê : Instance.t := [].
End Impl_core_marker_Copy_for_multisig_ConfirmationStatus.
End Impl_core_marker_Copy_for_multisig_ConfirmationStatus.



Module  Impl_core_default_Default_for_multisig_Transaction.
Section Impl_core_default_Default_for_multisig_Transaction.
  Definition Self : Ty.t := Ty.apply (Ty.path "multisig::Transaction") [].
  
  (*
  Default
  *)
  Definition default (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [] =>
      let* Œ±0 : Ty.function [] (Ty.apply (Ty.path "multisig::AccountId") []) :=
        ltac:(M.get_method (fun ‚Ñê =>
          core.default.Default.default
            (Self := Ty.apply (Ty.path "multisig::AccountId") [])
            (Trait := ‚Ñê))) in
      let* Œ±1 : Ty.apply (Ty.path "multisig::AccountId") [] := M.call Œ±0 in
      let* Œ±2 : Ty.function [] (Ty.apply (Ty.path "array") [Ty.path "u8"]) :=
        ltac:(M.get_method (fun ‚Ñê =>
          core.default.Default.default
            (Self := Ty.apply (Ty.path "array") [Ty.path "u8"])
            (Trait := ‚Ñê))) in
      let* Œ±3 : Ty.apply (Ty.path "array") [Ty.path "u8"] := M.call Œ±2 in
      let* Œ±4 :
          Ty.function
            []
            (Ty.apply
              (Ty.path "alloc::vec::Vec")
              [Ty.path "u8"; Ty.apply (Ty.path "alloc::alloc::Global") []]) :=
        ltac:(M.get_method (fun ‚Ñê =>
          core.default.Default.default
            (Self :=
              Ty.apply
                (Ty.path "alloc::vec::Vec")
                [Ty.path "u8"; Ty.apply (Ty.path "alloc::alloc::Global") []])
            (Trait := ‚Ñê))) in
      let* Œ±5 :
          Ty.apply
            (Ty.path "alloc::vec::Vec")
            [Ty.path "u8"; Ty.apply (Ty.path "alloc::alloc::Global") []] :=
        M.call Œ±4 in
      let* Œ±6 : Ty.function [] (Ty.path "u128") :=
        ltac:(M.get_method (fun ‚Ñê =>
          core.default.Default.default
            (Self := Ty.path "u128")
            (Trait := ‚Ñê))) in
      let* Œ±7 : Ty.path "u128" := M.call Œ±6 in
      let* Œ±8 : Ty.function [] (Ty.path "u64") :=
        ltac:(M.get_method (fun ‚Ñê =>
          core.default.Default.default (Self := Ty.path "u64") (Trait := ‚Ñê))) in
      let* Œ±9 : Ty.path "u64" := M.call Œ±8 in
      let* Œ±10 : Ty.function [] (Ty.path "bool") :=
        ltac:(M.get_method (fun ‚Ñê =>
          core.default.Default.default
            (Self := Ty.path "bool")
            (Trait := ‚Ñê))) in
      let* Œ±11 : Ty.path "bool" := M.call Œ±10 in
      M.pure
        {|
          multisig.Transaction.callee := Œ±1;
          multisig.Transaction.selector := Œ±3;
          multisig.Transaction.input := Œ±5;
          multisig.Transaction.transferred_value := Œ±7;
          multisig.Transaction.gas_limit := Œ±9;
          multisig.Transaction.allow_reentry := Œ±11;
        |}
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_default : Instance.t := {
    Notations.double_colon := default;
  }.
  
  Definition ‚Ñê : Instance.t := [("default", default)].
End Impl_core_default_Default_for_multisig_Transaction.
End Impl_core_default_Default_for_multisig_Transaction.



Module  Impl_core_clone_Clone_for_multisig_Error.
Section Impl_core_clone_Clone_for_multisig_Error.
  Definition Self : Ty.t := Ty.apply (Ty.path "multisig::Error") [].
  
  (*
  Clone
  *)
  Definition clone (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self] =>
      let* self := M.alloc self in
      let* Œ±0 :
          Ty.apply (Ty.path "ref") [Ty.apply (Ty.path "multisig::Error") []] :=
        M.read self in
      M.read (deref Œ±0)
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_clone : Instance.t := {
    Notations.double_colon := clone;
  }.
  
  Definition ‚Ñê : Instance.t := [("clone", clone); ("clone_from", clone_from)].
End Impl_core_clone_Clone_for_multisig_Error.
End Impl_core_clone_Clone_for_multisig_Error.

Module  Impl_core_marker_Copy_for_multisig_Error.
Section Impl_core_marker_Copy_for_multisig_Error.
  Definition Self : Ty.t := Ty.apply (Ty.path "multisig::Error") [].
  
  Definition ‚Ñê : Instance.t := [].
End Impl_core_marker_Copy_for_multisig_Error.
End Impl_core_marker_Copy_for_multisig_Error.

Module  Impl_core_marker_StructuralPartialEq_for_multisig_Error.
Section Impl_core_marker_StructuralPartialEq_for_multisig_Error.
  Definition Self : Ty.t := Ty.apply (Ty.path "multisig::Error") [].
  
  Definition ‚Ñê : Instance.t := [].
End Impl_core_marker_StructuralPartialEq_for_multisig_Error.
End Impl_core_marker_StructuralPartialEq_for_multisig_Error.

Module  Impl_core_cmp_PartialEq_for_multisig_Error.
Section Impl_core_cmp_PartialEq_for_multisig_Error.
  Definition Self : Ty.t := Ty.apply (Ty.path "multisig::Error") [].
  
  (*
  PartialEq
  *)
  Definition eq (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self; other] =>
      let* self := M.alloc self in
      let* other := M.alloc other in
      M.pure true
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_eq : Instance.t := {
    Notations.double_colon := eq;
  }.
  
  Definition ‚Ñê : Instance.t := [("eq", eq); ("ne", ne)].
End Impl_core_cmp_PartialEq_for_multisig_Error.
End Impl_core_cmp_PartialEq_for_multisig_Error.

Module  Impl_core_marker_StructuralEq_for_multisig_Error.
Section Impl_core_marker_StructuralEq_for_multisig_Error.
  Definition Self : Ty.t := Ty.apply (Ty.path "multisig::Error") [].
  
  Definition ‚Ñê : Instance.t := [].
End Impl_core_marker_StructuralEq_for_multisig_Error.
End Impl_core_marker_StructuralEq_for_multisig_Error.

Module  Impl_core_cmp_Eq_for_multisig_Error.
Section Impl_core_cmp_Eq_for_multisig_Error.
  Definition Self : Ty.t := Ty.apply (Ty.path "multisig::Error") [].
  
  (*
  Eq
  *)
  Definition assert_receiver_is_total_eq
      (ùúè : list Ty.t)
      (Œ± : list Value.t)
      : M :=
    match ùúè, Œ± with
    | [], [self] =>
      let* self := M.alloc self in
      M.pure tt
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_assert_receiver_is_total_eq : Instance.t := {
    Notations.double_colon := assert_receiver_is_total_eq;
  }.
  
  Definition ‚Ñê : Instance.t := [("assert_receiver_is_total_eq",
      assert_receiver_is_total_eq)].
End Impl_core_cmp_Eq_for_multisig_Error.
End Impl_core_cmp_Eq_for_multisig_Error.



Module  Impl_core_default_Default_for_multisig_Transactions.
Section Impl_core_default_Default_for_multisig_Transactions.
  Definition Self : Ty.t := Ty.apply (Ty.path "multisig::Transactions") [].
  
  (*
  Default
  *)
  Definition default (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [] =>
      let* Œ±0 :
          Ty.function
            []
            (Ty.apply
              (Ty.path "alloc::vec::Vec")
              [Ty.path "u32"; Ty.apply (Ty.path "alloc::alloc::Global") []]) :=
        ltac:(M.get_method (fun ‚Ñê =>
          core.default.Default.default
            (Self :=
              Ty.apply
                (Ty.path "alloc::vec::Vec")
                [Ty.path "u32"; Ty.apply (Ty.path "alloc::alloc::Global") []])
            (Trait := ‚Ñê))) in
      let* Œ±1 :
          Ty.apply
            (Ty.path "alloc::vec::Vec")
            [Ty.path "u32"; Ty.apply (Ty.path "alloc::alloc::Global") []] :=
        M.call Œ±0 in
      let* Œ±2 : Ty.function [] (Ty.path "u32") :=
        ltac:(M.get_method (fun ‚Ñê =>
          core.default.Default.default (Self := Ty.path "u32") (Trait := ‚Ñê))) in
      let* Œ±3 : Ty.path "u32" := M.call Œ±2 in
      M.pure
        {|
          multisig.Transactions.transactions := Œ±1;
          multisig.Transactions.next_id := Œ±3;
        |}
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_default : Instance.t := {
    Notations.double_colon := default;
  }.
  
  Definition ‚Ñê : Instance.t := [("default", default)].
End Impl_core_default_Default_for_multisig_Transactions.
End Impl_core_default_Default_for_multisig_Transactions.



















Module  Impl_multisig_Env.
Section Impl_multisig_Env.
  Definition Self : Set := Ty.apply (Ty.path "multisig::Env") [].
  
  (*
      fn caller(&self) -> AccountId {
          self.caller
      }
  *)
  Definition caller (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self] =>
      let* self := M.alloc self in
      let* Œ±0 :
          Ty.apply (Ty.path "ref") [Ty.apply (Ty.path "multisig::Env") []] :=
        M.read self in
      M.read (multisig.Env.Get_caller (deref Œ±0))
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_caller : Instance.t := {
    Notations.double_colon := caller;
  }.
  
  (*
      fn emit_event(&self, _event: Event) {
          unimplemented!()
      }
  *)
  Definition emit_event (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self; _event] =>
      let* self := M.alloc self in
      let* _event := M.alloc _event in
      let* Œ±0 : Ty.apply (Ty.path "ref") [Ty.path "str"] :=
        M.read (mk_str "not implemented") in
      let* Œ±1 : Ty.path "never" := M.call (core.panicking.panic Œ±0) in
      never_to_any Œ±1
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_emit_event : Instance.t := {
    Notations.double_colon := emit_event;
  }.
  
  (*
      fn transferred_value(&self) -> Balance {
          unimplemented!()
      }
  *)
  Definition transferred_value (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self] =>
      let* self := M.alloc self in
      let* Œ±0 : Ty.apply (Ty.path "ref") [Ty.path "str"] :=
        M.read (mk_str "not implemented") in
      let* Œ±1 : Ty.path "never" := M.call (core.panicking.panic Œ±0) in
      never_to_any Œ±1
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_transferred_value : Instance.t := {
    Notations.double_colon := transferred_value;
  }.
  
  (*
      fn account_id(&self) -> AccountId {
          unimplemented!()
      }
  *)
  Definition account_id (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self] =>
      let* self := M.alloc self in
      let* Œ±0 : Ty.apply (Ty.path "ref") [Ty.path "str"] :=
        M.read (mk_str "not implemented") in
      let* Œ±1 : Ty.path "never" := M.call (core.panicking.panic Œ±0) in
      never_to_any Œ±1
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_account_id : Instance.t := {
    Notations.double_colon := account_id;
  }.
End Impl_multisig_Env.
End Impl_multisig_Env.



Module  Impl_core_default_Default_for_multisig_Multisig.
Section Impl_core_default_Default_for_multisig_Multisig.
  Definition Self : Ty.t := Ty.apply (Ty.path "multisig::Multisig") [].
  
  (*
  Default
  *)
  Definition default (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [] =>
      let* Œ±0 :
          Ty.function
            []
            (Ty.apply
              (Ty.path "multisig::Mapping")
              [Ty.tuple
                  (Ty.path "u32")
                  (Ty.apply (Ty.path "multisig::AccountId") []);
                Ty.tuple]) :=
        ltac:(M.get_method (fun ‚Ñê =>
          core.default.Default.default
            (Self :=
              Ty.apply
                (Ty.path "multisig::Mapping")
                [Ty.tuple
                    (Ty.path "u32")
                    (Ty.apply (Ty.path "multisig::AccountId") []);
                  Ty.tuple])
            (Trait := ‚Ñê))) in
      let* Œ±1 :
          Ty.apply
            (Ty.path "multisig::Mapping")
            [Ty.tuple
                (Ty.path "u32")
                (Ty.apply (Ty.path "multisig::AccountId") []);
              Ty.tuple] :=
        M.call Œ±0 in
      let* Œ±2 :
          Ty.function
            []
            (Ty.apply
              (Ty.path "multisig::Mapping")
              [Ty.path "u32"; Ty.path "u32"]) :=
        ltac:(M.get_method (fun ‚Ñê =>
          core.default.Default.default
            (Self :=
              Ty.apply
                (Ty.path "multisig::Mapping")
                [Ty.path "u32"; Ty.path "u32"])
            (Trait := ‚Ñê))) in
      let* Œ±3 :
          Ty.apply
            (Ty.path "multisig::Mapping")
            [Ty.path "u32"; Ty.path "u32"] :=
        M.call Œ±2 in
      let* Œ±4 :
          Ty.function
            []
            (Ty.apply
              (Ty.path "multisig::Mapping")
              [Ty.path "u32"; Ty.apply (Ty.path "multisig::Transaction") []]) :=
        ltac:(M.get_method (fun ‚Ñê =>
          core.default.Default.default
            (Self :=
              Ty.apply
                (Ty.path "multisig::Mapping")
                [Ty.path "u32"; Ty.apply (Ty.path "multisig::Transaction") []])
            (Trait := ‚Ñê))) in
      let* Œ±5 :
          Ty.apply
            (Ty.path "multisig::Mapping")
            [Ty.path "u32"; Ty.apply (Ty.path "multisig::Transaction") []] :=
        M.call Œ±4 in
      let* Œ±6 :
          Ty.function [] (Ty.apply (Ty.path "multisig::Transactions") []) :=
        ltac:(M.get_method (fun ‚Ñê =>
          core.default.Default.default
            (Self := Ty.apply (Ty.path "multisig::Transactions") [])
            (Trait := ‚Ñê))) in
      let* Œ±7 : Ty.apply (Ty.path "multisig::Transactions") [] := M.call Œ±6 in
      let* Œ±8 :
          Ty.function
            []
            (Ty.apply
              (Ty.path "alloc::vec::Vec")
              [Ty.apply (Ty.path "multisig::AccountId") [];
                Ty.apply (Ty.path "alloc::alloc::Global") []]) :=
        ltac:(M.get_method (fun ‚Ñê =>
          core.default.Default.default
            (Self :=
              Ty.apply
                (Ty.path "alloc::vec::Vec")
                [Ty.apply (Ty.path "multisig::AccountId") [];
                  Ty.apply (Ty.path "alloc::alloc::Global") []])
            (Trait := ‚Ñê))) in
      let* Œ±9 :
          Ty.apply
            (Ty.path "alloc::vec::Vec")
            [Ty.apply (Ty.path "multisig::AccountId") [];
              Ty.apply (Ty.path "alloc::alloc::Global") []] :=
        M.call Œ±8 in
      let* Œ±10 :
          Ty.function
            []
            (Ty.apply
              (Ty.path "multisig::Mapping")
              [Ty.apply (Ty.path "multisig::AccountId") []; Ty.tuple]) :=
        ltac:(M.get_method (fun ‚Ñê =>
          core.default.Default.default
            (Self :=
              Ty.apply
                (Ty.path "multisig::Mapping")
                [Ty.apply (Ty.path "multisig::AccountId") []; Ty.tuple])
            (Trait := ‚Ñê))) in
      let* Œ±11 :
          Ty.apply
            (Ty.path "multisig::Mapping")
            [Ty.apply (Ty.path "multisig::AccountId") []; Ty.tuple] :=
        M.call Œ±10 in
      let* Œ±12 : Ty.function [] (Ty.path "u32") :=
        ltac:(M.get_method (fun ‚Ñê =>
          core.default.Default.default (Self := Ty.path "u32") (Trait := ‚Ñê))) in
      let* Œ±13 : Ty.path "u32" := M.call Œ±12 in
      M.pure
        {|
          multisig.Multisig.confirmations := Œ±1;
          multisig.Multisig.confirmation_count := Œ±3;
          multisig.Multisig.transactions := Œ±5;
          multisig.Multisig.transaction_list := Œ±7;
          multisig.Multisig.owners := Œ±9;
          multisig.Multisig.is_owner := Œ±11;
          multisig.Multisig.requirement := Œ±13;
        |}
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_default : Instance.t := {
    Notations.double_colon := default;
  }.
  
  Definition ‚Ñê : Instance.t := [("default", default)].
End Impl_core_default_Default_for_multisig_Multisig.
End Impl_core_default_Default_for_multisig_Multisig.

(*
fn ensure_requirement_is_valid(owners: u32, requirement: u32) {
    assert!(0 < requirement && requirement <= owners && owners <= MAX_OWNERS);
}
*)
Definition ensure_requirement_is_valid (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
  match ùúè, Œ± with
  | [], [owners; requirement] =>
    let* owners := M.alloc owners in
    let* requirement := M.alloc requirement in
    let* _ : Ty.tuple :=
      let* Œ±0 : Ty.path "u32" := M.read requirement in
      let* Œ±1 : Ty.path "u32" := M.read requirement in
      let* Œ±2 : Ty.path "u32" := M.read owners in
      let* Œ±3 : Ty.path "u32" := M.read owners in
      let* Œ±4 : Ty.path "u32" := M.read multisig.MAX_OWNERS in
      let* Œ±5 : Ty.path "bool" :=
        M.alloc
          (UnOp.not
            (BinOp.Pure.and
              (BinOp.Pure.and
                (BinOp.Pure.lt ((Integer.of_Z 0) : Ty.path "u32") Œ±0)
                (BinOp.Pure.le Œ±1 Œ±2))
              (BinOp.Pure.le Œ±3 Œ±4))) in
      let* Œ±6 : Ty.path "bool" := M.read (use Œ±5) in
      if Œ±6 then
        let* Œ±0 : Ty.apply (Ty.path "ref") [Ty.path "str"] :=
          M.read
            (mk_str
              "assertion failed: 0 < requirement && requirement <= owners && owners <= MAX_OWNERS") in
        let* Œ±1 : Ty.path "never" := M.call (core.panicking.panic Œ±0) in
        let* Œ±2 : Ty.tuple := never_to_any Œ±1 in
        M.alloc Œ±2
      else
        M.alloc tt in
    let* Œ±0 : Ty.path "unit" := M.alloc tt in
    M.read Œ±0
  | _, _ => M.impossible
  end.

Module  Impl_multisig_Multisig.
Section Impl_multisig_Multisig.
  Definition Self : Set := Ty.apply (Ty.path "multisig::Multisig") [].
  
  (*
      fn init_env() -> Env {
          unimplemented!()
      }
  *)
  Definition init_env (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [] =>
      let* Œ±0 : Ty.apply (Ty.path "ref") [Ty.path "str"] :=
        M.read (mk_str "not implemented") in
      let* Œ±1 : Ty.path "never" := M.call (core.panicking.panic Œ±0) in
      never_to_any Œ±1
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_init_env : Instance.t := {
    Notations.double_colon := init_env;
  }.
  
  (*
      fn env(&self) -> Env {
          Self::init_env()
      }
  *)
  Definition env (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self] =>
      let* self := M.alloc self in
      M.call (Ty.apply (Ty.path "multisig::Multisig") [])::["init_env"]
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_env : Instance.t := {
    Notations.double_colon := env;
  }.
  
  (*
      pub fn new(requirement: u32, mut owners: Vec<AccountId>) -> Self {
          let mut contract = Multisig::default();
          owners.sort_unstable();
          owners.dedup();
          ensure_requirement_is_valid(owners.len() as u32, requirement);
  
          for owner in &owners {
              contract.is_owner.insert( *owner, ());
          }
  
          contract.owners = owners;
          contract.transaction_list = Default::default();
          contract.requirement = requirement;
          contract
      }
  *)
  Definition new (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [requirement; owners] =>
      let* requirement := M.alloc requirement in
      let* owners := M.alloc owners in
      let* contract : Ty.apply (Ty.path "multisig::Multisig") [] :=
        let* Œ±0 : Ty.function [] (Ty.apply (Ty.path "multisig::Multisig") []) :=
          ltac:(M.get_method (fun ‚Ñê =>
            core.default.Default.default
              (Self := Ty.apply (Ty.path "multisig::Multisig") [])
              (Trait := ‚Ñê))) in
        let* Œ±1 : Ty.apply (Ty.path "multisig::Multisig") [] := M.call Œ±0 in
        M.alloc Œ±1 in
      let* _ : Ty.tuple :=
        let* Œ±0 :
            Ty.function
              [Ty.apply
                  (Ty.path "mut_ref")
                  [Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      [Ty.apply (Ty.path "multisig::AccountId") [];
                        Ty.apply (Ty.path "alloc::alloc::Global") []]]]
              (Ty.apply (Ty.path "mut_ref") [_]) :=
          ltac:(M.get_method (fun ‚Ñê =>
            core.ops.deref.DerefMut.deref_mut
              (Self :=
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  [Ty.apply (Ty.path "multisig::AccountId") [];
                    Ty.apply (Ty.path "alloc::alloc::Global") []])
              (Trait := ‚Ñê))) in
        let* Œ±1 :
            Ty.apply
              (Ty.path "mut_ref")
              [Ty.apply
                  (Ty.path "slice")
                  [Ty.apply (Ty.path "multisig::AccountId") []]] :=
          M.call (Œ±0 (borrow_mut owners)) in
        let* Œ±2 : Ty.tuple :=
          M.call
            ((Ty.apply
                  (Ty.path "slice")
                  [Ty.apply
                      (Ty.path "multisig::AccountId")
                      []])::["sort_unstable"]
              Œ±1) in
        M.alloc Œ±2 in
      let* _ : Ty.tuple :=
        let* Œ±0 : Ty.tuple :=
          M.call
            ((Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  [Ty.apply (Ty.path "multisig::AccountId") [];
                    Ty.apply (Ty.path "alloc::alloc::Global") []])::["dedup"]
              (borrow_mut owners)) in
        M.alloc Œ±0 in
      let* _ : Ty.tuple :=
        let* Œ±0 : Ty.path "usize" :=
          M.call
            ((Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  [Ty.apply (Ty.path "multisig::AccountId") [];
                    Ty.apply (Ty.path "alloc::alloc::Global") []])::["len"]
              (borrow owners)) in
        let* Œ±1 : Ty.path "u32" := M.read requirement in
        let* Œ±2 : Ty.tuple :=
          M.call (multisig.ensure_requirement_is_valid (rust_cast Œ±0) Œ±1) in
        M.alloc Œ±2 in
      let* _ : Ty.tuple :=
        let* Œ±0 :
            Ty.function
              [Ty.apply
                  (Ty.path "ref")
                  [Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      [Ty.apply (Ty.path "multisig::AccountId") [];
                        Ty.apply (Ty.path "alloc::alloc::Global") []]]]
              _ :=
          ltac:(M.get_method (fun ‚Ñê =>
            core.iter.traits.collect.IntoIterator.into_iter
              (Self :=
                Ty.apply
                  (Ty.path "ref")
                  [Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      [Ty.apply (Ty.path "multisig::AccountId") [];
                        Ty.apply (Ty.path "alloc::alloc::Global") []]])
              (Trait := ‚Ñê))) in
        let* Œ±1 :
            Ty.apply
              (Ty.path "core::slice::iter::Iter")
              [Ty.apply (Ty.path "multisig::AccountId") []] :=
          M.call (Œ±0 (borrow owners)) in
        let* Œ±2 :
            Ty.apply
              (Ty.path "core::slice::iter::Iter")
              [Ty.apply (Ty.path "multisig::AccountId") []] :=
          M.alloc Œ±1 in
        let* Œ±3 : Ty.tuple :=
          match_operator
            Œ±2
            [
              fun Œ≥ =>
                (let* iter := M.copy Œ≥ in
                M.loop
                  (let* _ : Ty.tuple :=
                    let* Œ±0 :
                        Ty.function
                          [Ty.apply
                              (Ty.path "mut_ref")
                              [Ty.apply
                                  (Ty.path "core::slice::iter::Iter")
                                  [Ty.apply
                                      (Ty.path "multisig::AccountId")
                                      []]]]
                          (Ty.apply (Ty.path "core::option::Option") [_]) :=
                      ltac:(M.get_method (fun ‚Ñê =>
                        core.iter.traits.iterator.Iterator.next
                          (Self :=
                            Ty.apply
                              (Ty.path "core::slice::iter::Iter")
                              [Ty.apply (Ty.path "multisig::AccountId") []])
                          (Trait := ‚Ñê))) in
                    let* Œ±1 :
                        Ty.apply
                          (Ty.path "core::option::Option")
                          [Ty.apply
                              (Ty.path "ref")
                              [Ty.apply (Ty.path "multisig::AccountId") []]] :=
                      M.call (Œ±0 (borrow_mut iter)) in
                    let* Œ±2 :
                        Ty.apply
                          (Ty.path "core::option::Option")
                          [Ty.apply
                              (Ty.path "ref")
                              [Ty.apply (Ty.path "multisig::AccountId") []]] :=
                      M.alloc Œ±1 in
                    match_operator
                      Œ±2
                      [
                        fun Œ≥ =>
                          (let* Œ±0 := M.read Œ≥ in
                          match Œ±0 with
                          | core.option.Option.None =>
                            let* Œ±0 : Ty.path "never" := M.break in
                            let* Œ±1 : Ty.path "never" := M.read Œ±0 in
                            let* Œ±2 : Ty.tuple := never_to_any Œ±1 in
                            M.alloc Œ±2
                          | _ => M.break_match
                          end) :
                          Ty.tuple;
                        fun Œ≥ =>
                          (let* Œ±0 := M.read Œ≥ in
                          match Œ±0 with
                          | core.option.Option.Some _ =>
                            let Œ≥0_0 := core.option.Option.Get_Some_0 Œ≥ in
                            let* owner := M.copy Œ≥0_0 in
                            let* _ :
                                Ty.apply
                                  (Ty.path "core::option::Option")
                                  [Ty.path "u32"] :=
                              let* Œ±0 :
                                  Ty.apply
                                    (Ty.path "ref")
                                    [Ty.apply
                                        (Ty.path "multisig::AccountId")
                                        []] :=
                                M.read owner in
                              let* Œ±1 :
                                  Ty.apply (Ty.path "multisig::AccountId") [] :=
                                M.read (deref Œ±0) in
                              let* Œ±2 :
                                  Ty.apply
                                    (Ty.path "core::option::Option")
                                    [Ty.path "u32"] :=
                                M.call
                                  ((Ty.apply
                                        (Ty.path "multisig::Mapping")
                                        [Ty.apply
                                            (Ty.path "multisig::AccountId")
                                            [];
                                          Ty.tuple])::["insert"]
                                    (borrow_mut
                                      (multisig.Multisig.Get_is_owner contract))
                                    Œ±1
                                    tt) in
                              M.alloc Œ±2 in
                            M.alloc tt
                          | _ => M.break_match
                          end) :
                          Ty.tuple
                      ] in
                  M.alloc tt)) :
                Ty.tuple
            ] in
        M.pure (use Œ±3) in
      let* _ : Ty.tuple :=
        let* Œ±0 :
            Ty.apply
              (Ty.path "alloc::vec::Vec")
              [Ty.apply (Ty.path "multisig::AccountId") [];
                Ty.apply (Ty.path "alloc::alloc::Global") []] :=
          M.read owners in
        assign (multisig.Multisig.Get_owners contract) Œ±0 in
      let* _ : Ty.tuple :=
        let* Œ±0 :
            Ty.function [] (Ty.apply (Ty.path "multisig::Transactions") []) :=
          ltac:(M.get_method (fun ‚Ñê =>
            core.default.Default.default
              (Self := Ty.apply (Ty.path "multisig::Transactions") [])
              (Trait := ‚Ñê))) in
        let* Œ±1 : Ty.apply (Ty.path "multisig::Transactions") [] := M.call Œ±0 in
        assign (multisig.Multisig.Get_transaction_list contract) Œ±1 in
      let* _ : Ty.tuple :=
        let* Œ±0 : Ty.path "u32" := M.read requirement in
        assign (multisig.Multisig.Get_requirement contract) Œ±0 in
      M.read contract
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_new : Instance.t := {
    Notations.double_colon := new;
  }.
  
  (*
      fn ensure_confirmed(&self, trans_id: TransactionId) {
          assert!(
              self.confirmation_count
                  .get(&trans_id)
                  .expect(WRONG_TRANSACTION_ID)
                  >= self.requirement
          );
      }
  *)
  Definition ensure_confirmed (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self; trans_id] =>
      let* self := M.alloc self in
      let* trans_id := M.alloc trans_id in
      let* _ : Ty.tuple :=
        let* Œ±0 :
            Ty.apply
              (Ty.path "ref")
              [Ty.apply (Ty.path "multisig::Multisig") []] :=
          M.read self in
        let* Œ±1 : Ty.apply (Ty.path "core::option::Option") [Ty.path "u32"] :=
          M.call
            ((Ty.apply
                  (Ty.path "multisig::Mapping")
                  [Ty.path "u32"; Ty.path "u32"])::["get"]
              (borrow (multisig.Multisig.Get_confirmation_count (deref Œ±0)))
              (borrow trans_id)) in
        let* Œ±2 : Ty.apply (Ty.path "ref") [Ty.path "str"] :=
          M.read multisig.WRONG_TRANSACTION_ID in
        let* Œ±3 : Ty.path "u32" :=
          M.call
            ((Ty.apply
                  (Ty.path "core::option::Option")
                  [Ty.path "u32"])::["expect"]
              Œ±1
              Œ±2) in
        let* Œ±4 :
            Ty.apply
              (Ty.path "ref")
              [Ty.apply (Ty.path "multisig::Multisig") []] :=
          M.read self in
        let* Œ±5 : Ty.path "u32" :=
          M.read (multisig.Multisig.Get_requirement (deref Œ±4)) in
        let* Œ±6 : Ty.path "bool" := M.alloc (UnOp.not (BinOp.Pure.ge Œ±3 Œ±5)) in
        let* Œ±7 : Ty.path "bool" := M.read (use Œ±6) in
        if Œ±7 then
          let* Œ±0 : Ty.apply (Ty.path "ref") [Ty.path "str"] :=
            M.read
              (mk_str
                "assertion failed: self.confirmation_count.get(&trans_id).expect(WRONG_TRANSACTION_ID) >=
    self.requirement") in
          let* Œ±1 : Ty.path "never" := M.call (core.panicking.panic Œ±0) in
          let* Œ±2 : Ty.tuple := never_to_any Œ±1 in
          M.alloc Œ±2
        else
          M.alloc tt in
      let* Œ±0 : Ty.path "unit" := M.alloc tt in
      M.read Œ±0
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_ensure_confirmed : Instance.t := {
    Notations.double_colon := ensure_confirmed;
  }.
  
  (*
      fn ensure_transaction_exists(&self, trans_id: TransactionId) {
          self.transactions
              .get(&trans_id)
              .expect(WRONG_TRANSACTION_ID);
      }
  *)
  Definition ensure_transaction_exists (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self; trans_id] =>
      let* self := M.alloc self in
      let* trans_id := M.alloc trans_id in
      let* _ : Ty.apply (Ty.path "multisig::Transaction") [] :=
        let* Œ±0 :
            Ty.apply
              (Ty.path "ref")
              [Ty.apply (Ty.path "multisig::Multisig") []] :=
          M.read self in
        let* Œ±1 :
            Ty.apply
              (Ty.path "core::option::Option")
              [Ty.apply (Ty.path "multisig::Transaction") []] :=
          M.call
            ((Ty.apply
                  (Ty.path "multisig::Mapping")
                  [Ty.path "u32";
                    Ty.apply (Ty.path "multisig::Transaction") []])::["get"]
              (borrow (multisig.Multisig.Get_transactions (deref Œ±0)))
              (borrow trans_id)) in
        let* Œ±2 : Ty.apply (Ty.path "ref") [Ty.path "str"] :=
          M.read multisig.WRONG_TRANSACTION_ID in
        let* Œ±3 : Ty.apply (Ty.path "multisig::Transaction") [] :=
          M.call
            ((Ty.apply
                  (Ty.path "core::option::Option")
                  [Ty.apply (Ty.path "multisig::Transaction") []])::["expect"]
              Œ±1
              Œ±2) in
        M.alloc Œ±3 in
      let* Œ±0 : Ty.path "unit" := M.alloc tt in
      M.read Œ±0
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_ensure_transaction_exists : Instance.t := {
    Notations.double_colon := ensure_transaction_exists;
  }.
  
  (*
      fn ensure_owner(&self, owner: &AccountId) {
          assert!(self.is_owner.contains(owner));
      }
  *)
  Definition ensure_owner (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self; owner] =>
      let* self := M.alloc self in
      let* owner := M.alloc owner in
      let* _ : Ty.tuple :=
        let* Œ±0 :
            Ty.apply
              (Ty.path "ref")
              [Ty.apply (Ty.path "multisig::Multisig") []] :=
          M.read self in
        let* Œ±1 :
            Ty.apply
              (Ty.path "ref")
              [Ty.apply (Ty.path "multisig::AccountId") []] :=
          M.read owner in
        let* Œ±2 : Ty.path "bool" :=
          M.call
            ((Ty.apply
                  (Ty.path "multisig::Mapping")
                  [Ty.apply (Ty.path "multisig::AccountId") [];
                    Ty.tuple])::["contains"]
              (borrow (multisig.Multisig.Get_is_owner (deref Œ±0)))
              Œ±1) in
        let* Œ±3 : Ty.path "bool" := M.alloc (UnOp.not Œ±2) in
        let* Œ±4 : Ty.path "bool" := M.read (use Œ±3) in
        if Œ±4 then
          let* Œ±0 : Ty.apply (Ty.path "ref") [Ty.path "str"] :=
            M.read (mk_str "assertion failed: self.is_owner.contains(owner)") in
          let* Œ±1 : Ty.path "never" := M.call (core.panicking.panic Œ±0) in
          let* Œ±2 : Ty.tuple := never_to_any Œ±1 in
          M.alloc Œ±2
        else
          M.alloc tt in
      let* Œ±0 : Ty.path "unit" := M.alloc tt in
      M.read Œ±0
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_ensure_owner : Instance.t := {
    Notations.double_colon := ensure_owner;
  }.
  
  (*
      fn ensure_caller_is_owner(&self) {
          self.ensure_owner(&self.env().caller());
      }
  *)
  Definition ensure_caller_is_owner (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self] =>
      let* self := M.alloc self in
      let* _ : Ty.tuple :=
        let* Œ±0 :
            Ty.apply
              (Ty.path "ref")
              [Ty.apply (Ty.path "multisig::Multisig") []] :=
          M.read self in
        let* Œ±1 :
            Ty.apply
              (Ty.path "ref")
              [Ty.apply (Ty.path "multisig::Multisig") []] :=
          M.read self in
        let* Œ±2 : Ty.apply (Ty.path "multisig::Env") [] :=
          M.call ((Ty.apply (Ty.path "multisig::Multisig") [])::["env"] Œ±1) in
        let* Œ±3 : Ty.apply (Ty.path "multisig::Env") [] := M.alloc Œ±2 in
        let* Œ±4 : Ty.apply (Ty.path "multisig::AccountId") [] :=
          M.call
            ((Ty.apply (Ty.path "multisig::Env") [])::["caller"] (borrow Œ±3)) in
        let* Œ±5 : Ty.apply (Ty.path "multisig::AccountId") [] := M.alloc Œ±4 in
        let* Œ±6 : Ty.tuple :=
          M.call
            ((Ty.apply (Ty.path "multisig::Multisig") [])::["ensure_owner"]
              Œ±0
              (borrow Œ±5)) in
        M.alloc Œ±6 in
      let* Œ±0 : Ty.path "unit" := M.alloc tt in
      M.read Œ±0
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_ensure_caller_is_owner : Instance.t := {
    Notations.double_colon := ensure_caller_is_owner;
  }.
  
  (*
      fn ensure_from_wallet(&self) {
          assert_eq!(self.env().caller(), self.env().account_id());
      }
  *)
  Definition ensure_from_wallet (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self] =>
      let* self := M.alloc self in
      let* _ : Ty.tuple :=
        let* Œ±0 :
            Ty.apply
              (Ty.path "ref")
              [Ty.apply (Ty.path "multisig::Multisig") []] :=
          M.read self in
        let* Œ±1 : Ty.apply (Ty.path "multisig::Env") [] :=
          M.call ((Ty.apply (Ty.path "multisig::Multisig") [])::["env"] Œ±0) in
        let* Œ±2 : Ty.apply (Ty.path "multisig::Env") [] := M.alloc Œ±1 in
        let* Œ±3 : Ty.apply (Ty.path "multisig::AccountId") [] :=
          M.call
            ((Ty.apply (Ty.path "multisig::Env") [])::["caller"] (borrow Œ±2)) in
        let* Œ±4 : Ty.apply (Ty.path "multisig::AccountId") [] := M.alloc Œ±3 in
        let* Œ±5 :
            Ty.apply
              (Ty.path "ref")
              [Ty.apply (Ty.path "multisig::Multisig") []] :=
          M.read self in
        let* Œ±6 : Ty.apply (Ty.path "multisig::Env") [] :=
          M.call ((Ty.apply (Ty.path "multisig::Multisig") [])::["env"] Œ±5) in
        let* Œ±7 : Ty.apply (Ty.path "multisig::Env") [] := M.alloc Œ±6 in
        let* Œ±8 : Ty.apply (Ty.path "multisig::AccountId") [] :=
          M.call
            ((Ty.apply (Ty.path "multisig::Env") [])::["account_id"]
              (borrow Œ±7)) in
        let* Œ±9 : Ty.apply (Ty.path "multisig::AccountId") [] := M.alloc Œ±8 in
        let* Œ±10 :
            Ty.tuple
              (Ty.apply
                (Ty.path "ref")
                [Ty.apply (Ty.path "multisig::AccountId") []])
              (Ty.apply
                (Ty.path "ref")
                [Ty.apply (Ty.path "multisig::AccountId") []]) :=
          M.alloc (borrow Œ±4, borrow Œ±9) in
        match_operator
          Œ±10
          [
            fun Œ≥ =>
              (let* Œ±0 := M.read Œ≥ in
              match Œ±0 with
              | (_, _) =>
                let Œ≥0_0 := Tuple.Access.left Œ≥ in
                let Œ≥0_1 := Tuple.Access.right Œ≥ in
                let* left_val := M.copy Œ≥0_0 in
                let* right_val := M.copy Œ≥0_1 in
                let* Œ±0 :
                    Ty.function
                      [Ty.apply
                          (Ty.path "ref")
                          [Ty.apply (Ty.path "multisig::AccountId") []];
                        Ty.apply
                          (Ty.path "ref")
                          [Ty.apply (Ty.path "multisig::AccountId") []]]
                      (Ty.path "bool") :=
                  ltac:(M.get_method (fun ‚Ñê =>
                    core.cmp.PartialEq.eq
                      (Self := Ty.apply (Ty.path "multisig::AccountId") [])
                      (Rhs := Ty.apply (Ty.path "multisig::AccountId") [])
                      (Trait := ‚Ñê))) in
                let* Œ±1 :
                    Ty.apply
                      (Ty.path "ref")
                      [Ty.apply (Ty.path "multisig::AccountId") []] :=
                  M.read left_val in
                let* Œ±2 :
                    Ty.apply
                      (Ty.path "ref")
                      [Ty.apply (Ty.path "multisig::AccountId") []] :=
                  M.read right_val in
                let* Œ±3 : Ty.path "bool" := M.call (Œ±0 Œ±1 Œ±2) in
                let* Œ±4 : Ty.path "bool" := M.alloc (UnOp.not Œ±3) in
                let* Œ±5 : Ty.path "bool" := M.read (use Œ±4) in
                if Œ±5 then
                  let* kind :
                      Ty.apply (Ty.path "core::panicking::AssertKind") [] :=
                    M.alloc core.panicking.AssertKind.Eq in
                  let* Œ±0 :
                      Ty.apply (Ty.path "core::panicking::AssertKind") [] :=
                    M.read kind in
                  let* Œ±1 :
                      Ty.apply
                        (Ty.path "ref")
                        [Ty.apply (Ty.path "multisig::AccountId") []] :=
                    M.read left_val in
                  let* Œ±2 :
                      Ty.apply
                        (Ty.path "ref")
                        [Ty.apply (Ty.path "multisig::AccountId") []] :=
                    M.read right_val in
                  let* Œ±3 : Ty.path "never" :=
                    M.call
                      (core.panicking.assert_failed
                        Œ±0
                        Œ±1
                        Œ±2
                        core.option.Option.None) in
                  let* Œ±0 : Ty.path "never" := M.alloc Œ±3 in
                  let* Œ±1 : Ty.path "never" := M.read Œ±0 in
                  let* Œ±2 : Ty.tuple := never_to_any Œ±1 in
                  M.alloc Œ±2
                else
                  M.alloc tt
              end) :
              Ty.tuple
          ] in
      let* Œ±0 : Ty.path "unit" := M.alloc tt in
      M.read Œ±0
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_ensure_from_wallet : Instance.t := {
    Notations.double_colon := ensure_from_wallet;
  }.
  
  (*
      fn ensure_no_owner(&self, owner: &AccountId) {
          assert!(!self.is_owner.contains(owner));
      }
  *)
  Definition ensure_no_owner (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self; owner] =>
      let* self := M.alloc self in
      let* owner := M.alloc owner in
      let* _ : Ty.tuple :=
        let* Œ±0 :
            Ty.apply
              (Ty.path "ref")
              [Ty.apply (Ty.path "multisig::Multisig") []] :=
          M.read self in
        let* Œ±1 :
            Ty.apply
              (Ty.path "ref")
              [Ty.apply (Ty.path "multisig::AccountId") []] :=
          M.read owner in
        let* Œ±2 : Ty.path "bool" :=
          M.call
            ((Ty.apply
                  (Ty.path "multisig::Mapping")
                  [Ty.apply (Ty.path "multisig::AccountId") [];
                    Ty.tuple])::["contains"]
              (borrow (multisig.Multisig.Get_is_owner (deref Œ±0)))
              Œ±1) in
        let* Œ±3 : Ty.path "bool" := M.alloc (UnOp.not (UnOp.not Œ±2)) in
        let* Œ±4 : Ty.path "bool" := M.read (use Œ±3) in
        if Œ±4 then
          let* Œ±0 : Ty.apply (Ty.path "ref") [Ty.path "str"] :=
            M.read
              (mk_str "assertion failed: !self.is_owner.contains(owner)") in
          let* Œ±1 : Ty.path "never" := M.call (core.panicking.panic Œ±0) in
          let* Œ±2 : Ty.tuple := never_to_any Œ±1 in
          M.alloc Œ±2
        else
          M.alloc tt in
      let* Œ±0 : Ty.path "unit" := M.alloc tt in
      M.read Œ±0
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_ensure_no_owner : Instance.t := {
    Notations.double_colon := ensure_no_owner;
  }.
  
  (*
      pub fn add_owner(&mut self, new_owner: AccountId) {
          self.ensure_from_wallet();
          self.ensure_no_owner(&new_owner);
          ensure_requirement_is_valid(self.owners.len() as u32 + 1, self.requirement);
          self.is_owner.insert(new_owner, ());
          self.owners.push(new_owner);
          self.env()
              .emit_event(Event::OwnerAddition(OwnerAddition { owner: new_owner }));
      }
  *)
  Definition add_owner (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self; new_owner] =>
      let* self := M.alloc self in
      let* new_owner := M.alloc new_owner in
      let* _ : Ty.tuple :=
        let* Œ±0 :
            Ty.apply
              (Ty.path "mut_ref")
              [Ty.apply (Ty.path "multisig::Multisig") []] :=
          M.read self in
        let* Œ±1 : Ty.tuple :=
          M.call
            ((Ty.apply
                  (Ty.path "multisig::Multisig")
                  [])::["ensure_from_wallet"]
              (borrow (deref Œ±0))) in
        M.alloc Œ±1 in
      let* _ : Ty.tuple :=
        let* Œ±0 :
            Ty.apply
              (Ty.path "mut_ref")
              [Ty.apply (Ty.path "multisig::Multisig") []] :=
          M.read self in
        let* Œ±1 : Ty.tuple :=
          M.call
            ((Ty.apply (Ty.path "multisig::Multisig") [])::["ensure_no_owner"]
              (borrow (deref Œ±0))
              (borrow new_owner)) in
        M.alloc Œ±1 in
      let* _ : Ty.tuple :=
        let* Œ±0 :
            Ty.apply
              (Ty.path "mut_ref")
              [Ty.apply (Ty.path "multisig::Multisig") []] :=
          M.read self in
        let* Œ±1 : Ty.path "usize" :=
          M.call
            ((Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  [Ty.apply (Ty.path "multisig::AccountId") [];
                    Ty.apply (Ty.path "alloc::alloc::Global") []])::["len"]
              (borrow (multisig.Multisig.Get_owners (deref Œ±0)))) in
        let* Œ±2 : Ty.path "u32" :=
          BinOp.Panic.add (rust_cast Œ±1) ((Integer.of_Z 1) : Ty.path "u32") in
        let* Œ±3 :
            Ty.apply
              (Ty.path "mut_ref")
              [Ty.apply (Ty.path "multisig::Multisig") []] :=
          M.read self in
        let* Œ±4 : Ty.path "u32" :=
          M.read (multisig.Multisig.Get_requirement (deref Œ±3)) in
        let* Œ±5 : Ty.tuple :=
          M.call (multisig.ensure_requirement_is_valid Œ±2 Œ±4) in
        M.alloc Œ±5 in
      let* _ : Ty.apply (Ty.path "core::option::Option") [Ty.path "u32"] :=
        let* Œ±0 :
            Ty.apply
              (Ty.path "mut_ref")
              [Ty.apply (Ty.path "multisig::Multisig") []] :=
          M.read self in
        let* Œ±1 : Ty.apply (Ty.path "multisig::AccountId") [] :=
          M.read new_owner in
        let* Œ±2 : Ty.apply (Ty.path "core::option::Option") [Ty.path "u32"] :=
          M.call
            ((Ty.apply
                  (Ty.path "multisig::Mapping")
                  [Ty.apply (Ty.path "multisig::AccountId") [];
                    Ty.tuple])::["insert"]
              (borrow_mut (multisig.Multisig.Get_is_owner (deref Œ±0)))
              Œ±1
              tt) in
        M.alloc Œ±2 in
      let* _ : Ty.tuple :=
        let* Œ±0 :
            Ty.apply
              (Ty.path "mut_ref")
              [Ty.apply (Ty.path "multisig::Multisig") []] :=
          M.read self in
        let* Œ±1 : Ty.apply (Ty.path "multisig::AccountId") [] :=
          M.read new_owner in
        let* Œ±2 : Ty.tuple :=
          M.call
            ((Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  [Ty.apply (Ty.path "multisig::AccountId") [];
                    Ty.apply (Ty.path "alloc::alloc::Global") []])::["push"]
              (borrow_mut (multisig.Multisig.Get_owners (deref Œ±0)))
              Œ±1) in
        M.alloc Œ±2 in
      let* _ : Ty.tuple :=
        let* Œ±0 :
            Ty.apply
              (Ty.path "mut_ref")
              [Ty.apply (Ty.path "multisig::Multisig") []] :=
          M.read self in
        let* Œ±1 : Ty.apply (Ty.path "multisig::Env") [] :=
          M.call
            ((Ty.apply (Ty.path "multisig::Multisig") [])::["env"]
              (borrow (deref Œ±0))) in
        let* Œ±2 : Ty.apply (Ty.path "multisig::Env") [] := M.alloc Œ±1 in
        let* Œ±3 : Ty.apply (Ty.path "multisig::AccountId") [] :=
          M.read new_owner in
        let* Œ±4 : Ty.tuple :=
          M.call
            ((Ty.apply (Ty.path "multisig::Env") [])::["emit_event"]
              (borrow Œ±2)
              (multisig.Event.OwnerAddition
                {| multisig.OwnerAddition.owner := Œ±3; |})) in
        M.alloc Œ±4 in
      let* Œ±0 : Ty.path "unit" := M.alloc tt in
      M.read Œ±0
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_add_owner : Instance.t := {
    Notations.double_colon := add_owner;
  }.
  
  (*
      fn owner_index(&self, owner: &AccountId) -> u32 {
          self.owners.iter().position(|x| *x == *owner).expect(
              "This is only called after it was already verified that the id is
                 actually an owner.",
          ) as u32
      }
  *)
  Definition owner_index (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self; owner] =>
      let* self := M.alloc self in
      let* owner := M.alloc owner in
      let* Œ±0 :
          Ty.function
            [Ty.apply
                (Ty.path "mut_ref")
                [Ty.apply
                    (Ty.path "core::slice::iter::Iter")
                    [Ty.apply (Ty.path "multisig::AccountId") []]];
              Ty.function
                [Ty.tuple
                    (Ty.apply
                      (Ty.path "ref")
                      [Ty.apply (Ty.path "multisig::AccountId") []])]
                (Ty.path "bool")]
            (Ty.apply (Ty.path "core::option::Option") [Ty.path "usize"]) :=
        ltac:(M.get_method (fun ‚Ñê =>
          core.iter.traits.iterator.Iterator.position
            (Self :=
              Ty.apply
                (Ty.path "core::slice::iter::Iter")
                [Ty.apply (Ty.path "multisig::AccountId") []])
            (P :=
              Ty.function
                [Ty.tuple
                    (Ty.apply
                      (Ty.path "ref")
                      [Ty.apply (Ty.path "multisig::AccountId") []])]
                (Ty.path "bool"))
            (Trait := ‚Ñê))) in
      let* Œ±1 :
          Ty.function
            [Ty.apply
                (Ty.path "ref")
                [Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    [Ty.apply (Ty.path "multisig::AccountId") [];
                      Ty.apply (Ty.path "alloc::alloc::Global") []]]]
            (Ty.apply (Ty.path "ref") [_]) :=
        ltac:(M.get_method (fun ‚Ñê =>
          core.ops.deref.Deref.deref
            (Self :=
              Ty.apply
                (Ty.path "alloc::vec::Vec")
                [Ty.apply (Ty.path "multisig::AccountId") [];
                  Ty.apply (Ty.path "alloc::alloc::Global") []])
            (Trait := ‚Ñê))) in
      let* Œ±2 :
          Ty.apply
            (Ty.path "ref")
            [Ty.apply (Ty.path "multisig::Multisig") []] :=
        M.read self in
      let* Œ±3 :
          Ty.apply
            (Ty.path "ref")
            [Ty.apply
                (Ty.path "slice")
                [Ty.apply (Ty.path "multisig::AccountId") []]] :=
        M.call (Œ±1 (borrow (multisig.Multisig.Get_owners (deref Œ±2)))) in
      let* Œ±4 :
          Ty.apply
            (Ty.path "core::slice::iter::Iter")
            [Ty.apply (Ty.path "multisig::AccountId") []] :=
        M.call
          ((Ty.apply
                (Ty.path "slice")
                [Ty.apply (Ty.path "multisig::AccountId") []])::["iter"]
            Œ±3) in
      let* Œ±5 :
          Ty.apply
            (Ty.path "core::slice::iter::Iter")
            [Ty.apply (Ty.path "multisig::AccountId") []] :=
        M.alloc Œ±4 in
      let* Œ±6 : Ty.apply (Ty.path "core::option::Option") [Ty.path "usize"] :=
        M.call
          (Œ±0
            (borrow_mut Œ±5)
            (fun
                (Œ±0 :
                  Ty.apply
                    (Ty.path "ref")
                    [Ty.apply (Ty.path "multisig::AccountId") []]) =>
              (let* Œ±0 := M.alloc Œ±0 in
              match_operator
                Œ±0
                [
                  fun Œ≥ =>
                    (let* x := M.copy Œ≥ in
                    let* Œ±0 :
                        Ty.function
                          [Ty.apply
                              (Ty.path "ref")
                              [Ty.apply (Ty.path "multisig::AccountId") []];
                            Ty.apply
                              (Ty.path "ref")
                              [Ty.apply (Ty.path "multisig::AccountId") []]]
                          (Ty.path "bool") :=
                      ltac:(M.get_method (fun ‚Ñê =>
                        core.cmp.PartialEq.eq
                          (Self := Ty.apply (Ty.path "multisig::AccountId") [])
                          (Rhs := Ty.apply (Ty.path "multisig::AccountId") [])
                          (Trait := ‚Ñê))) in
                    let* Œ±1 :
                        Ty.apply
                          (Ty.path "ref")
                          [Ty.apply (Ty.path "multisig::AccountId") []] :=
                      M.read x in
                    let* Œ±2 :
                        Ty.apply
                          (Ty.path "ref")
                          [Ty.apply (Ty.path "multisig::AccountId") []] :=
                      M.read owner in
                    M.call (Œ±0 Œ±1 Œ±2)) :
                    Ty.path "bool"
                ]) :
              Ty.path "bool")) in
      let* Œ±7 : Ty.apply (Ty.path "ref") [Ty.path "str"] :=
        M.read
          (mk_str
            "This is only called after it was already verified that the id is
               actually an owner.") in
      let* Œ±8 : Ty.path "usize" :=
        M.call
          ((Ty.apply
                (Ty.path "core::option::Option")
                [Ty.path "usize"])::["expect"]
            Œ±6
            Œ±7) in
      M.pure (rust_cast Œ±8)
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_owner_index : Instance.t := {
    Notations.double_colon := owner_index;
  }.
  
  (*
      fn clean_owner_confirmations(&mut self, owner: &AccountId) {
          for trans_id in &self.transaction_list.transactions {
              let key = ( *trans_id, *owner);
              if self.confirmations.contains(&key) {
                  self.confirmations.remove(key);
                  let mut count = self.confirmation_count.get(trans_id).unwrap_or(0 as u32);
                  count -= 1;
                  self.confirmation_count.insert( *trans_id, count);
              }
          }
      }
  *)
  Definition clean_owner_confirmations (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self; owner] =>
      let* self := M.alloc self in
      let* owner := M.alloc owner in
      let* Œ±0 :
          Ty.function
            [Ty.apply
                (Ty.path "ref")
                [Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    [Ty.path "u32";
                      Ty.apply (Ty.path "alloc::alloc::Global") []]]]
            _ :=
        ltac:(M.get_method (fun ‚Ñê =>
          core.iter.traits.collect.IntoIterator.into_iter
            (Self :=
              Ty.apply
                (Ty.path "ref")
                [Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    [Ty.path "u32";
                      Ty.apply (Ty.path "alloc::alloc::Global") []]])
            (Trait := ‚Ñê))) in
      let* Œ±1 :
          Ty.apply
            (Ty.path "mut_ref")
            [Ty.apply (Ty.path "multisig::Multisig") []] :=
        M.read self in
      let* Œ±2 : Ty.apply (Ty.path "core::slice::iter::Iter") [Ty.path "u32"] :=
        M.call
          (Œ±0
            (borrow
              (multisig.Transactions.Get_transactions
                (multisig.Multisig.Get_transaction_list (deref Œ±1))))) in
      let* Œ±3 : Ty.apply (Ty.path "core::slice::iter::Iter") [Ty.path "u32"] :=
        M.alloc Œ±2 in
      let* Œ±4 : Ty.tuple :=
        match_operator
          Œ±3
          [
            fun Œ≥ =>
              (let* iter := M.copy Œ≥ in
              M.loop
                (let* _ : Ty.tuple :=
                  let* Œ±0 :
                      Ty.function
                        [Ty.apply
                            (Ty.path "mut_ref")
                            [Ty.apply
                                (Ty.path "core::slice::iter::Iter")
                                [Ty.path "u32"]]]
                        (Ty.apply (Ty.path "core::option::Option") [_]) :=
                    ltac:(M.get_method (fun ‚Ñê =>
                      core.iter.traits.iterator.Iterator.next
                        (Self :=
                          Ty.apply
                            (Ty.path "core::slice::iter::Iter")
                            [Ty.path "u32"])
                        (Trait := ‚Ñê))) in
                  let* Œ±1 :
                      Ty.apply
                        (Ty.path "core::option::Option")
                        [Ty.apply (Ty.path "ref") [Ty.path "u32"]] :=
                    M.call (Œ±0 (borrow_mut iter)) in
                  let* Œ±2 :
                      Ty.apply
                        (Ty.path "core::option::Option")
                        [Ty.apply (Ty.path "ref") [Ty.path "u32"]] :=
                    M.alloc Œ±1 in
                  match_operator
                    Œ±2
                    [
                      fun Œ≥ =>
                        (let* Œ±0 := M.read Œ≥ in
                        match Œ±0 with
                        | core.option.Option.None =>
                          let* Œ±0 : Ty.path "never" := M.break in
                          let* Œ±1 : Ty.path "never" := M.read Œ±0 in
                          let* Œ±2 : Ty.tuple := never_to_any Œ±1 in
                          M.alloc Œ±2
                        | _ => M.break_match
                        end) :
                        Ty.tuple;
                      fun Œ≥ =>
                        (let* Œ±0 := M.read Œ≥ in
                        match Œ±0 with
                        | core.option.Option.Some _ =>
                          let Œ≥0_0 := core.option.Option.Get_Some_0 Œ≥ in
                          let* trans_id := M.copy Œ≥0_0 in
                          let* key :
                              Ty.tuple
                                (Ty.path "u32")
                                (Ty.apply (Ty.path "multisig::AccountId") []) :=
                            let* Œ±0 :
                                Ty.apply (Ty.path "ref") [Ty.path "u32"] :=
                              M.read trans_id in
                            let* Œ±1 : Ty.path "u32" := M.read (deref Œ±0) in
                            let* Œ±2 :
                                Ty.apply
                                  (Ty.path "ref")
                                  [Ty.apply
                                      (Ty.path "multisig::AccountId")
                                      []] :=
                              M.read owner in
                            let* Œ±3 :
                                Ty.apply (Ty.path "multisig::AccountId") [] :=
                              M.read (deref Œ±2) in
                            M.alloc (Œ±1, Œ±3) in
                          let* Œ±0 :
                              Ty.apply
                                (Ty.path "mut_ref")
                                [Ty.apply (Ty.path "multisig::Multisig") []] :=
                            M.read self in
                          let* Œ±1 : Ty.path "bool" :=
                            M.call
                              ((Ty.apply
                                    (Ty.path "multisig::Mapping")
                                    [Ty.tuple
                                        (Ty.path "u32")
                                        (Ty.apply
                                          (Ty.path "multisig::AccountId")
                                          []);
                                      Ty.tuple])::["contains"]
                                (borrow
                                  (multisig.Multisig.Get_confirmations
                                    (deref Œ±0)))
                                (borrow key)) in
                          let* Œ±2 : Ty.path "bool" := M.alloc Œ±1 in
                          let* Œ±3 : Ty.path "bool" := M.read (use Œ±2) in
                          if Œ±3 then
                            let* _ : Ty.tuple :=
                              let* Œ±0 :
                                  Ty.apply
                                    (Ty.path "mut_ref")
                                    [Ty.apply
                                        (Ty.path "multisig::Multisig")
                                        []] :=
                                M.read self in
                              let* Œ±1 :
                                  Ty.tuple
                                    (Ty.path "u32")
                                    (Ty.apply
                                      (Ty.path "multisig::AccountId")
                                      []) :=
                                M.read key in
                              let* Œ±2 : Ty.tuple :=
                                M.call
                                  ((Ty.apply
                                        (Ty.path "multisig::Mapping")
                                        [Ty.tuple
                                            (Ty.path "u32")
                                            (Ty.apply
                                              (Ty.path "multisig::AccountId")
                                              []);
                                          Ty.tuple])::["remove"]
                                    (borrow
                                      (multisig.Multisig.Get_confirmations
                                        (deref Œ±0)))
                                    Œ±1) in
                              M.alloc Œ±2 in
                            let* count : Ty.path "u32" :=
                              let* Œ±0 :
                                  Ty.apply
                                    (Ty.path "mut_ref")
                                    [Ty.apply
                                        (Ty.path "multisig::Multisig")
                                        []] :=
                                M.read self in
                              let* Œ±1 :
                                  Ty.apply (Ty.path "ref") [Ty.path "u32"] :=
                                M.read trans_id in
                              let* Œ±2 :
                                  Ty.apply
                                    (Ty.path "core::option::Option")
                                    [Ty.path "u32"] :=
                                M.call
                                  ((Ty.apply
                                        (Ty.path "multisig::Mapping")
                                        [Ty.path "u32"; Ty.path "u32"])::["get"]
                                    (borrow
                                      (multisig.Multisig.Get_confirmation_count
                                        (deref Œ±0)))
                                    Œ±1) in
                              let* Œ±3 : Ty.path "u32" :=
                                M.alloc ((Integer.of_Z 0) : Ty.path "u32") in
                              let* Œ±4 : Ty.path "u32" := M.read (use Œ±3) in
                              let* Œ±5 : Ty.path "u32" :=
                                M.call
                                  ((Ty.apply
                                        (Ty.path "core::option::Option")
                                        [Ty.path "u32"])::["unwrap_or"]
                                    Œ±2
                                    Œ±4) in
                              M.alloc Œ±5 in
                            let* _ : Ty.tuple :=
                              let Œ≤ : Ty.path "u32" := count in
                              let* Œ±0 := M.read Œ≤ in
                              let* Œ±1 :=
                                BinOp.Panic.sub
                                  Œ±0
                                  ((Integer.of_Z 1) : Ty.path "u32") in
                              assign Œ≤ Œ±1 in
                            let* _ :
                                Ty.apply
                                  (Ty.path "core::option::Option")
                                  [Ty.path "u32"] :=
                              let* Œ±0 :
                                  Ty.apply
                                    (Ty.path "mut_ref")
                                    [Ty.apply
                                        (Ty.path "multisig::Multisig")
                                        []] :=
                                M.read self in
                              let* Œ±1 :
                                  Ty.apply (Ty.path "ref") [Ty.path "u32"] :=
                                M.read trans_id in
                              let* Œ±2 : Ty.path "u32" := M.read (deref Œ±1) in
                              let* Œ±3 : Ty.path "u32" := M.read count in
                              let* Œ±4 :
                                  Ty.apply
                                    (Ty.path "core::option::Option")
                                    [Ty.path "u32"] :=
                                M.call
                                  ((Ty.apply
                                        (Ty.path "multisig::Mapping")
                                        [Ty.path "u32";
                                          Ty.path "u32"])::["insert"]
                                    (borrow_mut
                                      (multisig.Multisig.Get_confirmation_count
                                        (deref Œ±0)))
                                    Œ±2
                                    Œ±3) in
                              M.alloc Œ±4 in
                            M.alloc tt
                          else
                            M.alloc tt
                        | _ => M.break_match
                        end) :
                        Ty.tuple
                    ] in
                M.alloc tt)) :
              Ty.tuple
          ] in
      M.read (use Œ±4)
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_clean_owner_confirmations : Instance.t := {
    Notations.double_colon := clean_owner_confirmations;
  }.
  
  (*
      pub fn remove_owner(&mut self, owner: AccountId) {
          self.ensure_from_wallet();
          self.ensure_owner(&owner);
          let len = self.owners.len() as u32 - 1;
          let requirement = u32::min(len, self.requirement);
          ensure_requirement_is_valid(len, requirement);
          let owner_index = self.owner_index(&owner) as usize;
          self.owners.swap_remove(owner_index);
          self.is_owner.remove(owner);
          self.requirement = requirement;
          self.clean_owner_confirmations(&owner);
          self.env()
              .emit_event(Event::OwnerRemoval(OwnerRemoval { owner }));
      }
  *)
  Definition remove_owner (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self; owner] =>
      let* self := M.alloc self in
      let* owner := M.alloc owner in
      let* _ : Ty.tuple :=
        let* Œ±0 :
            Ty.apply
              (Ty.path "mut_ref")
              [Ty.apply (Ty.path "multisig::Multisig") []] :=
          M.read self in
        let* Œ±1 : Ty.tuple :=
          M.call
            ((Ty.apply
                  (Ty.path "multisig::Multisig")
                  [])::["ensure_from_wallet"]
              (borrow (deref Œ±0))) in
        M.alloc Œ±1 in
      let* _ : Ty.tuple :=
        let* Œ±0 :
            Ty.apply
              (Ty.path "mut_ref")
              [Ty.apply (Ty.path "multisig::Multisig") []] :=
          M.read self in
        let* Œ±1 : Ty.tuple :=
          M.call
            ((Ty.apply (Ty.path "multisig::Multisig") [])::["ensure_owner"]
              (borrow (deref Œ±0))
              (borrow owner)) in
        M.alloc Œ±1 in
      let* len : Ty.path "u32" :=
        let* Œ±0 :
            Ty.apply
              (Ty.path "mut_ref")
              [Ty.apply (Ty.path "multisig::Multisig") []] :=
          M.read self in
        let* Œ±1 : Ty.path "usize" :=
          M.call
            ((Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  [Ty.apply (Ty.path "multisig::AccountId") [];
                    Ty.apply (Ty.path "alloc::alloc::Global") []])::["len"]
              (borrow (multisig.Multisig.Get_owners (deref Œ±0)))) in
        let* Œ±2 : Ty.path "u32" :=
          BinOp.Panic.sub (rust_cast Œ±1) ((Integer.of_Z 1) : Ty.path "u32") in
        M.alloc Œ±2 in
      let* requirement : Ty.path "u32" :=
        let* Œ±0 : Ty.function [Ty.path "u32"; Ty.path "u32"] (Ty.path "u32") :=
          ltac:(M.get_method (fun ‚Ñê =>
            core.cmp.Ord.min (Self := Ty.path "u32") (Trait := ‚Ñê))) in
        let* Œ±1 : Ty.path "u32" := M.read len in
        let* Œ±2 :
            Ty.apply
              (Ty.path "mut_ref")
              [Ty.apply (Ty.path "multisig::Multisig") []] :=
          M.read self in
        let* Œ±3 : Ty.path "u32" :=
          M.read (multisig.Multisig.Get_requirement (deref Œ±2)) in
        let* Œ±4 : Ty.path "u32" := M.call (Œ±0 Œ±1 Œ±3) in
        M.alloc Œ±4 in
      let* _ : Ty.tuple :=
        let* Œ±0 : Ty.path "u32" := M.read len in
        let* Œ±1 : Ty.path "u32" := M.read requirement in
        let* Œ±2 : Ty.tuple :=
          M.call (multisig.ensure_requirement_is_valid Œ±0 Œ±1) in
        M.alloc Œ±2 in
      let* owner_index : Ty.path "usize" :=
        let* Œ±0 :
            Ty.apply
              (Ty.path "mut_ref")
              [Ty.apply (Ty.path "multisig::Multisig") []] :=
          M.read self in
        let* Œ±1 : Ty.path "u32" :=
          M.call
            ((Ty.apply (Ty.path "multisig::Multisig") [])::["owner_index"]
              (borrow (deref Œ±0))
              (borrow owner)) in
        M.alloc (rust_cast Œ±1) in
      let* _ : Ty.apply (Ty.path "multisig::AccountId") [] :=
        let* Œ±0 :
            Ty.apply
              (Ty.path "mut_ref")
              [Ty.apply (Ty.path "multisig::Multisig") []] :=
          M.read self in
        let* Œ±1 : Ty.path "usize" := M.read owner_index in
        let* Œ±2 : Ty.apply (Ty.path "multisig::AccountId") [] :=
          M.call
            ((Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  [Ty.apply (Ty.path "multisig::AccountId") [];
                    Ty.apply
                      (Ty.path "alloc::alloc::Global")
                      []])::["swap_remove"]
              (borrow_mut (multisig.Multisig.Get_owners (deref Œ±0)))
              Œ±1) in
        M.alloc Œ±2 in
      let* _ : Ty.tuple :=
        let* Œ±0 :
            Ty.apply
              (Ty.path "mut_ref")
              [Ty.apply (Ty.path "multisig::Multisig") []] :=
          M.read self in
        let* Œ±1 : Ty.apply (Ty.path "multisig::AccountId") [] := M.read owner in
        let* Œ±2 : Ty.tuple :=
          M.call
            ((Ty.apply
                  (Ty.path "multisig::Mapping")
                  [Ty.apply (Ty.path "multisig::AccountId") [];
                    Ty.tuple])::["remove"]
              (borrow (multisig.Multisig.Get_is_owner (deref Œ±0)))
              Œ±1) in
        M.alloc Œ±2 in
      let* _ : Ty.tuple :=
        let* Œ±0 :
            Ty.apply
              (Ty.path "mut_ref")
              [Ty.apply (Ty.path "multisig::Multisig") []] :=
          M.read self in
        let* Œ±1 : Ty.path "u32" := M.read requirement in
        assign (multisig.Multisig.Get_requirement (deref Œ±0)) Œ±1 in
      let* _ : Ty.tuple :=
        let* Œ±0 :
            Ty.apply
              (Ty.path "mut_ref")
              [Ty.apply (Ty.path "multisig::Multisig") []] :=
          M.read self in
        let* Œ±1 : Ty.tuple :=
          M.call
            ((Ty.apply
                  (Ty.path "multisig::Multisig")
                  [])::["clean_owner_confirmations"]
              Œ±0
              (borrow owner)) in
        M.alloc Œ±1 in
      let* _ : Ty.tuple :=
        let* Œ±0 :
            Ty.apply
              (Ty.path "mut_ref")
              [Ty.apply (Ty.path "multisig::Multisig") []] :=
          M.read self in
        let* Œ±1 : Ty.apply (Ty.path "multisig::Env") [] :=
          M.call
            ((Ty.apply (Ty.path "multisig::Multisig") [])::["env"]
              (borrow (deref Œ±0))) in
        let* Œ±2 : Ty.apply (Ty.path "multisig::Env") [] := M.alloc Œ±1 in
        let* Œ±3 : Ty.apply (Ty.path "multisig::AccountId") [] := M.read owner in
        let* Œ±4 : Ty.tuple :=
          M.call
            ((Ty.apply (Ty.path "multisig::Env") [])::["emit_event"]
              (borrow Œ±2)
              (multisig.Event.OwnerRemoval
                {| multisig.OwnerRemoval.owner := Œ±3; |})) in
        M.alloc Œ±4 in
      let* Œ±0 : Ty.path "unit" := M.alloc tt in
      M.read Œ±0
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_remove_owner : Instance.t := {
    Notations.double_colon := remove_owner;
  }.
  
  (*
      pub fn replace_owner(&mut self, old_owner: AccountId, new_owner: AccountId) {
          self.ensure_from_wallet();
          self.ensure_owner(&old_owner);
          self.ensure_no_owner(&new_owner);
          let owner_index = self.owner_index(&old_owner);
          self.owners[owner_index as usize] = new_owner;
          self.is_owner.remove(old_owner);
          self.is_owner.insert(new_owner, ());
          self.clean_owner_confirmations(&old_owner);
          self.env()
              .emit_event(Event::OwnerRemoval(OwnerRemoval { owner: old_owner }));
          self.env()
              .emit_event(Event::OwnerAddition(OwnerAddition { owner: new_owner }));
      }
  *)
  Definition replace_owner (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self; old_owner; new_owner] =>
      let* self := M.alloc self in
      let* old_owner := M.alloc old_owner in
      let* new_owner := M.alloc new_owner in
      let* _ : Ty.tuple :=
        let* Œ±0 :
            Ty.apply
              (Ty.path "mut_ref")
              [Ty.apply (Ty.path "multisig::Multisig") []] :=
          M.read self in
        let* Œ±1 : Ty.tuple :=
          M.call
            ((Ty.apply
                  (Ty.path "multisig::Multisig")
                  [])::["ensure_from_wallet"]
              (borrow (deref Œ±0))) in
        M.alloc Œ±1 in
      let* _ : Ty.tuple :=
        let* Œ±0 :
            Ty.apply
              (Ty.path "mut_ref")
              [Ty.apply (Ty.path "multisig::Multisig") []] :=
          M.read self in
        let* Œ±1 : Ty.tuple :=
          M.call
            ((Ty.apply (Ty.path "multisig::Multisig") [])::["ensure_owner"]
              (borrow (deref Œ±0))
              (borrow old_owner)) in
        M.alloc Œ±1 in
      let* _ : Ty.tuple :=
        let* Œ±0 :
            Ty.apply
              (Ty.path "mut_ref")
              [Ty.apply (Ty.path "multisig::Multisig") []] :=
          M.read self in
        let* Œ±1 : Ty.tuple :=
          M.call
            ((Ty.apply (Ty.path "multisig::Multisig") [])::["ensure_no_owner"]
              (borrow (deref Œ±0))
              (borrow new_owner)) in
        M.alloc Œ±1 in
      let* owner_index : Ty.path "u32" :=
        let* Œ±0 :
            Ty.apply
              (Ty.path "mut_ref")
              [Ty.apply (Ty.path "multisig::Multisig") []] :=
          M.read self in
        let* Œ±1 : Ty.path "u32" :=
          M.call
            ((Ty.apply (Ty.path "multisig::Multisig") [])::["owner_index"]
              (borrow (deref Œ±0))
              (borrow old_owner)) in
        M.alloc Œ±1 in
      let* _ : Ty.tuple :=
        let* Œ±0 :
            Ty.function
              [Ty.apply
                  (Ty.path "mut_ref")
                  [Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      [Ty.apply (Ty.path "multisig::AccountId") [];
                        Ty.apply (Ty.path "alloc::alloc::Global") []]];
                Ty.path "usize"]
              (Ty.apply (Ty.path "mut_ref") [_]) :=
          ltac:(M.get_method (fun ‚Ñê =>
            core.ops.index.IndexMut.index_mut
              (Self :=
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  [Ty.apply (Ty.path "multisig::AccountId") [];
                    Ty.apply (Ty.path "alloc::alloc::Global") []])
              (Idx := Ty.path "usize")
              (Trait := ‚Ñê))) in
        let* Œ±1 :
            Ty.apply
              (Ty.path "mut_ref")
              [Ty.apply (Ty.path "multisig::Multisig") []] :=
          M.read self in
        let* Œ±2 : Ty.path "u32" := M.read owner_index in
        let* Œ±3 :
            Ty.apply
              (Ty.path "mut_ref")
              [Ty.apply (Ty.path "multisig::AccountId") []] :=
          M.call
            (Œ±0
              (borrow_mut (multisig.Multisig.Get_owners (deref Œ±1)))
              (rust_cast Œ±2)) in
        let* Œ±4 : Ty.apply (Ty.path "multisig::AccountId") [] :=
          M.read new_owner in
        assign (deref Œ±3) Œ±4 in
      let* _ : Ty.tuple :=
        let* Œ±0 :
            Ty.apply
              (Ty.path "mut_ref")
              [Ty.apply (Ty.path "multisig::Multisig") []] :=
          M.read self in
        let* Œ±1 : Ty.apply (Ty.path "multisig::AccountId") [] :=
          M.read old_owner in
        let* Œ±2 : Ty.tuple :=
          M.call
            ((Ty.apply
                  (Ty.path "multisig::Mapping")
                  [Ty.apply (Ty.path "multisig::AccountId") [];
                    Ty.tuple])::["remove"]
              (borrow (multisig.Multisig.Get_is_owner (deref Œ±0)))
              Œ±1) in
        M.alloc Œ±2 in
      let* _ : Ty.apply (Ty.path "core::option::Option") [Ty.path "u32"] :=
        let* Œ±0 :
            Ty.apply
              (Ty.path "mut_ref")
              [Ty.apply (Ty.path "multisig::Multisig") []] :=
          M.read self in
        let* Œ±1 : Ty.apply (Ty.path "multisig::AccountId") [] :=
          M.read new_owner in
        let* Œ±2 : Ty.apply (Ty.path "core::option::Option") [Ty.path "u32"] :=
          M.call
            ((Ty.apply
                  (Ty.path "multisig::Mapping")
                  [Ty.apply (Ty.path "multisig::AccountId") [];
                    Ty.tuple])::["insert"]
              (borrow_mut (multisig.Multisig.Get_is_owner (deref Œ±0)))
              Œ±1
              tt) in
        M.alloc Œ±2 in
      let* _ : Ty.tuple :=
        let* Œ±0 :
            Ty.apply
              (Ty.path "mut_ref")
              [Ty.apply (Ty.path "multisig::Multisig") []] :=
          M.read self in
        let* Œ±1 : Ty.tuple :=
          M.call
            ((Ty.apply
                  (Ty.path "multisig::Multisig")
                  [])::["clean_owner_confirmations"]
              Œ±0
              (borrow old_owner)) in
        M.alloc Œ±1 in
      let* _ : Ty.tuple :=
        let* Œ±0 :
            Ty.apply
              (Ty.path "mut_ref")
              [Ty.apply (Ty.path "multisig::Multisig") []] :=
          M.read self in
        let* Œ±1 : Ty.apply (Ty.path "multisig::Env") [] :=
          M.call
            ((Ty.apply (Ty.path "multisig::Multisig") [])::["env"]
              (borrow (deref Œ±0))) in
        let* Œ±2 : Ty.apply (Ty.path "multisig::Env") [] := M.alloc Œ±1 in
        let* Œ±3 : Ty.apply (Ty.path "multisig::AccountId") [] :=
          M.read old_owner in
        let* Œ±4 : Ty.tuple :=
          M.call
            ((Ty.apply (Ty.path "multisig::Env") [])::["emit_event"]
              (borrow Œ±2)
              (multisig.Event.OwnerRemoval
                {| multisig.OwnerRemoval.owner := Œ±3; |})) in
        M.alloc Œ±4 in
      let* _ : Ty.tuple :=
        let* Œ±0 :
            Ty.apply
              (Ty.path "mut_ref")
              [Ty.apply (Ty.path "multisig::Multisig") []] :=
          M.read self in
        let* Œ±1 : Ty.apply (Ty.path "multisig::Env") [] :=
          M.call
            ((Ty.apply (Ty.path "multisig::Multisig") [])::["env"]
              (borrow (deref Œ±0))) in
        let* Œ±2 : Ty.apply (Ty.path "multisig::Env") [] := M.alloc Œ±1 in
        let* Œ±3 : Ty.apply (Ty.path "multisig::AccountId") [] :=
          M.read new_owner in
        let* Œ±4 : Ty.tuple :=
          M.call
            ((Ty.apply (Ty.path "multisig::Env") [])::["emit_event"]
              (borrow Œ±2)
              (multisig.Event.OwnerAddition
                {| multisig.OwnerAddition.owner := Œ±3; |})) in
        M.alloc Œ±4 in
      let* Œ±0 : Ty.path "unit" := M.alloc tt in
      M.read Œ±0
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_replace_owner : Instance.t := {
    Notations.double_colon := replace_owner;
  }.
  
  (*
      pub fn change_requirement(&mut self, new_requirement: u32) {
          self.ensure_from_wallet();
          ensure_requirement_is_valid(self.owners.len() as u32, new_requirement);
          self.requirement = new_requirement;
          self.env()
              .emit_event(Event::RequirementChange(RequirementChange {
                  new_requirement,
              }));
      }
  *)
  Definition change_requirement (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self; new_requirement] =>
      let* self := M.alloc self in
      let* new_requirement := M.alloc new_requirement in
      let* _ : Ty.tuple :=
        let* Œ±0 :
            Ty.apply
              (Ty.path "mut_ref")
              [Ty.apply (Ty.path "multisig::Multisig") []] :=
          M.read self in
        let* Œ±1 : Ty.tuple :=
          M.call
            ((Ty.apply
                  (Ty.path "multisig::Multisig")
                  [])::["ensure_from_wallet"]
              (borrow (deref Œ±0))) in
        M.alloc Œ±1 in
      let* _ : Ty.tuple :=
        let* Œ±0 :
            Ty.apply
              (Ty.path "mut_ref")
              [Ty.apply (Ty.path "multisig::Multisig") []] :=
          M.read self in
        let* Œ±1 : Ty.path "usize" :=
          M.call
            ((Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  [Ty.apply (Ty.path "multisig::AccountId") [];
                    Ty.apply (Ty.path "alloc::alloc::Global") []])::["len"]
              (borrow (multisig.Multisig.Get_owners (deref Œ±0)))) in
        let* Œ±2 : Ty.path "u32" := M.read new_requirement in
        let* Œ±3 : Ty.tuple :=
          M.call (multisig.ensure_requirement_is_valid (rust_cast Œ±1) Œ±2) in
        M.alloc Œ±3 in
      let* _ : Ty.tuple :=
        let* Œ±0 :
            Ty.apply
              (Ty.path "mut_ref")
              [Ty.apply (Ty.path "multisig::Multisig") []] :=
          M.read self in
        let* Œ±1 : Ty.path "u32" := M.read new_requirement in
        assign (multisig.Multisig.Get_requirement (deref Œ±0)) Œ±1 in
      let* _ : Ty.tuple :=
        let* Œ±0 :
            Ty.apply
              (Ty.path "mut_ref")
              [Ty.apply (Ty.path "multisig::Multisig") []] :=
          M.read self in
        let* Œ±1 : Ty.apply (Ty.path "multisig::Env") [] :=
          M.call
            ((Ty.apply (Ty.path "multisig::Multisig") [])::["env"]
              (borrow (deref Œ±0))) in
        let* Œ±2 : Ty.apply (Ty.path "multisig::Env") [] := M.alloc Œ±1 in
        let* Œ±3 : Ty.path "u32" := M.read new_requirement in
        let* Œ±4 : Ty.tuple :=
          M.call
            ((Ty.apply (Ty.path "multisig::Env") [])::["emit_event"]
              (borrow Œ±2)
              (multisig.Event.RequirementChange
                {| multisig.RequirementChange.new_requirement := Œ±3; |})) in
        M.alloc Œ±4 in
      let* Œ±0 : Ty.path "unit" := M.alloc tt in
      M.read Œ±0
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_change_requirement : Instance.t := {
    Notations.double_colon := change_requirement;
  }.
  
  (*
      fn confirm_by_caller(
          &mut self,
          confirmer: AccountId,
          transaction: TransactionId,
      ) -> ConfirmationStatus {
          let mut count = self
              .confirmation_count
              .get(&transaction)
              .unwrap_or(0 as u32);
          let key = (transaction, confirmer);
          let new_confirmation = !self.confirmations.contains(&key);
          if new_confirmation {
              count += 1;
              self.confirmations.insert(key, ());
              self.confirmation_count.insert(transaction, count);
          }
          let status = {
              if count >= self.requirement {
                  ConfirmationStatus::Confirmed
              } else {
                  ConfirmationStatus::ConfirmationsNeeded(self.requirement - count)
              }
          };
          if new_confirmation {
              self.env().emit_event(Event::Confirmation(Confirmation {
                  transaction,
                  from: confirmer,
                  status,
              }));
          }
          status
      }
  *)
  Definition confirm_by_caller (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self; confirmer; transaction] =>
      let* self := M.alloc self in
      let* confirmer := M.alloc confirmer in
      let* transaction := M.alloc transaction in
      let* count : Ty.path "u32" :=
        let* Œ±0 :
            Ty.apply
              (Ty.path "mut_ref")
              [Ty.apply (Ty.path "multisig::Multisig") []] :=
          M.read self in
        let* Œ±1 : Ty.apply (Ty.path "core::option::Option") [Ty.path "u32"] :=
          M.call
            ((Ty.apply
                  (Ty.path "multisig::Mapping")
                  [Ty.path "u32"; Ty.path "u32"])::["get"]
              (borrow (multisig.Multisig.Get_confirmation_count (deref Œ±0)))
              (borrow transaction)) in
        let* Œ±2 : Ty.path "u32" := M.alloc ((Integer.of_Z 0) : Ty.path "u32") in
        let* Œ±3 : Ty.path "u32" := M.read (use Œ±2) in
        let* Œ±4 : Ty.path "u32" :=
          M.call
            ((Ty.apply
                  (Ty.path "core::option::Option")
                  [Ty.path "u32"])::["unwrap_or"]
              Œ±1
              Œ±3) in
        M.alloc Œ±4 in
      let* key :
          Ty.tuple
            (Ty.path "u32")
            (Ty.apply (Ty.path "multisig::AccountId") []) :=
        let* Œ±0 : Ty.path "u32" := M.read transaction in
        let* Œ±1 : Ty.apply (Ty.path "multisig::AccountId") [] :=
          M.read confirmer in
        M.alloc (Œ±0, Œ±1) in
      let* new_confirmation : Ty.path "bool" :=
        let* Œ±0 :
            Ty.apply
              (Ty.path "mut_ref")
              [Ty.apply (Ty.path "multisig::Multisig") []] :=
          M.read self in
        let* Œ±1 : Ty.path "bool" :=
          M.call
            ((Ty.apply
                  (Ty.path "multisig::Mapping")
                  [Ty.tuple
                      (Ty.path "u32")
                      (Ty.apply (Ty.path "multisig::AccountId") []);
                    Ty.tuple])::["contains"]
              (borrow (multisig.Multisig.Get_confirmations (deref Œ±0)))
              (borrow key)) in
        M.alloc (UnOp.not Œ±1) in
      let* _ : Ty.tuple :=
        let* Œ±0 : Ty.path "bool" := M.read (use new_confirmation) in
        if Œ±0 then
          let* _ : Ty.tuple :=
            let Œ≤ : Ty.path "u32" := count in
            let* Œ±0 := M.read Œ≤ in
            let* Œ±1 := BinOp.Panic.add Œ±0 ((Integer.of_Z 1) : Ty.path "u32") in
            assign Œ≤ Œ±1 in
          let* _ : Ty.apply (Ty.path "core::option::Option") [Ty.path "u32"] :=
            let* Œ±0 :
                Ty.apply
                  (Ty.path "mut_ref")
                  [Ty.apply (Ty.path "multisig::Multisig") []] :=
              M.read self in
            let* Œ±1 :
                Ty.tuple
                  (Ty.path "u32")
                  (Ty.apply (Ty.path "multisig::AccountId") []) :=
              M.read key in
            let* Œ±2 :
                Ty.apply (Ty.path "core::option::Option") [Ty.path "u32"] :=
              M.call
                ((Ty.apply
                      (Ty.path "multisig::Mapping")
                      [Ty.tuple
                          (Ty.path "u32")
                          (Ty.apply (Ty.path "multisig::AccountId") []);
                        Ty.tuple])::["insert"]
                  (borrow_mut (multisig.Multisig.Get_confirmations (deref Œ±0)))
                  Œ±1
                  tt) in
            M.alloc Œ±2 in
          let* _ : Ty.apply (Ty.path "core::option::Option") [Ty.path "u32"] :=
            let* Œ±0 :
                Ty.apply
                  (Ty.path "mut_ref")
                  [Ty.apply (Ty.path "multisig::Multisig") []] :=
              M.read self in
            let* Œ±1 : Ty.path "u32" := M.read transaction in
            let* Œ±2 : Ty.path "u32" := M.read count in
            let* Œ±3 :
                Ty.apply (Ty.path "core::option::Option") [Ty.path "u32"] :=
              M.call
                ((Ty.apply
                      (Ty.path "multisig::Mapping")
                      [Ty.path "u32"; Ty.path "u32"])::["insert"]
                  (borrow_mut
                    (multisig.Multisig.Get_confirmation_count (deref Œ±0)))
                  Œ±1
                  Œ±2) in
            M.alloc Œ±3 in
          M.alloc tt
        else
          M.alloc tt in
      let* status : Ty.apply (Ty.path "multisig::ConfirmationStatus") [] :=
        let* Œ±0 : Ty.path "u32" := M.read count in
        let* Œ±1 :
            Ty.apply
              (Ty.path "mut_ref")
              [Ty.apply (Ty.path "multisig::Multisig") []] :=
          M.read self in
        let* Œ±2 : Ty.path "u32" :=
          M.read (multisig.Multisig.Get_requirement (deref Œ±1)) in
        let* Œ±3 : Ty.path "bool" := M.alloc (BinOp.Pure.ge Œ±0 Œ±2) in
        let* Œ±4 : Ty.path "bool" := M.read (use Œ±3) in
        let* Œ±5 : Ty.apply (Ty.path "multisig::ConfirmationStatus") [] :=
          if Œ±4 then
            M.alloc multisig.ConfirmationStatus.Confirmed
          else
            let* Œ±0 :
                Ty.apply
                  (Ty.path "mut_ref")
                  [Ty.apply (Ty.path "multisig::Multisig") []] :=
              M.read self in
            let* Œ±1 : Ty.path "u32" :=
              M.read (multisig.Multisig.Get_requirement (deref Œ±0)) in
            let* Œ±2 : Ty.path "u32" := M.read count in
            let* Œ±3 : Ty.path "u32" := BinOp.Panic.sub Œ±1 Œ±2 in
            M.alloc (multisig.ConfirmationStatus.ConfirmationsNeeded Œ±3) in
        M.copy Œ±5 in
      let* _ : Ty.tuple :=
        let* Œ±0 : Ty.path "bool" := M.read (use new_confirmation) in
        if Œ±0 then
          let* _ : Ty.tuple :=
            let* Œ±0 :
                Ty.apply
                  (Ty.path "mut_ref")
                  [Ty.apply (Ty.path "multisig::Multisig") []] :=
              M.read self in
            let* Œ±1 : Ty.apply (Ty.path "multisig::Env") [] :=
              M.call
                ((Ty.apply (Ty.path "multisig::Multisig") [])::["env"]
                  (borrow (deref Œ±0))) in
            let* Œ±2 : Ty.apply (Ty.path "multisig::Env") [] := M.alloc Œ±1 in
            let* Œ±3 : Ty.path "u32" := M.read transaction in
            let* Œ±4 : Ty.apply (Ty.path "multisig::AccountId") [] :=
              M.read confirmer in
            let* Œ±5 : Ty.apply (Ty.path "multisig::ConfirmationStatus") [] :=
              M.read status in
            let* Œ±6 : Ty.tuple :=
              M.call
                ((Ty.apply (Ty.path "multisig::Env") [])::["emit_event"]
                  (borrow Œ±2)
                  (multisig.Event.Confirmation
                    {|
                      multisig.Confirmation.transaction := Œ±3;
                      multisig.Confirmation.from := Œ±4;
                      multisig.Confirmation.status := Œ±5;
                    |})) in
            M.alloc Œ±6 in
          M.alloc tt
        else
          M.alloc tt in
      M.read status
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_confirm_by_caller : Instance.t := {
    Notations.double_colon := confirm_by_caller;
  }.
  
  (*
      pub fn submit_transaction(
          &mut self,
          transaction: Transaction,
      ) -> (TransactionId, ConfirmationStatus) {
          self.ensure_caller_is_owner();
          let trans_id = self.transaction_list.next_id;
          self.transaction_list.next_id = trans_id
              .checked_add(1 as u32)
              .expect("Transaction ids exhausted.");
          self.transactions.insert(trans_id, transaction);
          self.transaction_list.transactions.push(trans_id);
          self.env().emit_event(Event::Submission(Submission {
              transaction: trans_id,
          }));
          (
              trans_id,
              self.confirm_by_caller(self.env().caller(), trans_id),
          )
      }
  *)
  Definition submit_transaction (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self; transaction] =>
      let* self := M.alloc self in
      let* transaction := M.alloc transaction in
      let* _ : Ty.tuple :=
        let* Œ±0 :
            Ty.apply
              (Ty.path "mut_ref")
              [Ty.apply (Ty.path "multisig::Multisig") []] :=
          M.read self in
        let* Œ±1 : Ty.tuple :=
          M.call
            ((Ty.apply
                  (Ty.path "multisig::Multisig")
                  [])::["ensure_caller_is_owner"]
              (borrow (deref Œ±0))) in
        M.alloc Œ±1 in
      let* trans_id : Ty.path "u32" :=
        let* Œ±0 :
            Ty.apply
              (Ty.path "mut_ref")
              [Ty.apply (Ty.path "multisig::Multisig") []] :=
          M.read self in
        M.copy
          (multisig.Transactions.Get_next_id
            (multisig.Multisig.Get_transaction_list (deref Œ±0))) in
      let* _ : Ty.tuple :=
        let* Œ±0 :
            Ty.apply
              (Ty.path "mut_ref")
              [Ty.apply (Ty.path "multisig::Multisig") []] :=
          M.read self in
        let* Œ±1 : Ty.path "u32" := M.read trans_id in
        let* Œ±2 : Ty.path "u32" := M.alloc ((Integer.of_Z 1) : Ty.path "u32") in
        let* Œ±3 : Ty.path "u32" := M.read (use Œ±2) in
        let* Œ±4 : Ty.apply (Ty.path "core::option::Option") [Ty.path "u32"] :=
          M.call ((Ty.path "u32")::["checked_add"] Œ±1 Œ±3) in
        let* Œ±5 : Ty.apply (Ty.path "ref") [Ty.path "str"] :=
          M.read (mk_str "Transaction ids exhausted.") in
        let* Œ±6 : Ty.path "u32" :=
          M.call
            ((Ty.apply
                  (Ty.path "core::option::Option")
                  [Ty.path "u32"])::["expect"]
              Œ±4
              Œ±5) in
        assign
          (multisig.Transactions.Get_next_id
            (multisig.Multisig.Get_transaction_list (deref Œ±0)))
          Œ±6 in
      let* _ : Ty.apply (Ty.path "core::option::Option") [Ty.path "u32"] :=
        let* Œ±0 :
            Ty.apply
              (Ty.path "mut_ref")
              [Ty.apply (Ty.path "multisig::Multisig") []] :=
          M.read self in
        let* Œ±1 : Ty.path "u32" := M.read trans_id in
        let* Œ±2 : Ty.apply (Ty.path "multisig::Transaction") [] :=
          M.read transaction in
        let* Œ±3 : Ty.apply (Ty.path "core::option::Option") [Ty.path "u32"] :=
          M.call
            ((Ty.apply
                  (Ty.path "multisig::Mapping")
                  [Ty.path "u32";
                    Ty.apply (Ty.path "multisig::Transaction") []])::["insert"]
              (borrow_mut (multisig.Multisig.Get_transactions (deref Œ±0)))
              Œ±1
              Œ±2) in
        M.alloc Œ±3 in
      let* _ : Ty.tuple :=
        let* Œ±0 :
            Ty.apply
              (Ty.path "mut_ref")
              [Ty.apply (Ty.path "multisig::Multisig") []] :=
          M.read self in
        let* Œ±1 : Ty.path "u32" := M.read trans_id in
        let* Œ±2 : Ty.tuple :=
          M.call
            ((Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  [Ty.path "u32";
                    Ty.apply (Ty.path "alloc::alloc::Global") []])::["push"]
              (borrow_mut
                (multisig.Transactions.Get_transactions
                  (multisig.Multisig.Get_transaction_list (deref Œ±0))))
              Œ±1) in
        M.alloc Œ±2 in
      let* _ : Ty.tuple :=
        let* Œ±0 :
            Ty.apply
              (Ty.path "mut_ref")
              [Ty.apply (Ty.path "multisig::Multisig") []] :=
          M.read self in
        let* Œ±1 : Ty.apply (Ty.path "multisig::Env") [] :=
          M.call
            ((Ty.apply (Ty.path "multisig::Multisig") [])::["env"]
              (borrow (deref Œ±0))) in
        let* Œ±2 : Ty.apply (Ty.path "multisig::Env") [] := M.alloc Œ±1 in
        let* Œ±3 : Ty.path "u32" := M.read trans_id in
        let* Œ±4 : Ty.tuple :=
          M.call
            ((Ty.apply (Ty.path "multisig::Env") [])::["emit_event"]
              (borrow Œ±2)
              (multisig.Event.Submission
                {| multisig.Submission.transaction := Œ±3; |})) in
        M.alloc Œ±4 in
      let* Œ±0 : Ty.path "u32" := M.read trans_id in
      let* Œ±1 :
          Ty.apply
            (Ty.path "mut_ref")
            [Ty.apply (Ty.path "multisig::Multisig") []] :=
        M.read self in
      let* Œ±2 :
          Ty.apply
            (Ty.path "mut_ref")
            [Ty.apply (Ty.path "multisig::Multisig") []] :=
        M.read self in
      let* Œ±3 : Ty.apply (Ty.path "multisig::Env") [] :=
        M.call
          ((Ty.apply (Ty.path "multisig::Multisig") [])::["env"]
            (borrow (deref Œ±2))) in
      let* Œ±4 : Ty.apply (Ty.path "multisig::Env") [] := M.alloc Œ±3 in
      let* Œ±5 : Ty.apply (Ty.path "multisig::AccountId") [] :=
        M.call
          ((Ty.apply (Ty.path "multisig::Env") [])::["caller"] (borrow Œ±4)) in
      let* Œ±6 : Ty.path "u32" := M.read trans_id in
      let* Œ±7 : Ty.apply (Ty.path "multisig::ConfirmationStatus") [] :=
        M.call
          ((Ty.apply (Ty.path "multisig::Multisig") [])::["confirm_by_caller"]
            Œ±1
            Œ±5
            Œ±6) in
      let* Œ±0 :
          Ty.tuple
            (Ty.path "u32")
            (Ty.apply (Ty.path "multisig::ConfirmationStatus") []) :=
        M.alloc (Œ±0, Œ±7) in
      M.read Œ±0
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_submit_transaction : Instance.t := {
    Notations.double_colon := submit_transaction;
  }.
  
  (*
      fn take_transaction(&mut self, trans_id: TransactionId) -> Option<Transaction> {
          let transaction = self.transactions.get(&trans_id);
          if transaction.is_some() {
              self.transactions.remove(trans_id);
              let pos = self
                  .transaction_list
                  .transactions
                  .iter()
                  .position(|t| t == &trans_id)
                  .expect("The transaction exists hence it must also be in the list.");
              self.transaction_list.transactions.swap_remove(pos);
              for owner in self.owners.iter() {
                  self.confirmations.remove((trans_id, *owner));
              }
              self.confirmation_count.remove(trans_id);
          }
          transaction
      }
  *)
  Definition take_transaction (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self; trans_id] =>
      let* self := M.alloc self in
      let* trans_id := M.alloc trans_id in
      let* transaction :
          Ty.apply
            (Ty.path "core::option::Option")
            [Ty.apply (Ty.path "multisig::Transaction") []] :=
        let* Œ±0 :
            Ty.apply
              (Ty.path "mut_ref")
              [Ty.apply (Ty.path "multisig::Multisig") []] :=
          M.read self in
        let* Œ±1 :
            Ty.apply
              (Ty.path "core::option::Option")
              [Ty.apply (Ty.path "multisig::Transaction") []] :=
          M.call
            ((Ty.apply
                  (Ty.path "multisig::Mapping")
                  [Ty.path "u32";
                    Ty.apply (Ty.path "multisig::Transaction") []])::["get"]
              (borrow (multisig.Multisig.Get_transactions (deref Œ±0)))
              (borrow trans_id)) in
        M.alloc Œ±1 in
      let* _ : Ty.tuple :=
        let* Œ±0 : Ty.path "bool" :=
          M.call
            ((Ty.apply
                  (Ty.path "core::option::Option")
                  [Ty.apply (Ty.path "multisig::Transaction") []])::["is_some"]
              (borrow transaction)) in
        let* Œ±1 : Ty.path "bool" := M.alloc Œ±0 in
        let* Œ±2 : Ty.path "bool" := M.read (use Œ±1) in
        if Œ±2 then
          let* _ : Ty.tuple :=
            let* Œ±0 :
                Ty.apply
                  (Ty.path "mut_ref")
                  [Ty.apply (Ty.path "multisig::Multisig") []] :=
              M.read self in
            let* Œ±1 : Ty.path "u32" := M.read trans_id in
            let* Œ±2 : Ty.tuple :=
              M.call
                ((Ty.apply
                      (Ty.path "multisig::Mapping")
                      [Ty.path "u32";
                        Ty.apply
                          (Ty.path "multisig::Transaction")
                          []])::["remove"]
                  (borrow (multisig.Multisig.Get_transactions (deref Œ±0)))
                  Œ±1) in
            M.alloc Œ±2 in
          let* pos : Ty.path "usize" :=
            let* Œ±0 :
                Ty.function
                  [Ty.apply
                      (Ty.path "mut_ref")
                      [Ty.apply
                          (Ty.path "core::slice::iter::Iter")
                          [Ty.path "u32"]];
                    Ty.function
                      [Ty.tuple (Ty.apply (Ty.path "ref") [Ty.path "u32"])]
                      (Ty.path "bool")]
                  (Ty.apply
                    (Ty.path "core::option::Option")
                    [Ty.path "usize"]) :=
              ltac:(M.get_method (fun ‚Ñê =>
                core.iter.traits.iterator.Iterator.position
                  (Self :=
                    Ty.apply
                      (Ty.path "core::slice::iter::Iter")
                      [Ty.path "u32"])
                  (P :=
                    Ty.function
                      [Ty.tuple (Ty.apply (Ty.path "ref") [Ty.path "u32"])]
                      (Ty.path "bool"))
                  (Trait := ‚Ñê))) in
            let* Œ±1 :
                Ty.function
                  [Ty.apply
                      (Ty.path "ref")
                      [Ty.apply
                          (Ty.path "alloc::vec::Vec")
                          [Ty.path "u32";
                            Ty.apply (Ty.path "alloc::alloc::Global") []]]]
                  (Ty.apply (Ty.path "ref") [_]) :=
              ltac:(M.get_method (fun ‚Ñê =>
                core.ops.deref.Deref.deref
                  (Self :=
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      [Ty.path "u32";
                        Ty.apply (Ty.path "alloc::alloc::Global") []])
                  (Trait := ‚Ñê))) in
            let* Œ±2 :
                Ty.apply
                  (Ty.path "mut_ref")
                  [Ty.apply (Ty.path "multisig::Multisig") []] :=
              M.read self in
            let* Œ±3 :
                Ty.apply
                  (Ty.path "ref")
                  [Ty.apply (Ty.path "slice") [Ty.path "u32"]] :=
              M.call
                (Œ±1
                  (borrow
                    (multisig.Transactions.Get_transactions
                      (multisig.Multisig.Get_transaction_list (deref Œ±2))))) in
            let* Œ±4 :
                Ty.apply (Ty.path "core::slice::iter::Iter") [Ty.path "u32"] :=
              M.call
                ((Ty.apply (Ty.path "slice") [Ty.path "u32"])::["iter"] Œ±3) in
            let* Œ±5 :
                Ty.apply (Ty.path "core::slice::iter::Iter") [Ty.path "u32"] :=
              M.alloc Œ±4 in
            let* Œ±6 :
                Ty.apply (Ty.path "core::option::Option") [Ty.path "usize"] :=
              M.call
                (Œ±0
                  (borrow_mut Œ±5)
                  (fun (Œ±0 : Ty.apply (Ty.path "ref") [Ty.path "u32"]) =>
                    (let* Œ±0 := M.alloc Œ±0 in
                    match_operator
                      Œ±0
                      [
                        fun Œ≥ =>
                          (let* t := M.copy Œ≥ in
                          let* Œ±0 :
                              Ty.function
                                [Ty.apply
                                    (Ty.path "ref")
                                    [Ty.apply (Ty.path "ref") [Ty.path "u32"]];
                                  Ty.apply
                                    (Ty.path "ref")
                                    [Ty.apply (Ty.path "ref") [Ty.path "u32"]]]
                                (Ty.path "bool") :=
                            ltac:(M.get_method (fun ‚Ñê =>
                              core.cmp.PartialEq.eq
                                (Self :=
                                  Ty.apply (Ty.path "ref") [Ty.path "u32"])
                                (Rhs :=
                                  Ty.apply (Ty.path "ref") [Ty.path "u32"])
                                (Trait := ‚Ñê))) in
                          let* Œ±1 : Ty.apply (Ty.path "ref") [Ty.path "u32"] :=
                            M.alloc (borrow trans_id) in
                          M.call (Œ±0 (borrow t) (borrow Œ±1))) :
                          Ty.path "bool"
                      ]) :
                    Ty.path "bool")) in
            let* Œ±7 : Ty.apply (Ty.path "ref") [Ty.path "str"] :=
              M.read
                (mk_str
                  "The transaction exists hence it must also be in the list.") in
            let* Œ±8 : Ty.path "usize" :=
              M.call
                ((Ty.apply
                      (Ty.path "core::option::Option")
                      [Ty.path "usize"])::["expect"]
                  Œ±6
                  Œ±7) in
            M.alloc Œ±8 in
          let* _ : Ty.path "u32" :=
            let* Œ±0 :
                Ty.apply
                  (Ty.path "mut_ref")
                  [Ty.apply (Ty.path "multisig::Multisig") []] :=
              M.read self in
            let* Œ±1 : Ty.path "usize" := M.read pos in
            let* Œ±2 : Ty.path "u32" :=
              M.call
                ((Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      [Ty.path "u32";
                        Ty.apply
                          (Ty.path "alloc::alloc::Global")
                          []])::["swap_remove"]
                  (borrow_mut
                    (multisig.Transactions.Get_transactions
                      (multisig.Multisig.Get_transaction_list (deref Œ±0))))
                  Œ±1) in
            M.alloc Œ±2 in
          let* _ : Ty.tuple :=
            let* Œ±0 :
                Ty.function
                  [Ty.apply
                      (Ty.path "core::slice::iter::Iter")
                      [Ty.apply (Ty.path "multisig::AccountId") []]]
                  _ :=
              ltac:(M.get_method (fun ‚Ñê =>
                core.iter.traits.collect.IntoIterator.into_iter
                  (Self :=
                    Ty.apply
                      (Ty.path "core::slice::iter::Iter")
                      [Ty.apply (Ty.path "multisig::AccountId") []])
                  (Trait := ‚Ñê))) in
            let* Œ±1 :
                Ty.function
                  [Ty.apply
                      (Ty.path "ref")
                      [Ty.apply
                          (Ty.path "alloc::vec::Vec")
                          [Ty.apply (Ty.path "multisig::AccountId") [];
                            Ty.apply (Ty.path "alloc::alloc::Global") []]]]
                  (Ty.apply (Ty.path "ref") [_]) :=
              ltac:(M.get_method (fun ‚Ñê =>
                core.ops.deref.Deref.deref
                  (Self :=
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      [Ty.apply (Ty.path "multisig::AccountId") [];
                        Ty.apply (Ty.path "alloc::alloc::Global") []])
                  (Trait := ‚Ñê))) in
            let* Œ±2 :
                Ty.apply
                  (Ty.path "mut_ref")
                  [Ty.apply (Ty.path "multisig::Multisig") []] :=
              M.read self in
            let* Œ±3 :
                Ty.apply
                  (Ty.path "ref")
                  [Ty.apply
                      (Ty.path "slice")
                      [Ty.apply (Ty.path "multisig::AccountId") []]] :=
              M.call (Œ±1 (borrow (multisig.Multisig.Get_owners (deref Œ±2)))) in
            let* Œ±4 :
                Ty.apply
                  (Ty.path "core::slice::iter::Iter")
                  [Ty.apply (Ty.path "multisig::AccountId") []] :=
              M.call
                ((Ty.apply
                      (Ty.path "slice")
                      [Ty.apply (Ty.path "multisig::AccountId") []])::["iter"]
                  Œ±3) in
            let* Œ±5 :
                Ty.apply
                  (Ty.path "core::slice::iter::Iter")
                  [Ty.apply (Ty.path "multisig::AccountId") []] :=
              M.call (Œ±0 Œ±4) in
            let* Œ±6 :
                Ty.apply
                  (Ty.path "core::slice::iter::Iter")
                  [Ty.apply (Ty.path "multisig::AccountId") []] :=
              M.alloc Œ±5 in
            let* Œ±7 : Ty.tuple :=
              match_operator
                Œ±6
                [
                  fun Œ≥ =>
                    (let* iter := M.copy Œ≥ in
                    M.loop
                      (let* _ : Ty.tuple :=
                        let* Œ±0 :
                            Ty.function
                              [Ty.apply
                                  (Ty.path "mut_ref")
                                  [Ty.apply
                                      (Ty.path "core::slice::iter::Iter")
                                      [Ty.apply
                                          (Ty.path "multisig::AccountId")
                                          []]]]
                              (Ty.apply (Ty.path "core::option::Option") [_]) :=
                          ltac:(M.get_method (fun ‚Ñê =>
                            core.iter.traits.iterator.Iterator.next
                              (Self :=
                                Ty.apply
                                  (Ty.path "core::slice::iter::Iter")
                                  [Ty.apply (Ty.path "multisig::AccountId") []])
                              (Trait := ‚Ñê))) in
                        let* Œ±1 :
                            Ty.apply
                              (Ty.path "core::option::Option")
                              [Ty.apply
                                  (Ty.path "ref")
                                  [Ty.apply
                                      (Ty.path "multisig::AccountId")
                                      []]] :=
                          M.call (Œ±0 (borrow_mut iter)) in
                        let* Œ±2 :
                            Ty.apply
                              (Ty.path "core::option::Option")
                              [Ty.apply
                                  (Ty.path "ref")
                                  [Ty.apply
                                      (Ty.path "multisig::AccountId")
                                      []]] :=
                          M.alloc Œ±1 in
                        match_operator
                          Œ±2
                          [
                            fun Œ≥ =>
                              (let* Œ±0 := M.read Œ≥ in
                              match Œ±0 with
                              | core.option.Option.None =>
                                let* Œ±0 : Ty.path "never" := M.break in
                                let* Œ±1 : Ty.path "never" := M.read Œ±0 in
                                let* Œ±2 : Ty.tuple := never_to_any Œ±1 in
                                M.alloc Œ±2
                              | _ => M.break_match
                              end) :
                              Ty.tuple;
                            fun Œ≥ =>
                              (let* Œ±0 := M.read Œ≥ in
                              match Œ±0 with
                              | core.option.Option.Some _ =>
                                let Œ≥0_0 := core.option.Option.Get_Some_0 Œ≥ in
                                let* owner := M.copy Œ≥0_0 in
                                let* _ : Ty.tuple :=
                                  let* Œ±0 :
                                      Ty.apply
                                        (Ty.path "mut_ref")
                                        [Ty.apply
                                            (Ty.path "multisig::Multisig")
                                            []] :=
                                    M.read self in
                                  let* Œ±1 : Ty.path "u32" := M.read trans_id in
                                  let* Œ±2 :
                                      Ty.apply
                                        (Ty.path "ref")
                                        [Ty.apply
                                            (Ty.path "multisig::AccountId")
                                            []] :=
                                    M.read owner in
                                  let* Œ±3 :
                                      Ty.apply
                                        (Ty.path "multisig::AccountId")
                                        [] :=
                                    M.read (deref Œ±2) in
                                  let* Œ±4 : Ty.tuple :=
                                    M.call
                                      ((Ty.apply
                                            (Ty.path "multisig::Mapping")
                                            [Ty.tuple
                                                (Ty.path "u32")
                                                (Ty.apply
                                                  (Ty.path
                                                    "multisig::AccountId")
                                                  []);
                                              Ty.tuple])::["remove"]
                                        (borrow
                                          (multisig.Multisig.Get_confirmations
                                            (deref Œ±0)))
                                        (Œ±1, Œ±3)) in
                                  M.alloc Œ±4 in
                                M.alloc tt
                              | _ => M.break_match
                              end) :
                              Ty.tuple
                          ] in
                      M.alloc tt)) :
                    Ty.tuple
                ] in
            M.pure (use Œ±7) in
          let* _ : Ty.tuple :=
            let* Œ±0 :
                Ty.apply
                  (Ty.path "mut_ref")
                  [Ty.apply (Ty.path "multisig::Multisig") []] :=
              M.read self in
            let* Œ±1 : Ty.path "u32" := M.read trans_id in
            let* Œ±2 : Ty.tuple :=
              M.call
                ((Ty.apply
                      (Ty.path "multisig::Mapping")
                      [Ty.path "u32"; Ty.path "u32"])::["remove"]
                  (borrow (multisig.Multisig.Get_confirmation_count (deref Œ±0)))
                  Œ±1) in
            M.alloc Œ±2 in
          M.alloc tt
        else
          M.alloc tt in
      M.read transaction
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_take_transaction : Instance.t := {
    Notations.double_colon := take_transaction;
  }.
  
  (*
      pub fn cancel_transaction(&mut self, trans_id: TransactionId) {
          self.ensure_from_wallet();
          if self.take_transaction(trans_id).is_some() {
              self.env().emit_event(Event::Cancellation(Cancellation {
                  transaction: trans_id,
              }));
          }
      }
  *)
  Definition cancel_transaction (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self; trans_id] =>
      let* self := M.alloc self in
      let* trans_id := M.alloc trans_id in
      let* _ : Ty.tuple :=
        let* Œ±0 :
            Ty.apply
              (Ty.path "mut_ref")
              [Ty.apply (Ty.path "multisig::Multisig") []] :=
          M.read self in
        let* Œ±1 : Ty.tuple :=
          M.call
            ((Ty.apply
                  (Ty.path "multisig::Multisig")
                  [])::["ensure_from_wallet"]
              (borrow (deref Œ±0))) in
        M.alloc Œ±1 in
      let* Œ±0 :
          Ty.apply
            (Ty.path "mut_ref")
            [Ty.apply (Ty.path "multisig::Multisig") []] :=
        M.read self in
      let* Œ±1 : Ty.path "u32" := M.read trans_id in
      let* Œ±2 :
          Ty.apply
            (Ty.path "core::option::Option")
            [Ty.apply (Ty.path "multisig::Transaction") []] :=
        M.call
          ((Ty.apply (Ty.path "multisig::Multisig") [])::["take_transaction"]
            Œ±0
            Œ±1) in
      let* Œ±3 :
          Ty.apply
            (Ty.path "core::option::Option")
            [Ty.apply (Ty.path "multisig::Transaction") []] :=
        M.alloc Œ±2 in
      let* Œ±4 : Ty.path "bool" :=
        M.call
          ((Ty.apply
                (Ty.path "core::option::Option")
                [Ty.apply (Ty.path "multisig::Transaction") []])::["is_some"]
            (borrow Œ±3)) in
      let* Œ±5 : Ty.path "bool" := M.alloc Œ±4 in
      let* Œ±6 : Ty.path "bool" := M.read (use Œ±5) in
      let* Œ±0 : Ty.tuple :=
        if Œ±6 then
          let* _ : Ty.tuple :=
            let* Œ±0 :
                Ty.apply
                  (Ty.path "mut_ref")
                  [Ty.apply (Ty.path "multisig::Multisig") []] :=
              M.read self in
            let* Œ±1 : Ty.apply (Ty.path "multisig::Env") [] :=
              M.call
                ((Ty.apply (Ty.path "multisig::Multisig") [])::["env"]
                  (borrow (deref Œ±0))) in
            let* Œ±2 : Ty.apply (Ty.path "multisig::Env") [] := M.alloc Œ±1 in
            let* Œ±3 : Ty.path "u32" := M.read trans_id in
            let* Œ±4 : Ty.tuple :=
              M.call
                ((Ty.apply (Ty.path "multisig::Env") [])::["emit_event"]
                  (borrow Œ±2)
                  (multisig.Event.Cancellation
                    {| multisig.Cancellation.transaction := Œ±3; |})) in
            M.alloc Œ±4 in
          M.alloc tt
        else
          M.alloc tt in
      M.read Œ±0
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_cancel_transaction : Instance.t := {
    Notations.double_colon := cancel_transaction;
  }.
  
  (*
      pub fn confirm_transaction(&mut self, trans_id: TransactionId) -> ConfirmationStatus {
          self.ensure_caller_is_owner();
          self.ensure_transaction_exists(trans_id);
          self.confirm_by_caller(self.env().caller(), trans_id)
      }
  *)
  Definition confirm_transaction (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self; trans_id] =>
      let* self := M.alloc self in
      let* trans_id := M.alloc trans_id in
      let* _ : Ty.tuple :=
        let* Œ±0 :
            Ty.apply
              (Ty.path "mut_ref")
              [Ty.apply (Ty.path "multisig::Multisig") []] :=
          M.read self in
        let* Œ±1 : Ty.tuple :=
          M.call
            ((Ty.apply
                  (Ty.path "multisig::Multisig")
                  [])::["ensure_caller_is_owner"]
              (borrow (deref Œ±0))) in
        M.alloc Œ±1 in
      let* _ : Ty.tuple :=
        let* Œ±0 :
            Ty.apply
              (Ty.path "mut_ref")
              [Ty.apply (Ty.path "multisig::Multisig") []] :=
          M.read self in
        let* Œ±1 : Ty.path "u32" := M.read trans_id in
        let* Œ±2 : Ty.tuple :=
          M.call
            ((Ty.apply
                  (Ty.path "multisig::Multisig")
                  [])::["ensure_transaction_exists"]
              (borrow (deref Œ±0))
              Œ±1) in
        M.alloc Œ±2 in
      let* Œ±0 :
          Ty.apply
            (Ty.path "mut_ref")
            [Ty.apply (Ty.path "multisig::Multisig") []] :=
        M.read self in
      let* Œ±1 :
          Ty.apply
            (Ty.path "mut_ref")
            [Ty.apply (Ty.path "multisig::Multisig") []] :=
        M.read self in
      let* Œ±2 : Ty.apply (Ty.path "multisig::Env") [] :=
        M.call
          ((Ty.apply (Ty.path "multisig::Multisig") [])::["env"]
            (borrow (deref Œ±1))) in
      let* Œ±3 : Ty.apply (Ty.path "multisig::Env") [] := M.alloc Œ±2 in
      let* Œ±4 : Ty.apply (Ty.path "multisig::AccountId") [] :=
        M.call
          ((Ty.apply (Ty.path "multisig::Env") [])::["caller"] (borrow Œ±3)) in
      let* Œ±5 : Ty.path "u32" := M.read trans_id in
      let* Œ±6 : Ty.apply (Ty.path "multisig::ConfirmationStatus") [] :=
        M.call
          ((Ty.apply (Ty.path "multisig::Multisig") [])::["confirm_by_caller"]
            Œ±0
            Œ±4
            Œ±5) in
      let* Œ±0 : Ty.apply (Ty.path "multisig::ConfirmationStatus") [] :=
        M.alloc Œ±6 in
      M.read Œ±0
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_confirm_transaction : Instance.t := {
    Notations.double_colon := confirm_transaction;
  }.
  
  (*
      pub fn revoke_confirmation(&mut self, trans_id: TransactionId) {
          self.ensure_caller_is_owner();
          let caller = self.env().caller();
          if self.confirmations.contains(&(trans_id, caller)) {
              self.confirmations.remove((trans_id, caller));
              let mut confirmation_count = self
                  .confirmation_count
                  .get(&trans_id)
                  .expect("There is a entry in `self.confirmations`. Hence a count must exit.");
              // Will not underflow as there is at least one confirmation
              confirmation_count -= 1;
              self.confirmation_count.insert(trans_id, confirmation_count);
              self.env().emit_event(Event::Revocation(Revocation {
                  transaction: trans_id,
                  from: caller,
              }));
          }
      }
  *)
  Definition revoke_confirmation (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self; trans_id] =>
      let* self := M.alloc self in
      let* trans_id := M.alloc trans_id in
      let* _ : Ty.tuple :=
        let* Œ±0 :
            Ty.apply
              (Ty.path "mut_ref")
              [Ty.apply (Ty.path "multisig::Multisig") []] :=
          M.read self in
        let* Œ±1 : Ty.tuple :=
          M.call
            ((Ty.apply
                  (Ty.path "multisig::Multisig")
                  [])::["ensure_caller_is_owner"]
              (borrow (deref Œ±0))) in
        M.alloc Œ±1 in
      let* caller : Ty.apply (Ty.path "multisig::AccountId") [] :=
        let* Œ±0 :
            Ty.apply
              (Ty.path "mut_ref")
              [Ty.apply (Ty.path "multisig::Multisig") []] :=
          M.read self in
        let* Œ±1 : Ty.apply (Ty.path "multisig::Env") [] :=
          M.call
            ((Ty.apply (Ty.path "multisig::Multisig") [])::["env"]
              (borrow (deref Œ±0))) in
        let* Œ±2 : Ty.apply (Ty.path "multisig::Env") [] := M.alloc Œ±1 in
        let* Œ±3 : Ty.apply (Ty.path "multisig::AccountId") [] :=
          M.call
            ((Ty.apply (Ty.path "multisig::Env") [])::["caller"] (borrow Œ±2)) in
        M.alloc Œ±3 in
      let* Œ±0 :
          Ty.apply
            (Ty.path "mut_ref")
            [Ty.apply (Ty.path "multisig::Multisig") []] :=
        M.read self in
      let* Œ±1 : Ty.path "u32" := M.read trans_id in
      let* Œ±2 : Ty.apply (Ty.path "multisig::AccountId") [] := M.read caller in
      let* Œ±3 :
          Ty.tuple
            (Ty.path "u32")
            (Ty.apply (Ty.path "multisig::AccountId") []) :=
        M.alloc (Œ±1, Œ±2) in
      let* Œ±4 : Ty.path "bool" :=
        M.call
          ((Ty.apply
                (Ty.path "multisig::Mapping")
                [Ty.tuple
                    (Ty.path "u32")
                    (Ty.apply (Ty.path "multisig::AccountId") []);
                  Ty.tuple])::["contains"]
            (borrow (multisig.Multisig.Get_confirmations (deref Œ±0)))
            (borrow Œ±3)) in
      let* Œ±5 : Ty.path "bool" := M.alloc Œ±4 in
      let* Œ±6 : Ty.path "bool" := M.read (use Œ±5) in
      let* Œ±0 : Ty.tuple :=
        if Œ±6 then
          let* _ : Ty.tuple :=
            let* Œ±0 :
                Ty.apply
                  (Ty.path "mut_ref")
                  [Ty.apply (Ty.path "multisig::Multisig") []] :=
              M.read self in
            let* Œ±1 : Ty.path "u32" := M.read trans_id in
            let* Œ±2 : Ty.apply (Ty.path "multisig::AccountId") [] :=
              M.read caller in
            let* Œ±3 : Ty.tuple :=
              M.call
                ((Ty.apply
                      (Ty.path "multisig::Mapping")
                      [Ty.tuple
                          (Ty.path "u32")
                          (Ty.apply (Ty.path "multisig::AccountId") []);
                        Ty.tuple])::["remove"]
                  (borrow (multisig.Multisig.Get_confirmations (deref Œ±0)))
                  (Œ±1, Œ±2)) in
            M.alloc Œ±3 in
          let* confirmation_count : Ty.path "u32" :=
            let* Œ±0 :
                Ty.apply
                  (Ty.path "mut_ref")
                  [Ty.apply (Ty.path "multisig::Multisig") []] :=
              M.read self in
            let* Œ±1 :
                Ty.apply (Ty.path "core::option::Option") [Ty.path "u32"] :=
              M.call
                ((Ty.apply
                      (Ty.path "multisig::Mapping")
                      [Ty.path "u32"; Ty.path "u32"])::["get"]
                  (borrow (multisig.Multisig.Get_confirmation_count (deref Œ±0)))
                  (borrow trans_id)) in
            let* Œ±2 : Ty.apply (Ty.path "ref") [Ty.path "str"] :=
              M.read
                (mk_str
                  "There is a entry in `self.confirmations`. Hence a count must exit.") in
            let* Œ±3 : Ty.path "u32" :=
              M.call
                ((Ty.apply
                      (Ty.path "core::option::Option")
                      [Ty.path "u32"])::["expect"]
                  Œ±1
                  Œ±2) in
            M.alloc Œ±3 in
          let* _ : Ty.tuple :=
            let Œ≤ : Ty.path "u32" := confirmation_count in
            let* Œ±0 := M.read Œ≤ in
            let* Œ±1 := BinOp.Panic.sub Œ±0 ((Integer.of_Z 1) : Ty.path "u32") in
            assign Œ≤ Œ±1 in
          let* _ : Ty.apply (Ty.path "core::option::Option") [Ty.path "u32"] :=
            let* Œ±0 :
                Ty.apply
                  (Ty.path "mut_ref")
                  [Ty.apply (Ty.path "multisig::Multisig") []] :=
              M.read self in
            let* Œ±1 : Ty.path "u32" := M.read trans_id in
            let* Œ±2 : Ty.path "u32" := M.read confirmation_count in
            let* Œ±3 :
                Ty.apply (Ty.path "core::option::Option") [Ty.path "u32"] :=
              M.call
                ((Ty.apply
                      (Ty.path "multisig::Mapping")
                      [Ty.path "u32"; Ty.path "u32"])::["insert"]
                  (borrow_mut
                    (multisig.Multisig.Get_confirmation_count (deref Œ±0)))
                  Œ±1
                  Œ±2) in
            M.alloc Œ±3 in
          let* _ : Ty.tuple :=
            let* Œ±0 :
                Ty.apply
                  (Ty.path "mut_ref")
                  [Ty.apply (Ty.path "multisig::Multisig") []] :=
              M.read self in
            let* Œ±1 : Ty.apply (Ty.path "multisig::Env") [] :=
              M.call
                ((Ty.apply (Ty.path "multisig::Multisig") [])::["env"]
                  (borrow (deref Œ±0))) in
            let* Œ±2 : Ty.apply (Ty.path "multisig::Env") [] := M.alloc Œ±1 in
            let* Œ±3 : Ty.path "u32" := M.read trans_id in
            let* Œ±4 : Ty.apply (Ty.path "multisig::AccountId") [] :=
              M.read caller in
            let* Œ±5 : Ty.tuple :=
              M.call
                ((Ty.apply (Ty.path "multisig::Env") [])::["emit_event"]
                  (borrow Œ±2)
                  (multisig.Event.Revocation
                    {|
                      multisig.Revocation.transaction := Œ±3;
                      multisig.Revocation.from := Œ±4;
                    |})) in
            M.alloc Œ±5 in
          M.alloc tt
        else
          M.alloc tt in
      M.read Œ±0
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_revoke_confirmation : Instance.t := {
    Notations.double_colon := revoke_confirmation;
  }.
  
  (*
      pub fn invoke_transaction(&mut self, trans_id: TransactionId) -> Result<(), Error> {
          self.ensure_confirmed(trans_id);
          let t = self.take_transaction(trans_id).expect(WRONG_TRANSACTION_ID);
          assert!(self.env().transferred_value() == t.transferred_value);
          // let result = build_call()
          //     .call(t.callee)
          //     .gas_limit(t.gas_limit)
          //     .transferred_value(t.transferred_value)
          //     .call_flags(CallFlags::default().set_allow_reentry(t.allow_reentry))
          //     .exec_input(ExecutionInput::new(t.selector.into()).push_arg(CallInput(&t.input)))
          //     .returns::<()>()
          //     .try_invoke();
          let result: Result<Result<Vec<u8>, ()>, ()> = todo!();
  
          let result = match result {
              Ok(Ok(_)) => Ok(()),
              _ => Err(Error::TransactionFailed),
          };
  
          self.env().emit_event(Event::Execution(Execution {
              transaction: trans_id,
              result: result.map(|_| None),
          }));
          result
      }
  *)
  Definition invoke_transaction (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self; trans_id] =>
      let* self := M.alloc self in
      let* trans_id := M.alloc trans_id in
      let* _ : Ty.tuple :=
        let* Œ±0 :
            Ty.apply
              (Ty.path "mut_ref")
              [Ty.apply (Ty.path "multisig::Multisig") []] :=
          M.read self in
        let* Œ±1 : Ty.path "u32" := M.read trans_id in
        let* Œ±2 : Ty.tuple :=
          M.call
            ((Ty.apply (Ty.path "multisig::Multisig") [])::["ensure_confirmed"]
              (borrow (deref Œ±0))
              Œ±1) in
        M.alloc Œ±2 in
      let* t : Ty.apply (Ty.path "multisig::Transaction") [] :=
        let* Œ±0 :
            Ty.apply
              (Ty.path "mut_ref")
              [Ty.apply (Ty.path "multisig::Multisig") []] :=
          M.read self in
        let* Œ±1 : Ty.path "u32" := M.read trans_id in
        let* Œ±2 :
            Ty.apply
              (Ty.path "core::option::Option")
              [Ty.apply (Ty.path "multisig::Transaction") []] :=
          M.call
            ((Ty.apply (Ty.path "multisig::Multisig") [])::["take_transaction"]
              Œ±0
              Œ±1) in
        let* Œ±3 : Ty.apply (Ty.path "ref") [Ty.path "str"] :=
          M.read multisig.WRONG_TRANSACTION_ID in
        let* Œ±4 : Ty.apply (Ty.path "multisig::Transaction") [] :=
          M.call
            ((Ty.apply
                  (Ty.path "core::option::Option")
                  [Ty.apply (Ty.path "multisig::Transaction") []])::["expect"]
              Œ±2
              Œ±3) in
        M.alloc Œ±4 in
      let* _ : Ty.tuple :=
        let* Œ±0 :
            Ty.apply
              (Ty.path "mut_ref")
              [Ty.apply (Ty.path "multisig::Multisig") []] :=
          M.read self in
        let* Œ±1 : Ty.apply (Ty.path "multisig::Env") [] :=
          M.call
            ((Ty.apply (Ty.path "multisig::Multisig") [])::["env"]
              (borrow (deref Œ±0))) in
        let* Œ±2 : Ty.apply (Ty.path "multisig::Env") [] := M.alloc Œ±1 in
        let* Œ±3 : Ty.path "u128" :=
          M.call
            ((Ty.apply (Ty.path "multisig::Env") [])::["transferred_value"]
              (borrow Œ±2)) in
        let* Œ±4 : Ty.path "u128" :=
          M.read (multisig.Transaction.Get_transferred_value t) in
        let* Œ±5 : Ty.path "bool" := M.alloc (UnOp.not (BinOp.Pure.eq Œ±3 Œ±4)) in
        let* Œ±6 : Ty.path "bool" := M.read (use Œ±5) in
        if Œ±6 then
          let* Œ±0 : Ty.apply (Ty.path "ref") [Ty.path "str"] :=
            M.read
              (mk_str
                "assertion failed: self.env().transferred_value() == t.transferred_value") in
          let* Œ±1 : Ty.path "never" := M.call (core.panicking.panic Œ±0) in
          let* Œ±2 : Ty.tuple := never_to_any Œ±1 in
          M.alloc Œ±2
        else
          M.alloc tt in
      let* result :
          Ty.apply
            (Ty.path "core::result::Result")
            [Ty.apply
                (Ty.path "core::result::Result")
                [Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    [Ty.path "u8";
                      Ty.apply (Ty.path "alloc::alloc::Global") []];
                  Ty.tuple];
              Ty.tuple] :=
        let* Œ±0 : Ty.apply (Ty.path "ref") [Ty.path "str"] :=
          M.read (mk_str "not yet implemented") in
        let* Œ±1 : Ty.path "never" := M.call (core.panicking.panic Œ±0) in
        let* Œ±2 :
            Ty.apply
              (Ty.path "core::result::Result")
              [Ty.apply
                  (Ty.path "core::result::Result")
                  [Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      [Ty.path "u8";
                        Ty.apply (Ty.path "alloc::alloc::Global") []];
                    Ty.tuple];
                Ty.tuple] :=
          never_to_any Œ±1 in
        M.alloc Œ±2 in
      let* result :
          Ty.apply
            (Ty.path "core::result::Result")
            [Ty.tuple; Ty.apply (Ty.path "multisig::Error") []] :=
        let* Œ±0 :
            Ty.apply
              (Ty.path "core::result::Result")
              [Ty.tuple; Ty.apply (Ty.path "multisig::Error") []] :=
          match_operator
            result
            [
              fun Œ≥ =>
                (let* Œ±0 := M.read Œ≥ in
                match Œ±0 with
                | core.result.Result.Ok _ =>
                  let Œ≥0_0 := core.result.Result.Get_Ok_0 Œ≥ in
                  let* Œ±0 := M.read Œ≥0_0 in
                  match Œ±0 with
                  | core.result.Result.Ok _ =>
                    let Œ≥1_0 := core.result.Result.Get_Ok_0 Œ≥0_0 in
                    M.alloc (core.result.Result.Ok tt)
                  | _ => M.break_match
                  end
                | _ => M.break_match
                end) :
                Ty.apply
                  (Ty.path "core::result::Result")
                  [Ty.tuple; Ty.apply (Ty.path "multisig::Error") []];
              fun Œ≥ =>
                (M.alloc
                  (core.result.Result.Err multisig.Error.TransactionFailed)) :
                Ty.apply
                  (Ty.path "core::result::Result")
                  [Ty.tuple; Ty.apply (Ty.path "multisig::Error") []]
            ] in
        M.copy Œ±0 in
      let* _ : Ty.tuple :=
        let* Œ±0 :
            Ty.apply
              (Ty.path "mut_ref")
              [Ty.apply (Ty.path "multisig::Multisig") []] :=
          M.read self in
        let* Œ±1 : Ty.apply (Ty.path "multisig::Env") [] :=
          M.call
            ((Ty.apply (Ty.path "multisig::Multisig") [])::["env"]
              (borrow (deref Œ±0))) in
        let* Œ±2 : Ty.apply (Ty.path "multisig::Env") [] := M.alloc Œ±1 in
        let* Œ±3 : Ty.path "u32" := M.read trans_id in
        let* Œ±4 :
            Ty.apply
              (Ty.path "core::result::Result")
              [Ty.tuple; Ty.apply (Ty.path "multisig::Error") []] :=
          M.read result in
        let* Œ±5 :
            Ty.apply
              (Ty.path "core::result::Result")
              [Ty.apply
                  (Ty.path "core::option::Option")
                  [Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      [Ty.path "u8";
                        Ty.apply (Ty.path "alloc::alloc::Global") []]];
                Ty.apply (Ty.path "multisig::Error") []] :=
          M.call
            ((Ty.apply
                  (Ty.path "core::result::Result")
                  [Ty.tuple; Ty.apply (Ty.path "multisig::Error") []])::["map"]
              Œ±4
              (fun (Œ±0 : Ty.tuple) =>
                (let* Œ±0 := M.alloc Œ±0 in
                match_operator
                  Œ±0
                  [
                    fun Œ≥ =>
                      (M.pure core.option.Option.None) :
                      Ty.apply
                        (Ty.path "core::option::Option")
                        [Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            [Ty.path "u8";
                              Ty.apply (Ty.path "alloc::alloc::Global") []]]
                  ]) :
                Ty.apply
                  (Ty.path "core::option::Option")
                  [Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      [Ty.path "u8";
                        Ty.apply (Ty.path "alloc::alloc::Global") []]])) in
        let* Œ±6 : Ty.tuple :=
          M.call
            ((Ty.apply (Ty.path "multisig::Env") [])::["emit_event"]
              (borrow Œ±2)
              (multisig.Event.Execution
                {|
                  multisig.Execution.transaction := Œ±3;
                  multisig.Execution.result := Œ±5;
                |})) in
        M.alloc Œ±6 in
      M.read result
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_invoke_transaction : Instance.t := {
    Notations.double_colon := invoke_transaction;
  }.
  
  (*
      pub fn eval_transaction(&mut self, trans_id: TransactionId) -> Result<Vec<u8>, Error> {
          self.ensure_confirmed(trans_id);
          let t = self.take_transaction(trans_id).expect(WRONG_TRANSACTION_ID);
          // let result = build_call()
          //     .call(t.callee)
          //     .gas_limit(t.gas_limit)
          //     .transferred_value(t.transferred_value)
          //     .call_flags(CallFlags::default().set_allow_reentry(t.allow_reentry))
          //     .exec_input(ExecutionInput::new(t.selector.into()).push_arg(CallInput(&t.input)))
          //     .returns::<Vec<u8>>()
          //     .try_invoke();
          let result: Result<Result<Vec<u8>, ()>, ()> = todo!();
  
          let result = match result {
              Ok(Ok(v)) => Ok(v),
              _ => Err(Error::TransactionFailed),
          };
  
          self.env().emit_event(Event::Execution(Execution {
              transaction: trans_id,
              result: result.clone().map(Some),
          }));
          result
      }
  *)
  Parameter eval_transaction :
      (Ty.apply
          (Ty.path "mut_ref")
          [Ty.apply (Ty.path "multisig::Multisig") []])
        ->
        (Ty.path "u32") ->
        Ty.apply
          (Ty.path "core::result::Result")
          [Ty.apply
              (Ty.path "alloc::vec::Vec")
              [Ty.path "u8"; Ty.apply (Ty.path "alloc::alloc::Global") []];
            Ty.apply (Ty.path "multisig::Error") []].
  
  Definition AssociatedFunction_eval_transaction : Instance.t := {
    Notations.double_colon := eval_transaction;
  }.
End Impl_multisig_Multisig.
End Impl_multisig_Multisig.
