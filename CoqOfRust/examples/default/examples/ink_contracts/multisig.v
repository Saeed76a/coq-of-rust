(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module  Mapping.
Section Mapping.
  Context (K V : Set).
  
  Record t : Set := {
    _key : core.marker.PhantomData.t K;
    _value : core.marker.PhantomData.t V;
  }.
  
  Global Instance Get__key : Notations.Dot "_key" := {
    Notations.dot := Ref.map (fun x => x.(_key)) (fun v x => x <| _key := v |>);
  }.
  Global Instance Get_AF__key : Notations.DoubleColon t "_key" := {
    Notations.double_colon (x : M.Val t) := x.["_key"];
  }.
  Global Instance Get__value : Notations.Dot "_value" := {
    Notations.dot :=
      Ref.map (fun x => x.(_value)) (fun v x => x <| _value := v |>);
  }.
  Global Instance Get_AF__value : Notations.DoubleColon t "_value" := {
    Notations.double_colon (x : M.Val t) := x.["_value"];
  }.
End Mapping.
End Mapping.

Module  Impl_core_default_Default_for_multisig_Mapping_t_K_V.
Section Impl_core_default_Default_for_multisig_Mapping_t_K_V.
  Context {K V : Set}.
  
  Context
    {ℋ_0 : core.default.Default.Trait K}
    {ℋ_1 : core.default.Default.Trait V}.
  
  Definition Self : Set := multisig.Mapping.t K V.
  
  (*
  Default
  *)
  Definition default : M (multisig.Mapping.t K V) :=
    let* α0 : core.marker.PhantomData.t K :=
      M.call
        (core.default.Default.default
          (Self := core.marker.PhantomData.t K)
          (Trait := ltac:(refine _))) in
    let* α1 : core.marker.PhantomData.t V :=
      M.call
        (core.default.Default.default
          (Self := core.marker.PhantomData.t V)
          (Trait := ltac:(refine _))) in
    M.pure {| multisig.Mapping._key := α0; multisig.Mapping._value := α1; |}.
  
  Global Instance AssociatedFunction_default :
    Notations.DoubleColon Self "default" := {
    Notations.double_colon := default;
  }.
  
  Global Instance ℐ : core.default.Default.Trait Self := {
    core.default.Default.default := default;
  }.
End Impl_core_default_Default_for_multisig_Mapping_t_K_V.
End Impl_core_default_Default_for_multisig_Mapping_t_K_V.

Module  Impl_multisig_Mapping_t_K_V.
Section Impl_multisig_Mapping_t_K_V.
  Context {K V : Set}.
  
  Definition Self : Set := multisig.Mapping.t K V.
  
  (*
      fn contains(&self, _key: &K) -> bool {
          unimplemented!()
      }
  *)
  Definition contains (self : ref Self) (_key : ref K) : M bool.t :=
    let* self := M.alloc self in
    let* _key := M.alloc _key in
    let* α0 : ref str.t := M.read (mk_str "not implemented") in
    let* α1 : never.t := M.call (core.panicking.panic α0) in
    never_to_any α1.
  
  Global Instance AssociatedFunction_contains :
    Notations.DoubleColon Self "contains" := {
    Notations.double_colon := contains;
  }.
  
  (*
      fn get(&self, _key: &K) -> Option<V> {
          unimplemented!()
      }
  *)
  Definition get
      (self : ref Self)
      (_key : ref K)
      : M (core.option.Option.t V) :=
    let* self := M.alloc self in
    let* _key := M.alloc _key in
    let* α0 : ref str.t := M.read (mk_str "not implemented") in
    let* α1 : never.t := M.call (core.panicking.panic α0) in
    never_to_any α1.
  
  Global Instance AssociatedFunction_get : Notations.DoubleColon Self "get" := {
    Notations.double_colon := get;
  }.
  
  (*
      fn insert(&mut self, _key: K, _value: V) -> Option<u32> {
          unimplemented!()
      }
  *)
  Definition insert
      (self : mut_ref Self)
      (_key : K)
      (_value : V)
      : M (core.option.Option.t u32.t) :=
    let* self := M.alloc self in
    let* _key := M.alloc _key in
    let* _value := M.alloc _value in
    let* α0 : ref str.t := M.read (mk_str "not implemented") in
    let* α1 : never.t := M.call (core.panicking.panic α0) in
    never_to_any α1.
  
  Global Instance AssociatedFunction_insert :
    Notations.DoubleColon Self "insert" := {
    Notations.double_colon := insert;
  }.
  
  (*
      fn remove(&self, _key: K) {
          unimplemented!()
      }
  *)
  Definition remove (self : ref Self) (_key : K) : M unit :=
    let* self := M.alloc self in
    let* _key := M.alloc _key in
    let* α0 : ref str.t := M.read (mk_str "not implemented") in
    let* α1 : never.t := M.call (core.panicking.panic α0) in
    never_to_any α1.
  
  Global Instance AssociatedFunction_remove :
    Notations.DoubleColon Self "remove" := {
    Notations.double_colon := remove;
  }.
  
  (*
      fn size(&self, _key: K) -> Option<u32> {
          unimplemented!()
      }
  *)
  Definition size
      (self : ref Self)
      (_key : K)
      : M (core.option.Option.t u32.t) :=
    let* self := M.alloc self in
    let* _key := M.alloc _key in
    let* α0 : ref str.t := M.read (mk_str "not implemented") in
    let* α1 : never.t := M.call (core.panicking.panic α0) in
    never_to_any α1.
  
  Global Instance AssociatedFunction_size :
    Notations.DoubleColon Self "size" := {
    Notations.double_colon := size;
  }.
  
  (*
      fn take(&self, _key: K) -> Option<V> {
          unimplemented!()
      }
  *)
  Definition take (self : ref Self) (_key : K) : M (core.option.Option.t V) :=
    let* self := M.alloc self in
    let* _key := M.alloc _key in
    let* α0 : ref str.t := M.read (mk_str "not implemented") in
    let* α1 : never.t := M.call (core.panicking.panic α0) in
    never_to_any α1.
  
  Global Instance AssociatedFunction_take :
    Notations.DoubleColon Self "take" := {
    Notations.double_colon := take;
  }.
End Impl_multisig_Mapping_t_K_V.
End Impl_multisig_Mapping_t_K_V.

Module  AccountId.
Section AccountId.
  Record t : Set := {
    x0 : u128.t;
  }.
  
  Global Instance Get_0 : Notations.Dot "0" := {
    Notations.dot := Ref.map (fun x => x.(x0)) (fun v x => x <| x0 := v |>);
  }.
End AccountId.
End AccountId.

Module  Impl_core_default_Default_for_multisig_AccountId_t.
Section Impl_core_default_Default_for_multisig_AccountId_t.
  Definition Self : Set := multisig.AccountId.t.
  
  (*
  Default
  *)
  Definition default : M multisig.AccountId.t :=
    let* α0 : u128.t :=
      M.call
        (core.default.Default.default
          (Self := u128.t)
          (Trait := ltac:(refine _))) in
    M.pure (multisig.AccountId.Build_t α0).
  
  Global Instance AssociatedFunction_default :
    Notations.DoubleColon Self "default" := {
    Notations.double_colon := default;
  }.
  
  Global Instance ℐ : core.default.Default.Trait Self := {
    core.default.Default.default := default;
  }.
End Impl_core_default_Default_for_multisig_AccountId_t.
End Impl_core_default_Default_for_multisig_AccountId_t.

Module  Impl_core_fmt_Debug_for_multisig_AccountId_t.
Section Impl_core_fmt_Debug_for_multisig_AccountId_t.
  Definition Self : Set := multisig.AccountId.t.
  
  (*
  Debug
  *)
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter.t)
      : M ltac:(core.fmt.Result) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    let* α0 : mut_ref core.fmt.Formatter.t := M.read f in
    let* α1 : ref str.t := M.read (mk_str "AccountId") in
    let* α2 : ref multisig.AccountId.t := M.read self in
    let* α3 : M.Val (ref u128.t) := M.alloc (borrow (deref α2).["0"]) in
    let* α4 : M.Val (ref (ref u128.t)) := M.alloc (borrow α3) in
    let* α5 : ref dynamic := M.read (pointer_coercion "Unsize" α4) in
    M.call (core.fmt.Formatter.t::["debug_tuple_field1_finish"] α0 α1 α5).
  
  Global Instance AssociatedFunction_fmt : Notations.DoubleColon Self "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_multisig_AccountId_t.
End Impl_core_fmt_Debug_for_multisig_AccountId_t.

Module  Impl_core_clone_Clone_for_multisig_AccountId_t.
Section Impl_core_clone_Clone_for_multisig_AccountId_t.
  Definition Self : Set := multisig.AccountId.t.
  
  (*
  Clone
  *)
  Definition clone (self : ref Self) : M multisig.AccountId.t :=
    let* self := M.alloc self in
    let _ : unit := tt in
    let* α0 : ref multisig.AccountId.t := M.read self in
    M.read (deref α0).
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_multisig_AccountId_t.
End Impl_core_clone_Clone_for_multisig_AccountId_t.

Module  Impl_core_marker_Copy_for_multisig_AccountId_t.
Section Impl_core_marker_Copy_for_multisig_AccountId_t.
  Definition Self : Set := multisig.AccountId.t.
  
  Global Instance ℐ : core.marker.Copy.Trait Self := {
  }.
End Impl_core_marker_Copy_for_multisig_AccountId_t.
End Impl_core_marker_Copy_for_multisig_AccountId_t.

Module  Impl_core_marker_StructuralPartialEq_for_multisig_AccountId_t.
Section Impl_core_marker_StructuralPartialEq_for_multisig_AccountId_t.
  Definition Self : Set := multisig.AccountId.t.
  
  Global Instance ℐ : core.marker.StructuralPartialEq.Trait Self := {
  }.
End Impl_core_marker_StructuralPartialEq_for_multisig_AccountId_t.
End Impl_core_marker_StructuralPartialEq_for_multisig_AccountId_t.

Module  Impl_core_cmp_PartialEq_for_multisig_AccountId_t.
Section Impl_core_cmp_PartialEq_for_multisig_AccountId_t.
  Definition Self : Set := multisig.AccountId.t.
  
  (*
  PartialEq
  *)
  Definition eq
      (self : ref Self)
      (other : ref multisig.AccountId.t)
      : M bool.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    let* α0 : ref multisig.AccountId.t := M.read self in
    let* α1 : u128.t := M.read (deref α0).["0"] in
    let* α2 : ref multisig.AccountId.t := M.read other in
    let* α3 : u128.t := M.read (deref α2).["0"] in
    M.pure (BinOp.Pure.eq α1 α3).
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ :
    core.cmp.PartialEq.Required.Trait Self
      (Rhs := core.cmp.PartialEq.Default.Rhs Self) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_for_multisig_AccountId_t.
End Impl_core_cmp_PartialEq_for_multisig_AccountId_t.

Module  Impl_core_marker_StructuralEq_for_multisig_AccountId_t.
Section Impl_core_marker_StructuralEq_for_multisig_AccountId_t.
  Definition Self : Set := multisig.AccountId.t.
  
  Global Instance ℐ : core.marker.StructuralEq.Trait Self := {
  }.
End Impl_core_marker_StructuralEq_for_multisig_AccountId_t.
End Impl_core_marker_StructuralEq_for_multisig_AccountId_t.

Module  Impl_core_cmp_Eq_for_multisig_AccountId_t.
Section Impl_core_cmp_Eq_for_multisig_AccountId_t.
  Definition Self : Set := multisig.AccountId.t.
  
  (*
  Eq
  *)
  Definition assert_receiver_is_total_eq (self : ref Self) : M unit :=
    let* self := M.alloc self in
    let _ : unit := tt in
    let* α0 : M.Val unit := M.alloc tt in
    M.read α0.
  
  Global Instance AssociatedFunction_assert_receiver_is_total_eq :
    Notations.DoubleColon Self "assert_receiver_is_total_eq" := {
    Notations.double_colon := assert_receiver_is_total_eq;
  }.
  
  Global Instance ℐ : core.cmp.Eq.Required.Trait Self := {
    core.cmp.Eq.assert_receiver_is_total_eq :=
      Datatypes.Some assert_receiver_is_total_eq;
  }.
End Impl_core_cmp_Eq_for_multisig_AccountId_t.
End Impl_core_cmp_Eq_for_multisig_AccountId_t.

Module  Impl_core_cmp_PartialOrd_for_multisig_AccountId_t.
Section Impl_core_cmp_PartialOrd_for_multisig_AccountId_t.
  Definition Self : Set := multisig.AccountId.t.
  
  (*
  PartialOrd
  *)
  Definition partial_cmp
      (self : ref Self)
      (other : ref multisig.AccountId.t)
      : M (core.option.Option.t core.cmp.Ordering.t) :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    let* α0 : ref multisig.AccountId.t := M.read self in
    let* α1 : ref multisig.AccountId.t := M.read other in
    M.call
      ((core.cmp.PartialOrd.partial_cmp
          (Self := u128.t)
          (Trait := ltac:(refine _)))
        (borrow (deref α0).["0"])
        (borrow (deref α1).["0"])).
  
  Global Instance AssociatedFunction_partial_cmp :
    Notations.DoubleColon Self "partial_cmp" := {
    Notations.double_colon := partial_cmp;
  }.
  
  Global Instance ℐ :
    core.cmp.PartialOrd.Required.Trait Self
      (Rhs := core.cmp.PartialOrd.Default.Rhs Self) := {
    core.cmp.PartialOrd.partial_cmp := partial_cmp;
    core.cmp.PartialOrd.lt := Datatypes.None;
    core.cmp.PartialOrd.le := Datatypes.None;
    core.cmp.PartialOrd.gt := Datatypes.None;
    core.cmp.PartialOrd.ge := Datatypes.None;
  }.
End Impl_core_cmp_PartialOrd_for_multisig_AccountId_t.
End Impl_core_cmp_PartialOrd_for_multisig_AccountId_t.

Module  Impl_core_cmp_Ord_for_multisig_AccountId_t.
Section Impl_core_cmp_Ord_for_multisig_AccountId_t.
  Definition Self : Set := multisig.AccountId.t.
  
  (*
  Ord
  *)
  Definition cmp
      (self : ref Self)
      (other : ref multisig.AccountId.t)
      : M core.cmp.Ordering.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    let* α0 : ref multisig.AccountId.t := M.read self in
    let* α1 : ref multisig.AccountId.t := M.read other in
    M.call
      ((core.cmp.Ord.cmp (Self := u128.t) (Trait := ltac:(refine _)))
        (borrow (deref α0).["0"])
        (borrow (deref α1).["0"])).
  
  Global Instance AssociatedFunction_cmp : Notations.DoubleColon Self "cmp" := {
    Notations.double_colon := cmp;
  }.
  
  Global Instance ℐ : core.cmp.Ord.Required.Trait Self := {
    core.cmp.Ord.cmp := cmp;
    core.cmp.Ord.max := Datatypes.None;
    core.cmp.Ord.min := Datatypes.None;
    core.cmp.Ord.clamp := Datatypes.None;
  }.
End Impl_core_cmp_Ord_for_multisig_AccountId_t.
End Impl_core_cmp_Ord_for_multisig_AccountId_t.

Ltac Balance := exact u128.t.

Module  Env.
Section Env.
  Record t : Set := {
    caller : multisig.AccountId.t;
  }.
  
  Global Instance Get_caller : Notations.Dot "caller" := {
    Notations.dot :=
      Ref.map (fun x => x.(caller)) (fun v x => x <| caller := v |>);
  }.
  Global Instance Get_AF_caller : Notations.DoubleColon t "caller" := {
    Notations.double_colon (x : M.Val t) := x.["caller"];
  }.
End Env.
End Env.

Definition MAX_OWNERS : M.Val u32.t := M.run (M.alloc (Integer.of_Z 50)).

Ltac TransactionId := exact u32.t.

Definition WRONG_TRANSACTION_ID : M.Val (ref str.t) :=
  M.run
    (M.pure (mk_str "The user specified an invalid transaction id. Abort.")).

Module  CallInput.
Section CallInput.
  Record t : Set := {
    x0 : ref (slice u8.t);
  }.
  
  Global Instance Get_0 : Notations.Dot "0" := {
    Notations.dot := Ref.map (fun x => x.(x0)) (fun v x => x <| x0 := v |>);
  }.
End CallInput.
End CallInput.

Module ConfirmationStatus.
  Inductive t : Set :=
  | Confirmed
  | ConfirmationsNeeded (_ : u32.t).
End ConfirmationStatus.

Module  Impl_core_clone_Clone_for_multisig_ConfirmationStatus_t.
Section Impl_core_clone_Clone_for_multisig_ConfirmationStatus_t.
  Definition Self : Set := multisig.ConfirmationStatus.t.
  
  (*
  Clone
  *)
  Definition clone (self : ref Self) : M multisig.ConfirmationStatus.t :=
    let* self := M.alloc self in
    let _ : unit := tt in
    let* α0 : ref multisig.ConfirmationStatus.t := M.read self in
    M.read (deref α0).
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_multisig_ConfirmationStatus_t.
End Impl_core_clone_Clone_for_multisig_ConfirmationStatus_t.

Module  Impl_core_marker_Copy_for_multisig_ConfirmationStatus_t.
Section Impl_core_marker_Copy_for_multisig_ConfirmationStatus_t.
  Definition Self : Set := multisig.ConfirmationStatus.t.
  
  Global Instance ℐ : core.marker.Copy.Trait Self := {
  }.
End Impl_core_marker_Copy_for_multisig_ConfirmationStatus_t.
End Impl_core_marker_Copy_for_multisig_ConfirmationStatus_t.

Module  Transaction.
Section Transaction.
  Record t : Set := {
    callee : multisig.AccountId.t;
    selector : array u8.t;
    input : alloc.vec.Vec.t u8.t alloc.vec.Vec.Default.A;
    transferred_value : ltac:(multisig.Balance);
    gas_limit : u64.t;
    allow_reentry : bool.t;
  }.
  
  Global Instance Get_callee : Notations.Dot "callee" := {
    Notations.dot :=
      Ref.map (fun x => x.(callee)) (fun v x => x <| callee := v |>);
  }.
  Global Instance Get_AF_callee : Notations.DoubleColon t "callee" := {
    Notations.double_colon (x : M.Val t) := x.["callee"];
  }.
  Global Instance Get_selector : Notations.Dot "selector" := {
    Notations.dot :=
      Ref.map (fun x => x.(selector)) (fun v x => x <| selector := v |>);
  }.
  Global Instance Get_AF_selector : Notations.DoubleColon t "selector" := {
    Notations.double_colon (x : M.Val t) := x.["selector"];
  }.
  Global Instance Get_input : Notations.Dot "input" := {
    Notations.dot :=
      Ref.map (fun x => x.(input)) (fun v x => x <| input := v |>);
  }.
  Global Instance Get_AF_input : Notations.DoubleColon t "input" := {
    Notations.double_colon (x : M.Val t) := x.["input"];
  }.
  Global Instance Get_transferred_value : Notations.Dot "transferred_value" := {
    Notations.dot :=
      Ref.map
        (fun x => x.(transferred_value))
        (fun v x => x <| transferred_value := v |>);
  }.
  Global Instance Get_AF_transferred_value :
    Notations.DoubleColon t "transferred_value" := {
    Notations.double_colon (x : M.Val t) := x.["transferred_value"];
  }.
  Global Instance Get_gas_limit : Notations.Dot "gas_limit" := {
    Notations.dot :=
      Ref.map (fun x => x.(gas_limit)) (fun v x => x <| gas_limit := v |>);
  }.
  Global Instance Get_AF_gas_limit : Notations.DoubleColon t "gas_limit" := {
    Notations.double_colon (x : M.Val t) := x.["gas_limit"];
  }.
  Global Instance Get_allow_reentry : Notations.Dot "allow_reentry" := {
    Notations.dot :=
      Ref.map
        (fun x => x.(allow_reentry))
        (fun v x => x <| allow_reentry := v |>);
  }.
  Global Instance Get_AF_allow_reentry :
    Notations.DoubleColon t "allow_reentry" := {
    Notations.double_colon (x : M.Val t) := x.["allow_reentry"];
  }.
End Transaction.
End Transaction.

Module  Impl_core_default_Default_for_multisig_Transaction_t.
Section Impl_core_default_Default_for_multisig_Transaction_t.
  Definition Self : Set := multisig.Transaction.t.
  
  (*
  Default
  *)
  Definition default : M multisig.Transaction.t :=
    let* α0 : multisig.AccountId.t :=
      M.call
        (core.default.Default.default
          (Self := multisig.AccountId.t)
          (Trait := ltac:(refine _))) in
    let* α1 : array u8.t :=
      M.call
        (core.default.Default.default
          (Self := array u8.t)
          (Trait := ltac:(refine _))) in
    let* α2 : alloc.vec.Vec.t u8.t alloc.alloc.Global.t :=
      M.call
        (core.default.Default.default
          (Self := alloc.vec.Vec.t u8.t alloc.alloc.Global.t)
          (Trait := ltac:(refine _))) in
    let* α3 : u128.t :=
      M.call
        (core.default.Default.default
          (Self := u128.t)
          (Trait := ltac:(refine _))) in
    let* α4 : u64.t :=
      M.call
        (core.default.Default.default
          (Self := u64.t)
          (Trait := ltac:(refine _))) in
    let* α5 : bool.t :=
      M.call
        (core.default.Default.default
          (Self := bool.t)
          (Trait := ltac:(refine _))) in
    M.pure
      {|
        multisig.Transaction.callee := α0;
        multisig.Transaction.selector := α1;
        multisig.Transaction.input := α2;
        multisig.Transaction.transferred_value := α3;
        multisig.Transaction.gas_limit := α4;
        multisig.Transaction.allow_reentry := α5;
      |}.
  
  Global Instance AssociatedFunction_default :
    Notations.DoubleColon Self "default" := {
    Notations.double_colon := default;
  }.
  
  Global Instance ℐ : core.default.Default.Trait Self := {
    core.default.Default.default := default;
  }.
End Impl_core_default_Default_for_multisig_Transaction_t.
End Impl_core_default_Default_for_multisig_Transaction_t.

Module Error.
  Inductive t : Set :=
  | TransactionFailed.
End Error.

Module  Impl_core_clone_Clone_for_multisig_Error_t.
Section Impl_core_clone_Clone_for_multisig_Error_t.
  Definition Self : Set := multisig.Error.t.
  
  (*
  Clone
  *)
  Definition clone (self : ref Self) : M multisig.Error.t :=
    let* self := M.alloc self in
    let* α0 : ref multisig.Error.t := M.read self in
    M.read (deref α0).
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_multisig_Error_t.
End Impl_core_clone_Clone_for_multisig_Error_t.

Module  Impl_core_marker_Copy_for_multisig_Error_t.
Section Impl_core_marker_Copy_for_multisig_Error_t.
  Definition Self : Set := multisig.Error.t.
  
  Global Instance ℐ : core.marker.Copy.Trait Self := {
  }.
End Impl_core_marker_Copy_for_multisig_Error_t.
End Impl_core_marker_Copy_for_multisig_Error_t.

Module  Impl_core_marker_StructuralPartialEq_for_multisig_Error_t.
Section Impl_core_marker_StructuralPartialEq_for_multisig_Error_t.
  Definition Self : Set := multisig.Error.t.
  
  Global Instance ℐ : core.marker.StructuralPartialEq.Trait Self := {
  }.
End Impl_core_marker_StructuralPartialEq_for_multisig_Error_t.
End Impl_core_marker_StructuralPartialEq_for_multisig_Error_t.

Module  Impl_core_cmp_PartialEq_for_multisig_Error_t.
Section Impl_core_cmp_PartialEq_for_multisig_Error_t.
  Definition Self : Set := multisig.Error.t.
  
  (*
  PartialEq
  *)
  Definition eq (self : ref Self) (other : ref multisig.Error.t) : M bool.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    M.pure true.
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ :
    core.cmp.PartialEq.Required.Trait Self
      (Rhs := core.cmp.PartialEq.Default.Rhs Self) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_for_multisig_Error_t.
End Impl_core_cmp_PartialEq_for_multisig_Error_t.

Module  Impl_core_marker_StructuralEq_for_multisig_Error_t.
Section Impl_core_marker_StructuralEq_for_multisig_Error_t.
  Definition Self : Set := multisig.Error.t.
  
  Global Instance ℐ : core.marker.StructuralEq.Trait Self := {
  }.
End Impl_core_marker_StructuralEq_for_multisig_Error_t.
End Impl_core_marker_StructuralEq_for_multisig_Error_t.

Module  Impl_core_cmp_Eq_for_multisig_Error_t.
Section Impl_core_cmp_Eq_for_multisig_Error_t.
  Definition Self : Set := multisig.Error.t.
  
  (*
  Eq
  *)
  Definition assert_receiver_is_total_eq (self : ref Self) : M unit :=
    let* self := M.alloc self in
    M.pure tt.
  
  Global Instance AssociatedFunction_assert_receiver_is_total_eq :
    Notations.DoubleColon Self "assert_receiver_is_total_eq" := {
    Notations.double_colon := assert_receiver_is_total_eq;
  }.
  
  Global Instance ℐ : core.cmp.Eq.Required.Trait Self := {
    core.cmp.Eq.assert_receiver_is_total_eq :=
      Datatypes.Some assert_receiver_is_total_eq;
  }.
End Impl_core_cmp_Eq_for_multisig_Error_t.
End Impl_core_cmp_Eq_for_multisig_Error_t.

Module  Transactions.
Section Transactions.
  Record t : Set := {
    transactions :
      alloc.vec.Vec.t ltac:(multisig.TransactionId) alloc.vec.Vec.Default.A;
    next_id : ltac:(multisig.TransactionId);
  }.
  
  Global Instance Get_transactions : Notations.Dot "transactions" := {
    Notations.dot :=
      Ref.map
        (fun x => x.(transactions))
        (fun v x => x <| transactions := v |>);
  }.
  Global Instance Get_AF_transactions :
    Notations.DoubleColon t "transactions" := {
    Notations.double_colon (x : M.Val t) := x.["transactions"];
  }.
  Global Instance Get_next_id : Notations.Dot "next_id" := {
    Notations.dot :=
      Ref.map (fun x => x.(next_id)) (fun v x => x <| next_id := v |>);
  }.
  Global Instance Get_AF_next_id : Notations.DoubleColon t "next_id" := {
    Notations.double_colon (x : M.Val t) := x.["next_id"];
  }.
End Transactions.
End Transactions.

Module  Impl_core_default_Default_for_multisig_Transactions_t.
Section Impl_core_default_Default_for_multisig_Transactions_t.
  Definition Self : Set := multisig.Transactions.t.
  
  (*
  Default
  *)
  Definition default : M multisig.Transactions.t :=
    let* α0 : alloc.vec.Vec.t u32.t alloc.alloc.Global.t :=
      M.call
        (core.default.Default.default
          (Self := alloc.vec.Vec.t u32.t alloc.alloc.Global.t)
          (Trait := ltac:(refine _))) in
    let* α1 : u32.t :=
      M.call
        (core.default.Default.default
          (Self := u32.t)
          (Trait := ltac:(refine _))) in
    M.pure
      {|
        multisig.Transactions.transactions := α0;
        multisig.Transactions.next_id := α1;
      |}.
  
  Global Instance AssociatedFunction_default :
    Notations.DoubleColon Self "default" := {
    Notations.double_colon := default;
  }.
  
  Global Instance ℐ : core.default.Default.Trait Self := {
    core.default.Default.default := default;
  }.
End Impl_core_default_Default_for_multisig_Transactions_t.
End Impl_core_default_Default_for_multisig_Transactions_t.

Module  Confirmation.
Section Confirmation.
  Record t : Set := {
    transaction : ltac:(multisig.TransactionId);
    from : multisig.AccountId.t;
    status : multisig.ConfirmationStatus.t;
  }.
  
  Global Instance Get_transaction : Notations.Dot "transaction" := {
    Notations.dot :=
      Ref.map (fun x => x.(transaction)) (fun v x => x <| transaction := v |>);
  }.
  Global Instance Get_AF_transaction :
    Notations.DoubleColon t "transaction" := {
    Notations.double_colon (x : M.Val t) := x.["transaction"];
  }.
  Global Instance Get_from : Notations.Dot "from" := {
    Notations.dot := Ref.map (fun x => x.(from)) (fun v x => x <| from := v |>);
  }.
  Global Instance Get_AF_from : Notations.DoubleColon t "from" := {
    Notations.double_colon (x : M.Val t) := x.["from"];
  }.
  Global Instance Get_status : Notations.Dot "status" := {
    Notations.dot :=
      Ref.map (fun x => x.(status)) (fun v x => x <| status := v |>);
  }.
  Global Instance Get_AF_status : Notations.DoubleColon t "status" := {
    Notations.double_colon (x : M.Val t) := x.["status"];
  }.
End Confirmation.
End Confirmation.

Module  Revocation.
Section Revocation.
  Record t : Set := {
    transaction : ltac:(multisig.TransactionId);
    from : multisig.AccountId.t;
  }.
  
  Global Instance Get_transaction : Notations.Dot "transaction" := {
    Notations.dot :=
      Ref.map (fun x => x.(transaction)) (fun v x => x <| transaction := v |>);
  }.
  Global Instance Get_AF_transaction :
    Notations.DoubleColon t "transaction" := {
    Notations.double_colon (x : M.Val t) := x.["transaction"];
  }.
  Global Instance Get_from : Notations.Dot "from" := {
    Notations.dot := Ref.map (fun x => x.(from)) (fun v x => x <| from := v |>);
  }.
  Global Instance Get_AF_from : Notations.DoubleColon t "from" := {
    Notations.double_colon (x : M.Val t) := x.["from"];
  }.
End Revocation.
End Revocation.

Module  Submission.
Section Submission.
  Record t : Set := {
    transaction : ltac:(multisig.TransactionId);
  }.
  
  Global Instance Get_transaction : Notations.Dot "transaction" := {
    Notations.dot :=
      Ref.map (fun x => x.(transaction)) (fun v x => x <| transaction := v |>);
  }.
  Global Instance Get_AF_transaction :
    Notations.DoubleColon t "transaction" := {
    Notations.double_colon (x : M.Val t) := x.["transaction"];
  }.
End Submission.
End Submission.

Module  Cancellation.
Section Cancellation.
  Record t : Set := {
    transaction : ltac:(multisig.TransactionId);
  }.
  
  Global Instance Get_transaction : Notations.Dot "transaction" := {
    Notations.dot :=
      Ref.map (fun x => x.(transaction)) (fun v x => x <| transaction := v |>);
  }.
  Global Instance Get_AF_transaction :
    Notations.DoubleColon t "transaction" := {
    Notations.double_colon (x : M.Val t) := x.["transaction"];
  }.
End Cancellation.
End Cancellation.

Module  Execution.
Section Execution.
  Record t : Set := {
    transaction : ltac:(multisig.TransactionId);
    result :
      core.result.Result.t
        (core.option.Option.t (alloc.vec.Vec.t u8.t alloc.vec.Vec.Default.A))
        multisig.Error.t;
  }.
  
  Global Instance Get_transaction : Notations.Dot "transaction" := {
    Notations.dot :=
      Ref.map (fun x => x.(transaction)) (fun v x => x <| transaction := v |>);
  }.
  Global Instance Get_AF_transaction :
    Notations.DoubleColon t "transaction" := {
    Notations.double_colon (x : M.Val t) := x.["transaction"];
  }.
  Global Instance Get_result : Notations.Dot "result" := {
    Notations.dot :=
      Ref.map (fun x => x.(result)) (fun v x => x <| result := v |>);
  }.
  Global Instance Get_AF_result : Notations.DoubleColon t "result" := {
    Notations.double_colon (x : M.Val t) := x.["result"];
  }.
End Execution.
End Execution.

Module  OwnerAddition.
Section OwnerAddition.
  Record t : Set := {
    owner : multisig.AccountId.t;
  }.
  
  Global Instance Get_owner : Notations.Dot "owner" := {
    Notations.dot :=
      Ref.map (fun x => x.(owner)) (fun v x => x <| owner := v |>);
  }.
  Global Instance Get_AF_owner : Notations.DoubleColon t "owner" := {
    Notations.double_colon (x : M.Val t) := x.["owner"];
  }.
End OwnerAddition.
End OwnerAddition.

Module  OwnerRemoval.
Section OwnerRemoval.
  Record t : Set := {
    owner : multisig.AccountId.t;
  }.
  
  Global Instance Get_owner : Notations.Dot "owner" := {
    Notations.dot :=
      Ref.map (fun x => x.(owner)) (fun v x => x <| owner := v |>);
  }.
  Global Instance Get_AF_owner : Notations.DoubleColon t "owner" := {
    Notations.double_colon (x : M.Val t) := x.["owner"];
  }.
End OwnerRemoval.
End OwnerRemoval.

Module  RequirementChange.
Section RequirementChange.
  Record t : Set := {
    new_requirement : u32.t;
  }.
  
  Global Instance Get_new_requirement : Notations.Dot "new_requirement" := {
    Notations.dot :=
      Ref.map
        (fun x => x.(new_requirement))
        (fun v x => x <| new_requirement := v |>);
  }.
  Global Instance Get_AF_new_requirement :
    Notations.DoubleColon t "new_requirement" := {
    Notations.double_colon (x : M.Val t) := x.["new_requirement"];
  }.
End RequirementChange.
End RequirementChange.

Module Event.
  Inductive t : Set :=
  | Confirmation (_ : multisig.Confirmation.t)
  | Revocation (_ : multisig.Revocation.t)
  | Submission (_ : multisig.Submission.t)
  | Cancellation (_ : multisig.Cancellation.t)
  | Execution (_ : multisig.Execution.t)
  | OwnerAddition (_ : multisig.OwnerAddition.t)
  | OwnerRemoval (_ : multisig.OwnerRemoval.t)
  | RequirementChange (_ : multisig.RequirementChange.t).
End Event.

Module  Impl_multisig_Env_t.
Section Impl_multisig_Env_t.
  Definition Self : Set := multisig.Env.t.
  
  (*
      fn caller(&self) -> AccountId {
          self.caller
      }
  *)
  Definition caller (self : ref Self) : M multisig.AccountId.t :=
    let* self := M.alloc self in
    let* α0 : ref multisig.Env.t := M.read self in
    M.read (deref α0).["caller"].
  
  Global Instance AssociatedFunction_caller :
    Notations.DoubleColon Self "caller" := {
    Notations.double_colon := caller;
  }.
  
  (*
      fn emit_event(&self, _event: Event) {
          unimplemented!()
      }
  *)
  Definition emit_event
      (self : ref Self)
      (_event : multisig.Event.t)
      : M unit :=
    let* self := M.alloc self in
    let* _event := M.alloc _event in
    let* α0 : ref str.t := M.read (mk_str "not implemented") in
    let* α1 : never.t := M.call (core.panicking.panic α0) in
    never_to_any α1.
  
  Global Instance AssociatedFunction_emit_event :
    Notations.DoubleColon Self "emit_event" := {
    Notations.double_colon := emit_event;
  }.
  
  (*
      fn transferred_value(&self) -> Balance {
          unimplemented!()
      }
  *)
  Definition transferred_value (self : ref Self) : M ltac:(multisig.Balance) :=
    let* self := M.alloc self in
    let* α0 : ref str.t := M.read (mk_str "not implemented") in
    let* α1 : never.t := M.call (core.panicking.panic α0) in
    never_to_any α1.
  
  Global Instance AssociatedFunction_transferred_value :
    Notations.DoubleColon Self "transferred_value" := {
    Notations.double_colon := transferred_value;
  }.
  
  (*
      fn account_id(&self) -> AccountId {
          unimplemented!()
      }
  *)
  Definition account_id (self : ref Self) : M multisig.AccountId.t :=
    let* self := M.alloc self in
    let* α0 : ref str.t := M.read (mk_str "not implemented") in
    let* α1 : never.t := M.call (core.panicking.panic α0) in
    never_to_any α1.
  
  Global Instance AssociatedFunction_account_id :
    Notations.DoubleColon Self "account_id" := {
    Notations.double_colon := account_id;
  }.
End Impl_multisig_Env_t.
End Impl_multisig_Env_t.

Module  Multisig.
Section Multisig.
  Record t : Set := {
    confirmations :
      multisig.Mapping.t
        (ltac:(multisig.TransactionId) * multisig.AccountId.t)
        unit;
    confirmation_count : multisig.Mapping.t ltac:(multisig.TransactionId) u32.t;
    transactions :
      multisig.Mapping.t ltac:(multisig.TransactionId) multisig.Transaction.t;
    transaction_list : multisig.Transactions.t;
    owners : alloc.vec.Vec.t multisig.AccountId.t alloc.vec.Vec.Default.A;
    is_owner : multisig.Mapping.t multisig.AccountId.t unit;
    requirement : u32.t;
  }.
  
  Global Instance Get_confirmations : Notations.Dot "confirmations" := {
    Notations.dot :=
      Ref.map
        (fun x => x.(confirmations))
        (fun v x => x <| confirmations := v |>);
  }.
  Global Instance Get_AF_confirmations :
    Notations.DoubleColon t "confirmations" := {
    Notations.double_colon (x : M.Val t) := x.["confirmations"];
  }.
  Global Instance Get_confirmation_count :
    Notations.Dot "confirmation_count" := {
    Notations.dot :=
      Ref.map
        (fun x => x.(confirmation_count))
        (fun v x => x <| confirmation_count := v |>);
  }.
  Global Instance Get_AF_confirmation_count :
    Notations.DoubleColon t "confirmation_count" := {
    Notations.double_colon (x : M.Val t) := x.["confirmation_count"];
  }.
  Global Instance Get_transactions : Notations.Dot "transactions" := {
    Notations.dot :=
      Ref.map
        (fun x => x.(transactions))
        (fun v x => x <| transactions := v |>);
  }.
  Global Instance Get_AF_transactions :
    Notations.DoubleColon t "transactions" := {
    Notations.double_colon (x : M.Val t) := x.["transactions"];
  }.
  Global Instance Get_transaction_list : Notations.Dot "transaction_list" := {
    Notations.dot :=
      Ref.map
        (fun x => x.(transaction_list))
        (fun v x => x <| transaction_list := v |>);
  }.
  Global Instance Get_AF_transaction_list :
    Notations.DoubleColon t "transaction_list" := {
    Notations.double_colon (x : M.Val t) := x.["transaction_list"];
  }.
  Global Instance Get_owners : Notations.Dot "owners" := {
    Notations.dot :=
      Ref.map (fun x => x.(owners)) (fun v x => x <| owners := v |>);
  }.
  Global Instance Get_AF_owners : Notations.DoubleColon t "owners" := {
    Notations.double_colon (x : M.Val t) := x.["owners"];
  }.
  Global Instance Get_is_owner : Notations.Dot "is_owner" := {
    Notations.dot :=
      Ref.map (fun x => x.(is_owner)) (fun v x => x <| is_owner := v |>);
  }.
  Global Instance Get_AF_is_owner : Notations.DoubleColon t "is_owner" := {
    Notations.double_colon (x : M.Val t) := x.["is_owner"];
  }.
  Global Instance Get_requirement : Notations.Dot "requirement" := {
    Notations.dot :=
      Ref.map (fun x => x.(requirement)) (fun v x => x <| requirement := v |>);
  }.
  Global Instance Get_AF_requirement :
    Notations.DoubleColon t "requirement" := {
    Notations.double_colon (x : M.Val t) := x.["requirement"];
  }.
End Multisig.
End Multisig.

Module  Impl_core_default_Default_for_multisig_Multisig_t.
Section Impl_core_default_Default_for_multisig_Multisig_t.
  Definition Self : Set := multisig.Multisig.t.
  
  (*
  Default
  *)
  Definition default : M multisig.Multisig.t :=
    let* α0 : multisig.Mapping.t (u32.t * multisig.AccountId.t) unit :=
      M.call
        (core.default.Default.default
          (Self := multisig.Mapping.t (u32.t * multisig.AccountId.t) unit)
          (Trait := ltac:(refine _))) in
    let* α1 : multisig.Mapping.t u32.t u32.t :=
      M.call
        (core.default.Default.default
          (Self := multisig.Mapping.t u32.t u32.t)
          (Trait := ltac:(refine _))) in
    let* α2 : multisig.Mapping.t u32.t multisig.Transaction.t :=
      M.call
        (core.default.Default.default
          (Self := multisig.Mapping.t u32.t multisig.Transaction.t)
          (Trait := ltac:(refine _))) in
    let* α3 : multisig.Transactions.t :=
      M.call
        (core.default.Default.default
          (Self := multisig.Transactions.t)
          (Trait := ltac:(refine _))) in
    let* α4 : alloc.vec.Vec.t multisig.AccountId.t alloc.alloc.Global.t :=
      M.call
        (core.default.Default.default
          (Self := alloc.vec.Vec.t multisig.AccountId.t alloc.alloc.Global.t)
          (Trait := ltac:(refine _))) in
    let* α5 : multisig.Mapping.t multisig.AccountId.t unit :=
      M.call
        (core.default.Default.default
          (Self := multisig.Mapping.t multisig.AccountId.t unit)
          (Trait := ltac:(refine _))) in
    let* α6 : u32.t :=
      M.call
        (core.default.Default.default
          (Self := u32.t)
          (Trait := ltac:(refine _))) in
    M.pure
      {|
        multisig.Multisig.confirmations := α0;
        multisig.Multisig.confirmation_count := α1;
        multisig.Multisig.transactions := α2;
        multisig.Multisig.transaction_list := α3;
        multisig.Multisig.owners := α4;
        multisig.Multisig.is_owner := α5;
        multisig.Multisig.requirement := α6;
      |}.
  
  Global Instance AssociatedFunction_default :
    Notations.DoubleColon Self "default" := {
    Notations.double_colon := default;
  }.
  
  Global Instance ℐ : core.default.Default.Trait Self := {
    core.default.Default.default := default;
  }.
End Impl_core_default_Default_for_multisig_Multisig_t.
End Impl_core_default_Default_for_multisig_Multisig_t.

Module  Impl_multisig_Multisig_t.
Section Impl_multisig_Multisig_t.
  Definition Self : Set := multisig.Multisig.t.
  
  (*
      fn init_env() -> Env {
          unimplemented!()
      }
  *)
  Definition init_env : M multisig.Env.t :=
    let* α0 : ref str.t := M.read (mk_str "not implemented") in
    let* α1 : never.t := M.call (core.panicking.panic α0) in
    never_to_any α1.
  
  Global Instance AssociatedFunction_init_env :
    Notations.DoubleColon Self "init_env" := {
    Notations.double_colon := init_env;
  }.
  
  (*
      fn env(&self) -> Env {
          Self::init_env()
      }
  *)
  Definition env (self : ref Self) : M multisig.Env.t :=
    let* self := M.alloc self in
    M.call multisig.Multisig.t::["init_env"].
  
  Global Instance AssociatedFunction_env : Notations.DoubleColon Self "env" := {
    Notations.double_colon := env;
  }.
  
  (*
      pub fn new(requirement: u32, mut owners: Vec<AccountId>) -> Self {
          let mut contract = Multisig::default();
          owners.sort_unstable();
          owners.dedup();
          ensure_requirement_is_valid(owners.len() as u32, requirement);
  
          for owner in &owners {
              contract.is_owner.insert( *owner, ());
          }
  
          contract.owners = owners;
          contract.transaction_list = Default::default();
          contract.requirement = requirement;
          contract
      }
  *)
  Definition new
      (requirement : u32.t)
      (owners : alloc.vec.Vec.t multisig.AccountId.t alloc.vec.Vec.Default.A)
      : M Self :=
    let* requirement := M.alloc requirement in
    let* owners := M.alloc owners in
    let* contract : M.Val multisig.Multisig.t :=
      let* α0 : multisig.Multisig.t :=
        M.call
          (core.default.Default.default
            (Self := multisig.Multisig.t)
            (Trait := ltac:(refine _))) in
      M.alloc α0 in
    let* _ : M.Val unit :=
      let* α0 : mut_ref (slice multisig.AccountId.t) :=
        M.call
          ((core.ops.deref.DerefMut.deref_mut
              (Self :=
                alloc.vec.Vec.t multisig.AccountId.t alloc.alloc.Global.t)
              (Trait := ltac:(refine _)))
            (borrow_mut owners)) in
      let* α1 : unit :=
        M.call ((slice multisig.AccountId.t)::["sort_unstable"] α0) in
      M.alloc α1 in
    let* _ : M.Val unit :=
      let* α0 : unit :=
        M.call
          ((alloc.vec.Vec.t
                multisig.AccountId.t
                alloc.alloc.Global.t)::["dedup"]
            (borrow_mut owners)) in
      M.alloc α0 in
    let* _ : M.Val unit :=
      let* α0 : usize.t :=
        M.call
          ((alloc.vec.Vec.t multisig.AccountId.t alloc.alloc.Global.t)::["len"]
            (borrow owners)) in
      let* α1 : u32.t := cast α0 in
      let* α2 : u32.t := M.read requirement in
      let* α3 : unit := M.call (multisig.ensure_requirement_is_valid α1 α2) in
      M.alloc α3 in
    let* _ : M.Val unit :=
      let* α0 : core.slice.iter.Iter.t multisig.AccountId.t :=
        M.call
          ((core.iter.traits.collect.IntoIterator.into_iter
              (Self :=
                ref (alloc.vec.Vec.t multisig.AccountId.t alloc.alloc.Global.t))
              (Trait := ltac:(refine _)))
            (borrow owners)) in
      let* α1 : M.Val unit :=
        match α0 with
        | iter =>
          let* iter := M.alloc iter in
          loop
            (let* _ : M.Val unit :=
              let* α0 : core.option.Option.t (ref multisig.AccountId.t) :=
                M.call
                  ((core.iter.traits.iterator.Iterator.next
                      (Self := core.slice.iter.Iter.t multisig.AccountId.t)
                      (Trait := ltac:(refine _)))
                    (borrow_mut iter)) in
              match α0 with
              | core.option.Option.None =>
                let* α0 : M.Val never.t := Break in
                let* α1 := M.read α0 in
                let* α2 : unit := never_to_any α1 in
                M.alloc α2
              | core.option.Option.Some owner =>
                let* owner := M.alloc owner in
                let* _ : M.Val (core.option.Option.t u32.t) :=
                  let* α0 : ref multisig.AccountId.t := M.read owner in
                  let* α1 : multisig.AccountId.t := M.read (deref α0) in
                  let* α2 : core.option.Option.t u32.t :=
                    M.call
                      ((multisig.Mapping.t
                            multisig.AccountId.t
                            unit)::["insert"]
                        (borrow_mut contract.["is_owner"])
                        α1
                        tt) in
                  M.alloc α2 in
                M.alloc tt
              end in
            M.alloc tt)
        end in
      M.pure (use α1) in
    let* _ : M.Val unit :=
      let* α0 : alloc.vec.Vec.t multisig.AccountId.t alloc.alloc.Global.t :=
        M.read owners in
      assign contract.["owners"] α0 in
    let* _ : M.Val unit :=
      let* α0 : multisig.Transactions.t :=
        M.call
          (core.default.Default.default
            (Self := multisig.Transactions.t)
            (Trait := ltac:(refine _))) in
      assign contract.["transaction_list"] α0 in
    let* _ : M.Val unit :=
      let* α0 : u32.t := M.read requirement in
      assign contract.["requirement"] α0 in
    M.read contract.
  
  Global Instance AssociatedFunction_new : Notations.DoubleColon Self "new" := {
    Notations.double_colon := new;
  }.
  
  (*
      pub fn add_owner(&mut self, new_owner: AccountId) {
          self.ensure_from_wallet();
          self.ensure_no_owner(&new_owner);
          ensure_requirement_is_valid(self.owners.len() as u32 + 1, self.requirement);
          self.is_owner.insert(new_owner, ());
          self.owners.push(new_owner);
          self.env()
              .emit_event(Event::OwnerAddition(OwnerAddition { owner: new_owner }));
      }
  *)
  Definition add_owner
      (self : mut_ref Self)
      (new_owner : multisig.AccountId.t)
      : M unit :=
    let* self := M.alloc self in
    let* new_owner := M.alloc new_owner in
    let* _ : M.Val unit :=
      let* α0 : mut_ref multisig.Multisig.t := M.read self in
      let* α1 : unit :=
        M.call
          (multisig.Multisig.t::["ensure_from_wallet"] (borrow (deref α0))) in
      M.alloc α1 in
    let* _ : M.Val unit :=
      let* α0 : mut_ref multisig.Multisig.t := M.read self in
      let* α1 : unit :=
        M.call
          (multisig.Multisig.t::["ensure_no_owner"]
            (borrow (deref α0))
            (borrow new_owner)) in
      M.alloc α1 in
    let* _ : M.Val unit :=
      let* α0 : mut_ref multisig.Multisig.t := M.read self in
      let* α1 : usize.t :=
        M.call
          ((alloc.vec.Vec.t multisig.AccountId.t alloc.alloc.Global.t)::["len"]
            (borrow (deref α0).["owners"])) in
      let* α2 : u32.t := cast α1 in
      let* α3 : u32.t := BinOp.Panic.add α2 (Integer.of_Z 1) in
      let* α4 : mut_ref multisig.Multisig.t := M.read self in
      let* α5 : u32.t := M.read (deref α4).["requirement"] in
      let* α6 : unit := M.call (multisig.ensure_requirement_is_valid α3 α5) in
      M.alloc α6 in
    let* _ : M.Val (core.option.Option.t u32.t) :=
      let* α0 : mut_ref multisig.Multisig.t := M.read self in
      let* α1 : multisig.AccountId.t := M.read new_owner in
      let* α2 : core.option.Option.t u32.t :=
        M.call
          ((multisig.Mapping.t multisig.AccountId.t unit)::["insert"]
            (borrow_mut (deref α0).["is_owner"])
            α1
            tt) in
      M.alloc α2 in
    let* _ : M.Val unit :=
      let* α0 : mut_ref multisig.Multisig.t := M.read self in
      let* α1 : multisig.AccountId.t := M.read new_owner in
      let* α2 : unit :=
        M.call
          ((alloc.vec.Vec.t multisig.AccountId.t alloc.alloc.Global.t)::["push"]
            (borrow_mut (deref α0).["owners"])
            α1) in
      M.alloc α2 in
    let* _ : M.Val unit :=
      let* α0 : mut_ref multisig.Multisig.t := M.read self in
      let* α1 : multisig.Env.t :=
        M.call (multisig.Multisig.t::["env"] (borrow (deref α0))) in
      let* α2 : M.Val multisig.Env.t := M.alloc α1 in
      let* α3 : multisig.AccountId.t := M.read new_owner in
      let* α4 : unit :=
        M.call
          (multisig.Env.t::["emit_event"]
            (borrow α2)
            (multisig.Event.OwnerAddition
              {| multisig.OwnerAddition.owner := α3; |})) in
      M.alloc α4 in
    let* α0 : M.Val unit := M.alloc tt in
    M.read α0.
  
  Global Instance AssociatedFunction_add_owner :
    Notations.DoubleColon Self "add_owner" := {
    Notations.double_colon := add_owner;
  }.
  
  (*
      pub fn remove_owner(&mut self, owner: AccountId) {
          self.ensure_from_wallet();
          self.ensure_owner(&owner);
          let len = self.owners.len() as u32 - 1;
          let requirement = u32::min(len, self.requirement);
          ensure_requirement_is_valid(len, requirement);
          let owner_index = self.owner_index(&owner) as usize;
          self.owners.swap_remove(owner_index);
          self.is_owner.remove(owner);
          self.requirement = requirement;
          self.clean_owner_confirmations(&owner);
          self.env()
              .emit_event(Event::OwnerRemoval(OwnerRemoval { owner }));
      }
  *)
  Definition remove_owner
      (self : mut_ref Self)
      (owner : multisig.AccountId.t)
      : M unit :=
    let* self := M.alloc self in
    let* owner := M.alloc owner in
    let* _ : M.Val unit :=
      let* α0 : mut_ref multisig.Multisig.t := M.read self in
      let* α1 : unit :=
        M.call
          (multisig.Multisig.t::["ensure_from_wallet"] (borrow (deref α0))) in
      M.alloc α1 in
    let* _ : M.Val unit :=
      let* α0 : mut_ref multisig.Multisig.t := M.read self in
      let* α1 : unit :=
        M.call
          (multisig.Multisig.t::["ensure_owner"]
            (borrow (deref α0))
            (borrow owner)) in
      M.alloc α1 in
    let* len : M.Val u32.t :=
      let* α0 : mut_ref multisig.Multisig.t := M.read self in
      let* α1 : usize.t :=
        M.call
          ((alloc.vec.Vec.t multisig.AccountId.t alloc.alloc.Global.t)::["len"]
            (borrow (deref α0).["owners"])) in
      let* α2 : u32.t := cast α1 in
      let* α3 : u32.t := BinOp.Panic.sub α2 (Integer.of_Z 1) in
      M.alloc α3 in
    let* requirement : M.Val u32.t :=
      let* α0 : u32.t := M.read len in
      let* α1 : mut_ref multisig.Multisig.t := M.read self in
      let* α2 : u32.t := M.read (deref α1).["requirement"] in
      let* α3 : u32.t :=
        M.call
          ((core.cmp.Ord.min (Self := u32.t) (Trait := ltac:(refine _)))
            α0
            α2) in
      M.alloc α3 in
    let* _ : M.Val unit :=
      let* α0 : u32.t := M.read len in
      let* α1 : u32.t := M.read requirement in
      let* α2 : unit := M.call (multisig.ensure_requirement_is_valid α0 α1) in
      M.alloc α2 in
    let* owner_index : M.Val usize.t :=
      let* α0 : mut_ref multisig.Multisig.t := M.read self in
      let* α1 : u32.t :=
        M.call
          (multisig.Multisig.t::["owner_index"]
            (borrow (deref α0))
            (borrow owner)) in
      let* α2 : usize.t := cast α1 in
      M.alloc α2 in
    let* _ : M.Val multisig.AccountId.t :=
      let* α0 : mut_ref multisig.Multisig.t := M.read self in
      let* α1 : usize.t := M.read owner_index in
      let* α2 : multisig.AccountId.t :=
        M.call
          ((alloc.vec.Vec.t
                multisig.AccountId.t
                alloc.alloc.Global.t)::["swap_remove"]
            (borrow_mut (deref α0).["owners"])
            α1) in
      M.alloc α2 in
    let* _ : M.Val unit :=
      let* α0 : mut_ref multisig.Multisig.t := M.read self in
      let* α1 : multisig.AccountId.t := M.read owner in
      let* α2 : unit :=
        M.call
          ((multisig.Mapping.t multisig.AccountId.t unit)::["remove"]
            (borrow (deref α0).["is_owner"])
            α1) in
      M.alloc α2 in
    let* _ : M.Val unit :=
      let* α0 : mut_ref multisig.Multisig.t := M.read self in
      let* α1 : u32.t := M.read requirement in
      assign (deref α0).["requirement"] α1 in
    let* _ : M.Val unit :=
      let* α0 : mut_ref multisig.Multisig.t := M.read self in
      let* α1 : unit :=
        M.call
          (multisig.Multisig.t::["clean_owner_confirmations"]
            α0
            (borrow owner)) in
      M.alloc α1 in
    let* _ : M.Val unit :=
      let* α0 : mut_ref multisig.Multisig.t := M.read self in
      let* α1 : multisig.Env.t :=
        M.call (multisig.Multisig.t::["env"] (borrow (deref α0))) in
      let* α2 : M.Val multisig.Env.t := M.alloc α1 in
      let* α3 : multisig.AccountId.t := M.read owner in
      let* α4 : unit :=
        M.call
          (multisig.Env.t::["emit_event"]
            (borrow α2)
            (multisig.Event.OwnerRemoval
              {| multisig.OwnerRemoval.owner := α3; |})) in
      M.alloc α4 in
    let* α0 : M.Val unit := M.alloc tt in
    M.read α0.
  
  Global Instance AssociatedFunction_remove_owner :
    Notations.DoubleColon Self "remove_owner" := {
    Notations.double_colon := remove_owner;
  }.
  
  (*
      pub fn replace_owner(&mut self, old_owner: AccountId, new_owner: AccountId) {
          self.ensure_from_wallet();
          self.ensure_owner(&old_owner);
          self.ensure_no_owner(&new_owner);
          let owner_index = self.owner_index(&old_owner);
          self.owners[owner_index as usize] = new_owner;
          self.is_owner.remove(old_owner);
          self.is_owner.insert(new_owner, ());
          self.clean_owner_confirmations(&old_owner);
          self.env()
              .emit_event(Event::OwnerRemoval(OwnerRemoval { owner: old_owner }));
          self.env()
              .emit_event(Event::OwnerAddition(OwnerAddition { owner: new_owner }));
      }
  *)
  Definition replace_owner
      (self : mut_ref Self)
      (old_owner : multisig.AccountId.t)
      (new_owner : multisig.AccountId.t)
      : M unit :=
    let* self := M.alloc self in
    let* old_owner := M.alloc old_owner in
    let* new_owner := M.alloc new_owner in
    let* _ : M.Val unit :=
      let* α0 : mut_ref multisig.Multisig.t := M.read self in
      let* α1 : unit :=
        M.call
          (multisig.Multisig.t::["ensure_from_wallet"] (borrow (deref α0))) in
      M.alloc α1 in
    let* _ : M.Val unit :=
      let* α0 : mut_ref multisig.Multisig.t := M.read self in
      let* α1 : unit :=
        M.call
          (multisig.Multisig.t::["ensure_owner"]
            (borrow (deref α0))
            (borrow old_owner)) in
      M.alloc α1 in
    let* _ : M.Val unit :=
      let* α0 : mut_ref multisig.Multisig.t := M.read self in
      let* α1 : unit :=
        M.call
          (multisig.Multisig.t::["ensure_no_owner"]
            (borrow (deref α0))
            (borrow new_owner)) in
      M.alloc α1 in
    let* owner_index : M.Val u32.t :=
      let* α0 : mut_ref multisig.Multisig.t := M.read self in
      let* α1 : u32.t :=
        M.call
          (multisig.Multisig.t::["owner_index"]
            (borrow (deref α0))
            (borrow old_owner)) in
      M.alloc α1 in
    let* _ : M.Val unit :=
      let* α0 : mut_ref multisig.Multisig.t := M.read self in
      let* α1 : u32.t := M.read owner_index in
      let* α2 : usize.t := cast α1 in
      let* α3 : mut_ref multisig.AccountId.t :=
        M.call
          ((core.ops.index.IndexMut.index_mut
              (Self :=
                alloc.vec.Vec.t multisig.AccountId.t alloc.alloc.Global.t)
              (Trait := ltac:(refine _)))
            (borrow_mut (deref α0).["owners"])
            α2) in
      let* α4 : multisig.AccountId.t := M.read new_owner in
      assign (deref α3) α4 in
    let* _ : M.Val unit :=
      let* α0 : mut_ref multisig.Multisig.t := M.read self in
      let* α1 : multisig.AccountId.t := M.read old_owner in
      let* α2 : unit :=
        M.call
          ((multisig.Mapping.t multisig.AccountId.t unit)::["remove"]
            (borrow (deref α0).["is_owner"])
            α1) in
      M.alloc α2 in
    let* _ : M.Val (core.option.Option.t u32.t) :=
      let* α0 : mut_ref multisig.Multisig.t := M.read self in
      let* α1 : multisig.AccountId.t := M.read new_owner in
      let* α2 : core.option.Option.t u32.t :=
        M.call
          ((multisig.Mapping.t multisig.AccountId.t unit)::["insert"]
            (borrow_mut (deref α0).["is_owner"])
            α1
            tt) in
      M.alloc α2 in
    let* _ : M.Val unit :=
      let* α0 : mut_ref multisig.Multisig.t := M.read self in
      let* α1 : unit :=
        M.call
          (multisig.Multisig.t::["clean_owner_confirmations"]
            α0
            (borrow old_owner)) in
      M.alloc α1 in
    let* _ : M.Val unit :=
      let* α0 : mut_ref multisig.Multisig.t := M.read self in
      let* α1 : multisig.Env.t :=
        M.call (multisig.Multisig.t::["env"] (borrow (deref α0))) in
      let* α2 : M.Val multisig.Env.t := M.alloc α1 in
      let* α3 : multisig.AccountId.t := M.read old_owner in
      let* α4 : unit :=
        M.call
          (multisig.Env.t::["emit_event"]
            (borrow α2)
            (multisig.Event.OwnerRemoval
              {| multisig.OwnerRemoval.owner := α3; |})) in
      M.alloc α4 in
    let* _ : M.Val unit :=
      let* α0 : mut_ref multisig.Multisig.t := M.read self in
      let* α1 : multisig.Env.t :=
        M.call (multisig.Multisig.t::["env"] (borrow (deref α0))) in
      let* α2 : M.Val multisig.Env.t := M.alloc α1 in
      let* α3 : multisig.AccountId.t := M.read new_owner in
      let* α4 : unit :=
        M.call
          (multisig.Env.t::["emit_event"]
            (borrow α2)
            (multisig.Event.OwnerAddition
              {| multisig.OwnerAddition.owner := α3; |})) in
      M.alloc α4 in
    let* α0 : M.Val unit := M.alloc tt in
    M.read α0.
  
  Global Instance AssociatedFunction_replace_owner :
    Notations.DoubleColon Self "replace_owner" := {
    Notations.double_colon := replace_owner;
  }.
  
  (*
      pub fn change_requirement(&mut self, new_requirement: u32) {
          self.ensure_from_wallet();
          ensure_requirement_is_valid(self.owners.len() as u32, new_requirement);
          self.requirement = new_requirement;
          self.env()
              .emit_event(Event::RequirementChange(RequirementChange {
                  new_requirement,
              }));
      }
  *)
  Definition change_requirement
      (self : mut_ref Self)
      (new_requirement : u32.t)
      : M unit :=
    let* self := M.alloc self in
    let* new_requirement := M.alloc new_requirement in
    let* _ : M.Val unit :=
      let* α0 : mut_ref multisig.Multisig.t := M.read self in
      let* α1 : unit :=
        M.call
          (multisig.Multisig.t::["ensure_from_wallet"] (borrow (deref α0))) in
      M.alloc α1 in
    let* _ : M.Val unit :=
      let* α0 : mut_ref multisig.Multisig.t := M.read self in
      let* α1 : usize.t :=
        M.call
          ((alloc.vec.Vec.t multisig.AccountId.t alloc.alloc.Global.t)::["len"]
            (borrow (deref α0).["owners"])) in
      let* α2 : u32.t := cast α1 in
      let* α3 : u32.t := M.read new_requirement in
      let* α4 : unit := M.call (multisig.ensure_requirement_is_valid α2 α3) in
      M.alloc α4 in
    let* _ : M.Val unit :=
      let* α0 : mut_ref multisig.Multisig.t := M.read self in
      let* α1 : u32.t := M.read new_requirement in
      assign (deref α0).["requirement"] α1 in
    let* _ : M.Val unit :=
      let* α0 : mut_ref multisig.Multisig.t := M.read self in
      let* α1 : multisig.Env.t :=
        M.call (multisig.Multisig.t::["env"] (borrow (deref α0))) in
      let* α2 : M.Val multisig.Env.t := M.alloc α1 in
      let* α3 : u32.t := M.read new_requirement in
      let* α4 : unit :=
        M.call
          (multisig.Env.t::["emit_event"]
            (borrow α2)
            (multisig.Event.RequirementChange
              {| multisig.RequirementChange.new_requirement := α3; |})) in
      M.alloc α4 in
    let* α0 : M.Val unit := M.alloc tt in
    M.read α0.
  
  Global Instance AssociatedFunction_change_requirement :
    Notations.DoubleColon Self "change_requirement" := {
    Notations.double_colon := change_requirement;
  }.
  
  (*
      pub fn submit_transaction(
          &mut self,
          transaction: Transaction,
      ) -> (TransactionId, ConfirmationStatus) {
          self.ensure_caller_is_owner();
          let trans_id = self.transaction_list.next_id;
          self.transaction_list.next_id =
              trans_id.checked_add(1).expect("Transaction ids exhausted.");
          self.transactions.insert(trans_id, transaction);
          self.transaction_list.transactions.push(trans_id);
          self.env().emit_event(Event::Submission(Submission {
              transaction: trans_id,
          }));
          (
              trans_id,
              self.confirm_by_caller(self.env().caller(), trans_id),
          )
      }
  *)
  Definition submit_transaction
      (self : mut_ref Self)
      (transaction : multisig.Transaction.t)
      : M (ltac:(multisig.TransactionId) * multisig.ConfirmationStatus.t) :=
    let* self := M.alloc self in
    let* transaction := M.alloc transaction in
    let* _ : M.Val unit :=
      let* α0 : mut_ref multisig.Multisig.t := M.read self in
      let* α1 : unit :=
        M.call
          (multisig.Multisig.t::["ensure_caller_is_owner"]
            (borrow (deref α0))) in
      M.alloc α1 in
    let* trans_id : M.Val u32.t :=
      let* α0 : mut_ref multisig.Multisig.t := M.read self in
      M.copy (deref α0).["transaction_list"].["next_id"] in
    let* _ : M.Val unit :=
      let* α0 : mut_ref multisig.Multisig.t := M.read self in
      let* α1 : u32.t := M.read trans_id in
      let* α2 : core.option.Option.t u32.t :=
        M.call (u32.t::["checked_add"] α1 (Integer.of_Z 1)) in
      let* α3 : ref str.t := M.read (mk_str "Transaction ids exhausted.") in
      let* α4 : u32.t :=
        M.call ((core.option.Option.t u32.t)::["expect"] α2 α3) in
      assign (deref α0).["transaction_list"].["next_id"] α4 in
    let* _ : M.Val (core.option.Option.t u32.t) :=
      let* α0 : mut_ref multisig.Multisig.t := M.read self in
      let* α1 : u32.t := M.read trans_id in
      let* α2 : multisig.Transaction.t := M.read transaction in
      let* α3 : core.option.Option.t u32.t :=
        M.call
          ((multisig.Mapping.t u32.t multisig.Transaction.t)::["insert"]
            (borrow_mut (deref α0).["transactions"])
            α1
            α2) in
      M.alloc α3 in
    let* _ : M.Val unit :=
      let* α0 : mut_ref multisig.Multisig.t := M.read self in
      let* α1 : u32.t := M.read trans_id in
      let* α2 : unit :=
        M.call
          ((alloc.vec.Vec.t u32.t alloc.alloc.Global.t)::["push"]
            (borrow_mut (deref α0).["transaction_list"].["transactions"])
            α1) in
      M.alloc α2 in
    let* _ : M.Val unit :=
      let* α0 : mut_ref multisig.Multisig.t := M.read self in
      let* α1 : multisig.Env.t :=
        M.call (multisig.Multisig.t::["env"] (borrow (deref α0))) in
      let* α2 : M.Val multisig.Env.t := M.alloc α1 in
      let* α3 : u32.t := M.read trans_id in
      let* α4 : unit :=
        M.call
          (multisig.Env.t::["emit_event"]
            (borrow α2)
            (multisig.Event.Submission
              {| multisig.Submission.transaction := α3; |})) in
      M.alloc α4 in
    let* α0 : u32.t := M.read trans_id in
    let* α1 : mut_ref multisig.Multisig.t := M.read self in
    let* α2 : mut_ref multisig.Multisig.t := M.read self in
    let* α3 : multisig.Env.t :=
      M.call (multisig.Multisig.t::["env"] (borrow (deref α2))) in
    let* α4 : M.Val multisig.Env.t := M.alloc α3 in
    let* α5 : multisig.AccountId.t :=
      M.call (multisig.Env.t::["caller"] (borrow α4)) in
    let* α6 : u32.t := M.read trans_id in
    let* α7 : multisig.ConfirmationStatus.t :=
      M.call (multisig.Multisig.t::["confirm_by_caller"] α1 α5 α6) in
    let* α0 : M.Val (u32.t * multisig.ConfirmationStatus.t) :=
      M.alloc (α0, α7) in
    M.read α0.
  
  Global Instance AssociatedFunction_submit_transaction :
    Notations.DoubleColon Self "submit_transaction" := {
    Notations.double_colon := submit_transaction;
  }.
  
  (*
      pub fn cancel_transaction(&mut self, trans_id: TransactionId) {
          self.ensure_from_wallet();
          if self.take_transaction(trans_id).is_some() {
              self.env().emit_event(Event::Cancellation(Cancellation {
                  transaction: trans_id,
              }));
          }
      }
  *)
  Definition cancel_transaction
      (self : mut_ref Self)
      (trans_id : ltac:(multisig.TransactionId))
      : M unit :=
    let* self := M.alloc self in
    let* trans_id := M.alloc trans_id in
    let* _ : M.Val unit :=
      let* α0 : mut_ref multisig.Multisig.t := M.read self in
      let* α1 : unit :=
        M.call
          (multisig.Multisig.t::["ensure_from_wallet"] (borrow (deref α0))) in
      M.alloc α1 in
    let* α0 : mut_ref multisig.Multisig.t := M.read self in
    let* α1 : u32.t := M.read trans_id in
    let* α2 : core.option.Option.t multisig.Transaction.t :=
      M.call (multisig.Multisig.t::["take_transaction"] α0 α1) in
    let* α3 : M.Val (core.option.Option.t multisig.Transaction.t) :=
      M.alloc α2 in
    let* α4 : bool.t :=
      M.call
        ((core.option.Option.t multisig.Transaction.t)::["is_some"]
          (borrow α3)) in
    let* α5 : M.Val bool.t := M.alloc α4 in
    let* α6 : bool.t := M.read (use α5) in
    let* α0 : M.Val unit :=
      if α6 then
        let* _ : M.Val unit :=
          let* α0 : mut_ref multisig.Multisig.t := M.read self in
          let* α1 : multisig.Env.t :=
            M.call (multisig.Multisig.t::["env"] (borrow (deref α0))) in
          let* α2 : M.Val multisig.Env.t := M.alloc α1 in
          let* α3 : u32.t := M.read trans_id in
          let* α4 : unit :=
            M.call
              (multisig.Env.t::["emit_event"]
                (borrow α2)
                (multisig.Event.Cancellation
                  {| multisig.Cancellation.transaction := α3; |})) in
          M.alloc α4 in
        M.alloc tt
      else
        M.alloc tt in
    M.read α0.
  
  Global Instance AssociatedFunction_cancel_transaction :
    Notations.DoubleColon Self "cancel_transaction" := {
    Notations.double_colon := cancel_transaction;
  }.
  
  (*
      pub fn confirm_transaction(&mut self, trans_id: TransactionId) -> ConfirmationStatus {
          self.ensure_caller_is_owner();
          self.ensure_transaction_exists(trans_id);
          self.confirm_by_caller(self.env().caller(), trans_id)
      }
  *)
  Definition confirm_transaction
      (self : mut_ref Self)
      (trans_id : ltac:(multisig.TransactionId))
      : M multisig.ConfirmationStatus.t :=
    let* self := M.alloc self in
    let* trans_id := M.alloc trans_id in
    let* _ : M.Val unit :=
      let* α0 : mut_ref multisig.Multisig.t := M.read self in
      let* α1 : unit :=
        M.call
          (multisig.Multisig.t::["ensure_caller_is_owner"]
            (borrow (deref α0))) in
      M.alloc α1 in
    let* _ : M.Val unit :=
      let* α0 : mut_ref multisig.Multisig.t := M.read self in
      let* α1 : u32.t := M.read trans_id in
      let* α2 : unit :=
        M.call
          (multisig.Multisig.t::["ensure_transaction_exists"]
            (borrow (deref α0))
            α1) in
      M.alloc α2 in
    let* α0 : mut_ref multisig.Multisig.t := M.read self in
    let* α1 : mut_ref multisig.Multisig.t := M.read self in
    let* α2 : multisig.Env.t :=
      M.call (multisig.Multisig.t::["env"] (borrow (deref α1))) in
    let* α3 : M.Val multisig.Env.t := M.alloc α2 in
    let* α4 : multisig.AccountId.t :=
      M.call (multisig.Env.t::["caller"] (borrow α3)) in
    let* α5 : u32.t := M.read trans_id in
    let* α6 : multisig.ConfirmationStatus.t :=
      M.call (multisig.Multisig.t::["confirm_by_caller"] α0 α4 α5) in
    let* α0 : M.Val multisig.ConfirmationStatus.t := M.alloc α6 in
    M.read α0.
  
  Global Instance AssociatedFunction_confirm_transaction :
    Notations.DoubleColon Self "confirm_transaction" := {
    Notations.double_colon := confirm_transaction;
  }.
  
  (*
      pub fn revoke_confirmation(&mut self, trans_id: TransactionId) {
          self.ensure_caller_is_owner();
          let caller = self.env().caller();
          if self.confirmations.contains(&(trans_id, caller)) {
              self.confirmations.remove((trans_id, caller));
              let mut confirmation_count = self
                  .confirmation_count
                  .get(&trans_id)
                  .expect("There is a entry in `self.confirmations`. Hence a count must exit.");
              // Will not underflow as there is at least one confirmation
              confirmation_count -= 1;
              self.confirmation_count.insert(trans_id, confirmation_count);
              self.env().emit_event(Event::Revocation(Revocation {
                  transaction: trans_id,
                  from: caller,
              }));
          }
      }
  *)
  Definition revoke_confirmation
      (self : mut_ref Self)
      (trans_id : ltac:(multisig.TransactionId))
      : M unit :=
    let* self := M.alloc self in
    let* trans_id := M.alloc trans_id in
    let* _ : M.Val unit :=
      let* α0 : mut_ref multisig.Multisig.t := M.read self in
      let* α1 : unit :=
        M.call
          (multisig.Multisig.t::["ensure_caller_is_owner"]
            (borrow (deref α0))) in
      M.alloc α1 in
    let* caller : M.Val multisig.AccountId.t :=
      let* α0 : mut_ref multisig.Multisig.t := M.read self in
      let* α1 : multisig.Env.t :=
        M.call (multisig.Multisig.t::["env"] (borrow (deref α0))) in
      let* α2 : M.Val multisig.Env.t := M.alloc α1 in
      let* α3 : multisig.AccountId.t :=
        M.call (multisig.Env.t::["caller"] (borrow α2)) in
      M.alloc α3 in
    let* α0 : mut_ref multisig.Multisig.t := M.read self in
    let* α1 : u32.t := M.read trans_id in
    let* α2 : multisig.AccountId.t := M.read caller in
    let* α3 : M.Val (u32.t * multisig.AccountId.t) := M.alloc (α1, α2) in
    let* α4 : bool.t :=
      M.call
        ((multisig.Mapping.t (u32.t * multisig.AccountId.t) unit)::["contains"]
          (borrow (deref α0).["confirmations"])
          (borrow α3)) in
    let* α5 : M.Val bool.t := M.alloc α4 in
    let* α6 : bool.t := M.read (use α5) in
    let* α0 : M.Val unit :=
      if α6 then
        let* _ : M.Val unit :=
          let* α0 : mut_ref multisig.Multisig.t := M.read self in
          let* α1 : u32.t := M.read trans_id in
          let* α2 : multisig.AccountId.t := M.read caller in
          let* α3 : unit :=
            M.call
              ((multisig.Mapping.t
                    (u32.t * multisig.AccountId.t)
                    unit)::["remove"]
                (borrow (deref α0).["confirmations"])
                (α1, α2)) in
          M.alloc α3 in
        let* confirmation_count : M.Val u32.t :=
          let* α0 : mut_ref multisig.Multisig.t := M.read self in
          let* α1 : core.option.Option.t u32.t :=
            M.call
              ((multisig.Mapping.t u32.t u32.t)::["get"]
                (borrow (deref α0).["confirmation_count"])
                (borrow trans_id)) in
          let* α2 : ref str.t :=
            M.read
              (mk_str
                "There is a entry in `self.confirmations`. Hence a count must exit.") in
          let* α3 : u32.t :=
            M.call ((core.option.Option.t u32.t)::["expect"] α1 α2) in
          M.alloc α3 in
        let* _ : M.Val unit :=
          let β : M.Val u32.t := confirmation_count in
          let* α0 := M.read β in
          let* α1 := BinOp.Panic.sub α0 (Integer.of_Z 1) in
          assign β α1 in
        let* _ : M.Val (core.option.Option.t u32.t) :=
          let* α0 : mut_ref multisig.Multisig.t := M.read self in
          let* α1 : u32.t := M.read trans_id in
          let* α2 : u32.t := M.read confirmation_count in
          let* α3 : core.option.Option.t u32.t :=
            M.call
              ((multisig.Mapping.t u32.t u32.t)::["insert"]
                (borrow_mut (deref α0).["confirmation_count"])
                α1
                α2) in
          M.alloc α3 in
        let* _ : M.Val unit :=
          let* α0 : mut_ref multisig.Multisig.t := M.read self in
          let* α1 : multisig.Env.t :=
            M.call (multisig.Multisig.t::["env"] (borrow (deref α0))) in
          let* α2 : M.Val multisig.Env.t := M.alloc α1 in
          let* α3 : u32.t := M.read trans_id in
          let* α4 : multisig.AccountId.t := M.read caller in
          let* α5 : unit :=
            M.call
              (multisig.Env.t::["emit_event"]
                (borrow α2)
                (multisig.Event.Revocation
                  {|
                    multisig.Revocation.transaction := α3;
                    multisig.Revocation.from := α4;
                  |})) in
          M.alloc α5 in
        M.alloc tt
      else
        M.alloc tt in
    M.read α0.
  
  Global Instance AssociatedFunction_revoke_confirmation :
    Notations.DoubleColon Self "revoke_confirmation" := {
    Notations.double_colon := revoke_confirmation;
  }.
  
  (*
      pub fn invoke_transaction(&mut self, trans_id: TransactionId) -> Result<(), Error> {
          self.ensure_confirmed(trans_id);
          let t = self.take_transaction(trans_id).expect(WRONG_TRANSACTION_ID);
          assert!(self.env().transferred_value() == t.transferred_value);
          // let result = build_call()
          //     .call(t.callee)
          //     .gas_limit(t.gas_limit)
          //     .transferred_value(t.transferred_value)
          //     .call_flags(CallFlags::default().set_allow_reentry(t.allow_reentry))
          //     .exec_input(ExecutionInput::new(t.selector.into()).push_arg(CallInput(&t.input)))
          //     .returns::<()>()
          //     .try_invoke();
          let result: Result<Result<Vec<u8>, ()>, ()> = todo!();
  
          let result = match result {
              Ok(Ok(_)) => Ok(()),
              _ => Err(Error::TransactionFailed),
          };
  
          self.env().emit_event(Event::Execution(Execution {
              transaction: trans_id,
              result: result.map(|_| None),
          }));
          result
      }
  *)
  Definition invoke_transaction
      (self : mut_ref Self)
      (trans_id : ltac:(multisig.TransactionId))
      : M (core.result.Result.t unit multisig.Error.t) :=
    let* self := M.alloc self in
    let* trans_id := M.alloc trans_id in
    let* _ : M.Val unit :=
      let* α0 : mut_ref multisig.Multisig.t := M.read self in
      let* α1 : u32.t := M.read trans_id in
      let* α2 : unit :=
        M.call
          (multisig.Multisig.t::["ensure_confirmed"] (borrow (deref α0)) α1) in
      M.alloc α2 in
    let* t : M.Val multisig.Transaction.t :=
      let* α0 : mut_ref multisig.Multisig.t := M.read self in
      let* α1 : u32.t := M.read trans_id in
      let* α2 : core.option.Option.t multisig.Transaction.t :=
        M.call (multisig.Multisig.t::["take_transaction"] α0 α1) in
      let* α3 : ref str.t := M.read multisig.WRONG_TRANSACTION_ID in
      let* α4 : multisig.Transaction.t :=
        M.call
          ((core.option.Option.t multisig.Transaction.t)::["expect"] α2 α3) in
      M.alloc α4 in
    let* _ : M.Val unit :=
      let* α0 : mut_ref multisig.Multisig.t := M.read self in
      let* α1 : multisig.Env.t :=
        M.call (multisig.Multisig.t::["env"] (borrow (deref α0))) in
      let* α2 : M.Val multisig.Env.t := M.alloc α1 in
      let* α3 : u128.t :=
        M.call (multisig.Env.t::["transferred_value"] (borrow α2)) in
      let* α4 : u128.t := M.read t.["transferred_value"] in
      let* α5 : M.Val bool.t := M.alloc (UnOp.not (BinOp.Pure.eq α3 α4)) in
      let* α6 : bool.t := M.read (use α5) in
      if α6 then
        let* α0 : ref str.t :=
          M.read
            (mk_str
              "assertion failed: self.env().transferred_value() == t.transferred_value") in
        let* α1 : never.t := M.call (core.panicking.panic α0) in
        let* α2 : unit := never_to_any α1 in
        M.alloc α2
      else
        M.alloc tt in
    let* result :
        M.Val
          (core.result.Result.t
            (core.result.Result.t
              (alloc.vec.Vec.t u8.t alloc.alloc.Global.t)
              unit)
            unit) :=
      let* α0 : ref str.t := M.read (mk_str "not yet implemented") in
      let* α1 : never.t := M.call (core.panicking.panic α0) in
      let* α2 :
          core.result.Result.t
            (core.result.Result.t
              (alloc.vec.Vec.t u8.t alloc.alloc.Global.t)
              unit)
            unit :=
        never_to_any α1 in
      M.alloc α2 in
    let* result : M.Val (core.result.Result.t unit multisig.Error.t) :=
      let* α0 :
          core.result.Result.t
            (core.result.Result.t
              (alloc.vec.Vec.t u8.t alloc.alloc.Global.t)
              unit)
            unit :=
        M.read result in
      let* α1 : M.Val (core.result.Result.t unit multisig.Error.t) :=
        match α0 with
        | core.result.Result.Ok (core.result.Result.Ok _) =>
          M.alloc (core.result.Result.Ok tt)
        | _ => M.alloc (core.result.Result.Err multisig.Error.TransactionFailed)
        end in
      M.copy α1 in
    let* _ : M.Val unit :=
      let* α0 : mut_ref multisig.Multisig.t := M.read self in
      let* α1 : multisig.Env.t :=
        M.call (multisig.Multisig.t::["env"] (borrow (deref α0))) in
      let* α2 : M.Val multisig.Env.t := M.alloc α1 in
      let* α3 : u32.t := M.read trans_id in
      let* α4 : core.result.Result.t unit multisig.Error.t := M.read result in
      let* α5 :
          core.result.Result.t
            (core.option.Option.t (alloc.vec.Vec.t u8.t alloc.alloc.Global.t))
            multisig.Error.t :=
        M.call
          ((core.result.Result.t unit multisig.Error.t)::["map"]
            α4
            (fun (_ : unit) =>
              (M.pure core.option.Option.None) :
              M
                (core.option.Option.t
                  (alloc.vec.Vec.t u8.t alloc.alloc.Global.t)))) in
      let* α6 : unit :=
        M.call
          (multisig.Env.t::["emit_event"]
            (borrow α2)
            (multisig.Event.Execution
              {|
                multisig.Execution.transaction := α3;
                multisig.Execution.result := α5;
              |})) in
      M.alloc α6 in
    M.read result.
  
  Global Instance AssociatedFunction_invoke_transaction :
    Notations.DoubleColon Self "invoke_transaction" := {
    Notations.double_colon := invoke_transaction;
  }.
  
  (*
      pub fn eval_transaction(&mut self, trans_id: TransactionId) -> Result<Vec<u8>, Error> {
          self.ensure_confirmed(trans_id);
          let t = self.take_transaction(trans_id).expect(WRONG_TRANSACTION_ID);
          // let result = build_call()
          //     .call(t.callee)
          //     .gas_limit(t.gas_limit)
          //     .transferred_value(t.transferred_value)
          //     .call_flags(CallFlags::default().set_allow_reentry(t.allow_reentry))
          //     .exec_input(ExecutionInput::new(t.selector.into()).push_arg(CallInput(&t.input)))
          //     .returns::<Vec<u8>>()
          //     .try_invoke();
          let result: Result<Result<Vec<u8>, ()>, ()> = todo!();
  
          let result = match result {
              Ok(Ok(v)) => Ok(v),
              _ => Err(Error::TransactionFailed),
          };
  
          self.env().emit_event(Event::Execution(Execution {
              transaction: trans_id,
              result: result.clone().map(Some),
          }));
          result
      }
  *)
  Definition eval_transaction
      (self : mut_ref Self)
      (trans_id : ltac:(multisig.TransactionId))
      :
        M
          (core.result.Result.t
            (alloc.vec.Vec.t u8.t alloc.vec.Vec.Default.A)
            multisig.Error.t) :=
    let* self := M.alloc self in
    let* trans_id := M.alloc trans_id in
    let* _ : M.Val unit :=
      let* α0 : mut_ref multisig.Multisig.t := M.read self in
      let* α1 : u32.t := M.read trans_id in
      let* α2 : unit :=
        M.call
          (multisig.Multisig.t::["ensure_confirmed"] (borrow (deref α0)) α1) in
      M.alloc α2 in
    let* t : M.Val multisig.Transaction.t :=
      let* α0 : mut_ref multisig.Multisig.t := M.read self in
      let* α1 : u32.t := M.read trans_id in
      let* α2 : core.option.Option.t multisig.Transaction.t :=
        M.call (multisig.Multisig.t::["take_transaction"] α0 α1) in
      let* α3 : ref str.t := M.read multisig.WRONG_TRANSACTION_ID in
      let* α4 : multisig.Transaction.t :=
        M.call
          ((core.option.Option.t multisig.Transaction.t)::["expect"] α2 α3) in
      M.alloc α4 in
    let* result :
        M.Val
          (core.result.Result.t
            (core.result.Result.t
              (alloc.vec.Vec.t u8.t alloc.alloc.Global.t)
              unit)
            unit) :=
      let* α0 : ref str.t := M.read (mk_str "not yet implemented") in
      let* α1 : never.t := M.call (core.panicking.panic α0) in
      let* α2 :
          core.result.Result.t
            (core.result.Result.t
              (alloc.vec.Vec.t u8.t alloc.alloc.Global.t)
              unit)
            unit :=
        never_to_any α1 in
      M.alloc α2 in
    let* result :
        M.Val
          (core.result.Result.t
            (alloc.vec.Vec.t u8.t alloc.alloc.Global.t)
            multisig.Error.t) :=
      let* α0 :
          core.result.Result.t
            (core.result.Result.t
              (alloc.vec.Vec.t u8.t alloc.alloc.Global.t)
              unit)
            unit :=
        M.read result in
      let* α1 :
          M.Val
            (core.result.Result.t
              (alloc.vec.Vec.t u8.t alloc.alloc.Global.t)
              multisig.Error.t) :=
        match α0 with
        | core.result.Result.Ok (core.result.Result.Ok v) =>
          let* v := M.alloc v in
          let* α0 : alloc.vec.Vec.t u8.t alloc.alloc.Global.t := M.read v in
          M.alloc (core.result.Result.Ok α0)
        | _ => M.alloc (core.result.Result.Err multisig.Error.TransactionFailed)
        end in
      M.copy α1 in
    let* _ : M.Val unit :=
      let* α0 : mut_ref multisig.Multisig.t := M.read self in
      let* α1 : multisig.Env.t :=
        M.call (multisig.Multisig.t::["env"] (borrow (deref α0))) in
      let* α2 : M.Val multisig.Env.t := M.alloc α1 in
      let* α3 : u32.t := M.read trans_id in
      let* α4 :
          core.result.Result.t
            (alloc.vec.Vec.t u8.t alloc.alloc.Global.t)
            multisig.Error.t :=
        M.call
          ((core.clone.Clone.clone
              (Self :=
                core.result.Result.t
                  (alloc.vec.Vec.t u8.t alloc.alloc.Global.t)
                  multisig.Error.t)
              (Trait := ltac:(refine _)))
            (borrow result)) in
      let* α5 :
          core.result.Result.t
            (core.option.Option.t (alloc.vec.Vec.t u8.t alloc.alloc.Global.t))
            multisig.Error.t :=
        M.call
          ((core.result.Result.t
                (alloc.vec.Vec.t u8.t alloc.alloc.Global.t)
                multisig.Error.t)::["map"]
            α4
            core.option.Option.Some) in
      let* α6 : unit :=
        M.call
          (multisig.Env.t::["emit_event"]
            (borrow α2)
            (multisig.Event.Execution
              {|
                multisig.Execution.transaction := α3;
                multisig.Execution.result := α5;
              |})) in
      M.alloc α6 in
    M.read result.
  
  Global Instance AssociatedFunction_eval_transaction :
    Notations.DoubleColon Self "eval_transaction" := {
    Notations.double_colon := eval_transaction;
  }.
  
  (*
      fn confirm_by_caller(
          &mut self,
          confirmer: AccountId,
          transaction: TransactionId,
      ) -> ConfirmationStatus {
          let mut count = self.confirmation_count.get(&transaction).unwrap_or(0);
          let key = (transaction, confirmer);
          let new_confirmation = !self.confirmations.contains(&key);
          if new_confirmation {
              count += 1;
              self.confirmations.insert(key, ());
              self.confirmation_count.insert(transaction, count);
          }
          let status = {
              if count >= self.requirement {
                  ConfirmationStatus::Confirmed
              } else {
                  ConfirmationStatus::ConfirmationsNeeded(self.requirement - count)
              }
          };
          if new_confirmation {
              self.env().emit_event(Event::Confirmation(Confirmation {
                  transaction,
                  from: confirmer,
                  status,
              }));
          }
          status
      }
  *)
  Definition confirm_by_caller
      (self : mut_ref Self)
      (confirmer : multisig.AccountId.t)
      (transaction : ltac:(multisig.TransactionId))
      : M multisig.ConfirmationStatus.t :=
    let* self := M.alloc self in
    let* confirmer := M.alloc confirmer in
    let* transaction := M.alloc transaction in
    let* count : M.Val u32.t :=
      let* α0 : mut_ref multisig.Multisig.t := M.read self in
      let* α1 : core.option.Option.t u32.t :=
        M.call
          ((multisig.Mapping.t u32.t u32.t)::["get"]
            (borrow (deref α0).["confirmation_count"])
            (borrow transaction)) in
      let* α2 : u32.t :=
        M.call
          ((core.option.Option.t u32.t)::["unwrap_or"] α1 (Integer.of_Z 0)) in
      M.alloc α2 in
    let* key : M.Val (u32.t * multisig.AccountId.t) :=
      let* α0 : u32.t := M.read transaction in
      let* α1 : multisig.AccountId.t := M.read confirmer in
      M.alloc (α0, α1) in
    let* new_confirmation : M.Val bool.t :=
      let* α0 : mut_ref multisig.Multisig.t := M.read self in
      let* α1 : bool.t :=
        M.call
          ((multisig.Mapping.t
                (u32.t * multisig.AccountId.t)
                unit)::["contains"]
            (borrow (deref α0).["confirmations"])
            (borrow key)) in
      M.alloc (UnOp.not α1) in
    let* _ : M.Val unit :=
      let* α0 : bool.t := M.read (use new_confirmation) in
      if α0 then
        let* _ : M.Val unit :=
          let β : M.Val u32.t := count in
          let* α0 := M.read β in
          let* α1 := BinOp.Panic.add α0 (Integer.of_Z 1) in
          assign β α1 in
        let* _ : M.Val (core.option.Option.t u32.t) :=
          let* α0 : mut_ref multisig.Multisig.t := M.read self in
          let* α1 : u32.t * multisig.AccountId.t := M.read key in
          let* α2 : core.option.Option.t u32.t :=
            M.call
              ((multisig.Mapping.t
                    (u32.t * multisig.AccountId.t)
                    unit)::["insert"]
                (borrow_mut (deref α0).["confirmations"])
                α1
                tt) in
          M.alloc α2 in
        let* _ : M.Val (core.option.Option.t u32.t) :=
          let* α0 : mut_ref multisig.Multisig.t := M.read self in
          let* α1 : u32.t := M.read transaction in
          let* α2 : u32.t := M.read count in
          let* α3 : core.option.Option.t u32.t :=
            M.call
              ((multisig.Mapping.t u32.t u32.t)::["insert"]
                (borrow_mut (deref α0).["confirmation_count"])
                α1
                α2) in
          M.alloc α3 in
        M.alloc tt
      else
        M.alloc tt in
    let* status : M.Val multisig.ConfirmationStatus.t :=
      let* α0 : u32.t := M.read count in
      let* α1 : mut_ref multisig.Multisig.t := M.read self in
      let* α2 : u32.t := M.read (deref α1).["requirement"] in
      let* α3 : M.Val bool.t := M.alloc (BinOp.Pure.ge α0 α2) in
      let* α4 : bool.t := M.read (use α3) in
      let* α5 : M.Val multisig.ConfirmationStatus.t :=
        if α4 then
          M.alloc multisig.ConfirmationStatus.Confirmed
        else
          let* α0 : mut_ref multisig.Multisig.t := M.read self in
          let* α1 : u32.t := M.read (deref α0).["requirement"] in
          let* α2 : u32.t := M.read count in
          let* α3 : u32.t := BinOp.Panic.sub α1 α2 in
          M.alloc (multisig.ConfirmationStatus.ConfirmationsNeeded α3) in
      M.copy α5 in
    let* _ : M.Val unit :=
      let* α0 : bool.t := M.read (use new_confirmation) in
      if α0 then
        let* _ : M.Val unit :=
          let* α0 : mut_ref multisig.Multisig.t := M.read self in
          let* α1 : multisig.Env.t :=
            M.call (multisig.Multisig.t::["env"] (borrow (deref α0))) in
          let* α2 : M.Val multisig.Env.t := M.alloc α1 in
          let* α3 : u32.t := M.read transaction in
          let* α4 : multisig.AccountId.t := M.read confirmer in
          let* α5 : multisig.ConfirmationStatus.t := M.read status in
          let* α6 : unit :=
            M.call
              (multisig.Env.t::["emit_event"]
                (borrow α2)
                (multisig.Event.Confirmation
                  {|
                    multisig.Confirmation.transaction := α3;
                    multisig.Confirmation.from := α4;
                    multisig.Confirmation.status := α5;
                  |})) in
          M.alloc α6 in
        M.alloc tt
      else
        M.alloc tt in
    M.read status.
  
  Global Instance AssociatedFunction_confirm_by_caller :
    Notations.DoubleColon Self "confirm_by_caller" := {
    Notations.double_colon := confirm_by_caller;
  }.
  
  (*
      fn owner_index(&self, owner: &AccountId) -> u32 {
          self.owners.iter().position(|x| *x == *owner).expect(
              "This is only called after it was already verified that the id is
                 actually an owner.",
          ) as u32
      }
  *)
  Definition owner_index
      (self : ref Self)
      (owner : ref multisig.AccountId.t)
      : M u32.t :=
    let* self := M.alloc self in
    let* owner := M.alloc owner in
    let* α0 : ref multisig.Multisig.t := M.read self in
    let* α1 : ref (slice multisig.AccountId.t) :=
      M.call
        ((core.ops.deref.Deref.deref
            (Self := alloc.vec.Vec.t multisig.AccountId.t alloc.alloc.Global.t)
            (Trait := ltac:(refine _)))
          (borrow (deref α0).["owners"])) in
    let* α2 : core.slice.iter.Iter.t multisig.AccountId.t :=
      M.call ((slice multisig.AccountId.t)::["iter"] α1) in
    let* α3 : M.Val (core.slice.iter.Iter.t multisig.AccountId.t) :=
      M.alloc α2 in
    let* α4 : core.option.Option.t usize.t :=
      M.call
        ((core.iter.traits.iterator.Iterator.position
            (Self := core.slice.iter.Iter.t multisig.AccountId.t)
            (Trait := ltac:(refine _)))
          (borrow_mut α3)
          (fun (x : ref multisig.AccountId.t) =>
            (let* x := M.alloc x in
            let* α0 : ref multisig.AccountId.t := M.read x in
            let* α1 : ref multisig.AccountId.t := M.read owner in
            M.call
              ((core.cmp.PartialEq.eq
                  (Self := multisig.AccountId.t)
                  (Trait := ltac:(refine _)))
                α0
                α1)) :
            M bool.t)) in
    let* α5 : ref str.t :=
      M.read
        (mk_str
          "This is only called after it was already verified that the id is
               actually an owner.") in
    let* α6 : usize.t :=
      M.call ((core.option.Option.t usize.t)::["expect"] α4 α5) in
    cast α6.
  
  Global Instance AssociatedFunction_owner_index :
    Notations.DoubleColon Self "owner_index" := {
    Notations.double_colon := owner_index;
  }.
  
  (*
      fn take_transaction(&mut self, trans_id: TransactionId) -> Option<Transaction> {
          let transaction = self.transactions.get(&trans_id);
          if transaction.is_some() {
              self.transactions.remove(trans_id);
              let pos = self
                  .transaction_list
                  .transactions
                  .iter()
                  .position(|t| t == &trans_id)
                  .expect("The transaction exists hence it must also be in the list.");
              self.transaction_list.transactions.swap_remove(pos);
              for owner in self.owners.iter() {
                  self.confirmations.remove((trans_id, *owner));
              }
              self.confirmation_count.remove(trans_id);
          }
          transaction
      }
  *)
  Definition take_transaction
      (self : mut_ref Self)
      (trans_id : ltac:(multisig.TransactionId))
      : M (core.option.Option.t multisig.Transaction.t) :=
    let* self := M.alloc self in
    let* trans_id := M.alloc trans_id in
    let* transaction : M.Val (core.option.Option.t multisig.Transaction.t) :=
      let* α0 : mut_ref multisig.Multisig.t := M.read self in
      let* α1 : core.option.Option.t multisig.Transaction.t :=
        M.call
          ((multisig.Mapping.t u32.t multisig.Transaction.t)::["get"]
            (borrow (deref α0).["transactions"])
            (borrow trans_id)) in
      M.alloc α1 in
    let* _ : M.Val unit :=
      let* α0 : bool.t :=
        M.call
          ((core.option.Option.t multisig.Transaction.t)::["is_some"]
            (borrow transaction)) in
      let* α1 : M.Val bool.t := M.alloc α0 in
      let* α2 : bool.t := M.read (use α1) in
      if α2 then
        let* _ : M.Val unit :=
          let* α0 : mut_ref multisig.Multisig.t := M.read self in
          let* α1 : u32.t := M.read trans_id in
          let* α2 : unit :=
            M.call
              ((multisig.Mapping.t u32.t multisig.Transaction.t)::["remove"]
                (borrow (deref α0).["transactions"])
                α1) in
          M.alloc α2 in
        let* pos : M.Val usize.t :=
          let* α0 : mut_ref multisig.Multisig.t := M.read self in
          let* α1 : ref (slice u32.t) :=
            M.call
              ((core.ops.deref.Deref.deref
                  (Self := alloc.vec.Vec.t u32.t alloc.alloc.Global.t)
                  (Trait := ltac:(refine _)))
                (borrow (deref α0).["transaction_list"].["transactions"])) in
          let* α2 : core.slice.iter.Iter.t u32.t :=
            M.call ((slice u32.t)::["iter"] α1) in
          let* α3 : M.Val (core.slice.iter.Iter.t u32.t) := M.alloc α2 in
          let* α4 : core.option.Option.t usize.t :=
            M.call
              ((core.iter.traits.iterator.Iterator.position
                  (Self := core.slice.iter.Iter.t u32.t)
                  (Trait := ltac:(refine _)))
                (borrow_mut α3)
                (fun (t : ref u32.t) =>
                  (let* t := M.alloc t in
                  let* α0 : M.Val (ref u32.t) := M.alloc (borrow trans_id) in
                  M.call
                    ((core.cmp.PartialEq.eq
                        (Self := ref u32.t)
                        (Trait := ltac:(refine _)))
                      (borrow t)
                      (borrow α0))) :
                  M bool.t)) in
          let* α5 : ref str.t :=
            M.read
              (mk_str
                "The transaction exists hence it must also be in the list.") in
          let* α6 : usize.t :=
            M.call ((core.option.Option.t usize.t)::["expect"] α4 α5) in
          M.alloc α6 in
        let* _ : M.Val u32.t :=
          let* α0 : mut_ref multisig.Multisig.t := M.read self in
          let* α1 : usize.t := M.read pos in
          let* α2 : u32.t :=
            M.call
              ((alloc.vec.Vec.t u32.t alloc.alloc.Global.t)::["swap_remove"]
                (borrow_mut (deref α0).["transaction_list"].["transactions"])
                α1) in
          M.alloc α2 in
        let* _ : M.Val unit :=
          let* α0 : mut_ref multisig.Multisig.t := M.read self in
          let* α1 : ref (slice multisig.AccountId.t) :=
            M.call
              ((core.ops.deref.Deref.deref
                  (Self :=
                    alloc.vec.Vec.t multisig.AccountId.t alloc.alloc.Global.t)
                  (Trait := ltac:(refine _)))
                (borrow (deref α0).["owners"])) in
          let* α2 : core.slice.iter.Iter.t multisig.AccountId.t :=
            M.call ((slice multisig.AccountId.t)::["iter"] α1) in
          let* α3 : core.slice.iter.Iter.t multisig.AccountId.t :=
            M.call
              ((core.iter.traits.collect.IntoIterator.into_iter
                  (Self := core.slice.iter.Iter.t multisig.AccountId.t)
                  (Trait := ltac:(refine _)))
                α2) in
          let* α4 : M.Val unit :=
            match α3 with
            | iter =>
              let* iter := M.alloc iter in
              loop
                (let* _ : M.Val unit :=
                  let* α0 : core.option.Option.t (ref multisig.AccountId.t) :=
                    M.call
                      ((core.iter.traits.iterator.Iterator.next
                          (Self := core.slice.iter.Iter.t multisig.AccountId.t)
                          (Trait := ltac:(refine _)))
                        (borrow_mut iter)) in
                  match α0 with
                  | core.option.Option.None =>
                    let* α0 : M.Val never.t := Break in
                    let* α1 := M.read α0 in
                    let* α2 : unit := never_to_any α1 in
                    M.alloc α2
                  | core.option.Option.Some owner =>
                    let* owner := M.alloc owner in
                    let* _ : M.Val unit :=
                      let* α0 : mut_ref multisig.Multisig.t := M.read self in
                      let* α1 : u32.t := M.read trans_id in
                      let* α2 : ref multisig.AccountId.t := M.read owner in
                      let* α3 : multisig.AccountId.t := M.read (deref α2) in
                      let* α4 : unit :=
                        M.call
                          ((multisig.Mapping.t
                                (u32.t * multisig.AccountId.t)
                                unit)::["remove"]
                            (borrow (deref α0).["confirmations"])
                            (α1, α3)) in
                      M.alloc α4 in
                    M.alloc tt
                  end in
                M.alloc tt)
            end in
          M.pure (use α4) in
        let* _ : M.Val unit :=
          let* α0 : mut_ref multisig.Multisig.t := M.read self in
          let* α1 : u32.t := M.read trans_id in
          let* α2 : unit :=
            M.call
              ((multisig.Mapping.t u32.t u32.t)::["remove"]
                (borrow (deref α0).["confirmation_count"])
                α1) in
          M.alloc α2 in
        M.alloc tt
      else
        M.alloc tt in
    M.read transaction.
  
  Global Instance AssociatedFunction_take_transaction :
    Notations.DoubleColon Self "take_transaction" := {
    Notations.double_colon := take_transaction;
  }.
  
  (*
      fn clean_owner_confirmations(&mut self, owner: &AccountId) {
          for trans_id in &self.transaction_list.transactions {
              let key = ( *trans_id, *owner);
              if self.confirmations.contains(&key) {
                  self.confirmations.remove(key);
                  let mut count = self.confirmation_count.get(trans_id).unwrap_or(0);
                  count -= 1;
                  self.confirmation_count.insert( *trans_id, count);
              }
          }
      }
  *)
  Definition clean_owner_confirmations
      (self : mut_ref Self)
      (owner : ref multisig.AccountId.t)
      : M unit :=
    let* self := M.alloc self in
    let* owner := M.alloc owner in
    let* α0 : mut_ref multisig.Multisig.t := M.read self in
    let* α1 : core.slice.iter.Iter.t u32.t :=
      M.call
        ((core.iter.traits.collect.IntoIterator.into_iter
            (Self := ref (alloc.vec.Vec.t u32.t alloc.alloc.Global.t))
            (Trait := ltac:(refine _)))
          (borrow (deref α0).["transaction_list"].["transactions"])) in
    let* α2 : M.Val unit :=
      match α1 with
      | iter =>
        let* iter := M.alloc iter in
        loop
          (let* _ : M.Val unit :=
            let* α0 : core.option.Option.t (ref u32.t) :=
              M.call
                ((core.iter.traits.iterator.Iterator.next
                    (Self := core.slice.iter.Iter.t u32.t)
                    (Trait := ltac:(refine _)))
                  (borrow_mut iter)) in
            match α0 with
            | core.option.Option.None =>
              let* α0 : M.Val never.t := Break in
              let* α1 := M.read α0 in
              let* α2 : unit := never_to_any α1 in
              M.alloc α2
            | core.option.Option.Some trans_id =>
              let* trans_id := M.alloc trans_id in
              let* key : M.Val (u32.t * multisig.AccountId.t) :=
                let* α0 : ref u32.t := M.read trans_id in
                let* α1 : u32.t := M.read (deref α0) in
                let* α2 : ref multisig.AccountId.t := M.read owner in
                let* α3 : multisig.AccountId.t := M.read (deref α2) in
                M.alloc (α1, α3) in
              let* α0 : mut_ref multisig.Multisig.t := M.read self in
              let* α1 : bool.t :=
                M.call
                  ((multisig.Mapping.t
                        (u32.t * multisig.AccountId.t)
                        unit)::["contains"]
                    (borrow (deref α0).["confirmations"])
                    (borrow key)) in
              let* α2 : M.Val bool.t := M.alloc α1 in
              let* α3 : bool.t := M.read (use α2) in
              if α3 then
                let* _ : M.Val unit :=
                  let* α0 : mut_ref multisig.Multisig.t := M.read self in
                  let* α1 : u32.t * multisig.AccountId.t := M.read key in
                  let* α2 : unit :=
                    M.call
                      ((multisig.Mapping.t
                            (u32.t * multisig.AccountId.t)
                            unit)::["remove"]
                        (borrow (deref α0).["confirmations"])
                        α1) in
                  M.alloc α2 in
                let* count : M.Val u32.t :=
                  let* α0 : mut_ref multisig.Multisig.t := M.read self in
                  let* α1 : ref u32.t := M.read trans_id in
                  let* α2 : core.option.Option.t u32.t :=
                    M.call
                      ((multisig.Mapping.t u32.t u32.t)::["get"]
                        (borrow (deref α0).["confirmation_count"])
                        α1) in
                  let* α3 : u32.t :=
                    M.call
                      ((core.option.Option.t u32.t)::["unwrap_or"]
                        α2
                        (Integer.of_Z 0)) in
                  M.alloc α3 in
                let* _ : M.Val unit :=
                  let β : M.Val u32.t := count in
                  let* α0 := M.read β in
                  let* α1 := BinOp.Panic.sub α0 (Integer.of_Z 1) in
                  assign β α1 in
                let* _ : M.Val (core.option.Option.t u32.t) :=
                  let* α0 : mut_ref multisig.Multisig.t := M.read self in
                  let* α1 : ref u32.t := M.read trans_id in
                  let* α2 : u32.t := M.read (deref α1) in
                  let* α3 : u32.t := M.read count in
                  let* α4 : core.option.Option.t u32.t :=
                    M.call
                      ((multisig.Mapping.t u32.t u32.t)::["insert"]
                        (borrow_mut (deref α0).["confirmation_count"])
                        α2
                        α3) in
                  M.alloc α4 in
                M.alloc tt
              else
                M.alloc tt
            end in
          M.alloc tt)
      end in
    M.read (use α2).
  
  Global Instance AssociatedFunction_clean_owner_confirmations :
    Notations.DoubleColon Self "clean_owner_confirmations" := {
    Notations.double_colon := clean_owner_confirmations;
  }.
  
  (*
      fn ensure_confirmed(&self, trans_id: TransactionId) {
          assert!(
              self.confirmation_count
                  .get(&trans_id)
                  .expect(WRONG_TRANSACTION_ID)
                  >= self.requirement
          );
      }
  *)
  Definition ensure_confirmed
      (self : ref Self)
      (trans_id : ltac:(multisig.TransactionId))
      : M unit :=
    let* self := M.alloc self in
    let* trans_id := M.alloc trans_id in
    let* _ : M.Val unit :=
      let* α0 : ref multisig.Multisig.t := M.read self in
      let* α1 : core.option.Option.t u32.t :=
        M.call
          ((multisig.Mapping.t u32.t u32.t)::["get"]
            (borrow (deref α0).["confirmation_count"])
            (borrow trans_id)) in
      let* α2 : ref str.t := M.read multisig.WRONG_TRANSACTION_ID in
      let* α3 : u32.t :=
        M.call ((core.option.Option.t u32.t)::["expect"] α1 α2) in
      let* α4 : ref multisig.Multisig.t := M.read self in
      let* α5 : u32.t := M.read (deref α4).["requirement"] in
      let* α6 : M.Val bool.t := M.alloc (UnOp.not (BinOp.Pure.ge α3 α5)) in
      let* α7 : bool.t := M.read (use α6) in
      if α7 then
        let* α0 : ref str.t :=
          M.read
            (mk_str
              "assertion failed: self.confirmation_count.get(&trans_id).expect(WRONG_TRANSACTION_ID) >=\n    self.requirement") in
        let* α1 : never.t := M.call (core.panicking.panic α0) in
        let* α2 : unit := never_to_any α1 in
        M.alloc α2
      else
        M.alloc tt in
    let* α0 : M.Val unit := M.alloc tt in
    M.read α0.
  
  Global Instance AssociatedFunction_ensure_confirmed :
    Notations.DoubleColon Self "ensure_confirmed" := {
    Notations.double_colon := ensure_confirmed;
  }.
  
  (*
      fn ensure_transaction_exists(&self, trans_id: TransactionId) {
          self.transactions
              .get(&trans_id)
              .expect(WRONG_TRANSACTION_ID);
      }
  *)
  Definition ensure_transaction_exists
      (self : ref Self)
      (trans_id : ltac:(multisig.TransactionId))
      : M unit :=
    let* self := M.alloc self in
    let* trans_id := M.alloc trans_id in
    let* _ : M.Val multisig.Transaction.t :=
      let* α0 : ref multisig.Multisig.t := M.read self in
      let* α1 : core.option.Option.t multisig.Transaction.t :=
        M.call
          ((multisig.Mapping.t u32.t multisig.Transaction.t)::["get"]
            (borrow (deref α0).["transactions"])
            (borrow trans_id)) in
      let* α2 : ref str.t := M.read multisig.WRONG_TRANSACTION_ID in
      let* α3 : multisig.Transaction.t :=
        M.call
          ((core.option.Option.t multisig.Transaction.t)::["expect"] α1 α2) in
      M.alloc α3 in
    let* α0 : M.Val unit := M.alloc tt in
    M.read α0.
  
  Global Instance AssociatedFunction_ensure_transaction_exists :
    Notations.DoubleColon Self "ensure_transaction_exists" := {
    Notations.double_colon := ensure_transaction_exists;
  }.
  
  (*
      fn ensure_caller_is_owner(&self) {
          self.ensure_owner(&self.env().caller());
      }
  *)
  Definition ensure_caller_is_owner (self : ref Self) : M unit :=
    let* self := M.alloc self in
    let* _ : M.Val unit :=
      let* α0 : ref multisig.Multisig.t := M.read self in
      let* α1 : ref multisig.Multisig.t := M.read self in
      let* α2 : multisig.Env.t := M.call (multisig.Multisig.t::["env"] α1) in
      let* α3 : M.Val multisig.Env.t := M.alloc α2 in
      let* α4 : multisig.AccountId.t :=
        M.call (multisig.Env.t::["caller"] (borrow α3)) in
      let* α5 : M.Val multisig.AccountId.t := M.alloc α4 in
      let* α6 : unit :=
        M.call (multisig.Multisig.t::["ensure_owner"] α0 (borrow α5)) in
      M.alloc α6 in
    let* α0 : M.Val unit := M.alloc tt in
    M.read α0.
  
  Global Instance AssociatedFunction_ensure_caller_is_owner :
    Notations.DoubleColon Self "ensure_caller_is_owner" := {
    Notations.double_colon := ensure_caller_is_owner;
  }.
  
  (*
      fn ensure_from_wallet(&self) {
          assert_eq!(self.env().caller(), self.env().account_id());
      }
  *)
  Definition ensure_from_wallet (self : ref Self) : M unit :=
    let* self := M.alloc self in
    let* _ : M.Val unit :=
      let* α0 : ref multisig.Multisig.t := M.read self in
      let* α1 : multisig.Env.t := M.call (multisig.Multisig.t::["env"] α0) in
      let* α2 : M.Val multisig.Env.t := M.alloc α1 in
      let* α3 : multisig.AccountId.t :=
        M.call (multisig.Env.t::["caller"] (borrow α2)) in
      let* α4 : M.Val multisig.AccountId.t := M.alloc α3 in
      let* α5 : ref multisig.Multisig.t := M.read self in
      let* α6 : multisig.Env.t := M.call (multisig.Multisig.t::["env"] α5) in
      let* α7 : M.Val multisig.Env.t := M.alloc α6 in
      let* α8 : multisig.AccountId.t :=
        M.call (multisig.Env.t::["account_id"] (borrow α7)) in
      let* α9 : M.Val multisig.AccountId.t := M.alloc α8 in
      match (borrow α4, borrow α9) with
      | (left_val, right_val) =>
        let* left_val := M.alloc left_val in
        let* right_val := M.alloc right_val in
        let* α0 : ref multisig.AccountId.t := M.read left_val in
        let* α1 : ref multisig.AccountId.t := M.read right_val in
        let* α2 : bool.t :=
          M.call
            ((core.cmp.PartialEq.eq
                (Self := multisig.AccountId.t)
                (Trait := ltac:(refine _)))
              α0
              α1) in
        let* α3 : M.Val bool.t := M.alloc (UnOp.not α2) in
        let* α4 : bool.t := M.read (use α3) in
        if α4 then
          let* kind : M.Val core.panicking.AssertKind.t :=
            M.alloc core.panicking.AssertKind.Eq in
          let* _ : M.Val never.t :=
            let* α0 : core.panicking.AssertKind.t := M.read kind in
            let* α1 : ref multisig.AccountId.t := M.read left_val in
            let* α2 : ref multisig.AccountId.t := M.read right_val in
            let* α3 : never.t :=
              M.call
                (core.panicking.assert_failed
                  α0
                  α1
                  α2
                  core.option.Option.None) in
            M.alloc α3 in
          let* α0 : M.Val unit := M.alloc tt in
          let* α1 := M.read α0 in
          let* α2 : unit := never_to_any α1 in
          M.alloc α2
        else
          M.alloc tt
      end in
    let* α0 : M.Val unit := M.alloc tt in
    M.read α0.
  
  Global Instance AssociatedFunction_ensure_from_wallet :
    Notations.DoubleColon Self "ensure_from_wallet" := {
    Notations.double_colon := ensure_from_wallet;
  }.
  
  (*
      fn ensure_owner(&self, owner: &AccountId) {
          assert!(self.is_owner.contains(owner));
      }
  *)
  Definition ensure_owner
      (self : ref Self)
      (owner : ref multisig.AccountId.t)
      : M unit :=
    let* self := M.alloc self in
    let* owner := M.alloc owner in
    let* _ : M.Val unit :=
      let* α0 : ref multisig.Multisig.t := M.read self in
      let* α1 : ref multisig.AccountId.t := M.read owner in
      let* α2 : bool.t :=
        M.call
          ((multisig.Mapping.t multisig.AccountId.t unit)::["contains"]
            (borrow (deref α0).["is_owner"])
            α1) in
      let* α3 : M.Val bool.t := M.alloc (UnOp.not α2) in
      let* α4 : bool.t := M.read (use α3) in
      if α4 then
        let* α0 : ref str.t :=
          M.read (mk_str "assertion failed: self.is_owner.contains(owner)") in
        let* α1 : never.t := M.call (core.panicking.panic α0) in
        let* α2 : unit := never_to_any α1 in
        M.alloc α2
      else
        M.alloc tt in
    let* α0 : M.Val unit := M.alloc tt in
    M.read α0.
  
  Global Instance AssociatedFunction_ensure_owner :
    Notations.DoubleColon Self "ensure_owner" := {
    Notations.double_colon := ensure_owner;
  }.
  
  (*
      fn ensure_no_owner(&self, owner: &AccountId) {
          assert!(!self.is_owner.contains(owner));
      }
  *)
  Definition ensure_no_owner
      (self : ref Self)
      (owner : ref multisig.AccountId.t)
      : M unit :=
    let* self := M.alloc self in
    let* owner := M.alloc owner in
    let* _ : M.Val unit :=
      let* α0 : ref multisig.Multisig.t := M.read self in
      let* α1 : ref multisig.AccountId.t := M.read owner in
      let* α2 : bool.t :=
        M.call
          ((multisig.Mapping.t multisig.AccountId.t unit)::["contains"]
            (borrow (deref α0).["is_owner"])
            α1) in
      let* α3 : M.Val bool.t := M.alloc (UnOp.not (UnOp.not α2)) in
      let* α4 : bool.t := M.read (use α3) in
      if α4 then
        let* α0 : ref str.t :=
          M.read (mk_str "assertion failed: !self.is_owner.contains(owner)") in
        let* α1 : never.t := M.call (core.panicking.panic α0) in
        let* α2 : unit := never_to_any α1 in
        M.alloc α2
      else
        M.alloc tt in
    let* α0 : M.Val unit := M.alloc tt in
    M.read α0.
  
  Global Instance AssociatedFunction_ensure_no_owner :
    Notations.DoubleColon Self "ensure_no_owner" := {
    Notations.double_colon := ensure_no_owner;
  }.
End Impl_multisig_Multisig_t.
End Impl_multisig_Multisig_t.

(*
fn ensure_requirement_is_valid(owners: u32, requirement: u32) {
    assert!(0 < requirement && requirement <= owners && owners <= MAX_OWNERS);
}
*)
Definition ensure_requirement_is_valid
    (owners : u32.t)
    (requirement : u32.t)
    : M unit :=
  let* owners := M.alloc owners in
  let* requirement := M.alloc requirement in
  let* _ : M.Val unit :=
    let* α0 : u32.t := M.read requirement in
    let* α1 : u32.t := M.read requirement in
    let* α2 : u32.t := M.read owners in
    let* α3 : u32.t := M.read owners in
    let* α4 : u32.t := M.read multisig.MAX_OWNERS in
    let* α5 : M.Val bool.t :=
      M.alloc
        (UnOp.not
          (BinOp.Pure.and
            (BinOp.Pure.and
              (BinOp.Pure.lt (Integer.of_Z 0) α0)
              (BinOp.Pure.le α1 α2))
            (BinOp.Pure.le α3 α4))) in
    let* α6 : bool.t := M.read (use α5) in
    if α6 then
      let* α0 : ref str.t :=
        M.read
          (mk_str
            "assertion failed: 0 < requirement && requirement <= owners && owners <= MAX_OWNERS") in
      let* α1 : never.t := M.call (core.panicking.panic α0) in
      let* α2 : unit := never_to_any α1 in
      M.alloc α2
    else
      M.alloc tt in
  let* α0 : M.Val unit := M.alloc tt in
  M.read α0.
