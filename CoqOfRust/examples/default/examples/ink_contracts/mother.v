(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module  Mapping.
Section Mapping.
  Context (K V : Set).
  
  Record t : Set := {
    _key : core.marker.PhantomData.t K;
    _value : core.marker.PhantomData.t V;
  }.
  
  Global Instance Get__key : Notations.Dot "_key" := {
    Notations.dot :=
      Ref.map (fun α => Some α.(_key)) (fun β α => Some (α <| _key := β |>));
  }.
  Global Instance Get_AF__key : Notations.DoubleColon t "_key" := {
    Notations.double_colon (α : M.Val t) := α.["_key"];
  }.
  Global Instance Get__value : Notations.Dot "_value" := {
    Notations.dot :=
      Ref.map
        (fun α => Some α.(_value))
        (fun β α => Some (α <| _value := β |>));
  }.
  Global Instance Get_AF__value : Notations.DoubleColon t "_value" := {
    Notations.double_colon (α : M.Val t) := α.["_value"];
  }.
End Mapping.
End Mapping.

Module  Impl_core_default_Default_for_mother_Mapping_t_K_V.
Section Impl_core_default_Default_for_mother_Mapping_t_K_V.
  Context {K V : Set}.
  
  Context
    {ℋ_0 : core.default.Default.Trait K}
    {ℋ_1 : core.default.Default.Trait V}.
  
  Definition Self : Set := mother.Mapping.t K V.
  
  (*
  Default
  *)
  Definition default : M (mother.Mapping.t K V) :=
    let* α0 : core.marker.PhantomData.t K :=
      M.call
        (core.default.Default.default
          (Self := core.marker.PhantomData.t K)
          (Trait := ltac:(refine _))) in
    let* α1 : core.marker.PhantomData.t V :=
      M.call
        (core.default.Default.default
          (Self := core.marker.PhantomData.t V)
          (Trait := ltac:(refine _))) in
    M.pure {| mother.Mapping._key := α0; mother.Mapping._value := α1; |}.
  
  Global Instance AssociatedFunction_default :
    Notations.DoubleColon Self "default" := {
    Notations.double_colon := default;
  }.
  
  Global Instance ℐ : core.default.Default.Trait Self := {
    core.default.Default.default := default;
  }.
End Impl_core_default_Default_for_mother_Mapping_t_K_V.
End Impl_core_default_Default_for_mother_Mapping_t_K_V.

Module  Impl_mother_Mapping_t_K_V.
Section Impl_mother_Mapping_t_K_V.
  Context {K V : Set}.
  
  Definition Self : Set := mother.Mapping.t K V.
  
  (*
      fn get(&self, _key: &K) -> Option<V> {
          unimplemented!()
      }
  *)
  Definition get
      (self : ref Self)
      (_key : ref K)
      : M (core.option.Option.t V) :=
    let* self := M.alloc self in
    let* _key := M.alloc _key in
    let* α0 : ref str.t := M.read (mk_str "not implemented") in
    let* α1 : never.t := M.call (core.panicking.panic α0) in
    never_to_any α1.
  
  Global Instance AssociatedFunction_get : Notations.DoubleColon Self "get" := {
    Notations.double_colon := get;
  }.
  
  (*
      fn insert(&mut self, _key: K, _value: V) {
          unimplemented!()
      }
  *)
  Definition insert (self : mut_ref Self) (_key : K) (_value : V) : M unit :=
    let* self := M.alloc self in
    let* _key := M.alloc _key in
    let* _value := M.alloc _value in
    let* α0 : ref str.t := M.read (mk_str "not implemented") in
    let* α1 : never.t := M.call (core.panicking.panic α0) in
    never_to_any α1.
  
  Global Instance AssociatedFunction_insert :
    Notations.DoubleColon Self "insert" := {
    Notations.double_colon := insert;
  }.
End Impl_mother_Mapping_t_K_V.
End Impl_mother_Mapping_t_K_V.

Module  AccountId.
Section AccountId.
  Record t : Set := {
    x0 : u128.t;
  }.
  
  Global Instance Get_0 : Notations.Dot "0" := {
    Notations.dot :=
      Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>));
  }.
End AccountId.
End AccountId.

Module  Impl_core_default_Default_for_mother_AccountId_t.
Section Impl_core_default_Default_for_mother_AccountId_t.
  Definition Self : Set := mother.AccountId.t.
  
  (*
  Default
  *)
  Definition default : M mother.AccountId.t :=
    let* α0 : u128.t :=
      M.call
        (core.default.Default.default
          (Self := u128.t)
          (Trait := ltac:(refine _))) in
    M.pure (mother.AccountId.Build_t α0).
  
  Global Instance AssociatedFunction_default :
    Notations.DoubleColon Self "default" := {
    Notations.double_colon := default;
  }.
  
  Global Instance ℐ : core.default.Default.Trait Self := {
    core.default.Default.default := default;
  }.
End Impl_core_default_Default_for_mother_AccountId_t.
End Impl_core_default_Default_for_mother_AccountId_t.

Module  Impl_core_clone_Clone_for_mother_AccountId_t.
Section Impl_core_clone_Clone_for_mother_AccountId_t.
  Definition Self : Set := mother.AccountId.t.
  
  (*
  Clone
  *)
  Definition clone (self : ref Self) : M mother.AccountId.t :=
    let* self := M.alloc self in
    let _ : unit := tt in
    let* α0 : ref mother.AccountId.t := M.read self in
    M.read (deref α0).
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_mother_AccountId_t.
End Impl_core_clone_Clone_for_mother_AccountId_t.

Module  Impl_core_marker_Copy_for_mother_AccountId_t.
Section Impl_core_marker_Copy_for_mother_AccountId_t.
  Definition Self : Set := mother.AccountId.t.
  
  Global Instance ℐ : core.marker.Copy.Trait Self := {
  }.
End Impl_core_marker_Copy_for_mother_AccountId_t.
End Impl_core_marker_Copy_for_mother_AccountId_t.

Module  Impl_core_marker_StructuralPartialEq_for_mother_AccountId_t.
Section Impl_core_marker_StructuralPartialEq_for_mother_AccountId_t.
  Definition Self : Set := mother.AccountId.t.
  
  Global Instance ℐ : core.marker.StructuralPartialEq.Trait Self := {
  }.
End Impl_core_marker_StructuralPartialEq_for_mother_AccountId_t.
End Impl_core_marker_StructuralPartialEq_for_mother_AccountId_t.

Module  Impl_core_cmp_PartialEq_for_mother_AccountId_t.
Section Impl_core_cmp_PartialEq_for_mother_AccountId_t.
  Definition Self : Set := mother.AccountId.t.
  
  (*
  PartialEq
  *)
  Definition eq (self : ref Self) (other : ref mother.AccountId.t) : M bool.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    let* α0 : ref mother.AccountId.t := M.read self in
    let* α1 : u128.t := M.read (deref α0).["0"] in
    let* α2 : ref mother.AccountId.t := M.read other in
    let* α3 : u128.t := M.read (deref α2).["0"] in
    M.pure (BinOp.Pure.eq α1 α3).
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ :
    core.cmp.PartialEq.Required.Trait Self
      (Rhs := core.cmp.PartialEq.Default.Rhs Self) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_for_mother_AccountId_t.
End Impl_core_cmp_PartialEq_for_mother_AccountId_t.

Module  Impl_core_marker_StructuralEq_for_mother_AccountId_t.
Section Impl_core_marker_StructuralEq_for_mother_AccountId_t.
  Definition Self : Set := mother.AccountId.t.
  
  Global Instance ℐ : core.marker.StructuralEq.Trait Self := {
  }.
End Impl_core_marker_StructuralEq_for_mother_AccountId_t.
End Impl_core_marker_StructuralEq_for_mother_AccountId_t.

Module  Impl_core_cmp_Eq_for_mother_AccountId_t.
Section Impl_core_cmp_Eq_for_mother_AccountId_t.
  Definition Self : Set := mother.AccountId.t.
  
  (*
  Eq
  *)
  Definition assert_receiver_is_total_eq (self : ref Self) : M unit :=
    let* self := M.alloc self in
    let _ : unit := tt in
    let* α0 : M.Val unit := M.alloc tt in
    M.read α0.
  
  Global Instance AssociatedFunction_assert_receiver_is_total_eq :
    Notations.DoubleColon Self "assert_receiver_is_total_eq" := {
    Notations.double_colon := assert_receiver_is_total_eq;
  }.
  
  Global Instance ℐ : core.cmp.Eq.Required.Trait Self := {
    core.cmp.Eq.assert_receiver_is_total_eq :=
      Datatypes.Some assert_receiver_is_total_eq;
  }.
End Impl_core_cmp_Eq_for_mother_AccountId_t.
End Impl_core_cmp_Eq_for_mother_AccountId_t.

Ltac Balance := exact u128.t.

Ltac BlockNumber := exact u32.t.

Ltac Hash := exact (array u8.t).

Module  Env.
Section Env.
  Record t : Set := {
    caller : mother.AccountId.t;
  }.
  
  Global Instance Get_caller : Notations.Dot "caller" := {
    Notations.dot :=
      Ref.map
        (fun α => Some α.(caller))
        (fun β α => Some (α <| caller := β |>));
  }.
  Global Instance Get_AF_caller : Notations.DoubleColon t "caller" := {
    Notations.double_colon (α : M.Val t) := α.["caller"];
  }.
End Env.
End Env.

Module  Bids.
Section Bids.
  Record t : Set := {
    x0 :
      alloc.vec.Vec.t
        (alloc.vec.Vec.t
          (core.option.Option.t (mother.AccountId.t * ltac:(mother.Balance)))
          alloc.vec.Vec.Default.A)
        alloc.vec.Vec.Default.A;
  }.
  
  Global Instance Get_0 : Notations.Dot "0" := {
    Notations.dot :=
      Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>));
  }.
End Bids.
End Bids.

Module  Impl_core_default_Default_for_mother_Bids_t.
Section Impl_core_default_Default_for_mother_Bids_t.
  Definition Self : Set := mother.Bids.t.
  
  (*
  Default
  *)
  Definition default : M mother.Bids.t :=
    let* α0 :
        alloc.vec.Vec.t
          (alloc.vec.Vec.t
            (core.option.Option.t (mother.AccountId.t * u128.t))
            alloc.alloc.Global.t)
          alloc.alloc.Global.t :=
      M.call
        (core.default.Default.default
          (Self :=
            alloc.vec.Vec.t
              (alloc.vec.Vec.t
                (core.option.Option.t (mother.AccountId.t * u128.t))
                alloc.alloc.Global.t)
              alloc.alloc.Global.t)
          (Trait := ltac:(refine _))) in
    M.pure (mother.Bids.Build_t α0).
  
  Global Instance AssociatedFunction_default :
    Notations.DoubleColon Self "default" := {
    Notations.double_colon := default;
  }.
  
  Global Instance ℐ : core.default.Default.Trait Self := {
    core.default.Default.default := default;
  }.
End Impl_core_default_Default_for_mother_Bids_t.
End Impl_core_default_Default_for_mother_Bids_t.

Module  Impl_core_marker_StructuralPartialEq_for_mother_Bids_t.
Section Impl_core_marker_StructuralPartialEq_for_mother_Bids_t.
  Definition Self : Set := mother.Bids.t.
  
  Global Instance ℐ : core.marker.StructuralPartialEq.Trait Self := {
  }.
End Impl_core_marker_StructuralPartialEq_for_mother_Bids_t.
End Impl_core_marker_StructuralPartialEq_for_mother_Bids_t.

Module  Impl_core_cmp_PartialEq_for_mother_Bids_t.
Section Impl_core_cmp_PartialEq_for_mother_Bids_t.
  Definition Self : Set := mother.Bids.t.
  
  (*
  PartialEq
  *)
  Definition eq (self : ref Self) (other : ref mother.Bids.t) : M bool.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    let* α0 : ref mother.Bids.t := M.read self in
    let* α1 : ref mother.Bids.t := M.read other in
    M.call
      ((core.cmp.PartialEq.eq
          (Self :=
            alloc.vec.Vec.t
              (alloc.vec.Vec.t
                (core.option.Option.t (mother.AccountId.t * u128.t))
                alloc.alloc.Global.t)
              alloc.alloc.Global.t)
          (Trait := ltac:(refine _)))
        (borrow (deref α0).["0"])
        (borrow (deref α1).["0"])).
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ :
    core.cmp.PartialEq.Required.Trait Self
      (Rhs := core.cmp.PartialEq.Default.Rhs Self) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_for_mother_Bids_t.
End Impl_core_cmp_PartialEq_for_mother_Bids_t.

Module  Impl_core_marker_StructuralEq_for_mother_Bids_t.
Section Impl_core_marker_StructuralEq_for_mother_Bids_t.
  Definition Self : Set := mother.Bids.t.
  
  Global Instance ℐ : core.marker.StructuralEq.Trait Self := {
  }.
End Impl_core_marker_StructuralEq_for_mother_Bids_t.
End Impl_core_marker_StructuralEq_for_mother_Bids_t.

Module  Impl_core_cmp_Eq_for_mother_Bids_t.
Section Impl_core_cmp_Eq_for_mother_Bids_t.
  Definition Self : Set := mother.Bids.t.
  
  (*
  Eq
  *)
  Definition assert_receiver_is_total_eq (self : ref Self) : M unit :=
    let* self := M.alloc self in
    let _ : unit := tt in
    let* α0 : M.Val unit := M.alloc tt in
    M.read α0.
  
  Global Instance AssociatedFunction_assert_receiver_is_total_eq :
    Notations.DoubleColon Self "assert_receiver_is_total_eq" := {
    Notations.double_colon := assert_receiver_is_total_eq;
  }.
  
  Global Instance ℐ : core.cmp.Eq.Required.Trait Self := {
    core.cmp.Eq.assert_receiver_is_total_eq :=
      Datatypes.Some assert_receiver_is_total_eq;
  }.
End Impl_core_cmp_Eq_for_mother_Bids_t.
End Impl_core_cmp_Eq_for_mother_Bids_t.

Module  Impl_core_clone_Clone_for_mother_Bids_t.
Section Impl_core_clone_Clone_for_mother_Bids_t.
  Definition Self : Set := mother.Bids.t.
  
  (*
  Clone
  *)
  Definition clone (self : ref Self) : M mother.Bids.t :=
    let* self := M.alloc self in
    let* α0 : ref mother.Bids.t := M.read self in
    let* α1 :
        alloc.vec.Vec.t
          (alloc.vec.Vec.t
            (core.option.Option.t (mother.AccountId.t * u128.t))
            alloc.alloc.Global.t)
          alloc.alloc.Global.t :=
      M.call
        ((core.clone.Clone.clone
            (Self :=
              alloc.vec.Vec.t
                (alloc.vec.Vec.t
                  (core.option.Option.t (mother.AccountId.t * u128.t))
                  alloc.alloc.Global.t)
                alloc.alloc.Global.t)
            (Trait := ltac:(refine _)))
          (borrow (deref α0).["0"])) in
    M.pure (mother.Bids.Build_t α1).
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_mother_Bids_t.
End Impl_core_clone_Clone_for_mother_Bids_t.

Module Outline.
  Inductive t : Set :=
  | NoWinner
  | WinnerDetected
  | PayoutCompleted.
End Outline.

Module  Impl_core_marker_StructuralPartialEq_for_mother_Outline_t.
Section Impl_core_marker_StructuralPartialEq_for_mother_Outline_t.
  Definition Self : Set := mother.Outline.t.
  
  Global Instance ℐ : core.marker.StructuralPartialEq.Trait Self := {
  }.
End Impl_core_marker_StructuralPartialEq_for_mother_Outline_t.
End Impl_core_marker_StructuralPartialEq_for_mother_Outline_t.

Module  Impl_core_cmp_PartialEq_for_mother_Outline_t.
Section Impl_core_cmp_PartialEq_for_mother_Outline_t.
  Definition Self : Set := mother.Outline.t.
  
  (*
  PartialEq
  *)
  Definition eq (self : ref Self) (other : ref mother.Outline.t) : M bool.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    let* __self_tag : M.Val isize.t :=
      let* α0 : ref mother.Outline.t := M.read self in
      let* α1 : isize.t := M.call (core.intrinsics.discriminant_value α0) in
      M.alloc α1 in
    let* __arg1_tag : M.Val isize.t :=
      let* α0 : ref mother.Outline.t := M.read other in
      let* α1 : isize.t := M.call (core.intrinsics.discriminant_value α0) in
      M.alloc α1 in
    let* α0 : isize.t := M.read __self_tag in
    let* α1 : isize.t := M.read __arg1_tag in
    let* α0 : M.Val bool.t := M.alloc (BinOp.Pure.eq α0 α1) in
    M.read α0.
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ :
    core.cmp.PartialEq.Required.Trait Self
      (Rhs := core.cmp.PartialEq.Default.Rhs Self) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_for_mother_Outline_t.
End Impl_core_cmp_PartialEq_for_mother_Outline_t.

Module  Impl_core_marker_StructuralEq_for_mother_Outline_t.
Section Impl_core_marker_StructuralEq_for_mother_Outline_t.
  Definition Self : Set := mother.Outline.t.
  
  Global Instance ℐ : core.marker.StructuralEq.Trait Self := {
  }.
End Impl_core_marker_StructuralEq_for_mother_Outline_t.
End Impl_core_marker_StructuralEq_for_mother_Outline_t.

Module  Impl_core_cmp_Eq_for_mother_Outline_t.
Section Impl_core_cmp_Eq_for_mother_Outline_t.
  Definition Self : Set := mother.Outline.t.
  
  (*
  Eq
  *)
  Definition assert_receiver_is_total_eq (self : ref Self) : M unit :=
    let* self := M.alloc self in
    M.pure tt.
  
  Global Instance AssociatedFunction_assert_receiver_is_total_eq :
    Notations.DoubleColon Self "assert_receiver_is_total_eq" := {
    Notations.double_colon := assert_receiver_is_total_eq;
  }.
  
  Global Instance ℐ : core.cmp.Eq.Required.Trait Self := {
    core.cmp.Eq.assert_receiver_is_total_eq :=
      Datatypes.Some assert_receiver_is_total_eq;
  }.
End Impl_core_cmp_Eq_for_mother_Outline_t.
End Impl_core_cmp_Eq_for_mother_Outline_t.

Module  Impl_core_clone_Clone_for_mother_Outline_t.
Section Impl_core_clone_Clone_for_mother_Outline_t.
  Definition Self : Set := mother.Outline.t.
  
  (*
  Clone
  *)
  Definition clone (self : ref Self) : M mother.Outline.t :=
    let* self := M.alloc self in
    let* α0 : ref mother.Outline.t := M.read self in
    let* α1 := M.read α0 in
    let* α2 : M.Val mother.Outline.t :=
      match α1 with
      | mother.Outline.NoWinner => M.alloc mother.Outline.NoWinner
      | mother.Outline.WinnerDetected => M.alloc mother.Outline.WinnerDetected
      | mother.Outline.PayoutCompleted => M.alloc mother.Outline.PayoutCompleted
      end in
    M.read α2.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_mother_Outline_t.
End Impl_core_clone_Clone_for_mother_Outline_t.

Module Status.
  Inductive t : Set :=
  | NotStarted
  | OpeningPeriod
  | EndingPeriod (_ : ltac:(mother.BlockNumber))
  | Ended (_ : mother.Outline.t)
  | RfDelay (_ : ltac:(mother.BlockNumber)).
  
  Global Instance Get_EndingPeriod_0 : Notations.Dot "EndingPeriod.0" := {
    Notations.dot :=
      Ref.map
        (fun α => match α with | EndingPeriod α0 => Some α0 | _ => None end)
        (fun β α =>
          match α with
          | EndingPeriod _ => Some (EndingPeriod β)
          | _ => None
          end);
  }.
  
  Global Instance Get_Ended_0 : Notations.Dot "Ended.0" := {
    Notations.dot :=
      Ref.map
        (fun α => match α with | Ended α0 => Some α0 | _ => None end)
        (fun β α => match α with | Ended _ => Some (Ended β) | _ => None end);
  }.
  
  Global Instance Get_RfDelay_0 : Notations.Dot "RfDelay.0" := {
    Notations.dot :=
      Ref.map
        (fun α => match α with | RfDelay α0 => Some α0 | _ => None end)
        (fun β α =>
          match α with | RfDelay _ => Some (RfDelay β) | _ => None end);
  }.
End Status.

Module  Impl_core_marker_StructuralPartialEq_for_mother_Status_t.
Section Impl_core_marker_StructuralPartialEq_for_mother_Status_t.
  Definition Self : Set := mother.Status.t.
  
  Global Instance ℐ : core.marker.StructuralPartialEq.Trait Self := {
  }.
End Impl_core_marker_StructuralPartialEq_for_mother_Status_t.
End Impl_core_marker_StructuralPartialEq_for_mother_Status_t.

Module  Impl_core_cmp_PartialEq_for_mother_Status_t.
Section Impl_core_cmp_PartialEq_for_mother_Status_t.
  Definition Self : Set := mother.Status.t.
  
  (*
  PartialEq
  *)
  Definition eq (self : ref Self) (other : ref mother.Status.t) : M bool.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    let* __self_tag : M.Val isize.t :=
      let* α0 : ref mother.Status.t := M.read self in
      let* α1 : isize.t := M.call (core.intrinsics.discriminant_value α0) in
      M.alloc α1 in
    let* __arg1_tag : M.Val isize.t :=
      let* α0 : ref mother.Status.t := M.read other in
      let* α1 : isize.t := M.call (core.intrinsics.discriminant_value α0) in
      M.alloc α1 in
    let* α0 : isize.t := M.read __self_tag in
    let* α1 : isize.t := M.read __arg1_tag in
    let* α2 : ref mother.Status.t := M.read self in
    let* α3 : ref mother.Status.t := M.read other in
    let* α4 : M.Val bool.t :=
      match (α2, α3) with
      |
          (mother.Status.EndingPeriod __self_0,
            mother.Status.EndingPeriod __arg1_0)
          =>
        let* __self_0 := M.alloc __self_0 in
        let* __arg1_0 := M.alloc __arg1_0 in
        let* α0 : ref u32.t := M.read __self_0 in
        let* α1 : u32.t := M.read (deref α0) in
        let* α2 : ref u32.t := M.read __arg1_0 in
        let* α3 : u32.t := M.read (deref α2) in
        M.alloc (BinOp.Pure.eq α1 α3)
      | (mother.Status.Ended __self_0, mother.Status.Ended __arg1_0) =>
        let* __self_0 := M.alloc __self_0 in
        let* __arg1_0 := M.alloc __arg1_0 in
        let* α0 : ref mother.Outline.t := M.read __self_0 in
        let* α1 : ref mother.Outline.t := M.read __arg1_0 in
        let* α2 : bool.t :=
          M.call
            ((core.cmp.PartialEq.eq
                (Self := mother.Outline.t)
                (Trait := ltac:(refine _)))
              α0
              α1) in
        M.alloc α2
      | (mother.Status.RfDelay __self_0, mother.Status.RfDelay __arg1_0) =>
        let* __self_0 := M.alloc __self_0 in
        let* __arg1_0 := M.alloc __arg1_0 in
        let* α0 : ref u32.t := M.read __self_0 in
        let* α1 : u32.t := M.read (deref α0) in
        let* α2 : ref u32.t := M.read __arg1_0 in
        let* α3 : u32.t := M.read (deref α2) in
        M.alloc (BinOp.Pure.eq α1 α3)
      | _ => M.alloc true
      end in
    let* α5 : bool.t := M.read α4 in
    let* α0 : M.Val bool.t :=
      M.alloc (BinOp.Pure.and (BinOp.Pure.eq α0 α1) α5) in
    M.read α0.
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ :
    core.cmp.PartialEq.Required.Trait Self
      (Rhs := core.cmp.PartialEq.Default.Rhs Self) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_for_mother_Status_t.
End Impl_core_cmp_PartialEq_for_mother_Status_t.

Module  Impl_core_marker_StructuralEq_for_mother_Status_t.
Section Impl_core_marker_StructuralEq_for_mother_Status_t.
  Definition Self : Set := mother.Status.t.
  
  Global Instance ℐ : core.marker.StructuralEq.Trait Self := {
  }.
End Impl_core_marker_StructuralEq_for_mother_Status_t.
End Impl_core_marker_StructuralEq_for_mother_Status_t.

Module  Impl_core_cmp_Eq_for_mother_Status_t.
Section Impl_core_cmp_Eq_for_mother_Status_t.
  Definition Self : Set := mother.Status.t.
  
  (*
  Eq
  *)
  Definition assert_receiver_is_total_eq (self : ref Self) : M unit :=
    let* self := M.alloc self in
    let _ : unit := tt in
    let _ : unit := tt in
    let* α0 : M.Val unit := M.alloc tt in
    M.read α0.
  
  Global Instance AssociatedFunction_assert_receiver_is_total_eq :
    Notations.DoubleColon Self "assert_receiver_is_total_eq" := {
    Notations.double_colon := assert_receiver_is_total_eq;
  }.
  
  Global Instance ℐ : core.cmp.Eq.Required.Trait Self := {
    core.cmp.Eq.assert_receiver_is_total_eq :=
      Datatypes.Some assert_receiver_is_total_eq;
  }.
End Impl_core_cmp_Eq_for_mother_Status_t.
End Impl_core_cmp_Eq_for_mother_Status_t.

Module  Impl_core_clone_Clone_for_mother_Status_t.
Section Impl_core_clone_Clone_for_mother_Status_t.
  Definition Self : Set := mother.Status.t.
  
  (*
  Clone
  *)
  Definition clone (self : ref Self) : M mother.Status.t :=
    let* self := M.alloc self in
    let* α0 : ref mother.Status.t := M.read self in
    let* α1 : M.Val mother.Status.t :=
      match α0 with
      | mother.Status.NotStarted => M.alloc mother.Status.NotStarted
      | mother.Status.OpeningPeriod => M.alloc mother.Status.OpeningPeriod
      | mother.Status.EndingPeriod __self_0 =>
        let* __self_0 := M.alloc __self_0 in
        let* α0 : ref u32.t := M.read __self_0 in
        let* α1 : u32.t :=
          M.call
            ((core.clone.Clone.clone (Self := u32.t) (Trait := ltac:(refine _)))
              α0) in
        M.alloc (mother.Status.EndingPeriod α1)
      | mother.Status.Ended __self_0 =>
        let* __self_0 := M.alloc __self_0 in
        let* α0 : ref mother.Outline.t := M.read __self_0 in
        let* α1 : mother.Outline.t :=
          M.call
            ((core.clone.Clone.clone
                (Self := mother.Outline.t)
                (Trait := ltac:(refine _)))
              α0) in
        M.alloc (mother.Status.Ended α1)
      | mother.Status.RfDelay __self_0 =>
        let* __self_0 := M.alloc __self_0 in
        let* α0 : ref u32.t := M.read __self_0 in
        let* α1 : u32.t :=
          M.call
            ((core.clone.Clone.clone (Self := u32.t) (Trait := ltac:(refine _)))
              α0) in
        M.alloc (mother.Status.RfDelay α1)
      end in
    M.read α1.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_mother_Status_t.
End Impl_core_clone_Clone_for_mother_Status_t.

Module  Auction.
Section Auction.
  Record t : Set := {
    name : alloc.string.String.t;
    subject : ltac:(mother.Hash);
    bids : mother.Bids.t;
    terms : array ltac:(mother.BlockNumber);
    status : mother.Status.t;
    finalized : bool.t;
    vector : alloc.vec.Vec.t u8.t alloc.vec.Vec.Default.A;
  }.
  
  Global Instance Get_name : Notations.Dot "name" := {
    Notations.dot :=
      Ref.map (fun α => Some α.(name)) (fun β α => Some (α <| name := β |>));
  }.
  Global Instance Get_AF_name : Notations.DoubleColon t "name" := {
    Notations.double_colon (α : M.Val t) := α.["name"];
  }.
  Global Instance Get_subject : Notations.Dot "subject" := {
    Notations.dot :=
      Ref.map
        (fun α => Some α.(subject))
        (fun β α => Some (α <| subject := β |>));
  }.
  Global Instance Get_AF_subject : Notations.DoubleColon t "subject" := {
    Notations.double_colon (α : M.Val t) := α.["subject"];
  }.
  Global Instance Get_bids : Notations.Dot "bids" := {
    Notations.dot :=
      Ref.map (fun α => Some α.(bids)) (fun β α => Some (α <| bids := β |>));
  }.
  Global Instance Get_AF_bids : Notations.DoubleColon t "bids" := {
    Notations.double_colon (α : M.Val t) := α.["bids"];
  }.
  Global Instance Get_terms : Notations.Dot "terms" := {
    Notations.dot :=
      Ref.map (fun α => Some α.(terms)) (fun β α => Some (α <| terms := β |>));
  }.
  Global Instance Get_AF_terms : Notations.DoubleColon t "terms" := {
    Notations.double_colon (α : M.Val t) := α.["terms"];
  }.
  Global Instance Get_status : Notations.Dot "status" := {
    Notations.dot :=
      Ref.map
        (fun α => Some α.(status))
        (fun β α => Some (α <| status := β |>));
  }.
  Global Instance Get_AF_status : Notations.DoubleColon t "status" := {
    Notations.double_colon (α : M.Val t) := α.["status"];
  }.
  Global Instance Get_finalized : Notations.Dot "finalized" := {
    Notations.dot :=
      Ref.map
        (fun α => Some α.(finalized))
        (fun β α => Some (α <| finalized := β |>));
  }.
  Global Instance Get_AF_finalized : Notations.DoubleColon t "finalized" := {
    Notations.double_colon (α : M.Val t) := α.["finalized"];
  }.
  Global Instance Get_vector : Notations.Dot "vector" := {
    Notations.dot :=
      Ref.map
        (fun α => Some α.(vector))
        (fun β α => Some (α <| vector := β |>));
  }.
  Global Instance Get_AF_vector : Notations.DoubleColon t "vector" := {
    Notations.double_colon (α : M.Val t) := α.["vector"];
  }.
End Auction.
End Auction.

Module  Impl_core_marker_StructuralPartialEq_for_mother_Auction_t.
Section Impl_core_marker_StructuralPartialEq_for_mother_Auction_t.
  Definition Self : Set := mother.Auction.t.
  
  Global Instance ℐ : core.marker.StructuralPartialEq.Trait Self := {
  }.
End Impl_core_marker_StructuralPartialEq_for_mother_Auction_t.
End Impl_core_marker_StructuralPartialEq_for_mother_Auction_t.

Module  Impl_core_cmp_PartialEq_for_mother_Auction_t.
Section Impl_core_cmp_PartialEq_for_mother_Auction_t.
  Definition Self : Set := mother.Auction.t.
  
  (*
  PartialEq
  *)
  Definition eq (self : ref Self) (other : ref mother.Auction.t) : M bool.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    let* α0 : ref mother.Auction.t := M.read self in
    let* α1 : ref mother.Auction.t := M.read other in
    let* α2 : bool.t :=
      M.call
        ((core.cmp.PartialEq.eq
            (Self := alloc.string.String.t)
            (Trait := ltac:(refine _)))
          (borrow (deref α0).["name"])
          (borrow (deref α1).["name"])) in
    let* α3 : ref mother.Auction.t := M.read self in
    let* α4 : ref mother.Auction.t := M.read other in
    let* α5 : bool.t :=
      M.call
        ((core.cmp.PartialEq.eq (Self := array u8.t) (Trait := ltac:(refine _)))
          (borrow (deref α3).["subject"])
          (borrow (deref α4).["subject"])) in
    let* α6 : ref mother.Auction.t := M.read self in
    let* α7 : ref mother.Auction.t := M.read other in
    let* α8 : bool.t :=
      M.call
        ((core.cmp.PartialEq.eq
            (Self := mother.Bids.t)
            (Trait := ltac:(refine _)))
          (borrow (deref α6).["bids"])
          (borrow (deref α7).["bids"])) in
    let* α9 : ref mother.Auction.t := M.read self in
    let* α10 : ref mother.Auction.t := M.read other in
    let* α11 : bool.t :=
      M.call
        ((core.cmp.PartialEq.eq
            (Self := array u32.t)
            (Trait := ltac:(refine _)))
          (borrow (deref α9).["terms"])
          (borrow (deref α10).["terms"])) in
    let* α12 : ref mother.Auction.t := M.read self in
    let* α13 : ref mother.Auction.t := M.read other in
    let* α14 : bool.t :=
      M.call
        ((core.cmp.PartialEq.eq
            (Self := mother.Status.t)
            (Trait := ltac:(refine _)))
          (borrow (deref α12).["status"])
          (borrow (deref α13).["status"])) in
    let* α15 : ref mother.Auction.t := M.read self in
    let* α16 : bool.t := M.read (deref α15).["finalized"] in
    let* α17 : ref mother.Auction.t := M.read other in
    let* α18 : bool.t := M.read (deref α17).["finalized"] in
    let* α19 : ref mother.Auction.t := M.read self in
    let* α20 : ref mother.Auction.t := M.read other in
    let* α21 : bool.t :=
      M.call
        ((core.cmp.PartialEq.eq
            (Self := alloc.vec.Vec.t u8.t alloc.alloc.Global.t)
            (Trait := ltac:(refine _)))
          (borrow (deref α19).["vector"])
          (borrow (deref α20).["vector"])) in
    M.pure
      (BinOp.Pure.and
        (BinOp.Pure.and
          (BinOp.Pure.and
            (BinOp.Pure.and (BinOp.Pure.and (BinOp.Pure.and α2 α5) α8) α11)
            α14)
          (BinOp.Pure.eq α16 α18))
        α21).
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ :
    core.cmp.PartialEq.Required.Trait Self
      (Rhs := core.cmp.PartialEq.Default.Rhs Self) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_for_mother_Auction_t.
End Impl_core_cmp_PartialEq_for_mother_Auction_t.

Module  Impl_core_marker_StructuralEq_for_mother_Auction_t.
Section Impl_core_marker_StructuralEq_for_mother_Auction_t.
  Definition Self : Set := mother.Auction.t.
  
  Global Instance ℐ : core.marker.StructuralEq.Trait Self := {
  }.
End Impl_core_marker_StructuralEq_for_mother_Auction_t.
End Impl_core_marker_StructuralEq_for_mother_Auction_t.

Module  Impl_core_cmp_Eq_for_mother_Auction_t.
Section Impl_core_cmp_Eq_for_mother_Auction_t.
  Definition Self : Set := mother.Auction.t.
  
  (*
  Eq
  *)
  Definition assert_receiver_is_total_eq (self : ref Self) : M unit :=
    let* self := M.alloc self in
    let _ : unit := tt in
    let _ : unit := tt in
    let _ : unit := tt in
    let _ : unit := tt in
    let _ : unit := tt in
    let _ : unit := tt in
    let _ : unit := tt in
    let* α0 : M.Val unit := M.alloc tt in
    M.read α0.
  
  Global Instance AssociatedFunction_assert_receiver_is_total_eq :
    Notations.DoubleColon Self "assert_receiver_is_total_eq" := {
    Notations.double_colon := assert_receiver_is_total_eq;
  }.
  
  Global Instance ℐ : core.cmp.Eq.Required.Trait Self := {
    core.cmp.Eq.assert_receiver_is_total_eq :=
      Datatypes.Some assert_receiver_is_total_eq;
  }.
End Impl_core_cmp_Eq_for_mother_Auction_t.
End Impl_core_cmp_Eq_for_mother_Auction_t.

Module  Impl_core_clone_Clone_for_mother_Auction_t.
Section Impl_core_clone_Clone_for_mother_Auction_t.
  Definition Self : Set := mother.Auction.t.
  
  (*
  Clone
  *)
  Definition clone (self : ref Self) : M mother.Auction.t :=
    let* self := M.alloc self in
    let* α0 : ref mother.Auction.t := M.read self in
    let* α1 : alloc.string.String.t :=
      M.call
        ((core.clone.Clone.clone
            (Self := alloc.string.String.t)
            (Trait := ltac:(refine _)))
          (borrow (deref α0).["name"])) in
    let* α2 : ref mother.Auction.t := M.read self in
    let* α3 : array u8.t :=
      M.call
        ((core.clone.Clone.clone
            (Self := array u8.t)
            (Trait := ltac:(refine _)))
          (borrow (deref α2).["subject"])) in
    let* α4 : ref mother.Auction.t := M.read self in
    let* α5 : mother.Bids.t :=
      M.call
        ((core.clone.Clone.clone
            (Self := mother.Bids.t)
            (Trait := ltac:(refine _)))
          (borrow (deref α4).["bids"])) in
    let* α6 : ref mother.Auction.t := M.read self in
    let* α7 : array u32.t :=
      M.call
        ((core.clone.Clone.clone
            (Self := array u32.t)
            (Trait := ltac:(refine _)))
          (borrow (deref α6).["terms"])) in
    let* α8 : ref mother.Auction.t := M.read self in
    let* α9 : mother.Status.t :=
      M.call
        ((core.clone.Clone.clone
            (Self := mother.Status.t)
            (Trait := ltac:(refine _)))
          (borrow (deref α8).["status"])) in
    let* α10 : ref mother.Auction.t := M.read self in
    let* α11 : bool.t :=
      M.call
        ((core.clone.Clone.clone (Self := bool.t) (Trait := ltac:(refine _)))
          (borrow (deref α10).["finalized"])) in
    let* α12 : ref mother.Auction.t := M.read self in
    let* α13 : alloc.vec.Vec.t u8.t alloc.alloc.Global.t :=
      M.call
        ((core.clone.Clone.clone
            (Self := alloc.vec.Vec.t u8.t alloc.alloc.Global.t)
            (Trait := ltac:(refine _)))
          (borrow (deref α12).["vector"])) in
    M.pure
      {|
        mother.Auction.name := α1;
        mother.Auction.subject := α3;
        mother.Auction.bids := α5;
        mother.Auction.terms := α7;
        mother.Auction.status := α9;
        mother.Auction.finalized := α11;
        mother.Auction.vector := α13;
      |}.
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon Self "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_mother_Auction_t.
End Impl_core_clone_Clone_for_mother_Auction_t.

Module  Impl_core_default_Default_for_mother_Auction_t.
Section Impl_core_default_Default_for_mother_Auction_t.
  Definition Self : Set := mother.Auction.t.
  
  (*
      fn default() -> Auction {
          Auction {
              name: String::default(),
              subject: Hash::default(),
              bids: Bids::default(),
              terms: <[BlockNumber; 3]>::default(),
              status: Status::OpeningPeriod,
              finalized: false,
              vector: <Vec<u8>>::default(),
          }
      }
  *)
  Definition default : M mother.Auction.t :=
    let* α0 : alloc.string.String.t :=
      M.call
        (core.default.Default.default
          (Self := alloc.string.String.t)
          (Trait := ltac:(refine _))) in
    let* α1 : array u8.t :=
      M.call
        (core.default.Default.default
          (Self := array u8.t)
          (Trait := ltac:(refine _))) in
    let* α2 : mother.Bids.t :=
      M.call
        (core.default.Default.default
          (Self := mother.Bids.t)
          (Trait := ltac:(refine _))) in
    let* α3 : array u32.t :=
      M.call
        (core.default.Default.default
          (Self := array u32.t)
          (Trait := ltac:(refine _))) in
    let* α4 : alloc.vec.Vec.t u8.t alloc.alloc.Global.t :=
      M.call
        (core.default.Default.default
          (Self := alloc.vec.Vec.t u8.t alloc.alloc.Global.t)
          (Trait := ltac:(refine _))) in
    M.pure
      {|
        mother.Auction.name := α0;
        mother.Auction.subject := α1;
        mother.Auction.bids := α2;
        mother.Auction.terms := α3;
        mother.Auction.status := mother.Status.OpeningPeriod;
        mother.Auction.finalized := false;
        mother.Auction.vector := α4;
      |}.
  
  Global Instance AssociatedFunction_default :
    Notations.DoubleColon Self "default" := {
    Notations.double_colon := default;
  }.
  
  Global Instance ℐ : core.default.Default.Trait Self := {
    core.default.Default.default := default;
  }.
End Impl_core_default_Default_for_mother_Auction_t.
End Impl_core_default_Default_for_mother_Auction_t.

Module Failure.
  Inductive t : Set :=
  | Revert (_ : alloc.string.String.t)
  | Panic.
  
  Global Instance Get_Revert_0 : Notations.Dot "Revert.0" := {
    Notations.dot :=
      Ref.map
        (fun α => match α with | Revert α0 => Some α0 | _ => None end)
        (fun β α => match α with | Revert _ => Some (Revert β) | _ => None end);
  }.
End Failure.

Module  Impl_core_marker_StructuralPartialEq_for_mother_Failure_t.
Section Impl_core_marker_StructuralPartialEq_for_mother_Failure_t.
  Definition Self : Set := mother.Failure.t.
  
  Global Instance ℐ : core.marker.StructuralPartialEq.Trait Self := {
  }.
End Impl_core_marker_StructuralPartialEq_for_mother_Failure_t.
End Impl_core_marker_StructuralPartialEq_for_mother_Failure_t.

Module  Impl_core_cmp_PartialEq_for_mother_Failure_t.
Section Impl_core_cmp_PartialEq_for_mother_Failure_t.
  Definition Self : Set := mother.Failure.t.
  
  (*
  PartialEq
  *)
  Definition eq (self : ref Self) (other : ref mother.Failure.t) : M bool.t :=
    let* self := M.alloc self in
    let* other := M.alloc other in
    let* __self_tag : M.Val isize.t :=
      let* α0 : ref mother.Failure.t := M.read self in
      let* α1 : isize.t := M.call (core.intrinsics.discriminant_value α0) in
      M.alloc α1 in
    let* __arg1_tag : M.Val isize.t :=
      let* α0 : ref mother.Failure.t := M.read other in
      let* α1 : isize.t := M.call (core.intrinsics.discriminant_value α0) in
      M.alloc α1 in
    let* α0 : isize.t := M.read __self_tag in
    let* α1 : isize.t := M.read __arg1_tag in
    let* α2 : ref mother.Failure.t := M.read self in
    let* α3 : ref mother.Failure.t := M.read other in
    let* α4 : M.Val bool.t :=
      match (α2, α3) with
      | (mother.Failure.Revert __self_0, mother.Failure.Revert __arg1_0) =>
        let* __self_0 := M.alloc __self_0 in
        let* __arg1_0 := M.alloc __arg1_0 in
        let* α0 : ref alloc.string.String.t := M.read __self_0 in
        let* α1 : ref alloc.string.String.t := M.read __arg1_0 in
        let* α2 : bool.t :=
          M.call
            ((core.cmp.PartialEq.eq
                (Self := alloc.string.String.t)
                (Trait := ltac:(refine _)))
              α0
              α1) in
        M.alloc α2
      | _ => M.alloc true
      end in
    let* α5 : bool.t := M.read α4 in
    let* α0 : M.Val bool.t :=
      M.alloc (BinOp.Pure.and (BinOp.Pure.eq α0 α1) α5) in
    M.read α0.
  
  Global Instance AssociatedFunction_eq : Notations.DoubleColon Self "eq" := {
    Notations.double_colon := eq;
  }.
  
  Global Instance ℐ :
    core.cmp.PartialEq.Required.Trait Self
      (Rhs := core.cmp.PartialEq.Default.Rhs Self) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_for_mother_Failure_t.
End Impl_core_cmp_PartialEq_for_mother_Failure_t.

Module  Impl_core_marker_StructuralEq_for_mother_Failure_t.
Section Impl_core_marker_StructuralEq_for_mother_Failure_t.
  Definition Self : Set := mother.Failure.t.
  
  Global Instance ℐ : core.marker.StructuralEq.Trait Self := {
  }.
End Impl_core_marker_StructuralEq_for_mother_Failure_t.
End Impl_core_marker_StructuralEq_for_mother_Failure_t.

Module  Impl_core_cmp_Eq_for_mother_Failure_t.
Section Impl_core_cmp_Eq_for_mother_Failure_t.
  Definition Self : Set := mother.Failure.t.
  
  (*
  Eq
  *)
  Definition assert_receiver_is_total_eq (self : ref Self) : M unit :=
    let* self := M.alloc self in
    let _ : unit := tt in
    let* α0 : M.Val unit := M.alloc tt in
    M.read α0.
  
  Global Instance AssociatedFunction_assert_receiver_is_total_eq :
    Notations.DoubleColon Self "assert_receiver_is_total_eq" := {
    Notations.double_colon := assert_receiver_is_total_eq;
  }.
  
  Global Instance ℐ : core.cmp.Eq.Required.Trait Self := {
    core.cmp.Eq.assert_receiver_is_total_eq :=
      Datatypes.Some assert_receiver_is_total_eq;
  }.
End Impl_core_cmp_Eq_for_mother_Failure_t.
End Impl_core_cmp_Eq_for_mother_Failure_t.

Module  AuctionEchoed.
Section AuctionEchoed.
  Record t : Set := {
    auction : mother.Auction.t;
  }.
  
  Global Instance Get_auction : Notations.Dot "auction" := {
    Notations.dot :=
      Ref.map
        (fun α => Some α.(auction))
        (fun β α => Some (α <| auction := β |>));
  }.
  Global Instance Get_AF_auction : Notations.DoubleColon t "auction" := {
    Notations.double_colon (α : M.Val t) := α.["auction"];
  }.
End AuctionEchoed.
End AuctionEchoed.

Module Event.
  Inductive t : Set :=
  | AuctionEchoed (_ : mother.AuctionEchoed.t).
  
  Global Instance Get_AuctionEchoed_0 : Notations.Dot "AuctionEchoed.0" := {
    Notations.dot :=
      Ref.map
        (fun α => match α with | AuctionEchoed α0 => Some α0 end)
        (fun β α =>
          match α with | AuctionEchoed _ => Some (AuctionEchoed β) end);
  }.
End Event.

Module  Impl_mother_Env_t.
Section Impl_mother_Env_t.
  Definition Self : Set := mother.Env.t.
  
  (*
      fn caller(&self) -> AccountId {
          self.caller
      }
  *)
  Definition caller (self : ref Self) : M mother.AccountId.t :=
    let* self := M.alloc self in
    let* α0 : ref mother.Env.t := M.read self in
    M.read (deref α0).["caller"].
  
  Global Instance AssociatedFunction_caller :
    Notations.DoubleColon Self "caller" := {
    Notations.double_colon := caller;
  }.
  
  (*
      fn emit_event(&self, _event: Event) {
          unimplemented!()
      }
  *)
  Definition emit_event (self : ref Self) (_event : mother.Event.t) : M unit :=
    let* self := M.alloc self in
    let* _event := M.alloc _event in
    let* α0 : ref str.t := M.read (mk_str "not implemented") in
    let* α1 : never.t := M.call (core.panicking.panic α0) in
    never_to_any α1.
  
  Global Instance AssociatedFunction_emit_event :
    Notations.DoubleColon Self "emit_event" := {
    Notations.double_colon := emit_event;
  }.
End Impl_mother_Env_t.
End Impl_mother_Env_t.

Module  Mother.
Section Mother.
  Record t : Set := {
    auction : mother.Auction.t;
    balances : mother.Mapping.t mother.AccountId.t ltac:(mother.Balance);
  }.
  
  Global Instance Get_auction : Notations.Dot "auction" := {
    Notations.dot :=
      Ref.map
        (fun α => Some α.(auction))
        (fun β α => Some (α <| auction := β |>));
  }.
  Global Instance Get_AF_auction : Notations.DoubleColon t "auction" := {
    Notations.double_colon (α : M.Val t) := α.["auction"];
  }.
  Global Instance Get_balances : Notations.Dot "balances" := {
    Notations.dot :=
      Ref.map
        (fun α => Some α.(balances))
        (fun β α => Some (α <| balances := β |>));
  }.
  Global Instance Get_AF_balances : Notations.DoubleColon t "balances" := {
    Notations.double_colon (α : M.Val t) := α.["balances"];
  }.
End Mother.
End Mother.

Module  Impl_core_default_Default_for_mother_Mother_t.
Section Impl_core_default_Default_for_mother_Mother_t.
  Definition Self : Set := mother.Mother.t.
  
  (*
  Default
  *)
  Definition default : M mother.Mother.t :=
    let* α0 : mother.Auction.t :=
      M.call
        (core.default.Default.default
          (Self := mother.Auction.t)
          (Trait := ltac:(refine _))) in
    let* α1 : mother.Mapping.t mother.AccountId.t u128.t :=
      M.call
        (core.default.Default.default
          (Self := mother.Mapping.t mother.AccountId.t u128.t)
          (Trait := ltac:(refine _))) in
    M.pure {| mother.Mother.auction := α0; mother.Mother.balances := α1; |}.
  
  Global Instance AssociatedFunction_default :
    Notations.DoubleColon Self "default" := {
    Notations.double_colon := default;
  }.
  
  Global Instance ℐ : core.default.Default.Trait Self := {
    core.default.Default.default := default;
  }.
End Impl_core_default_Default_for_mother_Mother_t.
End Impl_core_default_Default_for_mother_Mother_t.

Module  Impl_mother_Mother_t.
Section Impl_mother_Mother_t.
  Definition Self : Set := mother.Mother.t.
  
  (*
      fn init_env() -> Env {
          unimplemented!()
      }
  *)
  Definition init_env : M mother.Env.t :=
    let* α0 : ref str.t := M.read (mk_str "not implemented") in
    let* α1 : never.t := M.call (core.panicking.panic α0) in
    never_to_any α1.
  
  Global Instance AssociatedFunction_init_env :
    Notations.DoubleColon Self "init_env" := {
    Notations.double_colon := init_env;
  }.
  
  (*
      fn env(&self) -> Env {
          Self::init_env()
      }
  *)
  Definition env (self : ref Self) : M mother.Env.t :=
    let* self := M.alloc self in
    M.call mother.Mother.t::["init_env"].
  
  Global Instance AssociatedFunction_env : Notations.DoubleColon Self "env" := {
    Notations.double_colon := env;
  }.
  
  (*
      pub fn new(auction: Auction) -> Self {
          Self {
              balances: Default::default(),
              auction,
          }
      }
  *)
  Definition new (auction : mother.Auction.t) : M Self :=
    let* auction := M.alloc auction in
    let* α0 : mother.Mapping.t mother.AccountId.t u128.t :=
      M.call
        (core.default.Default.default
          (Self := mother.Mapping.t mother.AccountId.t u128.t)
          (Trait := ltac:(refine _))) in
    let* α1 : mother.Auction.t := M.read auction in
    M.pure {| mother.Mother.balances := α0; mother.Mother.auction := α1; |}.
  
  Global Instance AssociatedFunction_new : Notations.DoubleColon Self "new" := {
    Notations.double_colon := new;
  }.
  
  (*
      pub fn new_default() -> Self {
          Default::default()
      }
  *)
  Definition new_default : M Self :=
    M.call
      (core.default.Default.default
        (Self := mother.Mother.t)
        (Trait := ltac:(refine _))).
  
  Global Instance AssociatedFunction_new_default :
    Notations.DoubleColon Self "new_default" := {
    Notations.double_colon := new_default;
  }.
  
  (*
      pub fn failed_new(fail: bool) -> Result<Self, Failure> {
          if fail {
              Err(Failure::Revert("Reverting instantiation".to_string()))
          } else {
              Ok(Default::default())
          }
      }
  *)
  Definition failed_new
      (fail : bool.t)
      : M (core.result.Result.t Self mother.Failure.t) :=
    let* fail := M.alloc fail in
    let* α0 : bool.t := M.read (use fail) in
    let* α1 : M.Val (core.result.Result.t mother.Mother.t mother.Failure.t) :=
      if α0 then
        let* α0 : ref str.t := M.read (mk_str "Reverting instantiation") in
        let* α1 : alloc.string.String.t :=
          M.call
            ((alloc.string.ToString.to_string
                (Self := str.t)
                (Trait := ltac:(refine _)))
              α0) in
        M.alloc (core.result.Result.Err (mother.Failure.Revert α1))
      else
        let* α0 : mother.Mother.t :=
          M.call
            (core.default.Default.default
              (Self := mother.Mother.t)
              (Trait := ltac:(refine _))) in
        M.alloc (core.result.Result.Ok α0) in
    M.read α1.
  
  Global Instance AssociatedFunction_failed_new :
    Notations.DoubleColon Self "failed_new" := {
    Notations.double_colon := failed_new;
  }.
  
  (*
      pub fn echo_auction(&mut self, auction: Auction) -> Auction {
          self.env().emit_event(Event::AuctionEchoed(AuctionEchoed {
              auction: auction.clone(),
          }));
          auction
      }
  *)
  Definition echo_auction
      (self : mut_ref Self)
      (auction : mother.Auction.t)
      : M mother.Auction.t :=
    let* self := M.alloc self in
    let* auction := M.alloc auction in
    let* _ : M.Val unit :=
      let* α0 : mut_ref mother.Mother.t := M.read self in
      let* α1 : mother.Env.t :=
        M.call (mother.Mother.t::["env"] (borrow (deref α0))) in
      let* α2 : M.Val mother.Env.t := M.alloc α1 in
      let* α3 : mother.Auction.t :=
        M.call
          ((core.clone.Clone.clone
              (Self := mother.Auction.t)
              (Trait := ltac:(refine _)))
            (borrow auction)) in
      let* α4 : unit :=
        M.call
          (mother.Env.t::["emit_event"]
            (borrow α2)
            (mother.Event.AuctionEchoed
              {| mother.AuctionEchoed.auction := α3; |})) in
      M.alloc α4 in
    M.read auction.
  
  Global Instance AssociatedFunction_echo_auction :
    Notations.DoubleColon Self "echo_auction" := {
    Notations.double_colon := echo_auction;
  }.
  
  (*
      pub fn revert_or_trap(&mut self, fail: Option<Failure>) -> Result<(), Failure> {
          match fail {
              Some(Failure::Revert(_)) => {
                  Err(Failure::Revert("Reverting on user demand!".to_string()))
              }
              Some(Failure::Panic) => {
                  panic!("Trapping on user demand!")
              }
              None => Ok(()),
          }
      }
  *)
  Definition revert_or_trap
      (self : mut_ref Self)
      (fail : core.option.Option.t mother.Failure.t)
      : M (core.result.Result.t unit mother.Failure.t) :=
    let* self := M.alloc self in
    let* fail := M.alloc fail in
    let* α0 : core.option.Option.t mother.Failure.t := M.read fail in
    let* α1 : M.Val (core.result.Result.t unit mother.Failure.t) :=
      match α0 with
      | core.option.Option.Some (mother.Failure.Revert _) =>
        let* α0 : ref str.t := M.read (mk_str "Reverting on user demand!") in
        let* α1 : alloc.string.String.t :=
          M.call
            ((alloc.string.ToString.to_string
                (Self := str.t)
                (Trait := ltac:(refine _)))
              α0) in
        M.alloc (core.result.Result.Err (mother.Failure.Revert α1))
      | core.option.Option.Some mother.Failure.Panic =>
        let* α0 : ref str.t := M.read (mk_str "Trapping on user demand!") in
        let* α1 : never.t := M.call (std.panicking.begin_panic α0) in
        let* α2 : core.result.Result.t unit mother.Failure.t :=
          never_to_any α1 in
        M.alloc α2
      | core.option.Option.None => M.alloc (core.result.Result.Ok tt)
      end in
    M.read α1.
  
  Global Instance AssociatedFunction_revert_or_trap :
    Notations.DoubleColon Self "revert_or_trap" := {
    Notations.double_colon := revert_or_trap;
  }.
  
  (*
      pub fn debug_log(&mut self, _message: String) {
          println!("debug_log: {}", _message);
      }
  *)
  Definition debug_log
      (self : mut_ref Self)
      (_message : alloc.string.String.t)
      : M unit :=
    let* self := M.alloc self in
    let* _message := M.alloc _message in
    let* _ : M.Val unit :=
      let* _ : M.Val unit :=
        let* α0 : ref str.t := M.read (mk_str "debug_log: ") in
        let* α1 : ref str.t := M.read (mk_str "
") in
        let* α2 : M.Val (array (ref str.t)) := M.alloc [ α0; α1 ] in
        let* α3 : M.Val (ref (array (ref str.t))) := M.alloc (borrow α2) in
        let* α4 : ref (slice (ref str.t)) :=
          M.read (pointer_coercion "Unsize" α3) in
        let* α5 : core.fmt.rt.Argument.t :=
          M.call (core.fmt.rt.Argument.t::["new_display"] (borrow _message)) in
        let* α6 : M.Val (array core.fmt.rt.Argument.t) := M.alloc [ α5 ] in
        let* α7 : M.Val (ref (array core.fmt.rt.Argument.t)) :=
          M.alloc (borrow α6) in
        let* α8 : ref (slice core.fmt.rt.Argument.t) :=
          M.read (pointer_coercion "Unsize" α7) in
        let* α9 : core.fmt.Arguments.t :=
          M.call (core.fmt.Arguments.t::["new_v1"] α4 α8) in
        let* α10 : unit := M.call (std.io.stdio._print α9) in
        M.alloc α10 in
      M.alloc tt in
    let* α0 : M.Val unit := M.alloc tt in
    M.read α0.
  
  Global Instance AssociatedFunction_debug_log :
    Notations.DoubleColon Self "debug_log" := {
    Notations.double_colon := debug_log;
  }.
End Impl_mother_Mother_t.
End Impl_mother_Mother_t.
