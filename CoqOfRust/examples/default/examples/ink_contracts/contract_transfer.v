(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

(* Struct AccountId *)

Module Impl_core_default_Default_for_contract_transfer_AccountId.
  (*
  Default
  *)
  Definition default (𝜏 : list Ty.t) (α : list Value.t) : M :=
    match 𝜏, α with
    | [ Self ], [] =>
      let* α0 :=
        M.get_trait_method
          "core::default::Default"
          "default"
          [ (* Self *) Ty.path "u128" ] in
      let* α1 := M.call α0 [] in
      M.pure (Value.StructTuple "contract_transfer::AccountId" [ α1 ])
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::default::Default"
      (* Self *) (Ty.path "contract_transfer::AccountId")
      (* Trait polymorphic types *) []
      (* Instance *) [ ("default", InstanceField.Method default) ]
      (* Instance polymorphic types *) [].
End Impl_core_default_Default_for_contract_transfer_AccountId.

Module Impl_core_clone_Clone_for_contract_transfer_AccountId.
  (*
  Clone
  *)
  Definition clone (𝜏 : list Ty.t) (α : list Value.t) : M :=
    match 𝜏, α with
    | [ Self ], [ self ] =>
      let* self := M.alloc self in
      let* α0 :=
        match_operator Value.DeclaredButUndefined [ fun γ => (M.read self) ] in
      M.read α0
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::clone::Clone"
      (* Self *) (Ty.path "contract_transfer::AccountId")
      (* Trait polymorphic types *) []
      (* Instance *) [ ("clone", InstanceField.Method clone) ]
      (* Instance polymorphic types *) [].
End Impl_core_clone_Clone_for_contract_transfer_AccountId.

Module Impl_core_marker_Copy_for_contract_transfer_AccountId.
  Axiom Implements :
    M.IsTraitInstance
      "core::marker::Copy"
      (* Self *) (Ty.path "contract_transfer::AccountId")
      (* Trait polymorphic types *) []
      (* Instance *) []
      (* Instance polymorphic types *) [].
End Impl_core_marker_Copy_for_contract_transfer_AccountId.

Axiom Balance : (Ty.path "contract_transfer::Balance") = (Ty.path "u128").

(* Struct Env *)

Module Impl_contract_transfer_Env.
  Definition Self : Ty.t := Ty.path "contract_transfer::Env".
  
  (*
      fn caller(&self) -> AccountId {
          self.caller
      }
  *)
  Definition caller (𝜏 : list Ty.t) (α : list Value.t) : M :=
    match 𝜏, α with
    | [ Self ], [ self ] =>
      let* self := M.alloc self in
      let* α0 := M.read self in
      M.read (M.get_struct_record α0 "caller")
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_caller :
    M.IsAssociatedFunction Self "caller" caller [].
  
  (*
      fn balance(&self) -> Balance {
          unimplemented!()
      }
  *)
  Definition balance (𝜏 : list Ty.t) (α : list Value.t) : M :=
    match 𝜏, α with
    | [ Self ], [ self ] =>
      let* self := M.alloc self in
      let* α0 := M.var "core::panicking::panic" in
      let* α1 := M.read (mk_str "not implemented") in
      let* α2 := M.call α0 [ α1 ] in
      M.never_to_any α2
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_balance :
    M.IsAssociatedFunction Self "balance" balance [].
  
  (*
      fn transfer(&mut self, _to: AccountId, _value: Balance) -> Result<(), ()> {
          unimplemented!()
      }
  *)
  Definition transfer (𝜏 : list Ty.t) (α : list Value.t) : M :=
    match 𝜏, α with
    | [ Self ], [ self; _to; _value ] =>
      let* self := M.alloc self in
      let* _to := M.alloc _to in
      let* _value := M.alloc _value in
      let* α0 := M.var "core::panicking::panic" in
      let* α1 := M.read (mk_str "not implemented") in
      let* α2 := M.call α0 [ α1 ] in
      M.never_to_any α2
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_transfer :
    M.IsAssociatedFunction Self "transfer" transfer [].
  
  (*
      fn transferred_value(&self) -> Balance {
          unimplemented!()
      }
  *)
  Definition transferred_value (𝜏 : list Ty.t) (α : list Value.t) : M :=
    match 𝜏, α with
    | [ Self ], [ self ] =>
      let* self := M.alloc self in
      let* α0 := M.var "core::panicking::panic" in
      let* α1 := M.read (mk_str "not implemented") in
      let* α2 := M.call α0 [ α1 ] in
      M.never_to_any α2
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_transferred_value :
    M.IsAssociatedFunction Self "transferred_value" transferred_value [].
End Impl_contract_transfer_Env.

(* Struct GiveMe *)

Module Impl_contract_transfer_GiveMe.
  Definition Self : Ty.t := Ty.path "contract_transfer::GiveMe".
  
  (*
      fn init_env() -> Env {
          unimplemented!()
      }
  *)
  Definition init_env (𝜏 : list Ty.t) (α : list Value.t) : M :=
    match 𝜏, α with
    | [ Self ], [] =>
      let* α0 := M.var "core::panicking::panic" in
      let* α1 := M.read (mk_str "not implemented") in
      let* α2 := M.call α0 [ α1 ] in
      M.never_to_any α2
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_init_env :
    M.IsAssociatedFunction Self "init_env" init_env [].
  
  (*
      fn env(&self) -> Env {
          Self::init_env()
      }
  *)
  Definition env (𝜏 : list Ty.t) (α : list Value.t) : M :=
    match 𝜏, α with
    | [ Self ], [ self ] =>
      let* self := M.alloc self in
      M.call (Ty.path "contract_transfer::GiveMe")::["init_env"] []
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_env : M.IsAssociatedFunction Self "env" env [].
  
  (*
      pub fn new() -> Self {
          Self {}
      }
  *)
  Definition new (𝜏 : list Ty.t) (α : list Value.t) : M :=
    match 𝜏, α with
    | [ Self ], [] => M.pure contract_transfer.GiveMe.Build
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_new : M.IsAssociatedFunction Self "new" new [].
  
  (*
      pub fn give_me(&mut self, value: Balance) {
          println!("requested value: {}", value);
          println!("contract balance: {}", self.env().balance());
  
          assert!(value <= self.env().balance(), "insufficient funds!");
  
          if self.env().transfer(self.env().caller(), value).is_err() {
              panic!(
                  "requested transfer failed. this can be the case if the contract does not\
                   have sufficient free funds or if the transfer would have brought the\
                   contract's balance below minimum balance."
              )
          }
      }
  *)
  Definition give_me (𝜏 : list Ty.t) (α : list Value.t) : M :=
    match 𝜏, α with
    | [ Self ], [ self; value ] =>
      let* self := M.alloc self in
      let* value := M.alloc value in
      let* _ :=
        let* _ :=
          let* α0 := M.var "std::io::stdio::_print" in
          let* α1 := M.read (mk_str "requested value: ") in
          let* α2 := M.read (mk_str "
") in
          let* α3 := M.alloc [ α1; α2 ] in
          let* α4 :=
            M.call
              (Ty.path "core::fmt::rt::Argument")::["new_display"]
              [ value ] in
          let* α5 := M.alloc [ α4 ] in
          let* α6 :=
            M.call
              (Ty.path "core::fmt::Arguments")::["new_v1"]
              [ M.pointer_coercion "Unsize" α3; M.pointer_coercion "Unsize" α5
              ] in
          let* α7 := M.call α0 [ α6 ] in
          M.alloc α7 in
        M.alloc tt in
      let* _ :=
        let* _ :=
          let* α0 := M.var "std::io::stdio::_print" in
          let* α1 := M.read (mk_str "contract balance: ") in
          let* α2 := M.read (mk_str "
") in
          let* α3 := M.alloc [ α1; α2 ] in
          let* α4 := M.read self in
          let* α5 :=
            M.call (Ty.path "contract_transfer::GiveMe")::["env"] [ α4 ] in
          let* α6 := M.alloc α5 in
          let* α7 :=
            M.call (Ty.path "contract_transfer::Env")::["balance"] [ α6 ] in
          let* α8 := M.alloc α7 in
          let* α9 :=
            M.call
              (Ty.path "core::fmt::rt::Argument")::["new_display"]
              [ α8 ] in
          let* α10 := M.alloc [ α9 ] in
          let* α11 :=
            M.call
              (Ty.path "core::fmt::Arguments")::["new_v1"]
              [ M.pointer_coercion "Unsize" α3; M.pointer_coercion "Unsize" α10
              ] in
          let* α12 := M.call α0 [ α11 ] in
          M.alloc α12 in
        M.alloc tt in
      let* _ :=
        let* α0 := M.read value in
        let* α1 := M.read self in
        let* α2 :=
          M.call (Ty.path "contract_transfer::GiveMe")::["env"] [ α1 ] in
        let* α3 := M.alloc α2 in
        let* α4 :=
          M.call (Ty.path "contract_transfer::Env")::["balance"] [ α3 ] in
        let* α5 := M.alloc (UnOp.not (BinOp.Pure.le α0 α4)) in
        let* α6 := M.read (M.use α5) in
        if α6 then
          let* α0 := M.var "std::panicking::begin_panic" in
          let* α1 := M.read (mk_str "insufficient funds!") in
          let* α2 := M.call α0 [ α1 ] in
          let* α3 := M.never_to_any α2 in
          M.alloc α3
        else
          M.alloc tt in
      let* α0 := M.read self in
      let* α1 := M.call (Ty.path "contract_transfer::GiveMe")::["env"] [ α0 ] in
      let* α2 := M.alloc α1 in
      let* α3 := M.read self in
      let* α4 := M.call (Ty.path "contract_transfer::GiveMe")::["env"] [ α3 ] in
      let* α5 := M.alloc α4 in
      let* α6 := M.call (Ty.path "contract_transfer::Env")::["caller"] [ α5 ] in
      let* α7 := M.read value in
      let* α8 :=
        M.call
          (Ty.path "contract_transfer::Env")::["transfer"]
          [ α2; α6; α7 ] in
      let* α9 := M.alloc α8 in
      let* α10 :=
        M.call
          (Ty.apply
              (Ty.path "core::result::Result")
              [ Ty.tuple []; Ty.tuple [] ])::["is_err"]
          [ α9 ] in
      let* α11 := M.alloc α10 in
      let* α12 := M.read (M.use α11) in
      let* α0 :=
        if α12 then
          let* α0 := M.var "std::panicking::begin_panic" in
          let* α1 :=
            M.read
              (mk_str
                "requested transfer failed. this can be the case if the contract does nothave sufficient free funds or if the transfer would have brought thecontract's balance below minimum balance.") in
          let* α2 := M.call α0 [ α1 ] in
          let* α3 := M.never_to_any α2 in
          M.alloc α3
        else
          M.alloc tt in
      M.read α0
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_give_me :
    M.IsAssociatedFunction Self "give_me" give_me [].
  
  (*
      pub fn was_it_ten(&self) {
          println!("received payment: {}", self.env().transferred_value());
          assert!(self.env().transferred_value() == 10, "payment was not ten");
      }
  *)
  Definition was_it_ten (𝜏 : list Ty.t) (α : list Value.t) : M :=
    match 𝜏, α with
    | [ Self ], [ self ] =>
      let* self := M.alloc self in
      let* _ :=
        let* _ :=
          let* α0 := M.var "std::io::stdio::_print" in
          let* α1 := M.read (mk_str "received payment: ") in
          let* α2 := M.read (mk_str "
") in
          let* α3 := M.alloc [ α1; α2 ] in
          let* α4 := M.read self in
          let* α5 :=
            M.call (Ty.path "contract_transfer::GiveMe")::["env"] [ α4 ] in
          let* α6 := M.alloc α5 in
          let* α7 :=
            M.call
              (Ty.path "contract_transfer::Env")::["transferred_value"]
              [ α6 ] in
          let* α8 := M.alloc α7 in
          let* α9 :=
            M.call
              (Ty.path "core::fmt::rt::Argument")::["new_display"]
              [ α8 ] in
          let* α10 := M.alloc [ α9 ] in
          let* α11 :=
            M.call
              (Ty.path "core::fmt::Arguments")::["new_v1"]
              [ M.pointer_coercion "Unsize" α3; M.pointer_coercion "Unsize" α10
              ] in
          let* α12 := M.call α0 [ α11 ] in
          M.alloc α12 in
        M.alloc tt in
      let* _ :=
        let* α0 := M.read self in
        let* α1 :=
          M.call (Ty.path "contract_transfer::GiveMe")::["env"] [ α0 ] in
        let* α2 := M.alloc α1 in
        let* α3 :=
          M.call
            (Ty.path "contract_transfer::Env")::["transferred_value"]
            [ α2 ] in
        let* α4 :=
          M.alloc
            (UnOp.not (BinOp.Pure.eq α3 (Value.Integer Integer.U128 10))) in
        let* α5 := M.read (M.use α4) in
        if α5 then
          let* α0 := M.var "std::panicking::begin_panic" in
          let* α1 := M.read (mk_str "payment was not ten") in
          let* α2 := M.call α0 [ α1 ] in
          let* α3 := M.never_to_any α2 in
          M.alloc α3
        else
          M.alloc tt in
      let* α0 := M.alloc tt in
      M.read α0
    | _, _ => M.impossible
    end.
  
  Axiom AssociatedFunction_was_it_ten :
    M.IsAssociatedFunction Self "was_it_ten" was_it_ten [].
End Impl_contract_transfer_GiveMe.
