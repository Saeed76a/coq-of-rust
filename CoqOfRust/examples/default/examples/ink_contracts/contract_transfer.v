(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.



Module  Impl_core_default_Default_for_contract_transfer_AccountId.
Section Impl_core_default_Default_for_contract_transfer_AccountId.
  Definition Self : Ty.t :=
    Ty.apply (Ty.path "contract_transfer::AccountId") [].
  
  (*
  Default
  *)
  Definition default (𝜏 : list Ty.t) (α : list Value.t) : M :=
    match 𝜏, α with
    | [], [] =>
      let* α0 : Ty.function [] (Ty.path "u128") :=
        ltac:(M.get_method (fun ℐ =>
          core.default.Default.default
            (Self := Ty.path "u128")
            (Trait := ℐ))) in
      let* α1 : Ty.path "u128" := M.call α0 in
      M.pure (contract_transfer.AccountId.Build_t α1)
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_default : Instance.t := {
    Notations.double_colon := default;
  }.
  
  Definition ℐ : Instance.t := [("default", default)].
End Impl_core_default_Default_for_contract_transfer_AccountId.
End Impl_core_default_Default_for_contract_transfer_AccountId.

Module  Impl_core_clone_Clone_for_contract_transfer_AccountId.
Section Impl_core_clone_Clone_for_contract_transfer_AccountId.
  Definition Self : Ty.t :=
    Ty.apply (Ty.path "contract_transfer::AccountId") [].
  
  (*
  Clone
  *)
  Definition clone (𝜏 : list Ty.t) (α : list Value.t) : M :=
    match 𝜏, α with
    | [], [self] =>
      let* self := M.alloc self in
      let* α0 : Ty.apply (Ty.path "contract_transfer::AccountId") [] :=
        match_operator
          (DeclaredButUndefinedVariable
            (A :=
              Ty.apply
                (Ty.path "core::clone::AssertParamIsClone")
                [Ty.path "u128"]))
          [
            fun γ =>
              (let* α0 :
                  Ty.apply
                    (Ty.path "ref")
                    [Ty.apply (Ty.path "contract_transfer::AccountId") []] :=
                M.read self in
              M.pure (deref α0)) :
              Ty.apply (Ty.path "contract_transfer::AccountId") []
          ] in
      M.read α0
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_clone : Instance.t := {
    Notations.double_colon := clone;
  }.
  
  Definition ℐ : Instance.t := [("clone", clone); ("clone_from", clone_from)].
End Impl_core_clone_Clone_for_contract_transfer_AccountId.
End Impl_core_clone_Clone_for_contract_transfer_AccountId.

Module  Impl_core_marker_Copy_for_contract_transfer_AccountId.
Section Impl_core_marker_Copy_for_contract_transfer_AccountId.
  Definition Self : Ty.t :=
    Ty.apply (Ty.path "contract_transfer::AccountId") [].
  
  Definition ℐ : Instance.t := [].
End Impl_core_marker_Copy_for_contract_transfer_AccountId.
End Impl_core_marker_Copy_for_contract_transfer_AccountId.

Axiom Balance : Ty.path "u128".



Module  Impl_contract_transfer_Env.
Section Impl_contract_transfer_Env.
  Definition Self : Set := Ty.apply (Ty.path "contract_transfer::Env") [].
  
  (*
      fn caller(&self) -> AccountId {
          self.caller
      }
  *)
  Definition caller (𝜏 : list Ty.t) (α : list Value.t) : M :=
    match 𝜏, α with
    | [], [self] =>
      let* self := M.alloc self in
      let* α0 :
          Ty.apply
            (Ty.path "ref")
            [Ty.apply (Ty.path "contract_transfer::Env") []] :=
        M.read self in
      M.read (contract_transfer.Env.Get_caller (deref α0))
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_caller : Instance.t := {
    Notations.double_colon := caller;
  }.
  
  (*
      fn balance(&self) -> Balance {
          unimplemented!()
      }
  *)
  Definition balance (𝜏 : list Ty.t) (α : list Value.t) : M :=
    match 𝜏, α with
    | [], [self] =>
      let* self := M.alloc self in
      let* α0 : Ty.apply (Ty.path "ref") [Ty.path "str"] :=
        M.read (mk_str "not implemented") in
      let* α1 : Ty.path "never" := M.call (core.panicking.panic α0) in
      never_to_any α1
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_balance : Instance.t := {
    Notations.double_colon := balance;
  }.
  
  (*
      fn transfer(&mut self, _to: AccountId, _value: Balance) -> Result<(), ()> {
          unimplemented!()
      }
  *)
  Definition transfer (𝜏 : list Ty.t) (α : list Value.t) : M :=
    match 𝜏, α with
    | [], [self; _to; _value] =>
      let* self := M.alloc self in
      let* _to := M.alloc _to in
      let* _value := M.alloc _value in
      let* α0 : Ty.apply (Ty.path "ref") [Ty.path "str"] :=
        M.read (mk_str "not implemented") in
      let* α1 : Ty.path "never" := M.call (core.panicking.panic α0) in
      never_to_any α1
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_transfer : Instance.t := {
    Notations.double_colon := transfer;
  }.
  
  (*
      fn transferred_value(&self) -> Balance {
          unimplemented!()
      }
  *)
  Definition transferred_value (𝜏 : list Ty.t) (α : list Value.t) : M :=
    match 𝜏, α with
    | [], [self] =>
      let* self := M.alloc self in
      let* α0 : Ty.apply (Ty.path "ref") [Ty.path "str"] :=
        M.read (mk_str "not implemented") in
      let* α1 : Ty.path "never" := M.call (core.panicking.panic α0) in
      never_to_any α1
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_transferred_value : Instance.t := {
    Notations.double_colon := transferred_value;
  }.
End Impl_contract_transfer_Env.
End Impl_contract_transfer_Env.



Module  Impl_contract_transfer_GiveMe.
Section Impl_contract_transfer_GiveMe.
  Definition Self : Set := Ty.apply (Ty.path "contract_transfer::GiveMe") [].
  
  (*
      fn init_env() -> Env {
          unimplemented!()
      }
  *)
  Definition init_env (𝜏 : list Ty.t) (α : list Value.t) : M :=
    match 𝜏, α with
    | [], [] =>
      let* α0 : Ty.apply (Ty.path "ref") [Ty.path "str"] :=
        M.read (mk_str "not implemented") in
      let* α1 : Ty.path "never" := M.call (core.panicking.panic α0) in
      never_to_any α1
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_init_env : Instance.t := {
    Notations.double_colon := init_env;
  }.
  
  (*
      fn env(&self) -> Env {
          Self::init_env()
      }
  *)
  Definition env (𝜏 : list Ty.t) (α : list Value.t) : M :=
    match 𝜏, α with
    | [], [self] =>
      let* self := M.alloc self in
      M.call (Ty.apply (Ty.path "contract_transfer::GiveMe") [])::["init_env"]
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_env : Instance.t := {
    Notations.double_colon := env;
  }.
  
  (*
      pub fn new() -> Self {
          Self {}
      }
  *)
  Definition new (𝜏 : list Ty.t) (α : list Value.t) : M :=
    match 𝜏, α with
    | [], [] => M.pure contract_transfer.GiveMe.Build
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_new : Instance.t := {
    Notations.double_colon := new;
  }.
  
  (*
      pub fn give_me(&mut self, value: Balance) {
          println!("requested value: {}", value);
          println!("contract balance: {}", self.env().balance());
  
          assert!(value <= self.env().balance(), "insufficient funds!");
  
          if self.env().transfer(self.env().caller(), value).is_err() {
              panic!(
                  "requested transfer failed. this can be the case if the contract does not\
                   have sufficient free funds or if the transfer would have brought the\
                   contract's balance below minimum balance."
              )
          }
      }
  *)
  Definition give_me (𝜏 : list Ty.t) (α : list Value.t) : M :=
    match 𝜏, α with
    | [], [self; value] =>
      let* self := M.alloc self in
      let* value := M.alloc value in
      let* _ : Ty.tuple :=
        let* _ : Ty.tuple :=
          let* α0 : Ty.apply (Ty.path "ref") [Ty.path "str"] :=
            M.read (mk_str "requested value: ") in
          let* α1 : Ty.apply (Ty.path "ref") [Ty.path "str"] :=
            M.read (mk_str "
") in
          let* α2 :
              Ty.apply
                (Ty.path "array")
                [Ty.apply (Ty.path "ref") [Ty.path "str"]] :=
            M.alloc [ α0; α1 ] in
          let* α3 : Ty.apply (Ty.path "core::fmt::rt::Argument") [] :=
            M.call
              ((Ty.apply
                    (Ty.path "core::fmt::rt::Argument")
                    [])::["new_display"]
                (borrow value)) in
          let* α4 :
              Ty.apply
                (Ty.path "array")
                [Ty.apply (Ty.path "core::fmt::rt::Argument") []] :=
            M.alloc [ α3 ] in
          let* α5 : Ty.apply (Ty.path "core::fmt::Arguments") [] :=
            M.call
              ((Ty.apply (Ty.path "core::fmt::Arguments") [])::["new_v1"]
                (pointer_coercion "Unsize" (borrow α2))
                (pointer_coercion "Unsize" (borrow α4))) in
          let* α6 : Ty.tuple := M.call (std.io.stdio._print α5) in
          M.alloc α6 in
        M.alloc tt in
      let* _ : Ty.tuple :=
        let* _ : Ty.tuple :=
          let* α0 : Ty.apply (Ty.path "ref") [Ty.path "str"] :=
            M.read (mk_str "contract balance: ") in
          let* α1 : Ty.apply (Ty.path "ref") [Ty.path "str"] :=
            M.read (mk_str "
") in
          let* α2 :
              Ty.apply
                (Ty.path "array")
                [Ty.apply (Ty.path "ref") [Ty.path "str"]] :=
            M.alloc [ α0; α1 ] in
          let* α3 :
              Ty.apply
                (Ty.path "mut_ref")
                [Ty.apply (Ty.path "contract_transfer::GiveMe") []] :=
            M.read self in
          let* α4 : Ty.apply (Ty.path "contract_transfer::Env") [] :=
            M.call
              ((Ty.apply (Ty.path "contract_transfer::GiveMe") [])::["env"]
                (borrow (deref α3))) in
          let* α5 : Ty.apply (Ty.path "contract_transfer::Env") [] :=
            M.alloc α4 in
          let* α6 : Ty.path "u128" :=
            M.call
              ((Ty.apply (Ty.path "contract_transfer::Env") [])::["balance"]
                (borrow α5)) in
          let* α7 : Ty.path "u128" := M.alloc α6 in
          let* α8 : Ty.apply (Ty.path "core::fmt::rt::Argument") [] :=
            M.call
              ((Ty.apply
                    (Ty.path "core::fmt::rt::Argument")
                    [])::["new_display"]
                (borrow α7)) in
          let* α9 :
              Ty.apply
                (Ty.path "array")
                [Ty.apply (Ty.path "core::fmt::rt::Argument") []] :=
            M.alloc [ α8 ] in
          let* α10 : Ty.apply (Ty.path "core::fmt::Arguments") [] :=
            M.call
              ((Ty.apply (Ty.path "core::fmt::Arguments") [])::["new_v1"]
                (pointer_coercion "Unsize" (borrow α2))
                (pointer_coercion "Unsize" (borrow α9))) in
          let* α11 : Ty.tuple := M.call (std.io.stdio._print α10) in
          M.alloc α11 in
        M.alloc tt in
      let* _ : Ty.tuple :=
        let* α0 : Ty.path "u128" := M.read value in
        let* α1 :
            Ty.apply
              (Ty.path "mut_ref")
              [Ty.apply (Ty.path "contract_transfer::GiveMe") []] :=
          M.read self in
        let* α2 : Ty.apply (Ty.path "contract_transfer::Env") [] :=
          M.call
            ((Ty.apply (Ty.path "contract_transfer::GiveMe") [])::["env"]
              (borrow (deref α1))) in
        let* α3 : Ty.apply (Ty.path "contract_transfer::Env") [] :=
          M.alloc α2 in
        let* α4 : Ty.path "u128" :=
          M.call
            ((Ty.apply (Ty.path "contract_transfer::Env") [])::["balance"]
              (borrow α3)) in
        let* α5 : Ty.path "bool" := M.alloc (UnOp.not (BinOp.Pure.le α0 α4)) in
        let* α6 : Ty.path "bool" := M.read (use α5) in
        if α6 then
          let* α0 : Ty.apply (Ty.path "ref") [Ty.path "str"] :=
            M.read (mk_str "insufficient funds!") in
          let* α1 : Ty.path "never" := M.call (std.panicking.begin_panic α0) in
          let* α2 : Ty.tuple := never_to_any α1 in
          M.alloc α2
        else
          M.alloc tt in
      let* α0 :
          Ty.apply
            (Ty.path "mut_ref")
            [Ty.apply (Ty.path "contract_transfer::GiveMe") []] :=
        M.read self in
      let* α1 : Ty.apply (Ty.path "contract_transfer::Env") [] :=
        M.call
          ((Ty.apply (Ty.path "contract_transfer::GiveMe") [])::["env"]
            (borrow (deref α0))) in
      let* α2 : Ty.apply (Ty.path "contract_transfer::Env") [] := M.alloc α1 in
      let* α3 :
          Ty.apply
            (Ty.path "mut_ref")
            [Ty.apply (Ty.path "contract_transfer::GiveMe") []] :=
        M.read self in
      let* α4 : Ty.apply (Ty.path "contract_transfer::Env") [] :=
        M.call
          ((Ty.apply (Ty.path "contract_transfer::GiveMe") [])::["env"]
            (borrow (deref α3))) in
      let* α5 : Ty.apply (Ty.path "contract_transfer::Env") [] := M.alloc α4 in
      let* α6 : Ty.apply (Ty.path "contract_transfer::AccountId") [] :=
        M.call
          ((Ty.apply (Ty.path "contract_transfer::Env") [])::["caller"]
            (borrow α5)) in
      let* α7 : Ty.path "u128" := M.read value in
      let* α8 :
          Ty.apply (Ty.path "core::result::Result") [Ty.tuple; Ty.tuple] :=
        M.call
          ((Ty.apply (Ty.path "contract_transfer::Env") [])::["transfer"]
            (borrow_mut α2)
            α6
            α7) in
      let* α9 :
          Ty.apply (Ty.path "core::result::Result") [Ty.tuple; Ty.tuple] :=
        M.alloc α8 in
      let* α10 : Ty.path "bool" :=
        M.call
          ((Ty.apply
                (Ty.path "core::result::Result")
                [Ty.tuple; Ty.tuple])::["is_err"]
            (borrow α9)) in
      let* α11 : Ty.path "bool" := M.alloc α10 in
      let* α12 : Ty.path "bool" := M.read (use α11) in
      let* α0 : Ty.tuple :=
        if α12 then
          let* α0 : Ty.apply (Ty.path "ref") [Ty.path "str"] :=
            M.read
              (mk_str
                "requested transfer failed. this can be the case if the contract does nothave sufficient free funds or if the transfer would have brought thecontract's balance below minimum balance.") in
          let* α1 : Ty.path "never" := M.call (std.panicking.begin_panic α0) in
          let* α2 : Ty.tuple := never_to_any α1 in
          M.alloc α2
        else
          M.alloc tt in
      M.read α0
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_give_me : Instance.t := {
    Notations.double_colon := give_me;
  }.
  
  (*
      pub fn was_it_ten(&self) {
          println!("received payment: {}", self.env().transferred_value());
          assert!(self.env().transferred_value() == 10, "payment was not ten");
      }
  *)
  Definition was_it_ten (𝜏 : list Ty.t) (α : list Value.t) : M :=
    match 𝜏, α with
    | [], [self] =>
      let* self := M.alloc self in
      let* _ : Ty.tuple :=
        let* _ : Ty.tuple :=
          let* α0 : Ty.apply (Ty.path "ref") [Ty.path "str"] :=
            M.read (mk_str "received payment: ") in
          let* α1 : Ty.apply (Ty.path "ref") [Ty.path "str"] :=
            M.read (mk_str "
") in
          let* α2 :
              Ty.apply
                (Ty.path "array")
                [Ty.apply (Ty.path "ref") [Ty.path "str"]] :=
            M.alloc [ α0; α1 ] in
          let* α3 :
              Ty.apply
                (Ty.path "ref")
                [Ty.apply (Ty.path "contract_transfer::GiveMe") []] :=
            M.read self in
          let* α4 : Ty.apply (Ty.path "contract_transfer::Env") [] :=
            M.call
              ((Ty.apply (Ty.path "contract_transfer::GiveMe") [])::["env"]
                α3) in
          let* α5 : Ty.apply (Ty.path "contract_transfer::Env") [] :=
            M.alloc α4 in
          let* α6 : Ty.path "u128" :=
            M.call
              ((Ty.apply
                    (Ty.path "contract_transfer::Env")
                    [])::["transferred_value"]
                (borrow α5)) in
          let* α7 : Ty.path "u128" := M.alloc α6 in
          let* α8 : Ty.apply (Ty.path "core::fmt::rt::Argument") [] :=
            M.call
              ((Ty.apply
                    (Ty.path "core::fmt::rt::Argument")
                    [])::["new_display"]
                (borrow α7)) in
          let* α9 :
              Ty.apply
                (Ty.path "array")
                [Ty.apply (Ty.path "core::fmt::rt::Argument") []] :=
            M.alloc [ α8 ] in
          let* α10 : Ty.apply (Ty.path "core::fmt::Arguments") [] :=
            M.call
              ((Ty.apply (Ty.path "core::fmt::Arguments") [])::["new_v1"]
                (pointer_coercion "Unsize" (borrow α2))
                (pointer_coercion "Unsize" (borrow α9))) in
          let* α11 : Ty.tuple := M.call (std.io.stdio._print α10) in
          M.alloc α11 in
        M.alloc tt in
      let* _ : Ty.tuple :=
        let* α0 :
            Ty.apply
              (Ty.path "ref")
              [Ty.apply (Ty.path "contract_transfer::GiveMe") []] :=
          M.read self in
        let* α1 : Ty.apply (Ty.path "contract_transfer::Env") [] :=
          M.call
            ((Ty.apply (Ty.path "contract_transfer::GiveMe") [])::["env"] α0) in
        let* α2 : Ty.apply (Ty.path "contract_transfer::Env") [] :=
          M.alloc α1 in
        let* α3 : Ty.path "u128" :=
          M.call
            ((Ty.apply
                  (Ty.path "contract_transfer::Env")
                  [])::["transferred_value"]
              (borrow α2)) in
        let* α4 : Ty.path "bool" :=
          M.alloc
            (UnOp.not
              (BinOp.Pure.eq α3 ((Integer.of_Z 10) : Ty.path "u128"))) in
        let* α5 : Ty.path "bool" := M.read (use α4) in
        if α5 then
          let* α0 : Ty.apply (Ty.path "ref") [Ty.path "str"] :=
            M.read (mk_str "payment was not ten") in
          let* α1 : Ty.path "never" := M.call (std.panicking.begin_panic α0) in
          let* α2 : Ty.tuple := never_to_any α1 in
          M.alloc α2
        else
          M.alloc tt in
      let* α0 : Ty.path "unit" := M.alloc tt in
      M.read α0
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_was_it_ten : Instance.t := {
    Notations.double_colon := was_it_ten;
  }.
End Impl_contract_transfer_GiveMe.
End Impl_contract_transfer_GiveMe.
