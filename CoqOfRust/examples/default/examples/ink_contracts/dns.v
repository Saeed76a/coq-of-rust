(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

(* Enum Mapping *)

Module Impl_core_default_Default_for_dns_Mapping_K_V.
  Definition Self (K V : Ty.t) : Ty.t :=
    Ty.apply (Ty.path "dns::Mapping") [K; V].
  
  (*
  Default
  *)
  Definition default (𝜏 : list Ty.t) (α : list Value.t) : M :=
    match 𝜏, α with
    | [], [] =>
      let* α0 :=
        ltac:(M.get_method (fun ℐ =>
          core.default.Default.default
            (Self := Ty.apply (Ty.path "core::marker::PhantomData") [K])
            (Trait := ℐ))) in
      let* α1 := M.call α0 in
      let* α2 :=
        ltac:(M.get_method (fun ℐ =>
          core.default.Default.default
            (Self := Ty.apply (Ty.path "core::marker::PhantomData") [V])
            (Trait := ℐ))) in
      let* α3 := M.call α2 in
      M.pure {| dns.Mapping._key := α1; dns.Mapping._value := α3; |}
    | _, _ => M.impossible
    end.
  
  Definition ℐ (K V : Ty.t) : Instance.t :=
    [("default", InstanceField.Method (default K V))].
End Impl_core_default_Default_for_dns_Mapping_K_V.

Module Impl_dns_Mapping_K_V.
  Definition Self (K V : Ty.t) : Ty.t :=
    Ty.apply (Ty.path "dns::Mapping") [K; V].
  
  (*
      fn contains(&self, _key: &K) -> bool {
          unimplemented!()
      }
  *)
  Definition contains (𝜏 : list Ty.t) (α : list Value.t) : M :=
    match 𝜏, α with
    | [], [self; _key] =>
      let* self := M.alloc self in
      let* _key := M.alloc _key in
      let* α0 := M.read (mk_str "not implemented") in
      let* α1 := M.call ((M.var "core::panicking::panic") α0) in
      never_to_any α1
    | _, _ => M.impossible
    end.
  
  (*
      fn get(&self, _key: &K) -> Option<V> {
          unimplemented!()
      }
  *)
  Definition get (𝜏 : list Ty.t) (α : list Value.t) : M :=
    match 𝜏, α with
    | [], [self; _key] =>
      let* self := M.alloc self in
      let* _key := M.alloc _key in
      let* α0 := M.read (mk_str "not implemented") in
      let* α1 := M.call ((M.var "core::panicking::panic") α0) in
      never_to_any α1
    | _, _ => M.impossible
    end.
  
  (*
      fn insert(&mut self, _key: K, _value: V) -> Option<u32> {
          unimplemented!()
      }
  *)
  Definition insert (𝜏 : list Ty.t) (α : list Value.t) : M :=
    match 𝜏, α with
    | [], [self; _key; _value] =>
      let* self := M.alloc self in
      let* _key := M.alloc _key in
      let* _value := M.alloc _value in
      let* α0 := M.read (mk_str "not implemented") in
      let* α1 := M.call ((M.var "core::panicking::panic") α0) in
      never_to_any α1
    | _, _ => M.impossible
    end.
  
  (*
      fn new() -> Mapping<K, V> {
          unimplemented!()
      }
  *)
  Definition new (𝜏 : list Ty.t) (α : list Value.t) : M :=
    match 𝜏, α with
    | [], [] =>
      let* α0 := M.read (mk_str "not implemented") in
      let* α1 := M.call ((M.var "core::panicking::panic") α0) in
      never_to_any α1
    | _, _ => M.impossible
    end.
  
  (*
      fn remove(&self, _key: K) {
          unimplemented!()
      }
  *)
  Definition remove (𝜏 : list Ty.t) (α : list Value.t) : M :=
    match 𝜏, α with
    | [], [self; _key] =>
      let* self := M.alloc self in
      let* _key := M.alloc _key in
      let* α0 := M.read (mk_str "not implemented") in
      let* α1 := M.call ((M.var "core::panicking::panic") α0) in
      never_to_any α1
    | _, _ => M.impossible
    end.
  
  (*
      fn size(&self, _key: K) -> Option<u32> {
          unimplemented!()
      }
  *)
  Definition size (𝜏 : list Ty.t) (α : list Value.t) : M :=
    match 𝜏, α with
    | [], [self; _key] =>
      let* self := M.alloc self in
      let* _key := M.alloc _key in
      let* α0 := M.read (mk_str "not implemented") in
      let* α1 := M.call ((M.var "core::panicking::panic") α0) in
      never_to_any α1
    | _, _ => M.impossible
    end.
  
  (*
      fn take(&self, _key: K) -> Option<V> {
          unimplemented!()
      }
  *)
  Definition take (𝜏 : list Ty.t) (α : list Value.t) : M :=
    match 𝜏, α with
    | [], [self; _key] =>
      let* self := M.alloc self in
      let* _key := M.alloc _key in
      let* α0 := M.read (mk_str "not implemented") in
      let* α1 := M.call ((M.var "core::panicking::panic") α0) in
      never_to_any α1
    | _, _ => M.impossible
    end.
End Impl_dns_Mapping_K_V.

(* Struct AccountId *)

Module Impl_core_default_Default_for_dns_AccountId.
  Definition Self : Ty.t := Ty.path "dns::AccountId".
  
  (*
  Default
  *)
  Definition default (𝜏 : list Ty.t) (α : list Value.t) : M :=
    match 𝜏, α with
    | [], [] =>
      let* α0 :=
        ltac:(M.get_method (fun ℐ =>
          core.default.Default.default
            (Self := Ty.path "u128")
            (Trait := ℐ))) in
      let* α1 := M.call α0 in
      M.pure (dns.AccountId.Build_t α1)
    | _, _ => M.impossible
    end.
  
  Definition ℐ : Instance.t := [("default", InstanceField.Method default)].
End Impl_core_default_Default_for_dns_AccountId.

Module Impl_core_clone_Clone_for_dns_AccountId.
  Definition Self : Ty.t := Ty.path "dns::AccountId".
  
  (*
  Clone
  *)
  Definition clone (𝜏 : list Ty.t) (α : list Value.t) : M :=
    match 𝜏, α with
    | [], [self] =>
      let* self := M.alloc self in
      let* α0 :=
        match_operator
          (DeclaredButUndefinedVariable
            (A :=
              Ty.apply
                (Ty.path "core::clone::AssertParamIsClone")
                [Ty.path "u128"]))
          [
            fun γ =>
              (let* α0 := M.read self in
              M.pure (deref α0)) :
              Ty.path "dns::AccountId"
          ] in
      M.read α0
    | _, _ => M.impossible
    end.
  
  Definition ℐ : Instance.t := [("clone", InstanceField.Method clone)].
End Impl_core_clone_Clone_for_dns_AccountId.

Module Impl_core_marker_Copy_for_dns_AccountId.
  Definition Self : Ty.t := Ty.path "dns::AccountId".
  
  Definition ℐ : Instance.t := [].
End Impl_core_marker_Copy_for_dns_AccountId.

Module Impl_core_marker_StructuralPartialEq_for_dns_AccountId.
  Definition Self : Ty.t := Ty.path "dns::AccountId".
  
  Definition ℐ : Instance.t := [].
End Impl_core_marker_StructuralPartialEq_for_dns_AccountId.

Module Impl_core_cmp_PartialEq_for_dns_AccountId.
  Definition Self : Ty.t := Ty.path "dns::AccountId".
  
  (*
  PartialEq
  *)
  Definition eq (𝜏 : list Ty.t) (α : list Value.t) : M :=
    match 𝜏, α with
    | [], [self; other] =>
      let* self := M.alloc self in
      let* other := M.alloc other in
      let* α0 := M.read self in
      let* α1 := M.read ((M.var "dns::AccountId::Get_0") (deref α0)) in
      let* α2 := M.read other in
      let* α3 := M.read ((M.var "dns::AccountId::Get_0") (deref α2)) in
      M.pure ((M.var "BinOp::Pure::eq") α1 α3)
    | _, _ => M.impossible
    end.
  
  Definition ℐ : Instance.t := [("eq", InstanceField.Method eq)].
End Impl_core_cmp_PartialEq_for_dns_AccountId.

Module Impl_core_convert_From_array_u8_for_dns_AccountId.
  Definition Self : Ty.t := Ty.path "dns::AccountId".
  
  (*
      fn from(_value: [u8; 32]) -> Self {
          unimplemented!()
      }
  *)
  Definition from (𝜏 : list Ty.t) (α : list Value.t) : M :=
    match 𝜏, α with
    | [], [_value] =>
      let* _value := M.alloc _value in
      let* α0 := M.read (mk_str "not implemented") in
      let* α1 := M.call ((M.var "core::panicking::panic") α0) in
      never_to_any α1
    | _, _ => M.impossible
    end.
  
  Definition ℐ : Instance.t := [("from", InstanceField.Method from)].
End Impl_core_convert_From_array_u8_for_dns_AccountId.

Axiom Balance : (Ty.path "dns::Balance") = (Ty.path "u128").

Axiom Hash :
  (Ty.path "dns::Hash") = (Ty.apply (Ty.path "array") [Ty.path "u8"]).

(* Enum Env *)

(* Enum Register *)

(* Enum SetAddress *)

(* Enum Transfer *)

(* Enum Event *)

Module Impl_dns_Env.
  Definition Self : Ty.t := Ty.path "dns::Env".
  
  (*
      fn caller(&self) -> AccountId {
          self.caller
      }
  *)
  Definition caller (𝜏 : list Ty.t) (α : list Value.t) : M :=
    match 𝜏, α with
    | [], [self] =>
      let* self := M.alloc self in
      let* α0 := M.read self in
      M.read ((M.var "dns::Env::Get_caller") (deref α0))
    | _, _ => M.impossible
    end.
  
  (*
      fn emit_event(&self, _event: Event) {
          unimplemented!()
      }
  *)
  Definition emit_event (𝜏 : list Ty.t) (α : list Value.t) : M :=
    match 𝜏, α with
    | [], [self; _event] =>
      let* self := M.alloc self in
      let* _event := M.alloc _event in
      let* α0 := M.read (mk_str "not implemented") in
      let* α1 := M.call ((M.var "core::panicking::panic") α0) in
      never_to_any α1
    | _, _ => M.impossible
    end.
End Impl_dns_Env.

(* Enum DomainNameService *)

(*
fn zero_address() -> AccountId {
    [0u8; 32].into()
}
*)
Definition zero_address (𝜏 : list Ty.t) (α : list Value.t) : M :=
  match 𝜏, α with
  | [], [] =>
    let* α0 :=
      ltac:(M.get_method (fun ℐ =>
        core.convert.Into.into
          (Self := Ty.apply (Ty.path "array") [Ty.path "u8"])
          (T := Ty.path "dns::AccountId")
          (Trait := ℐ))) in
    M.call (α0 (repeat ((Integer.of_Z 0) : Ty.path "u8") 32))
  | _, _ => M.impossible
  end.

Module Impl_core_default_Default_for_dns_DomainNameService.
  Definition Self : Ty.t := Ty.path "dns::DomainNameService".
  
  (*
      fn default() -> Self {
          let mut name_to_address = Mapping::new();
          name_to_address.insert(Hash::default(), zero_address());
          let mut name_to_owner = Mapping::new();
          name_to_owner.insert(Hash::default(), zero_address());
  
          Self {
              name_to_address,
              name_to_owner,
              default_address: zero_address(),
          }
      }
  *)
  Definition default (𝜏 : list Ty.t) (α : list Value.t) : M :=
    match 𝜏, α with
    | [], [] =>
      let* name_to_address :=
        let* α0 :=
          M.call
            (Ty.apply
                (Ty.path "dns::Mapping")
                [Ty.apply (Ty.path "array") [Ty.path "u8"];
                  Ty.path "dns::AccountId"])::["new"] in
        M.alloc α0 in
      let* _ :=
        let* α0 :=
          ltac:(M.get_method (fun ℐ =>
            core.default.Default.default
              (Self := Ty.apply (Ty.path "array") [Ty.path "u8"])
              (Trait := ℐ))) in
        let* α1 := M.call α0 in
        let* α2 := M.call (M.var "dns::zero_address") in
        let* α3 :=
          M.call
            ((Ty.apply
                  (Ty.path "dns::Mapping")
                  [Ty.apply (Ty.path "array") [Ty.path "u8"];
                    Ty.path "dns::AccountId"])::["insert"]
              (borrow_mut name_to_address)
              α1
              α2) in
        M.alloc α3 in
      let* name_to_owner :=
        let* α0 :=
          M.call
            (Ty.apply
                (Ty.path "dns::Mapping")
                [Ty.apply (Ty.path "array") [Ty.path "u8"];
                  Ty.path "dns::AccountId"])::["new"] in
        M.alloc α0 in
      let* _ :=
        let* α0 :=
          ltac:(M.get_method (fun ℐ =>
            core.default.Default.default
              (Self := Ty.apply (Ty.path "array") [Ty.path "u8"])
              (Trait := ℐ))) in
        let* α1 := M.call α0 in
        let* α2 := M.call (M.var "dns::zero_address") in
        let* α3 :=
          M.call
            ((Ty.apply
                  (Ty.path "dns::Mapping")
                  [Ty.apply (Ty.path "array") [Ty.path "u8"];
                    Ty.path "dns::AccountId"])::["insert"]
              (borrow_mut name_to_owner)
              α1
              α2) in
        M.alloc α3 in
      let* α0 := M.read name_to_address in
      let* α1 := M.read name_to_owner in
      let* α2 := M.call (M.var "dns::zero_address") in
      let* α0 :=
        M.alloc
          {|
            dns.DomainNameService.name_to_address := α0;
            dns.DomainNameService.name_to_owner := α1;
            dns.DomainNameService.default_address := α2;
          |} in
      M.read α0
    | _, _ => M.impossible
    end.
  
  Definition ℐ : Instance.t := [("default", InstanceField.Method default)].
End Impl_core_default_Default_for_dns_DomainNameService.

(* Enum Error *)

Module Impl_core_marker_StructuralPartialEq_for_dns_Error.
  Definition Self : Ty.t := Ty.path "dns::Error".
  
  Definition ℐ : Instance.t := [].
End Impl_core_marker_StructuralPartialEq_for_dns_Error.

Module Impl_core_cmp_PartialEq_for_dns_Error.
  Definition Self : Ty.t := Ty.path "dns::Error".
  
  (*
  PartialEq
  *)
  Definition eq (𝜏 : list Ty.t) (α : list Value.t) : M :=
    match 𝜏, α with
    | [], [self; other] =>
      let* self := M.alloc self in
      let* other := M.alloc other in
      let* __self_tag :=
        let* α0 := M.read self in
        let* α1 := M.call ((M.var "core::intrinsics::discriminant_value") α0) in
        M.alloc α1 in
      let* __arg1_tag :=
        let* α0 := M.read other in
        let* α1 := M.call ((M.var "core::intrinsics::discriminant_value") α0) in
        M.alloc α1 in
      let* α0 := M.read __self_tag in
      let* α1 := M.read __arg1_tag in
      let* α0 := M.alloc ((M.var "BinOp::Pure::eq") α0 α1) in
      M.read α0
    | _, _ => M.impossible
    end.
  
  Definition ℐ : Instance.t := [("eq", InstanceField.Method eq)].
End Impl_core_cmp_PartialEq_for_dns_Error.

Module Impl_core_marker_StructuralEq_for_dns_Error.
  Definition Self : Ty.t := Ty.path "dns::Error".
  
  Definition ℐ : Instance.t := [].
End Impl_core_marker_StructuralEq_for_dns_Error.

Module Impl_core_cmp_Eq_for_dns_Error.
  Definition Self : Ty.t := Ty.path "dns::Error".
  
  (*
  Eq
  *)
  Definition assert_receiver_is_total_eq
      (𝜏 : list Ty.t)
      (α : list Value.t)
      : M :=
    match 𝜏, α with
    | [], [self] =>
      let* self := M.alloc self in
      M.pure tt
    | _, _ => M.impossible
    end.
  
  Definition ℐ : Instance.t :=
    [("assert_receiver_is_total_eq",
        InstanceField.Method assert_receiver_is_total_eq)].
End Impl_core_cmp_Eq_for_dns_Error.

Axiom Result :
  forall (T : Ty.t),
  (Ty.path "dns::Result") =
    (Ty.apply (Ty.path "core::result::Result") [T; Ty.path "dns::Error"]).

Module Impl_dns_DomainNameService.
  Definition Self : Ty.t := Ty.path "dns::DomainNameService".
  
  (*
      fn init_env() -> Env {
          unimplemented!()
      }
  *)
  Definition init_env (𝜏 : list Ty.t) (α : list Value.t) : M :=
    match 𝜏, α with
    | [], [] =>
      let* α0 := M.read (mk_str "not implemented") in
      let* α1 := M.call ((M.var "core::panicking::panic") α0) in
      never_to_any α1
    | _, _ => M.impossible
    end.
  
  (*
      fn env(&self) -> Env {
          Self::init_env()
      }
  *)
  Definition env (𝜏 : list Ty.t) (α : list Value.t) : M :=
    match 𝜏, α with
    | [], [self] =>
      let* self := M.alloc self in
      M.call (Ty.path "dns::DomainNameService")::["init_env"]
    | _, _ => M.impossible
    end.
  
  (*
      pub fn new() -> Self {
          Default::default()
      }
  *)
  Definition new (𝜏 : list Ty.t) (α : list Value.t) : M :=
    match 𝜏, α with
    | [], [] =>
      let* α0 :=
        ltac:(M.get_method (fun ℐ =>
          core.default.Default.default
            (Self := Ty.path "dns::DomainNameService")
            (Trait := ℐ))) in
      M.call α0
    | _, _ => M.impossible
    end.
  
  (*
      pub fn register(&mut self, name: Hash) -> Result<()> {
          let caller = self.env().caller();
          if self.name_to_owner.contains(&name) {
              return Err(Error::NameAlreadyExists);
          }
  
          self.name_to_owner.insert(name, caller);
          self.env()
              .emit_event(Event::Register(Register { name, from: caller }));
  
          Ok(())
      }
  *)
  Definition register (𝜏 : list Ty.t) (α : list Value.t) : M :=
    match 𝜏, α with
    | [], [self; name] =>
      let* self := M.alloc self in
      let* name := M.alloc name in
      let return_ :=
        M.return_
          (R :=
            Ty.apply
              (Ty.path "core::result::Result")
              [Ty.tuple []; Ty.path "dns::Error"]) in
      M.catch_return
        (let* caller :=
          let* α0 := M.read self in
          let* α1 :=
            M.call
              ((Ty.path "dns::DomainNameService")::["env"]
                (borrow (deref α0))) in
          let* α2 := M.alloc α1 in
          let* α3 := M.call ((Ty.path "dns::Env")::["caller"] (borrow α2)) in
          M.alloc α3 in
        let* _ :=
          let* α0 := M.read self in
          let* α1 :=
            M.call
              ((Ty.apply
                    (Ty.path "dns::Mapping")
                    [Ty.apply (Ty.path "array") [Ty.path "u8"];
                      Ty.path "dns::AccountId"])::["contains"]
                (borrow
                  ((M.var "dns::DomainNameService::Get_name_to_owner")
                    (deref α0)))
                (borrow name)) in
          let* α2 := M.alloc α1 in
          let* α3 := M.read (use α2) in
          if α3 then
            let* α0 :=
              return_ (core.result.Result.Err dns.Error.NameAlreadyExists) in
            let* α1 := M.read α0 in
            let* α2 := never_to_any α1 in
            M.alloc α2
          else
            M.alloc tt in
        let* _ :=
          let* α0 := M.read self in
          let* α1 := M.read name in
          let* α2 := M.read caller in
          let* α3 :=
            M.call
              ((Ty.apply
                    (Ty.path "dns::Mapping")
                    [Ty.apply (Ty.path "array") [Ty.path "u8"];
                      Ty.path "dns::AccountId"])::["insert"]
                (borrow_mut
                  ((M.var "dns::DomainNameService::Get_name_to_owner")
                    (deref α0)))
                α1
                α2) in
          M.alloc α3 in
        let* _ :=
          let* α0 := M.read self in
          let* α1 :=
            M.call
              ((Ty.path "dns::DomainNameService")::["env"]
                (borrow (deref α0))) in
          let* α2 := M.alloc α1 in
          let* α3 := M.read name in
          let* α4 := M.read caller in
          let* α5 :=
            M.call
              ((Ty.path "dns::Env")::["emit_event"]
                (borrow α2)
                (dns.Event.Register
                  {| dns.Register.name := α3; dns.Register.from := α4; |})) in
          M.alloc α5 in
        let* α0 := M.alloc (core.result.Result.Ok tt) in
        M.read α0)
    | _, _ => M.impossible
    end.
  
  (*
      fn get_owner_or_default(&self, name: Hash) -> AccountId {
          self.name_to_owner
              .get(&name)
              .unwrap_or(self.default_address)
      }
  *)
  Definition get_owner_or_default (𝜏 : list Ty.t) (α : list Value.t) : M :=
    match 𝜏, α with
    | [], [self; name] =>
      let* self := M.alloc self in
      let* name := M.alloc name in
      let* α0 := M.read self in
      let* α1 :=
        M.call
          ((Ty.apply
                (Ty.path "dns::Mapping")
                [Ty.apply (Ty.path "array") [Ty.path "u8"];
                  Ty.path "dns::AccountId"])::["get"]
            (borrow
              ((M.var "dns::DomainNameService::Get_name_to_owner") (deref α0)))
            (borrow name)) in
      let* α2 := M.read self in
      let* α3 :=
        M.read
          ((M.var "dns::DomainNameService::Get_default_address") (deref α2)) in
      M.call
        ((Ty.apply
              (Ty.path "core::option::Option")
              [Ty.path "dns::AccountId"])::["unwrap_or"]
          α1
          α3)
    | _, _ => M.impossible
    end.
  
  (*
      pub fn set_address(&mut self, name: Hash, new_address: AccountId) -> Result<()> {
          let caller = self.env().caller();
          let owner = self.get_owner_or_default(name);
          if caller != owner {
              return Err(Error::CallerIsNotOwner);
          }
  
          let old_address = self.name_to_address.get(&name);
          self.name_to_address.insert(name, new_address);
  
          self.env().emit_event(Event::SetAddress(SetAddress {
              name,
              from: caller,
              old_address,
              new_address,
          }));
          Ok(())
      }
  *)
  Definition set_address (𝜏 : list Ty.t) (α : list Value.t) : M :=
    match 𝜏, α with
    | [], [self; name; new_address] =>
      let* self := M.alloc self in
      let* name := M.alloc name in
      let* new_address := M.alloc new_address in
      let return_ :=
        M.return_
          (R :=
            Ty.apply
              (Ty.path "core::result::Result")
              [Ty.tuple []; Ty.path "dns::Error"]) in
      M.catch_return
        (let* caller :=
          let* α0 := M.read self in
          let* α1 :=
            M.call
              ((Ty.path "dns::DomainNameService")::["env"]
                (borrow (deref α0))) in
          let* α2 := M.alloc α1 in
          let* α3 := M.call ((Ty.path "dns::Env")::["caller"] (borrow α2)) in
          M.alloc α3 in
        let* owner :=
          let* α0 := M.read self in
          let* α1 := M.read name in
          let* α2 :=
            M.call
              ((Ty.path "dns::DomainNameService")::["get_owner_or_default"]
                (borrow (deref α0))
                α1) in
          M.alloc α2 in
        let* _ :=
          let* α0 :=
            ltac:(M.get_method (fun ℐ =>
              core.cmp.PartialEq.ne
                (Self := Ty.path "dns::AccountId")
                (Rhs := Ty.path "dns::AccountId")
                (Trait := ℐ))) in
          let* α1 := M.call (α0 (borrow caller) (borrow owner)) in
          let* α2 := M.alloc α1 in
          let* α3 := M.read (use α2) in
          if α3 then
            let* α0 :=
              return_ (core.result.Result.Err dns.Error.CallerIsNotOwner) in
            let* α1 := M.read α0 in
            let* α2 := never_to_any α1 in
            M.alloc α2
          else
            M.alloc tt in
        let* old_address :=
          let* α0 := M.read self in
          let* α1 :=
            M.call
              ((Ty.apply
                    (Ty.path "dns::Mapping")
                    [Ty.apply (Ty.path "array") [Ty.path "u8"];
                      Ty.path "dns::AccountId"])::["get"]
                (borrow
                  ((M.var "dns::DomainNameService::Get_name_to_address")
                    (deref α0)))
                (borrow name)) in
          M.alloc α1 in
        let* _ :=
          let* α0 := M.read self in
          let* α1 := M.read name in
          let* α2 := M.read new_address in
          let* α3 :=
            M.call
              ((Ty.apply
                    (Ty.path "dns::Mapping")
                    [Ty.apply (Ty.path "array") [Ty.path "u8"];
                      Ty.path "dns::AccountId"])::["insert"]
                (borrow_mut
                  ((M.var "dns::DomainNameService::Get_name_to_address")
                    (deref α0)))
                α1
                α2) in
          M.alloc α3 in
        let* _ :=
          let* α0 := M.read self in
          let* α1 :=
            M.call
              ((Ty.path "dns::DomainNameService")::["env"]
                (borrow (deref α0))) in
          let* α2 := M.alloc α1 in
          let* α3 := M.read name in
          let* α4 := M.read caller in
          let* α5 := M.read old_address in
          let* α6 := M.read new_address in
          let* α7 :=
            M.call
              ((Ty.path "dns::Env")::["emit_event"]
                (borrow α2)
                (dns.Event.SetAddress
                  {|
                    dns.SetAddress.name := α3;
                    dns.SetAddress.from := α4;
                    dns.SetAddress.old_address := α5;
                    dns.SetAddress.new_address := α6;
                  |})) in
          M.alloc α7 in
        let* α0 := M.alloc (core.result.Result.Ok tt) in
        M.read α0)
    | _, _ => M.impossible
    end.
  
  (*
      pub fn transfer(&mut self, name: Hash, to: AccountId) -> Result<()> {
          let caller = self.env().caller();
          let owner = self.get_owner_or_default(name);
          if caller != owner {
              return Err(Error::CallerIsNotOwner);
          }
  
          let old_owner = self.name_to_owner.get(&name);
          self.name_to_owner.insert(name, to);
  
          self.env().emit_event(Event::Transfer(Transfer {
              name,
              from: caller,
              old_owner,
              new_owner: to,
          }));
  
          Ok(())
      }
  *)
  Definition transfer (𝜏 : list Ty.t) (α : list Value.t) : M :=
    match 𝜏, α with
    | [], [self; name; to] =>
      let* self := M.alloc self in
      let* name := M.alloc name in
      let* to := M.alloc to in
      let return_ :=
        M.return_
          (R :=
            Ty.apply
              (Ty.path "core::result::Result")
              [Ty.tuple []; Ty.path "dns::Error"]) in
      M.catch_return
        (let* caller :=
          let* α0 := M.read self in
          let* α1 :=
            M.call
              ((Ty.path "dns::DomainNameService")::["env"]
                (borrow (deref α0))) in
          let* α2 := M.alloc α1 in
          let* α3 := M.call ((Ty.path "dns::Env")::["caller"] (borrow α2)) in
          M.alloc α3 in
        let* owner :=
          let* α0 := M.read self in
          let* α1 := M.read name in
          let* α2 :=
            M.call
              ((Ty.path "dns::DomainNameService")::["get_owner_or_default"]
                (borrow (deref α0))
                α1) in
          M.alloc α2 in
        let* _ :=
          let* α0 :=
            ltac:(M.get_method (fun ℐ =>
              core.cmp.PartialEq.ne
                (Self := Ty.path "dns::AccountId")
                (Rhs := Ty.path "dns::AccountId")
                (Trait := ℐ))) in
          let* α1 := M.call (α0 (borrow caller) (borrow owner)) in
          let* α2 := M.alloc α1 in
          let* α3 := M.read (use α2) in
          if α3 then
            let* α0 :=
              return_ (core.result.Result.Err dns.Error.CallerIsNotOwner) in
            let* α1 := M.read α0 in
            let* α2 := never_to_any α1 in
            M.alloc α2
          else
            M.alloc tt in
        let* old_owner :=
          let* α0 := M.read self in
          let* α1 :=
            M.call
              ((Ty.apply
                    (Ty.path "dns::Mapping")
                    [Ty.apply (Ty.path "array") [Ty.path "u8"];
                      Ty.path "dns::AccountId"])::["get"]
                (borrow
                  ((M.var "dns::DomainNameService::Get_name_to_owner")
                    (deref α0)))
                (borrow name)) in
          M.alloc α1 in
        let* _ :=
          let* α0 := M.read self in
          let* α1 := M.read name in
          let* α2 := M.read to in
          let* α3 :=
            M.call
              ((Ty.apply
                    (Ty.path "dns::Mapping")
                    [Ty.apply (Ty.path "array") [Ty.path "u8"];
                      Ty.path "dns::AccountId"])::["insert"]
                (borrow_mut
                  ((M.var "dns::DomainNameService::Get_name_to_owner")
                    (deref α0)))
                α1
                α2) in
          M.alloc α3 in
        let* _ :=
          let* α0 := M.read self in
          let* α1 :=
            M.call
              ((Ty.path "dns::DomainNameService")::["env"]
                (borrow (deref α0))) in
          let* α2 := M.alloc α1 in
          let* α3 := M.read name in
          let* α4 := M.read caller in
          let* α5 := M.read old_owner in
          let* α6 := M.read to in
          let* α7 :=
            M.call
              ((Ty.path "dns::Env")::["emit_event"]
                (borrow α2)
                (dns.Event.Transfer
                  {|
                    dns.Transfer.name := α3;
                    dns.Transfer.from := α4;
                    dns.Transfer.old_owner := α5;
                    dns.Transfer.new_owner := α6;
                  |})) in
          M.alloc α7 in
        let* α0 := M.alloc (core.result.Result.Ok tt) in
        M.read α0)
    | _, _ => M.impossible
    end.
  
  (*
      fn get_address_or_default(&self, name: Hash) -> AccountId {
          self.name_to_address
              .get(&name)
              .unwrap_or(self.default_address)
      }
  *)
  Definition get_address_or_default (𝜏 : list Ty.t) (α : list Value.t) : M :=
    match 𝜏, α with
    | [], [self; name] =>
      let* self := M.alloc self in
      let* name := M.alloc name in
      let* α0 := M.read self in
      let* α1 :=
        M.call
          ((Ty.apply
                (Ty.path "dns::Mapping")
                [Ty.apply (Ty.path "array") [Ty.path "u8"];
                  Ty.path "dns::AccountId"])::["get"]
            (borrow
              ((M.var "dns::DomainNameService::Get_name_to_address")
                (deref α0)))
            (borrow name)) in
      let* α2 := M.read self in
      let* α3 :=
        M.read
          ((M.var "dns::DomainNameService::Get_default_address") (deref α2)) in
      M.call
        ((Ty.apply
              (Ty.path "core::option::Option")
              [Ty.path "dns::AccountId"])::["unwrap_or"]
          α1
          α3)
    | _, _ => M.impossible
    end.
  
  (*
      pub fn get_address(&self, name: Hash) -> AccountId {
          self.get_address_or_default(name)
      }
  *)
  Definition get_address (𝜏 : list Ty.t) (α : list Value.t) : M :=
    match 𝜏, α with
    | [], [self; name] =>
      let* self := M.alloc self in
      let* name := M.alloc name in
      let* α0 := M.read self in
      let* α1 := M.read name in
      M.call
        ((Ty.path "dns::DomainNameService")::["get_address_or_default"] α0 α1)
    | _, _ => M.impossible
    end.
  
  (*
      pub fn get_owner(&self, name: Hash) -> AccountId {
          self.get_owner_or_default(name)
      }
  *)
  Definition get_owner (𝜏 : list Ty.t) (α : list Value.t) : M :=
    match 𝜏, α with
    | [], [self; name] =>
      let* self := M.alloc self in
      let* name := M.alloc name in
      let* α0 := M.read self in
      let* α1 := M.read name in
      M.call
        ((Ty.path "dns::DomainNameService")::["get_owner_or_default"] α0 α1)
    | _, _ => M.impossible
    end.
End Impl_dns_DomainNameService.
