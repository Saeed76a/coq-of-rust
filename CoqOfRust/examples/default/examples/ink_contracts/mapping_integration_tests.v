(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module  Mapping.
Section Mapping.
  Context (K V : Set).
  
  Record t : Set := {
    _key : core.marker.PhantomData.t K;
    _value : core.marker.PhantomData.t V;
  }.
  
  Global Instance Get__key : Notations.Dot "_key" := {
    Notations.dot := Ref.map (fun x => x.(_key)) (fun v x => x <| _key := v |>);
  }.
  Global Instance Get_AF__key : Notations.DoubleColon t "_key" := {
    Notations.double_colon (x : M.Val t) := x.["_key"];
  }.
  Global Instance Get__value : Notations.Dot "_value" := {
    Notations.dot :=
      Ref.map (fun x => x.(_value)) (fun v x => x <| _value := v |>);
  }.
  Global Instance Get_AF__value : Notations.DoubleColon t "_value" := {
    Notations.double_colon (x : M.Val t) := x.["_value"];
  }.
End Mapping.
End Mapping.

Module  Impl_core_default_Default_for_mapping_integration_tests_Mapping_t_K_V.
Section Impl_core_default_Default_for_mapping_integration_tests_Mapping_t_K_V.
  Context {K V : Set}.
  
  Context
    {ℋ_0 : core.default.Default.Trait K}
    {ℋ_1 : core.default.Default.Trait V}.
  
  Ltac Self := exact (mapping_integration_tests.Mapping.t K V).
  
  (*
  Default
  *)
  Definition default : M (mapping_integration_tests.Mapping.t K V) :=
    let* α0 : core.marker.PhantomData.t K :=
      M.call
        (core.default.Default.default
          (Self := core.marker.PhantomData.t K)
          (Trait := ltac:(refine _))) in
    let* α1 : core.marker.PhantomData.t V :=
      M.call
        (core.default.Default.default
          (Self := core.marker.PhantomData.t V)
          (Trait := ltac:(refine _))) in
    M.pure
      {|
        mapping_integration_tests.Mapping._key := α0;
        mapping_integration_tests.Mapping._value := α1;
      |}.
  
  Global Instance AssociatedFunction_default :
    Notations.DoubleColon ltac:(Self) "default" := {
    Notations.double_colon := default;
  }.
  
  Global Instance ℐ : core.default.Default.Trait ltac:(Self) := {
    core.default.Default.default := default;
  }.
End Impl_core_default_Default_for_mapping_integration_tests_Mapping_t_K_V.
End Impl_core_default_Default_for_mapping_integration_tests_Mapping_t_K_V.

Module  Impl_mapping_integration_tests_Mapping_t_K_V.
Section Impl_mapping_integration_tests_Mapping_t_K_V.
  Context {K V : Set}.
  
  Ltac Self := exact (mapping_integration_tests.Mapping.t K V).
  
  (*
      fn contains(&self, _key: &K) -> bool {
          unimplemented!()
      }
  *)
  Definition contains (self : ref ltac:(Self)) (_key : ref K) : M bool.t :=
    let* self : M.Val (ref ltac:(Self)) := M.alloc self in
    let* _key : M.Val (ref K) := M.alloc _key in
    let* α0 : ref str.t := M.read (mk_str "not implemented") in
    let* α1 : never.t := M.call (core.panicking.panic α0) in
    never_to_any α1.
  
  Global Instance AssociatedFunction_contains :
    Notations.DoubleColon ltac:(Self) "contains" := {
    Notations.double_colon := contains;
  }.
  
  (*
      fn get(&self, _key: &K) -> Option<V> {
          unimplemented!()
      }
  *)
  Definition get
      (self : ref ltac:(Self))
      (_key : ref K)
      : M (core.option.Option.t V) :=
    let* self : M.Val (ref ltac:(Self)) := M.alloc self in
    let* _key : M.Val (ref K) := M.alloc _key in
    let* α0 : ref str.t := M.read (mk_str "not implemented") in
    let* α1 : never.t := M.call (core.panicking.panic α0) in
    never_to_any α1.
  
  Global Instance AssociatedFunction_get :
    Notations.DoubleColon ltac:(Self) "get" := {
    Notations.double_colon := get;
  }.
  
  (*
      fn insert(&mut self, _key: K, _value: V) -> Option<u32> {
          unimplemented!()
      }
  *)
  Definition insert
      (self : mut_ref ltac:(Self))
      (_key : K)
      (_value : V)
      : M (core.option.Option.t u32.t) :=
    let* self : M.Val (mut_ref ltac:(Self)) := M.alloc self in
    let* _key : M.Val K := M.alloc _key in
    let* _value : M.Val V := M.alloc _value in
    let* α0 : ref str.t := M.read (mk_str "not implemented") in
    let* α1 : never.t := M.call (core.panicking.panic α0) in
    never_to_any α1.
  
  Global Instance AssociatedFunction_insert :
    Notations.DoubleColon ltac:(Self) "insert" := {
    Notations.double_colon := insert;
  }.
  
  (*
      fn new() -> Mapping<K, V> {
          unimplemented!()
      }
  *)
  Definition new : M (mapping_integration_tests.Mapping.t K V) :=
    let* α0 : ref str.t := M.read (mk_str "not implemented") in
    let* α1 : never.t := M.call (core.panicking.panic α0) in
    never_to_any α1.
  
  Global Instance AssociatedFunction_new :
    Notations.DoubleColon ltac:(Self) "new" := {
    Notations.double_colon := new;
  }.
  
  (*
      fn remove(&self, _key: K) {
          unimplemented!()
      }
  *)
  Definition remove (self : ref ltac:(Self)) (_key : K) : M unit :=
    let* self : M.Val (ref ltac:(Self)) := M.alloc self in
    let* _key : M.Val K := M.alloc _key in
    let* α0 : ref str.t := M.read (mk_str "not implemented") in
    let* α1 : never.t := M.call (core.panicking.panic α0) in
    never_to_any α1.
  
  Global Instance AssociatedFunction_remove :
    Notations.DoubleColon ltac:(Self) "remove" := {
    Notations.double_colon := remove;
  }.
  
  (*
      fn size(&self, _key: K) -> Option<u32> {
          unimplemented!()
      }
  *)
  Definition size
      (self : ref ltac:(Self))
      (_key : K)
      : M (core.option.Option.t u32.t) :=
    let* self : M.Val (ref ltac:(Self)) := M.alloc self in
    let* _key : M.Val K := M.alloc _key in
    let* α0 : ref str.t := M.read (mk_str "not implemented") in
    let* α1 : never.t := M.call (core.panicking.panic α0) in
    never_to_any α1.
  
  Global Instance AssociatedFunction_size :
    Notations.DoubleColon ltac:(Self) "size" := {
    Notations.double_colon := size;
  }.
  
  (*
      fn take(&self, _key: K) -> Option<V> {
          unimplemented!()
      }
  *)
  Definition take
      (self : ref ltac:(Self))
      (_key : K)
      : M (core.option.Option.t V) :=
    let* self : M.Val (ref ltac:(Self)) := M.alloc self in
    let* _key : M.Val K := M.alloc _key in
    let* α0 : ref str.t := M.read (mk_str "not implemented") in
    let* α1 : never.t := M.call (core.panicking.panic α0) in
    never_to_any α1.
  
  Global Instance AssociatedFunction_take :
    Notations.DoubleColon ltac:(Self) "take" := {
    Notations.double_colon := take;
  }.
End Impl_mapping_integration_tests_Mapping_t_K_V.
End Impl_mapping_integration_tests_Mapping_t_K_V.

Module  AccountId.
Section AccountId.
  Record t : Set := {
    x0 : u128.t;
  }.
  
  Global Instance Get_0 : Notations.Dot "0" := {
    Notations.dot := Ref.map (fun x => x.(x0)) (fun v x => x <| x0 := v |>);
  }.
End AccountId.
End AccountId.

Module  Impl_core_default_Default_for_mapping_integration_tests_AccountId_t.
Section Impl_core_default_Default_for_mapping_integration_tests_AccountId_t.
  Ltac Self := exact mapping_integration_tests.AccountId.t.
  
  (*
  Default
  *)
  Definition default : M mapping_integration_tests.AccountId.t :=
    let* α0 : u128.t :=
      M.call
        (core.default.Default.default
          (Self := u128.t)
          (Trait := ltac:(refine _))) in
    M.pure (mapping_integration_tests.AccountId.Build_t α0).
  
  Global Instance AssociatedFunction_default :
    Notations.DoubleColon ltac:(Self) "default" := {
    Notations.double_colon := default;
  }.
  
  Global Instance ℐ : core.default.Default.Trait ltac:(Self) := {
    core.default.Default.default := default;
  }.
End Impl_core_default_Default_for_mapping_integration_tests_AccountId_t.
End Impl_core_default_Default_for_mapping_integration_tests_AccountId_t.

Module  Impl_core_clone_Clone_for_mapping_integration_tests_AccountId_t.
Section Impl_core_clone_Clone_for_mapping_integration_tests_AccountId_t.
  Ltac Self := exact mapping_integration_tests.AccountId.t.
  
  (*
  Clone
  *)
  Definition clone
      (self : ref ltac:(Self))
      : M mapping_integration_tests.AccountId.t :=
    let* self : M.Val (ref ltac:(Self)) := M.alloc self in
    let* _ : M.Val unit := M.alloc tt in
    let* α0 : ref mapping_integration_tests.AccountId.t := M.read self in
    M.read (deref α0).
  
  Global Instance AssociatedFunction_clone :
    Notations.DoubleColon ltac:(Self) "clone" := {
    Notations.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait ltac:(Self) := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_mapping_integration_tests_AccountId_t.
End Impl_core_clone_Clone_for_mapping_integration_tests_AccountId_t.

Module  Impl_core_marker_Copy_for_mapping_integration_tests_AccountId_t.
Section Impl_core_marker_Copy_for_mapping_integration_tests_AccountId_t.
  Ltac Self := exact mapping_integration_tests.AccountId.t.
  
  Global Instance ℐ : core.marker.Copy.Trait ltac:(Self) := {
  }.
End Impl_core_marker_Copy_for_mapping_integration_tests_AccountId_t.
End Impl_core_marker_Copy_for_mapping_integration_tests_AccountId_t.

Ltac Balance := exact u128.t.

Module  Env.
Section Env.
  Record t : Set := {
    caller : mapping_integration_tests.AccountId.t;
  }.
  
  Global Instance Get_caller : Notations.Dot "caller" := {
    Notations.dot :=
      Ref.map (fun x => x.(caller)) (fun v x => x <| caller := v |>);
  }.
  Global Instance Get_AF_caller : Notations.DoubleColon t "caller" := {
    Notations.double_colon (x : M.Val t) := x.["caller"];
  }.
End Env.
End Env.

Module  Impl_mapping_integration_tests_Env_t.
Section Impl_mapping_integration_tests_Env_t.
  Ltac Self := exact mapping_integration_tests.Env.t.
  
  (*
      fn caller(&self) -> AccountId {
          self.caller
      }
  *)
  Definition caller
      (self : ref ltac:(Self))
      : M mapping_integration_tests.AccountId.t :=
    let* self : M.Val (ref ltac:(Self)) := M.alloc self in
    let* α0 : ref mapping_integration_tests.Env.t := M.read self in
    M.read (deref α0).["caller"].
  
  Global Instance AssociatedFunction_caller :
    Notations.DoubleColon ltac:(Self) "caller" := {
    Notations.double_colon := caller;
  }.
End Impl_mapping_integration_tests_Env_t.
End Impl_mapping_integration_tests_Env_t.

Module  Mappings.
Section Mappings.
  Record t : Set := {
    balances :
      mapping_integration_tests.Mapping.t
        mapping_integration_tests.AccountId.t
        ltac:(mapping_integration_tests.Balance);
  }.
  
  Global Instance Get_balances : Notations.Dot "balances" := {
    Notations.dot :=
      Ref.map (fun x => x.(balances)) (fun v x => x <| balances := v |>);
  }.
  Global Instance Get_AF_balances : Notations.DoubleColon t "balances" := {
    Notations.double_colon (x : M.Val t) := x.["balances"];
  }.
End Mappings.
End Mappings.

Module  Impl_core_default_Default_for_mapping_integration_tests_Mappings_t.
Section Impl_core_default_Default_for_mapping_integration_tests_Mappings_t.
  Ltac Self := exact mapping_integration_tests.Mappings.t.
  
  (*
  Default
  *)
  Definition default : M mapping_integration_tests.Mappings.t :=
    let* α0 :
        mapping_integration_tests.Mapping.t
          mapping_integration_tests.AccountId.t
          u128.t :=
      M.call
        (core.default.Default.default
          (Self :=
            mapping_integration_tests.Mapping.t
              mapping_integration_tests.AccountId.t
              u128.t)
          (Trait := ltac:(refine _))) in
    M.pure {| mapping_integration_tests.Mappings.balances := α0; |}.
  
  Global Instance AssociatedFunction_default :
    Notations.DoubleColon ltac:(Self) "default" := {
    Notations.double_colon := default;
  }.
  
  Global Instance ℐ : core.default.Default.Trait ltac:(Self) := {
    core.default.Default.default := default;
  }.
End Impl_core_default_Default_for_mapping_integration_tests_Mappings_t.
End Impl_core_default_Default_for_mapping_integration_tests_Mappings_t.

Module  Impl_mapping_integration_tests_Mappings_t.
Section Impl_mapping_integration_tests_Mappings_t.
  Ltac Self := exact mapping_integration_tests.Mappings.t.
  
  (*
      fn init_env() -> Env {
          unimplemented!()
      }
  *)
  Definition init_env : M mapping_integration_tests.Env.t :=
    let* α0 : ref str.t := M.read (mk_str "not implemented") in
    let* α1 : never.t := M.call (core.panicking.panic α0) in
    never_to_any α1.
  
  Global Instance AssociatedFunction_init_env :
    Notations.DoubleColon ltac:(Self) "init_env" := {
    Notations.double_colon := init_env;
  }.
  
  (*
      fn env() -> Env {
          unimplemented!()
      }
  *)
  Definition env : M mapping_integration_tests.Env.t :=
    let* α0 : ref str.t := M.read (mk_str "not implemented") in
    let* α1 : never.t := M.call (core.panicking.panic α0) in
    never_to_any α1.
  
  Global Instance AssociatedFunction_env :
    Notations.DoubleColon ltac:(Self) "env" := {
    Notations.double_colon := env;
  }.
  
  (*
      pub fn new() -> Self {
          let balances = Mapping::default();
          Self { balances }
      }
  *)
  Definition new : M ltac:(Self) :=
    let* balances :
        M.Val
          (mapping_integration_tests.Mapping.t
            mapping_integration_tests.AccountId.t
            u128.t) :=
      let* α0 :
          mapping_integration_tests.Mapping.t
            mapping_integration_tests.AccountId.t
            u128.t :=
        M.call
          (core.default.Default.default
            (Self :=
              mapping_integration_tests.Mapping.t
                mapping_integration_tests.AccountId.t
                u128.t)
            (Trait := ltac:(refine _))) in
      M.alloc α0 in
    let* α0 :
        mapping_integration_tests.Mapping.t
          mapping_integration_tests.AccountId.t
          u128.t :=
      M.read balances in
    let* α0 : M.Val mapping_integration_tests.Mappings.t :=
      M.alloc {| mapping_integration_tests.Mappings.balances := α0; |} in
    M.read α0.
  
  Global Instance AssociatedFunction_new :
    Notations.DoubleColon ltac:(Self) "new" := {
    Notations.double_colon := new;
  }.
  
  (*
      pub fn get_balance(&self) -> Option<Balance> {
          let caller = Self::env().caller();
          self.balances.get(&caller)
      }
  *)
  Definition get_balance
      (self : ref ltac:(Self))
      : M (core.option.Option.t ltac:(mapping_integration_tests.Balance)) :=
    let* self : M.Val (ref ltac:(Self)) := M.alloc self in
    let* caller : M.Val mapping_integration_tests.AccountId.t :=
      let* α0 : mapping_integration_tests.Env.t :=
        M.call mapping_integration_tests.Mappings.t::["env"] in
      let* α1 : M.Val mapping_integration_tests.Env.t := M.alloc α0 in
      let* α2 : mapping_integration_tests.AccountId.t :=
        M.call (mapping_integration_tests.Env.t::["caller"] (borrow α1)) in
      M.alloc α2 in
    let* α0 : ref mapping_integration_tests.Mappings.t := M.read self in
    let* α1 : core.option.Option.t u128.t :=
      M.call
        ((mapping_integration_tests.Mapping.t
              mapping_integration_tests.AccountId.t
              u128.t)::["get"]
          (borrow (deref α0).["balances"])
          (borrow caller)) in
    let* α0 : M.Val (core.option.Option.t u128.t) := M.alloc α1 in
    M.read α0.
  
  Global Instance AssociatedFunction_get_balance :
    Notations.DoubleColon ltac:(Self) "get_balance" := {
    Notations.double_colon := get_balance;
  }.
  
  (*
      pub fn insert_balance(&mut self, value: Balance) -> Option<u32> {
          let caller = Self::env().caller();
          self.balances.insert(caller, value)
      }
  *)
  Definition insert_balance
      (self : mut_ref ltac:(Self))
      (value : ltac:(mapping_integration_tests.Balance))
      : M (core.option.Option.t u32.t) :=
    let* self : M.Val (mut_ref ltac:(Self)) := M.alloc self in
    let* value : M.Val ltac:(mapping_integration_tests.Balance) :=
      M.alloc value in
    let* caller : M.Val mapping_integration_tests.AccountId.t :=
      let* α0 : mapping_integration_tests.Env.t :=
        M.call mapping_integration_tests.Mappings.t::["env"] in
      let* α1 : M.Val mapping_integration_tests.Env.t := M.alloc α0 in
      let* α2 : mapping_integration_tests.AccountId.t :=
        M.call (mapping_integration_tests.Env.t::["caller"] (borrow α1)) in
      M.alloc α2 in
    let* α0 : mut_ref mapping_integration_tests.Mappings.t := M.read self in
    let* α1 : mapping_integration_tests.AccountId.t := M.read caller in
    let* α2 : u128.t := M.read value in
    let* α3 : core.option.Option.t u32.t :=
      M.call
        ((mapping_integration_tests.Mapping.t
              mapping_integration_tests.AccountId.t
              u128.t)::["insert"]
          (borrow_mut (deref α0).["balances"])
          α1
          α2) in
    let* α0 : M.Val (core.option.Option.t u32.t) := M.alloc α3 in
    M.read α0.
  
  Global Instance AssociatedFunction_insert_balance :
    Notations.DoubleColon ltac:(Self) "insert_balance" := {
    Notations.double_colon := insert_balance;
  }.
  
  (*
      pub fn size_balance(&mut self) -> Option<u32> {
          let caller = Self::env().caller();
          self.balances.size(caller)
      }
  *)
  Definition size_balance
      (self : mut_ref ltac:(Self))
      : M (core.option.Option.t u32.t) :=
    let* self : M.Val (mut_ref ltac:(Self)) := M.alloc self in
    let* caller : M.Val mapping_integration_tests.AccountId.t :=
      let* α0 : mapping_integration_tests.Env.t :=
        M.call mapping_integration_tests.Mappings.t::["env"] in
      let* α1 : M.Val mapping_integration_tests.Env.t := M.alloc α0 in
      let* α2 : mapping_integration_tests.AccountId.t :=
        M.call (mapping_integration_tests.Env.t::["caller"] (borrow α1)) in
      M.alloc α2 in
    let* α0 : mut_ref mapping_integration_tests.Mappings.t := M.read self in
    let* α1 : mapping_integration_tests.AccountId.t := M.read caller in
    let* α2 : core.option.Option.t u32.t :=
      M.call
        ((mapping_integration_tests.Mapping.t
              mapping_integration_tests.AccountId.t
              u128.t)::["size"]
          (borrow (deref α0).["balances"])
          α1) in
    let* α0 : M.Val (core.option.Option.t u32.t) := M.alloc α2 in
    M.read α0.
  
  Global Instance AssociatedFunction_size_balance :
    Notations.DoubleColon ltac:(Self) "size_balance" := {
    Notations.double_colon := size_balance;
  }.
  
  (*
      pub fn contains_balance(&self) -> bool {
          let caller = Self::env().caller();
          self.balances.contains(&caller)
      }
  *)
  Definition contains_balance (self : ref ltac:(Self)) : M bool.t :=
    let* self : M.Val (ref ltac:(Self)) := M.alloc self in
    let* caller : M.Val mapping_integration_tests.AccountId.t :=
      let* α0 : mapping_integration_tests.Env.t :=
        M.call mapping_integration_tests.Mappings.t::["env"] in
      let* α1 : M.Val mapping_integration_tests.Env.t := M.alloc α0 in
      let* α2 : mapping_integration_tests.AccountId.t :=
        M.call (mapping_integration_tests.Env.t::["caller"] (borrow α1)) in
      M.alloc α2 in
    let* α0 : ref mapping_integration_tests.Mappings.t := M.read self in
    let* α1 : bool.t :=
      M.call
        ((mapping_integration_tests.Mapping.t
              mapping_integration_tests.AccountId.t
              u128.t)::["contains"]
          (borrow (deref α0).["balances"])
          (borrow caller)) in
    let* α0 : M.Val bool.t := M.alloc α1 in
    M.read α0.
  
  Global Instance AssociatedFunction_contains_balance :
    Notations.DoubleColon ltac:(Self) "contains_balance" := {
    Notations.double_colon := contains_balance;
  }.
  
  (*
      pub fn remove_balance(&mut self) {
          let caller = Self::env().caller();
          self.balances.remove(caller);
      }
  *)
  Definition remove_balance (self : mut_ref ltac:(Self)) : M unit :=
    let* self : M.Val (mut_ref ltac:(Self)) := M.alloc self in
    let* caller : M.Val mapping_integration_tests.AccountId.t :=
      let* α0 : mapping_integration_tests.Env.t :=
        M.call mapping_integration_tests.Mappings.t::["env"] in
      let* α1 : M.Val mapping_integration_tests.Env.t := M.alloc α0 in
      let* α2 : mapping_integration_tests.AccountId.t :=
        M.call (mapping_integration_tests.Env.t::["caller"] (borrow α1)) in
      M.alloc α2 in
    let* _ : M.Val unit :=
      let* α0 : mut_ref mapping_integration_tests.Mappings.t := M.read self in
      let* α1 : mapping_integration_tests.AccountId.t := M.read caller in
      let* α2 : unit :=
        M.call
          ((mapping_integration_tests.Mapping.t
                mapping_integration_tests.AccountId.t
                u128.t)::["remove"]
            (borrow (deref α0).["balances"])
            α1) in
      M.alloc α2 in
    let* α0 : M.Val unit := M.alloc tt in
    M.read α0.
  
  Global Instance AssociatedFunction_remove_balance :
    Notations.DoubleColon ltac:(Self) "remove_balance" := {
    Notations.double_colon := remove_balance;
  }.
  
  (*
      pub fn take_balance(&mut self) -> Option<Balance> {
          let caller = Self::env().caller();
          self.balances.take(caller)
      }
  *)
  Definition take_balance
      (self : mut_ref ltac:(Self))
      : M (core.option.Option.t ltac:(mapping_integration_tests.Balance)) :=
    let* self : M.Val (mut_ref ltac:(Self)) := M.alloc self in
    let* caller : M.Val mapping_integration_tests.AccountId.t :=
      let* α0 : mapping_integration_tests.Env.t :=
        M.call mapping_integration_tests.Mappings.t::["env"] in
      let* α1 : M.Val mapping_integration_tests.Env.t := M.alloc α0 in
      let* α2 : mapping_integration_tests.AccountId.t :=
        M.call (mapping_integration_tests.Env.t::["caller"] (borrow α1)) in
      M.alloc α2 in
    let* α0 : mut_ref mapping_integration_tests.Mappings.t := M.read self in
    let* α1 : mapping_integration_tests.AccountId.t := M.read caller in
    let* α2 : core.option.Option.t u128.t :=
      M.call
        ((mapping_integration_tests.Mapping.t
              mapping_integration_tests.AccountId.t
              u128.t)::["take"]
          (borrow (deref α0).["balances"])
          α1) in
    let* α0 : M.Val (core.option.Option.t u128.t) := M.alloc α2 in
    M.read α0.
  
  Global Instance AssociatedFunction_take_balance :
    Notations.DoubleColon ltac:(Self) "take_balance" := {
    Notations.double_colon := take_balance;
  }.
End Impl_mapping_integration_tests_Mappings_t.
End Impl_mapping_integration_tests_Mappings_t.
