(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.



Module  Impl_core_marker_Copy_for_subtle_Choice.
Section Impl_core_marker_Copy_for_subtle_Choice.
  Definition Self : Ty.t := Ty.apply (Ty.path "subtle::Choice") [].
  
  Definition ‚Ñê : Instance.t := [].
End Impl_core_marker_Copy_for_subtle_Choice.
End Impl_core_marker_Copy_for_subtle_Choice.

Module  Impl_core_clone_Clone_for_subtle_Choice.
Section Impl_core_clone_Clone_for_subtle_Choice.
  Definition Self : Ty.t := Ty.apply (Ty.path "subtle::Choice") [].
  
  (*
  Clone
  *)
  Definition clone (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self] =>
      let* self := M.alloc self in
      let* Œ±0 : Ty.apply (Ty.path "subtle::Choice") [] :=
        match_operator
          (DeclaredButUndefinedVariable
            (A :=
              Ty.apply
                (Ty.path "core::clone::AssertParamIsClone")
                [Ty.path "u8"]))
          [
            fun Œ≥ =>
              (let* Œ±0 :
                  Ty.apply
                    (Ty.path "ref")
                    [Ty.apply (Ty.path "subtle::Choice") []] :=
                M.read self in
              M.pure (deref Œ±0)) :
              Ty.apply (Ty.path "subtle::Choice") []
          ] in
      M.read Œ±0
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_clone : Instance.t := {
    Notations.double_colon := clone;
  }.
  
  Definition ‚Ñê : Instance.t := [("clone", clone); ("clone_from", clone_from)].
End Impl_core_clone_Clone_for_subtle_Choice.
End Impl_core_clone_Clone_for_subtle_Choice.

Module  Impl_core_fmt_Debug_for_subtle_Choice.
Section Impl_core_fmt_Debug_for_subtle_Choice.
  Definition Self : Ty.t := Ty.apply (Ty.path "subtle::Choice") [].
  
  (*
  Debug
  *)
  Definition fmt (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self; f] =>
      let* self := M.alloc self in
      let* f := M.alloc f in
      let* Œ±0 :
          Ty.apply
            (Ty.path "mut_ref")
            [Ty.apply (Ty.path "core::fmt::Formatter") []] :=
        M.read f in
      let* Œ±1 : Ty.apply (Ty.path "ref") [Ty.path "str"] :=
        M.read (mk_str "Choice") in
      let* Œ±2 :
          Ty.apply (Ty.path "ref") [Ty.apply (Ty.path "subtle::Choice") []] :=
        M.read self in
      let* Œ±3 : Ty.apply (Ty.path "ref") [Ty.path "u8"] :=
        M.alloc (borrow (subtle.Choice.Get_0 (deref Œ±2))) in
      M.call
        ((Ty.apply
              (Ty.path "core::fmt::Formatter")
              [])::["debug_tuple_field1_finish"]
          Œ±0
          Œ±1
          (pointer_coercion "Unsize" (borrow Œ±3)))
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_fmt : Instance.t := {
    Notations.double_colon := fmt;
  }.
  
  Definition ‚Ñê : Instance.t := [("fmt", fmt)].
End Impl_core_fmt_Debug_for_subtle_Choice.
End Impl_core_fmt_Debug_for_subtle_Choice.

Module  Impl_subtle_Choice.
Section Impl_subtle_Choice.
  Definition Self : Set := Ty.apply (Ty.path "subtle::Choice") [].
  
  (*
      pub fn unwrap_u8(&self) -> u8 {
          self.0
      }
  *)
  Definition unwrap_u8 (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self] =>
      let* self := M.alloc self in
      let* Œ±0 :
          Ty.apply (Ty.path "ref") [Ty.apply (Ty.path "subtle::Choice") []] :=
        M.read self in
      M.read (subtle.Choice.Get_0 (deref Œ±0))
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_unwrap_u8 : Instance.t := {
    Notations.double_colon := unwrap_u8;
  }.
End Impl_subtle_Choice.
End Impl_subtle_Choice.

Module  Impl_core_convert_From_subtle_Choice_for_bool.
Section Impl_core_convert_From_subtle_Choice_for_bool.
  Definition Self : Ty.t := Ty.path "bool".
  
  (*
      fn from(source: Choice) -> bool {
          debug_assert!((source.0 == 0u8) | (source.0 == 1u8));
          source.0 != 0
      }
  *)
  Definition from (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [source] =>
      let* source := M.alloc source in
      let* _ : Ty.tuple :=
        let* Œ±0 : Ty.path "bool" := M.alloc true in
        let* Œ±1 : Ty.path "bool" := M.read (use Œ±0) in
        if Œ±1 then
          let* _ : Ty.tuple :=
            let* Œ±0 : Ty.path "u8" := M.read (subtle.Choice.Get_0 source) in
            let* Œ±1 : Ty.path "u8" := M.read (subtle.Choice.Get_0 source) in
            let* Œ±2 : Ty.path "bool" :=
              M.alloc
                (UnOp.not
                  (BinOp.Pure.bit_or
                    (BinOp.Pure.eq Œ±0 ((Integer.of_Z 0) : Ty.path "u8"))
                    (BinOp.Pure.eq Œ±1 ((Integer.of_Z 1) : Ty.path "u8")))) in
            let* Œ±3 : Ty.path "bool" := M.read (use Œ±2) in
            if Œ±3 then
              let* Œ±0 : Ty.apply (Ty.path "ref") [Ty.path "str"] :=
                M.read
                  (mk_str
                    "assertion failed: (source.0 == 0u8) | (source.0 == 1u8)") in
              let* Œ±1 : Ty.path "never" := M.call (core.panicking.panic Œ±0) in
              let* Œ±2 : Ty.tuple := never_to_any Œ±1 in
              M.alloc Œ±2
            else
              M.alloc tt in
          M.alloc tt
        else
          M.alloc tt in
      let* Œ±0 : Ty.path "u8" := M.read (subtle.Choice.Get_0 source) in
      let* Œ±0 : Ty.path "bool" :=
        M.alloc (BinOp.Pure.ne Œ±0 ((Integer.of_Z 0) : Ty.path "u8")) in
      M.read Œ±0
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_from : Instance.t := {
    Notations.double_colon := from;
  }.
  
  Definition ‚Ñê : Instance.t := [("from", from)].
End Impl_core_convert_From_subtle_Choice_for_bool.
End Impl_core_convert_From_subtle_Choice_for_bool.

Module  Impl_core_ops_bit_BitAnd_for_subtle_Choice.
Section Impl_core_ops_bit_BitAnd_for_subtle_Choice.
  Definition Self : Ty.t := Ty.apply (Ty.path "subtle::Choice") [].
  
  (*
      type Output = Choice;
  *)
  Definition Output : Set := Ty.apply (Ty.path "subtle::Choice") [].
  
  (*
      fn bitand(self, rhs: Choice) -> Choice {
          (self.0 & rhs.0).into()
      }
  *)
  Definition bitand (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self; rhs] =>
      let* self := M.alloc self in
      let* rhs := M.alloc rhs in
      let* Œ±0 :
          Ty.function [Ty.path "u8"] (Ty.apply (Ty.path "subtle::Choice") []) :=
        ltac:(M.get_method (fun ‚Ñê =>
          core.convert.Into.into
            (Self := Ty.path "u8")
            (T := Ty.apply (Ty.path "subtle::Choice") [])
            (Trait := ‚Ñê))) in
      let* Œ±1 : Ty.path "u8" := M.read (subtle.Choice.Get_0 self) in
      let* Œ±2 : Ty.path "u8" := M.read (subtle.Choice.Get_0 rhs) in
      M.call (Œ±0 (BinOp.Pure.bit_and Œ±1 Œ±2))
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_bitand : Instance.t := {
    Notations.double_colon := bitand;
  }.
  
  Definition ‚Ñê : Instance.t := [("Output", Output); ("bitand", bitand)].
End Impl_core_ops_bit_BitAnd_for_subtle_Choice.
End Impl_core_ops_bit_BitAnd_for_subtle_Choice.

Module  Impl_core_ops_bit_BitAndAssign_for_subtle_Choice.
Section Impl_core_ops_bit_BitAndAssign_for_subtle_Choice.
  Definition Self : Ty.t := Ty.apply (Ty.path "subtle::Choice") [].
  
  (*
      fn bitand_assign(&mut self, rhs: Choice) {
          *self = *self & rhs;
      }
  *)
  Definition bitand_assign (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self; rhs] =>
      let* self := M.alloc self in
      let* rhs := M.alloc rhs in
      let* _ : Ty.tuple :=
        let* Œ±0 :
            Ty.apply
              (Ty.path "mut_ref")
              [Ty.apply (Ty.path "subtle::Choice") []] :=
          M.read self in
        let* Œ±1 :
            Ty.function
              [Ty.apply (Ty.path "subtle::Choice") [];
                Ty.apply (Ty.path "subtle::Choice") []]
              _ :=
          ltac:(M.get_method (fun ‚Ñê =>
            core.ops.bit.BitAnd.bitand
              (Self := Ty.apply (Ty.path "subtle::Choice") [])
              (Rhs := Ty.apply (Ty.path "subtle::Choice") [])
              (Trait := ‚Ñê))) in
        let* Œ±2 :
            Ty.apply
              (Ty.path "mut_ref")
              [Ty.apply (Ty.path "subtle::Choice") []] :=
          M.read self in
        let* Œ±3 : Ty.apply (Ty.path "subtle::Choice") [] := M.read (deref Œ±2) in
        let* Œ±4 : Ty.apply (Ty.path "subtle::Choice") [] := M.read rhs in
        let* Œ±5 : Ty.apply (Ty.path "subtle::Choice") [] := M.call (Œ±1 Œ±3 Œ±4) in
        assign (deref Œ±0) Œ±5 in
      let* Œ±0 : Ty.path "unit" := M.alloc tt in
      M.read Œ±0
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_bitand_assign : Instance.t := {
    Notations.double_colon := bitand_assign;
  }.
  
  Definition ‚Ñê : Instance.t := [("bitand_assign", bitand_assign)].
End Impl_core_ops_bit_BitAndAssign_for_subtle_Choice.
End Impl_core_ops_bit_BitAndAssign_for_subtle_Choice.

Module  Impl_core_ops_bit_BitOr_for_subtle_Choice.
Section Impl_core_ops_bit_BitOr_for_subtle_Choice.
  Definition Self : Ty.t := Ty.apply (Ty.path "subtle::Choice") [].
  
  (*
      type Output = Choice;
  *)
  Definition Output : Set := Ty.apply (Ty.path "subtle::Choice") [].
  
  (*
      fn bitor(self, rhs: Choice) -> Choice {
          (self.0 | rhs.0).into()
      }
  *)
  Definition bitor (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self; rhs] =>
      let* self := M.alloc self in
      let* rhs := M.alloc rhs in
      let* Œ±0 :
          Ty.function [Ty.path "u8"] (Ty.apply (Ty.path "subtle::Choice") []) :=
        ltac:(M.get_method (fun ‚Ñê =>
          core.convert.Into.into
            (Self := Ty.path "u8")
            (T := Ty.apply (Ty.path "subtle::Choice") [])
            (Trait := ‚Ñê))) in
      let* Œ±1 : Ty.path "u8" := M.read (subtle.Choice.Get_0 self) in
      let* Œ±2 : Ty.path "u8" := M.read (subtle.Choice.Get_0 rhs) in
      M.call (Œ±0 (BinOp.Pure.bit_or Œ±1 Œ±2))
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_bitor : Instance.t := {
    Notations.double_colon := bitor;
  }.
  
  Definition ‚Ñê : Instance.t := [("Output", Output); ("bitor", bitor)].
End Impl_core_ops_bit_BitOr_for_subtle_Choice.
End Impl_core_ops_bit_BitOr_for_subtle_Choice.

Module  Impl_core_ops_bit_BitOrAssign_for_subtle_Choice.
Section Impl_core_ops_bit_BitOrAssign_for_subtle_Choice.
  Definition Self : Ty.t := Ty.apply (Ty.path "subtle::Choice") [].
  
  (*
      fn bitor_assign(&mut self, rhs: Choice) {
          *self = *self | rhs;
      }
  *)
  Definition bitor_assign (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self; rhs] =>
      let* self := M.alloc self in
      let* rhs := M.alloc rhs in
      let* _ : Ty.tuple :=
        let* Œ±0 :
            Ty.apply
              (Ty.path "mut_ref")
              [Ty.apply (Ty.path "subtle::Choice") []] :=
          M.read self in
        let* Œ±1 :
            Ty.function
              [Ty.apply (Ty.path "subtle::Choice") [];
                Ty.apply (Ty.path "subtle::Choice") []]
              _ :=
          ltac:(M.get_method (fun ‚Ñê =>
            core.ops.bit.BitOr.bitor
              (Self := Ty.apply (Ty.path "subtle::Choice") [])
              (Rhs := Ty.apply (Ty.path "subtle::Choice") [])
              (Trait := ‚Ñê))) in
        let* Œ±2 :
            Ty.apply
              (Ty.path "mut_ref")
              [Ty.apply (Ty.path "subtle::Choice") []] :=
          M.read self in
        let* Œ±3 : Ty.apply (Ty.path "subtle::Choice") [] := M.read (deref Œ±2) in
        let* Œ±4 : Ty.apply (Ty.path "subtle::Choice") [] := M.read rhs in
        let* Œ±5 : Ty.apply (Ty.path "subtle::Choice") [] := M.call (Œ±1 Œ±3 Œ±4) in
        assign (deref Œ±0) Œ±5 in
      let* Œ±0 : Ty.path "unit" := M.alloc tt in
      M.read Œ±0
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_bitor_assign : Instance.t := {
    Notations.double_colon := bitor_assign;
  }.
  
  Definition ‚Ñê : Instance.t := [("bitor_assign", bitor_assign)].
End Impl_core_ops_bit_BitOrAssign_for_subtle_Choice.
End Impl_core_ops_bit_BitOrAssign_for_subtle_Choice.

Module  Impl_core_ops_bit_BitXor_for_subtle_Choice.
Section Impl_core_ops_bit_BitXor_for_subtle_Choice.
  Definition Self : Ty.t := Ty.apply (Ty.path "subtle::Choice") [].
  
  (*
      type Output = Choice;
  *)
  Definition Output : Set := Ty.apply (Ty.path "subtle::Choice") [].
  
  (*
      fn bitxor(self, rhs: Choice) -> Choice {
          (self.0 ^ rhs.0).into()
      }
  *)
  Definition bitxor (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self; rhs] =>
      let* self := M.alloc self in
      let* rhs := M.alloc rhs in
      let* Œ±0 :
          Ty.function [Ty.path "u8"] (Ty.apply (Ty.path "subtle::Choice") []) :=
        ltac:(M.get_method (fun ‚Ñê =>
          core.convert.Into.into
            (Self := Ty.path "u8")
            (T := Ty.apply (Ty.path "subtle::Choice") [])
            (Trait := ‚Ñê))) in
      let* Œ±1 : Ty.path "u8" := M.read (subtle.Choice.Get_0 self) in
      let* Œ±2 : Ty.path "u8" := M.read (subtle.Choice.Get_0 rhs) in
      M.call (Œ±0 (BinOp.Pure.bit_xor Œ±1 Œ±2))
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_bitxor : Instance.t := {
    Notations.double_colon := bitxor;
  }.
  
  Definition ‚Ñê : Instance.t := [("Output", Output); ("bitxor", bitxor)].
End Impl_core_ops_bit_BitXor_for_subtle_Choice.
End Impl_core_ops_bit_BitXor_for_subtle_Choice.

Module  Impl_core_ops_bit_BitXorAssign_for_subtle_Choice.
Section Impl_core_ops_bit_BitXorAssign_for_subtle_Choice.
  Definition Self : Ty.t := Ty.apply (Ty.path "subtle::Choice") [].
  
  (*
      fn bitxor_assign(&mut self, rhs: Choice) {
          *self = *self ^ rhs;
      }
  *)
  Definition bitxor_assign (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self; rhs] =>
      let* self := M.alloc self in
      let* rhs := M.alloc rhs in
      let* _ : Ty.tuple :=
        let* Œ±0 :
            Ty.apply
              (Ty.path "mut_ref")
              [Ty.apply (Ty.path "subtle::Choice") []] :=
          M.read self in
        let* Œ±1 :
            Ty.function
              [Ty.apply (Ty.path "subtle::Choice") [];
                Ty.apply (Ty.path "subtle::Choice") []]
              _ :=
          ltac:(M.get_method (fun ‚Ñê =>
            core.ops.bit.BitXor.bitxor
              (Self := Ty.apply (Ty.path "subtle::Choice") [])
              (Rhs := Ty.apply (Ty.path "subtle::Choice") [])
              (Trait := ‚Ñê))) in
        let* Œ±2 :
            Ty.apply
              (Ty.path "mut_ref")
              [Ty.apply (Ty.path "subtle::Choice") []] :=
          M.read self in
        let* Œ±3 : Ty.apply (Ty.path "subtle::Choice") [] := M.read (deref Œ±2) in
        let* Œ±4 : Ty.apply (Ty.path "subtle::Choice") [] := M.read rhs in
        let* Œ±5 : Ty.apply (Ty.path "subtle::Choice") [] := M.call (Œ±1 Œ±3 Œ±4) in
        assign (deref Œ±0) Œ±5 in
      let* Œ±0 : Ty.path "unit" := M.alloc tt in
      M.read Œ±0
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_bitxor_assign : Instance.t := {
    Notations.double_colon := bitxor_assign;
  }.
  
  Definition ‚Ñê : Instance.t := [("bitxor_assign", bitxor_assign)].
End Impl_core_ops_bit_BitXorAssign_for_subtle_Choice.
End Impl_core_ops_bit_BitXorAssign_for_subtle_Choice.

Module  Impl_core_ops_bit_Not_for_subtle_Choice.
Section Impl_core_ops_bit_Not_for_subtle_Choice.
  Definition Self : Ty.t := Ty.apply (Ty.path "subtle::Choice") [].
  
  (*
      type Output = Choice;
  *)
  Definition Output : Set := Ty.apply (Ty.path "subtle::Choice") [].
  
  (*
      fn not(self) -> Choice {
          (1u8 & (!self.0)).into()
      }
  *)
  Definition not (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self] =>
      let* self := M.alloc self in
      let* Œ±0 :
          Ty.function [Ty.path "u8"] (Ty.apply (Ty.path "subtle::Choice") []) :=
        ltac:(M.get_method (fun ‚Ñê =>
          core.convert.Into.into
            (Self := Ty.path "u8")
            (T := Ty.apply (Ty.path "subtle::Choice") [])
            (Trait := ‚Ñê))) in
      let* Œ±1 : Ty.path "u8" := M.read (subtle.Choice.Get_0 self) in
      M.call
        (Œ±0
          (BinOp.Pure.bit_and ((Integer.of_Z 1) : Ty.path "u8") (UnOp.not Œ±1)))
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_not : Instance.t := {
    Notations.double_colon := not;
  }.
  
  Definition ‚Ñê : Instance.t := [("Output", Output); ("not", not)].
End Impl_core_ops_bit_Not_for_subtle_Choice.
End Impl_core_ops_bit_Not_for_subtle_Choice.

(*
fn black_box(input: u8) -> u8 {
    debug_assert!((input == 0u8) | (input == 1u8));

    unsafe {
        // Optimization barrier
        //
        // Unsafe is ok, because:
        //   - &input is not NULL;
        //   - size of input is not zero;
        //   - u8 is neither Sync, nor Send;
        //   - u8 is Copy, so input is always live;
        //   - u8 type is always properly aligned.
        core::ptr::read_volatile(&input as *const u8)
    }
}
*)
Definition black_box (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
  match ùúè, Œ± with
  | [], [input] =>
    let* input := M.alloc input in
    let* _ : Ty.tuple :=
      let* Œ±0 : Ty.path "bool" := M.alloc true in
      let* Œ±1 : Ty.path "bool" := M.read (use Œ±0) in
      if Œ±1 then
        let* _ : Ty.tuple :=
          let* Œ±0 : Ty.path "u8" := M.read input in
          let* Œ±1 : Ty.path "u8" := M.read input in
          let* Œ±2 : Ty.path "bool" :=
            M.alloc
              (UnOp.not
                (BinOp.Pure.bit_or
                  (BinOp.Pure.eq Œ±0 ((Integer.of_Z 0) : Ty.path "u8"))
                  (BinOp.Pure.eq Œ±1 ((Integer.of_Z 1) : Ty.path "u8")))) in
          let* Œ±3 : Ty.path "bool" := M.read (use Œ±2) in
          if Œ±3 then
            let* Œ±0 : Ty.apply (Ty.path "ref") [Ty.path "str"] :=
              M.read
                (mk_str "assertion failed: (input == 0u8) | (input == 1u8)") in
            let* Œ±1 : Ty.path "never" := M.call (core.panicking.panic Œ±0) in
            let* Œ±2 : Ty.tuple := never_to_any Œ±1 in
            M.alloc Œ±2
          else
            M.alloc tt in
        M.alloc tt
      else
        M.alloc tt in
    let* Œ±0 : Ty.apply (Ty.path "ref") [Ty.path "u8"] :=
      M.alloc (addr_of input) in
    let* Œ±1 : Ty.apply (Ty.path "ref") [Ty.path "u8"] := M.read (use Œ±0) in
    let* Œ±2 : Ty.path "u8" := M.call (core.ptr.read_volatile Œ±1) in
    let* Œ±0 : Ty.path "u8" := M.alloc Œ±2 in
    M.read Œ±0
  | _, _ => M.impossible
  end.

Module  Impl_core_convert_From_u8_for_subtle_Choice.
Section Impl_core_convert_From_u8_for_subtle_Choice.
  Definition Self : Ty.t := Ty.apply (Ty.path "subtle::Choice") [].
  
  (*
      fn from(input: u8) -> Choice {
          // Our goal is to prevent the compiler from inferring that the value held inside the
          // resulting `Choice` struct is really an `i1` instead of an `i8`.
          Choice(black_box(input))
      }
  *)
  Definition from (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [input] =>
      let* input := M.alloc input in
      let* Œ±0 : Ty.path "u8" := M.read input in
      let* Œ±1 : Ty.path "u8" := M.call (subtle.black_box Œ±0) in
      M.pure (subtle.Choice.Build_t Œ±1)
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_from : Instance.t := {
    Notations.double_colon := from;
  }.
  
  Definition ‚Ñê : Instance.t := [("from", from)].
End Impl_core_convert_From_u8_for_subtle_Choice.
End Impl_core_convert_From_u8_for_subtle_Choice.

Module  ConstantTimeEq.
Section ConstantTimeEq.
  Class Trait (Self : Set) : Type := {
    ct_eq :
      Ty.function
        [Ty.apply (Ty.path "ref") [Self]; Ty.apply (Ty.path "ref") [Self]]
        (Ty.apply (Ty.path "subtle::Choice") []);
  }.
  
End ConstantTimeEq.
End ConstantTimeEq.

Module  Impl_subtle_ConstantTimeEq_for_slice_T.
Section Impl_subtle_ConstantTimeEq_for_slice_T.
  Context {T : Set}.
  
  Definition Self : Ty.t := Ty.apply (Ty.path "slice") [T].
  
  (*
      fn ct_eq(&self, _rhs: &[T]) -> Choice {
          let len = self.len();
  
          // Short-circuit on the *lengths* of the slices, not their
          // contents.
          if len != _rhs.len() {
              return Choice::from(0);
          }
  
          // This loop shouldn't be shortcircuitable, since the compiler
          // shouldn't be able to reason about the value of the `u8`
          // unwrapped from the `ct_eq` result.
          let mut x = 1u8;
          for (ai, bi) in self.iter().zip(_rhs.iter()) {
              x &= ai.ct_eq(bi).unwrap_u8();
          }
  
          x.into()
      }
  *)
  Definition ct_eq (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self; _rhs] =>
      let* self := M.alloc self in
      let* _rhs := M.alloc _rhs in
      let return_ := M.return_ (R := Ty.apply (Ty.path "subtle::Choice") []) in
      M.catch_return
        (let* len : Ty.path "usize" :=
          let* Œ±0 : Ty.apply (Ty.path "ref") [Ty.apply (Ty.path "slice") [T]] :=
            M.read self in
          let* Œ±1 : Ty.path "usize" :=
            M.call ((Ty.apply (Ty.path "slice") [T])::["len"] Œ±0) in
          M.alloc Œ±1 in
        let* _ : Ty.tuple :=
          let* Œ±0 : Ty.path "usize" := M.read len in
          let* Œ±1 : Ty.apply (Ty.path "ref") [Ty.apply (Ty.path "slice") [T]] :=
            M.read _rhs in
          let* Œ±2 : Ty.path "usize" :=
            M.call ((Ty.apply (Ty.path "slice") [T])::["len"] Œ±1) in
          let* Œ±3 : Ty.path "bool" := M.alloc (BinOp.Pure.ne Œ±0 Œ±2) in
          let* Œ±4 : Ty.path "bool" := M.read (use Œ±3) in
          if Œ±4 then
            let* Œ±0 :
                Ty.function
                  [Ty.path "u8"]
                  (Ty.apply (Ty.path "subtle::Choice") []) :=
              ltac:(M.get_method (fun ‚Ñê =>
                core.convert.From.from
                  (Self := Ty.apply (Ty.path "subtle::Choice") [])
                  (T := Ty.path "u8")
                  (Trait := ‚Ñê))) in
            let* Œ±1 : Ty.apply (Ty.path "subtle::Choice") [] :=
              M.call (Œ±0 ((Integer.of_Z 0) : Ty.path "u8")) in
            let* Œ±2 : Ty.path "never" := return_ Œ±1 in
            let* Œ±3 : Ty.path "never" := M.read Œ±2 in
            let* Œ±4 : Ty.tuple := never_to_any Œ±3 in
            M.alloc Œ±4
          else
            M.alloc tt in
        let* x : Ty.path "u8" := M.alloc ((Integer.of_Z 1) : Ty.path "u8") in
        let* _ : Ty.tuple :=
          let* Œ±0 :
              Ty.function
                [Ty.apply
                    (Ty.path "core::iter::adapters::zip::Zip")
                    [Ty.apply (Ty.path "core::slice::iter::Iter") [T];
                      Ty.apply (Ty.path "core::slice::iter::Iter") [T]]]
                _ :=
            ltac:(M.get_method (fun ‚Ñê =>
              core.iter.traits.collect.IntoIterator.into_iter
                (Self :=
                  Ty.apply
                    (Ty.path "core::iter::adapters::zip::Zip")
                    [Ty.apply (Ty.path "core::slice::iter::Iter") [T];
                      Ty.apply (Ty.path "core::slice::iter::Iter") [T]])
                (Trait := ‚Ñê))) in
          let* Œ±1 :
              Ty.function
                [Ty.apply (Ty.path "core::slice::iter::Iter") [T];
                  Ty.apply (Ty.path "core::slice::iter::Iter") [T]]
                (Ty.apply
                  (Ty.path "core::iter::adapters::zip::Zip")
                  [Ty.apply (Ty.path "core::slice::iter::Iter") [T]; _]) :=
            ltac:(M.get_method (fun ‚Ñê =>
              core.iter.traits.iterator.Iterator.zip
                (Self := Ty.apply (Ty.path "core::slice::iter::Iter") [T])
                (U := Ty.apply (Ty.path "core::slice::iter::Iter") [T])
                (Trait := ‚Ñê))) in
          let* Œ±2 : Ty.apply (Ty.path "ref") [Ty.apply (Ty.path "slice") [T]] :=
            M.read self in
          let* Œ±3 : Ty.apply (Ty.path "core::slice::iter::Iter") [T] :=
            M.call ((Ty.apply (Ty.path "slice") [T])::["iter"] Œ±2) in
          let* Œ±4 : Ty.apply (Ty.path "ref") [Ty.apply (Ty.path "slice") [T]] :=
            M.read _rhs in
          let* Œ±5 : Ty.apply (Ty.path "core::slice::iter::Iter") [T] :=
            M.call ((Ty.apply (Ty.path "slice") [T])::["iter"] Œ±4) in
          let* Œ±6 :
              Ty.apply
                (Ty.path "core::iter::adapters::zip::Zip")
                [Ty.apply (Ty.path "core::slice::iter::Iter") [T];
                  Ty.apply (Ty.path "core::slice::iter::Iter") [T]] :=
            M.call (Œ±1 Œ±3 Œ±5) in
          let* Œ±7 :
              Ty.apply
                (Ty.path "core::iter::adapters::zip::Zip")
                [Ty.apply (Ty.path "core::slice::iter::Iter") [T];
                  Ty.apply (Ty.path "core::slice::iter::Iter") [T]] :=
            M.call (Œ±0 Œ±6) in
          let* Œ±8 :
              Ty.apply
                (Ty.path "core::iter::adapters::zip::Zip")
                [Ty.apply (Ty.path "core::slice::iter::Iter") [T];
                  Ty.apply (Ty.path "core::slice::iter::Iter") [T]] :=
            M.alloc Œ±7 in
          let* Œ±9 : Ty.tuple :=
            match_operator
              Œ±8
              [
                fun Œ≥ =>
                  (let* iter := M.copy Œ≥ in
                  M.loop
                    (let* _ : Ty.tuple :=
                      let* Œ±0 :
                          Ty.function
                            [Ty.apply
                                (Ty.path "mut_ref")
                                [Ty.apply
                                    (Ty.path "core::iter::adapters::zip::Zip")
                                    [Ty.apply
                                        (Ty.path "core::slice::iter::Iter")
                                        [T];
                                      Ty.apply
                                        (Ty.path "core::slice::iter::Iter")
                                        [T]]]]
                            (Ty.apply (Ty.path "core::option::Option") [_]) :=
                        ltac:(M.get_method (fun ‚Ñê =>
                          core.iter.traits.iterator.Iterator.next
                            (Self :=
                              Ty.apply
                                (Ty.path "core::iter::adapters::zip::Zip")
                                [Ty.apply
                                    (Ty.path "core::slice::iter::Iter")
                                    [T];
                                  Ty.apply
                                    (Ty.path "core::slice::iter::Iter")
                                    [T]])
                            (Trait := ‚Ñê))) in
                      let* Œ±1 :
                          Ty.apply
                            (Ty.path "core::option::Option")
                            [Ty.tuple
                                (Ty.apply (Ty.path "ref") [T])
                                (Ty.apply (Ty.path "ref") [T])] :=
                        M.call (Œ±0 (borrow_mut iter)) in
                      let* Œ±2 :
                          Ty.apply
                            (Ty.path "core::option::Option")
                            [Ty.tuple
                                (Ty.apply (Ty.path "ref") [T])
                                (Ty.apply (Ty.path "ref") [T])] :=
                        M.alloc Œ±1 in
                      match_operator
                        Œ±2
                        [
                          fun Œ≥ =>
                            (let* Œ±0 := M.read Œ≥ in
                            match Œ±0 with
                            | core.option.Option.None =>
                              let* Œ±0 : Ty.path "never" := M.break in
                              let* Œ±1 : Ty.path "never" := M.read Œ±0 in
                              let* Œ±2 : Ty.tuple := never_to_any Œ±1 in
                              M.alloc Œ±2
                            | _ => M.break_match
                            end) :
                            Ty.tuple;
                          fun Œ≥ =>
                            (let* Œ±0 := M.read Œ≥ in
                            match Œ±0 with
                            | core.option.Option.Some _ =>
                              let Œ≥0_0 := core.option.Option.Get_Some_0 Œ≥ in
                              let* Œ±0 := M.read Œ≥0_0 in
                              match Œ±0 with
                              | (_, _) =>
                                let Œ≥1_0 := Tuple.Access.left Œ≥0_0 in
                                let Œ≥1_1 := Tuple.Access.right Œ≥0_0 in
                                let* ai := M.copy Œ≥1_0 in
                                let* bi := M.copy Œ≥1_1 in
                                let* _ : Ty.tuple :=
                                  let Œ≤ : Ty.path "u8" := x in
                                  let* Œ±0 := M.read Œ≤ in
                                  let* Œ±1 :
                                      Ty.function
                                        [Ty.apply (Ty.path "ref") [T];
                                          Ty.apply (Ty.path "ref") [T]]
                                        (Ty.apply
                                          (Ty.path "subtle::Choice")
                                          []) :=
                                    ltac:(M.get_method (fun ‚Ñê =>
                                      subtle.ConstantTimeEq.ct_eq
                                        (Self := T)
                                        (Trait := ‚Ñê))) in
                                  let* Œ±2 : Ty.apply (Ty.path "ref") [T] :=
                                    M.read ai in
                                  let* Œ±3 : Ty.apply (Ty.path "ref") [T] :=
                                    M.read bi in
                                  let* Œ±4 :
                                      Ty.apply (Ty.path "subtle::Choice") [] :=
                                    M.call (Œ±1 Œ±2 Œ±3) in
                                  let* Œ±5 :
                                      Ty.apply (Ty.path "subtle::Choice") [] :=
                                    M.alloc Œ±4 in
                                  let* Œ±6 : Ty.path "u8" :=
                                    M.call
                                      ((Ty.apply
                                            (Ty.path "subtle::Choice")
                                            [])::["unwrap_u8"]
                                        (borrow Œ±5)) in
                                  assign Œ≤ (BinOp.Pure.bit_and Œ±0 Œ±6) in
                                M.alloc tt
                              end
                            | _ => M.break_match
                            end) :
                            Ty.tuple
                        ] in
                    M.alloc tt)) :
                  Ty.tuple
              ] in
          M.pure (use Œ±9) in
        let* Œ±0 :
            Ty.function
              [Ty.path "u8"]
              (Ty.apply (Ty.path "subtle::Choice") []) :=
          ltac:(M.get_method (fun ‚Ñê =>
            core.convert.Into.into
              (Self := Ty.path "u8")
              (T := Ty.apply (Ty.path "subtle::Choice") [])
              (Trait := ‚Ñê))) in
        let* Œ±1 : Ty.path "u8" := M.read x in
        let* Œ±2 : Ty.apply (Ty.path "subtle::Choice") [] := M.call (Œ±0 Œ±1) in
        let* Œ±0 : Ty.apply (Ty.path "subtle::Choice") [] := M.alloc Œ±2 in
        M.read Œ±0)
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_ct_eq : Instance.t := {
    Notations.double_colon := ct_eq;
  }.
  
  Definition ‚Ñê : Instance.t := [("ct_eq", ct_eq); ("ct_ne", ct_ne)].
End Impl_subtle_ConstantTimeEq_for_slice_T.
End Impl_subtle_ConstantTimeEq_for_slice_T.

Module  Impl_subtle_ConstantTimeEq_for_subtle_Choice.
Section Impl_subtle_ConstantTimeEq_for_subtle_Choice.
  Definition Self : Ty.t := Ty.apply (Ty.path "subtle::Choice") [].
  
  (*
      fn ct_eq(&self, rhs: &Choice) -> Choice {
          !( *self ^ *rhs)
      }
  *)
  Definition ct_eq (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self; rhs] =>
      let* self := M.alloc self in
      let* rhs := M.alloc rhs in
      let* Œ±0 : Ty.function [Ty.apply (Ty.path "subtle::Choice") []] _ :=
        ltac:(M.get_method (fun ‚Ñê =>
          core.ops.bit.Not.not
            (Self := Ty.apply (Ty.path "subtle::Choice") [])
            (Trait := ‚Ñê))) in
      let* Œ±1 :
          Ty.function
            [Ty.apply (Ty.path "subtle::Choice") [];
              Ty.apply (Ty.path "subtle::Choice") []]
            _ :=
        ltac:(M.get_method (fun ‚Ñê =>
          core.ops.bit.BitXor.bitxor
            (Self := Ty.apply (Ty.path "subtle::Choice") [])
            (Rhs := Ty.apply (Ty.path "subtle::Choice") [])
            (Trait := ‚Ñê))) in
      let* Œ±2 :
          Ty.apply (Ty.path "ref") [Ty.apply (Ty.path "subtle::Choice") []] :=
        M.read self in
      let* Œ±3 : Ty.apply (Ty.path "subtle::Choice") [] := M.read (deref Œ±2) in
      let* Œ±4 :
          Ty.apply (Ty.path "ref") [Ty.apply (Ty.path "subtle::Choice") []] :=
        M.read rhs in
      let* Œ±5 : Ty.apply (Ty.path "subtle::Choice") [] := M.read (deref Œ±4) in
      let* Œ±6 : Ty.apply (Ty.path "subtle::Choice") [] := M.call (Œ±1 Œ±3 Œ±5) in
      M.call (Œ±0 Œ±6)
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_ct_eq : Instance.t := {
    Notations.double_colon := ct_eq;
  }.
  
  Definition ‚Ñê : Instance.t := [("ct_eq", ct_eq); ("ct_ne", ct_ne)].
End Impl_subtle_ConstantTimeEq_for_subtle_Choice.
End Impl_subtle_ConstantTimeEq_for_subtle_Choice.

Module  Impl_subtle_ConstantTimeEq_for_u8.
Section Impl_subtle_ConstantTimeEq_for_u8.
  Definition Self : Ty.t := Ty.path "u8".
  
  (*
              fn ct_eq(&self, other: &$t_u) -> Choice {
                  // x == 0 if and only if self == other
                  let x: $t_u = self ^ other;
  
                  // If x == 0, then x and -x are both equal to zero;
                  // otherwise, one or both will have its high bit set.
                  let y: $t_u = (x | x.wrapping_neg()) >> ($bit_width - 1);
  
                  // Result is the opposite of the high bit (now shifted to low).
                  ((y ^ (1 as $t_u)) as u8).into()
              }
  *)
  Definition ct_eq (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self; other] =>
      let* self := M.alloc self in
      let* other := M.alloc other in
      let* x : Ty.path "u8" :=
        let* Œ±0 :
            Ty.function
              [Ty.apply (Ty.path "ref") [Ty.path "u8"];
                Ty.apply (Ty.path "ref") [Ty.path "u8"]]
              _ :=
          ltac:(M.get_method (fun ‚Ñê =>
            core.ops.bit.BitXor.bitxor
              (Self := Ty.apply (Ty.path "ref") [Ty.path "u8"])
              (Rhs := Ty.apply (Ty.path "ref") [Ty.path "u8"])
              (Trait := ‚Ñê))) in
        let* Œ±1 : Ty.apply (Ty.path "ref") [Ty.path "u8"] := M.read self in
        let* Œ±2 : Ty.apply (Ty.path "ref") [Ty.path "u8"] := M.read other in
        let* Œ±3 : Ty.path "u8" := M.call (Œ±0 Œ±1 Œ±2) in
        M.alloc Œ±3 in
      let* y : Ty.path "u8" :=
        let* Œ±0 : Ty.path "u8" := M.read x in
        let* Œ±1 : Ty.path "u8" := M.read x in
        let* Œ±2 : Ty.path "u8" :=
          M.call ((Ty.path "u8")::["wrapping_neg"] Œ±1) in
        let* Œ±3 : Ty.path "i32" :=
          BinOp.Panic.sub
            ((Integer.of_Z 8) : Ty.path "i32")
            ((Integer.of_Z 1) : Ty.path "i32") in
        let* Œ±4 : Ty.path "u8" :=
          BinOp.Panic.shr (BinOp.Pure.bit_or Œ±0 Œ±2) Œ±3 in
        M.alloc Œ±4 in
      let* Œ±0 :
          Ty.function [Ty.path "u8"] (Ty.apply (Ty.path "subtle::Choice") []) :=
        ltac:(M.get_method (fun ‚Ñê =>
          core.convert.Into.into
            (Self := Ty.path "u8")
            (T := Ty.apply (Ty.path "subtle::Choice") [])
            (Trait := ‚Ñê))) in
      let* Œ±1 : Ty.path "u8" := M.read y in
      let* Œ±2 : Ty.path "u8" := M.alloc ((Integer.of_Z 1) : Ty.path "u8") in
      let* Œ±3 : Ty.path "u8" := M.read (use Œ±2) in
      let* Œ±4 : Ty.path "u8" := M.alloc (BinOp.Pure.bit_xor Œ±1 Œ±3) in
      let* Œ±5 : Ty.path "u8" := M.read (use Œ±4) in
      let* Œ±6 : Ty.apply (Ty.path "subtle::Choice") [] := M.call (Œ±0 Œ±5) in
      let* Œ±0 : Ty.apply (Ty.path "subtle::Choice") [] := M.alloc Œ±6 in
      M.read Œ±0
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_ct_eq : Instance.t := {
    Notations.double_colon := ct_eq;
  }.
  
  Definition ‚Ñê : Instance.t := [("ct_eq", ct_eq); ("ct_ne", ct_ne)].
End Impl_subtle_ConstantTimeEq_for_u8.
End Impl_subtle_ConstantTimeEq_for_u8.

Module  Impl_subtle_ConstantTimeEq_for_i8.
Section Impl_subtle_ConstantTimeEq_for_i8.
  Definition Self : Ty.t := Ty.path "i8".
  
  (*
              fn ct_eq(&self, other: &$t_i) -> Choice {
                  // Bitcast to unsigned and call that implementation.
                  ( *self as $t_u).ct_eq(&( *other as $t_u))
              }
  *)
  Definition ct_eq (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self; other] =>
      let* self := M.alloc self in
      let* other := M.alloc other in
      let* Œ±0 :
          Ty.function
            [Ty.apply (Ty.path "ref") [Ty.path "u8"];
              Ty.apply (Ty.path "ref") [Ty.path "u8"]]
            (Ty.apply (Ty.path "subtle::Choice") []) :=
        ltac:(M.get_method (fun ‚Ñê =>
          subtle.ConstantTimeEq.ct_eq (Self := Ty.path "u8") (Trait := ‚Ñê))) in
      let* Œ±1 : Ty.apply (Ty.path "ref") [Ty.path "i8"] := M.read self in
      let* Œ±2 : Ty.path "i8" := M.read (deref Œ±1) in
      let* Œ±3 : Ty.path "u8" := M.alloc (rust_cast Œ±2) in
      let* Œ±4 : Ty.apply (Ty.path "ref") [Ty.path "i8"] := M.read other in
      let* Œ±5 : Ty.path "i8" := M.read (deref Œ±4) in
      let* Œ±6 : Ty.path "u8" := M.alloc (rust_cast Œ±5) in
      M.call (Œ±0 (borrow Œ±3) (borrow Œ±6))
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_ct_eq : Instance.t := {
    Notations.double_colon := ct_eq;
  }.
  
  Definition ‚Ñê : Instance.t := [("ct_eq", ct_eq); ("ct_ne", ct_ne)].
End Impl_subtle_ConstantTimeEq_for_i8.
End Impl_subtle_ConstantTimeEq_for_i8.

Module  Impl_subtle_ConstantTimeEq_for_u16.
Section Impl_subtle_ConstantTimeEq_for_u16.
  Definition Self : Ty.t := Ty.path "u16".
  
  (*
              fn ct_eq(&self, other: &$t_u) -> Choice {
                  // x == 0 if and only if self == other
                  let x: $t_u = self ^ other;
  
                  // If x == 0, then x and -x are both equal to zero;
                  // otherwise, one or both will have its high bit set.
                  let y: $t_u = (x | x.wrapping_neg()) >> ($bit_width - 1);
  
                  // Result is the opposite of the high bit (now shifted to low).
                  ((y ^ (1 as $t_u)) as u8).into()
              }
  *)
  Definition ct_eq (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self; other] =>
      let* self := M.alloc self in
      let* other := M.alloc other in
      let* x : Ty.path "u16" :=
        let* Œ±0 :
            Ty.function
              [Ty.apply (Ty.path "ref") [Ty.path "u16"];
                Ty.apply (Ty.path "ref") [Ty.path "u16"]]
              _ :=
          ltac:(M.get_method (fun ‚Ñê =>
            core.ops.bit.BitXor.bitxor
              (Self := Ty.apply (Ty.path "ref") [Ty.path "u16"])
              (Rhs := Ty.apply (Ty.path "ref") [Ty.path "u16"])
              (Trait := ‚Ñê))) in
        let* Œ±1 : Ty.apply (Ty.path "ref") [Ty.path "u16"] := M.read self in
        let* Œ±2 : Ty.apply (Ty.path "ref") [Ty.path "u16"] := M.read other in
        let* Œ±3 : Ty.path "u16" := M.call (Œ±0 Œ±1 Œ±2) in
        M.alloc Œ±3 in
      let* y : Ty.path "u16" :=
        let* Œ±0 : Ty.path "u16" := M.read x in
        let* Œ±1 : Ty.path "u16" := M.read x in
        let* Œ±2 : Ty.path "u16" :=
          M.call ((Ty.path "u16")::["wrapping_neg"] Œ±1) in
        let* Œ±3 : Ty.path "i32" :=
          BinOp.Panic.sub
            ((Integer.of_Z 16) : Ty.path "i32")
            ((Integer.of_Z 1) : Ty.path "i32") in
        let* Œ±4 : Ty.path "u16" :=
          BinOp.Panic.shr (BinOp.Pure.bit_or Œ±0 Œ±2) Œ±3 in
        M.alloc Œ±4 in
      let* Œ±0 :
          Ty.function [Ty.path "u8"] (Ty.apply (Ty.path "subtle::Choice") []) :=
        ltac:(M.get_method (fun ‚Ñê =>
          core.convert.Into.into
            (Self := Ty.path "u8")
            (T := Ty.apply (Ty.path "subtle::Choice") [])
            (Trait := ‚Ñê))) in
      let* Œ±1 : Ty.path "u16" := M.read y in
      let* Œ±2 : Ty.path "u16" := M.alloc ((Integer.of_Z 1) : Ty.path "u16") in
      let* Œ±3 : Ty.path "u16" := M.read (use Œ±2) in
      let* Œ±4 : Ty.apply (Ty.path "subtle::Choice") [] :=
        M.call (Œ±0 (rust_cast (BinOp.Pure.bit_xor Œ±1 Œ±3))) in
      let* Œ±0 : Ty.apply (Ty.path "subtle::Choice") [] := M.alloc Œ±4 in
      M.read Œ±0
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_ct_eq : Instance.t := {
    Notations.double_colon := ct_eq;
  }.
  
  Definition ‚Ñê : Instance.t := [("ct_eq", ct_eq); ("ct_ne", ct_ne)].
End Impl_subtle_ConstantTimeEq_for_u16.
End Impl_subtle_ConstantTimeEq_for_u16.

Module  Impl_subtle_ConstantTimeEq_for_i16.
Section Impl_subtle_ConstantTimeEq_for_i16.
  Definition Self : Ty.t := Ty.path "i16".
  
  (*
              fn ct_eq(&self, other: &$t_i) -> Choice {
                  // Bitcast to unsigned and call that implementation.
                  ( *self as $t_u).ct_eq(&( *other as $t_u))
              }
  *)
  Definition ct_eq (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self; other] =>
      let* self := M.alloc self in
      let* other := M.alloc other in
      let* Œ±0 :
          Ty.function
            [Ty.apply (Ty.path "ref") [Ty.path "u16"];
              Ty.apply (Ty.path "ref") [Ty.path "u16"]]
            (Ty.apply (Ty.path "subtle::Choice") []) :=
        ltac:(M.get_method (fun ‚Ñê =>
          subtle.ConstantTimeEq.ct_eq (Self := Ty.path "u16") (Trait := ‚Ñê))) in
      let* Œ±1 : Ty.apply (Ty.path "ref") [Ty.path "i16"] := M.read self in
      let* Œ±2 : Ty.path "i16" := M.read (deref Œ±1) in
      let* Œ±3 : Ty.path "u16" := M.alloc (rust_cast Œ±2) in
      let* Œ±4 : Ty.apply (Ty.path "ref") [Ty.path "i16"] := M.read other in
      let* Œ±5 : Ty.path "i16" := M.read (deref Œ±4) in
      let* Œ±6 : Ty.path "u16" := M.alloc (rust_cast Œ±5) in
      M.call (Œ±0 (borrow Œ±3) (borrow Œ±6))
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_ct_eq : Instance.t := {
    Notations.double_colon := ct_eq;
  }.
  
  Definition ‚Ñê : Instance.t := [("ct_eq", ct_eq); ("ct_ne", ct_ne)].
End Impl_subtle_ConstantTimeEq_for_i16.
End Impl_subtle_ConstantTimeEq_for_i16.

Module  Impl_subtle_ConstantTimeEq_for_u32.
Section Impl_subtle_ConstantTimeEq_for_u32.
  Definition Self : Ty.t := Ty.path "u32".
  
  (*
              fn ct_eq(&self, other: &$t_u) -> Choice {
                  // x == 0 if and only if self == other
                  let x: $t_u = self ^ other;
  
                  // If x == 0, then x and -x are both equal to zero;
                  // otherwise, one or both will have its high bit set.
                  let y: $t_u = (x | x.wrapping_neg()) >> ($bit_width - 1);
  
                  // Result is the opposite of the high bit (now shifted to low).
                  ((y ^ (1 as $t_u)) as u8).into()
              }
  *)
  Definition ct_eq (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self; other] =>
      let* self := M.alloc self in
      let* other := M.alloc other in
      let* x : Ty.path "u32" :=
        let* Œ±0 :
            Ty.function
              [Ty.apply (Ty.path "ref") [Ty.path "u32"];
                Ty.apply (Ty.path "ref") [Ty.path "u32"]]
              _ :=
          ltac:(M.get_method (fun ‚Ñê =>
            core.ops.bit.BitXor.bitxor
              (Self := Ty.apply (Ty.path "ref") [Ty.path "u32"])
              (Rhs := Ty.apply (Ty.path "ref") [Ty.path "u32"])
              (Trait := ‚Ñê))) in
        let* Œ±1 : Ty.apply (Ty.path "ref") [Ty.path "u32"] := M.read self in
        let* Œ±2 : Ty.apply (Ty.path "ref") [Ty.path "u32"] := M.read other in
        let* Œ±3 : Ty.path "u32" := M.call (Œ±0 Œ±1 Œ±2) in
        M.alloc Œ±3 in
      let* y : Ty.path "u32" :=
        let* Œ±0 : Ty.path "u32" := M.read x in
        let* Œ±1 : Ty.path "u32" := M.read x in
        let* Œ±2 : Ty.path "u32" :=
          M.call ((Ty.path "u32")::["wrapping_neg"] Œ±1) in
        let* Œ±3 : Ty.path "i32" :=
          BinOp.Panic.sub
            ((Integer.of_Z 32) : Ty.path "i32")
            ((Integer.of_Z 1) : Ty.path "i32") in
        let* Œ±4 : Ty.path "u32" :=
          BinOp.Panic.shr (BinOp.Pure.bit_or Œ±0 Œ±2) Œ±3 in
        M.alloc Œ±4 in
      let* Œ±0 :
          Ty.function [Ty.path "u8"] (Ty.apply (Ty.path "subtle::Choice") []) :=
        ltac:(M.get_method (fun ‚Ñê =>
          core.convert.Into.into
            (Self := Ty.path "u8")
            (T := Ty.apply (Ty.path "subtle::Choice") [])
            (Trait := ‚Ñê))) in
      let* Œ±1 : Ty.path "u32" := M.read y in
      let* Œ±2 : Ty.path "u32" := M.alloc ((Integer.of_Z 1) : Ty.path "u32") in
      let* Œ±3 : Ty.path "u32" := M.read (use Œ±2) in
      let* Œ±4 : Ty.apply (Ty.path "subtle::Choice") [] :=
        M.call (Œ±0 (rust_cast (BinOp.Pure.bit_xor Œ±1 Œ±3))) in
      let* Œ±0 : Ty.apply (Ty.path "subtle::Choice") [] := M.alloc Œ±4 in
      M.read Œ±0
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_ct_eq : Instance.t := {
    Notations.double_colon := ct_eq;
  }.
  
  Definition ‚Ñê : Instance.t := [("ct_eq", ct_eq); ("ct_ne", ct_ne)].
End Impl_subtle_ConstantTimeEq_for_u32.
End Impl_subtle_ConstantTimeEq_for_u32.

Module  Impl_subtle_ConstantTimeEq_for_i32.
Section Impl_subtle_ConstantTimeEq_for_i32.
  Definition Self : Ty.t := Ty.path "i32".
  
  (*
              fn ct_eq(&self, other: &$t_i) -> Choice {
                  // Bitcast to unsigned and call that implementation.
                  ( *self as $t_u).ct_eq(&( *other as $t_u))
              }
  *)
  Definition ct_eq (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self; other] =>
      let* self := M.alloc self in
      let* other := M.alloc other in
      let* Œ±0 :
          Ty.function
            [Ty.apply (Ty.path "ref") [Ty.path "u32"];
              Ty.apply (Ty.path "ref") [Ty.path "u32"]]
            (Ty.apply (Ty.path "subtle::Choice") []) :=
        ltac:(M.get_method (fun ‚Ñê =>
          subtle.ConstantTimeEq.ct_eq (Self := Ty.path "u32") (Trait := ‚Ñê))) in
      let* Œ±1 : Ty.apply (Ty.path "ref") [Ty.path "i32"] := M.read self in
      let* Œ±2 : Ty.path "i32" := M.read (deref Œ±1) in
      let* Œ±3 : Ty.path "u32" := M.alloc (rust_cast Œ±2) in
      let* Œ±4 : Ty.apply (Ty.path "ref") [Ty.path "i32"] := M.read other in
      let* Œ±5 : Ty.path "i32" := M.read (deref Œ±4) in
      let* Œ±6 : Ty.path "u32" := M.alloc (rust_cast Œ±5) in
      M.call (Œ±0 (borrow Œ±3) (borrow Œ±6))
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_ct_eq : Instance.t := {
    Notations.double_colon := ct_eq;
  }.
  
  Definition ‚Ñê : Instance.t := [("ct_eq", ct_eq); ("ct_ne", ct_ne)].
End Impl_subtle_ConstantTimeEq_for_i32.
End Impl_subtle_ConstantTimeEq_for_i32.

Module  Impl_subtle_ConstantTimeEq_for_u64.
Section Impl_subtle_ConstantTimeEq_for_u64.
  Definition Self : Ty.t := Ty.path "u64".
  
  (*
              fn ct_eq(&self, other: &$t_u) -> Choice {
                  // x == 0 if and only if self == other
                  let x: $t_u = self ^ other;
  
                  // If x == 0, then x and -x are both equal to zero;
                  // otherwise, one or both will have its high bit set.
                  let y: $t_u = (x | x.wrapping_neg()) >> ($bit_width - 1);
  
                  // Result is the opposite of the high bit (now shifted to low).
                  ((y ^ (1 as $t_u)) as u8).into()
              }
  *)
  Definition ct_eq (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self; other] =>
      let* self := M.alloc self in
      let* other := M.alloc other in
      let* x : Ty.path "u64" :=
        let* Œ±0 :
            Ty.function
              [Ty.apply (Ty.path "ref") [Ty.path "u64"];
                Ty.apply (Ty.path "ref") [Ty.path "u64"]]
              _ :=
          ltac:(M.get_method (fun ‚Ñê =>
            core.ops.bit.BitXor.bitxor
              (Self := Ty.apply (Ty.path "ref") [Ty.path "u64"])
              (Rhs := Ty.apply (Ty.path "ref") [Ty.path "u64"])
              (Trait := ‚Ñê))) in
        let* Œ±1 : Ty.apply (Ty.path "ref") [Ty.path "u64"] := M.read self in
        let* Œ±2 : Ty.apply (Ty.path "ref") [Ty.path "u64"] := M.read other in
        let* Œ±3 : Ty.path "u64" := M.call (Œ±0 Œ±1 Œ±2) in
        M.alloc Œ±3 in
      let* y : Ty.path "u64" :=
        let* Œ±0 : Ty.path "u64" := M.read x in
        let* Œ±1 : Ty.path "u64" := M.read x in
        let* Œ±2 : Ty.path "u64" :=
          M.call ((Ty.path "u64")::["wrapping_neg"] Œ±1) in
        let* Œ±3 : Ty.path "i32" :=
          BinOp.Panic.sub
            ((Integer.of_Z 64) : Ty.path "i32")
            ((Integer.of_Z 1) : Ty.path "i32") in
        let* Œ±4 : Ty.path "u64" :=
          BinOp.Panic.shr (BinOp.Pure.bit_or Œ±0 Œ±2) Œ±3 in
        M.alloc Œ±4 in
      let* Œ±0 :
          Ty.function [Ty.path "u8"] (Ty.apply (Ty.path "subtle::Choice") []) :=
        ltac:(M.get_method (fun ‚Ñê =>
          core.convert.Into.into
            (Self := Ty.path "u8")
            (T := Ty.apply (Ty.path "subtle::Choice") [])
            (Trait := ‚Ñê))) in
      let* Œ±1 : Ty.path "u64" := M.read y in
      let* Œ±2 : Ty.path "u64" := M.alloc ((Integer.of_Z 1) : Ty.path "u64") in
      let* Œ±3 : Ty.path "u64" := M.read (use Œ±2) in
      let* Œ±4 : Ty.apply (Ty.path "subtle::Choice") [] :=
        M.call (Œ±0 (rust_cast (BinOp.Pure.bit_xor Œ±1 Œ±3))) in
      let* Œ±0 : Ty.apply (Ty.path "subtle::Choice") [] := M.alloc Œ±4 in
      M.read Œ±0
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_ct_eq : Instance.t := {
    Notations.double_colon := ct_eq;
  }.
  
  Definition ‚Ñê : Instance.t := [("ct_eq", ct_eq); ("ct_ne", ct_ne)].
End Impl_subtle_ConstantTimeEq_for_u64.
End Impl_subtle_ConstantTimeEq_for_u64.

Module  Impl_subtle_ConstantTimeEq_for_i64.
Section Impl_subtle_ConstantTimeEq_for_i64.
  Definition Self : Ty.t := Ty.path "i64".
  
  (*
              fn ct_eq(&self, other: &$t_i) -> Choice {
                  // Bitcast to unsigned and call that implementation.
                  ( *self as $t_u).ct_eq(&( *other as $t_u))
              }
  *)
  Definition ct_eq (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self; other] =>
      let* self := M.alloc self in
      let* other := M.alloc other in
      let* Œ±0 :
          Ty.function
            [Ty.apply (Ty.path "ref") [Ty.path "u64"];
              Ty.apply (Ty.path "ref") [Ty.path "u64"]]
            (Ty.apply (Ty.path "subtle::Choice") []) :=
        ltac:(M.get_method (fun ‚Ñê =>
          subtle.ConstantTimeEq.ct_eq (Self := Ty.path "u64") (Trait := ‚Ñê))) in
      let* Œ±1 : Ty.apply (Ty.path "ref") [Ty.path "i64"] := M.read self in
      let* Œ±2 : Ty.path "i64" := M.read (deref Œ±1) in
      let* Œ±3 : Ty.path "u64" := M.alloc (rust_cast Œ±2) in
      let* Œ±4 : Ty.apply (Ty.path "ref") [Ty.path "i64"] := M.read other in
      let* Œ±5 : Ty.path "i64" := M.read (deref Œ±4) in
      let* Œ±6 : Ty.path "u64" := M.alloc (rust_cast Œ±5) in
      M.call (Œ±0 (borrow Œ±3) (borrow Œ±6))
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_ct_eq : Instance.t := {
    Notations.double_colon := ct_eq;
  }.
  
  Definition ‚Ñê : Instance.t := [("ct_eq", ct_eq); ("ct_ne", ct_ne)].
End Impl_subtle_ConstantTimeEq_for_i64.
End Impl_subtle_ConstantTimeEq_for_i64.

Module  Impl_subtle_ConstantTimeEq_for_usize.
Section Impl_subtle_ConstantTimeEq_for_usize.
  Definition Self : Ty.t := Ty.path "usize".
  
  (*
              fn ct_eq(&self, other: &$t_u) -> Choice {
                  // x == 0 if and only if self == other
                  let x: $t_u = self ^ other;
  
                  // If x == 0, then x and -x are both equal to zero;
                  // otherwise, one or both will have its high bit set.
                  let y: $t_u = (x | x.wrapping_neg()) >> ($bit_width - 1);
  
                  // Result is the opposite of the high bit (now shifted to low).
                  ((y ^ (1 as $t_u)) as u8).into()
              }
  *)
  Definition ct_eq (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self; other] =>
      let* self := M.alloc self in
      let* other := M.alloc other in
      let* x : Ty.path "usize" :=
        let* Œ±0 :
            Ty.function
              [Ty.apply (Ty.path "ref") [Ty.path "usize"];
                Ty.apply (Ty.path "ref") [Ty.path "usize"]]
              _ :=
          ltac:(M.get_method (fun ‚Ñê =>
            core.ops.bit.BitXor.bitxor
              (Self := Ty.apply (Ty.path "ref") [Ty.path "usize"])
              (Rhs := Ty.apply (Ty.path "ref") [Ty.path "usize"])
              (Trait := ‚Ñê))) in
        let* Œ±1 : Ty.apply (Ty.path "ref") [Ty.path "usize"] := M.read self in
        let* Œ±2 : Ty.apply (Ty.path "ref") [Ty.path "usize"] := M.read other in
        let* Œ±3 : Ty.path "usize" := M.call (Œ±0 Œ±1 Œ±2) in
        M.alloc Œ±3 in
      let* y : Ty.path "usize" :=
        let* Œ±0 : Ty.path "usize" := M.read x in
        let* Œ±1 : Ty.path "usize" := M.read x in
        let* Œ±2 : Ty.path "usize" :=
          M.call ((Ty.path "usize")::["wrapping_neg"] Œ±1) in
        let* Œ±3 : Ty.path "usize" := M.call core.mem.size_of in
        let* Œ±4 : Ty.path "usize" :=
          BinOp.Panic.mul Œ±3 ((Integer.of_Z 8) : Ty.path "usize") in
        let* Œ±5 : Ty.path "usize" :=
          BinOp.Panic.sub Œ±4 ((Integer.of_Z 1) : Ty.path "usize") in
        let* Œ±6 : Ty.path "usize" :=
          BinOp.Panic.shr (BinOp.Pure.bit_or Œ±0 Œ±2) Œ±5 in
        M.alloc Œ±6 in
      let* Œ±0 :
          Ty.function [Ty.path "u8"] (Ty.apply (Ty.path "subtle::Choice") []) :=
        ltac:(M.get_method (fun ‚Ñê =>
          core.convert.Into.into
            (Self := Ty.path "u8")
            (T := Ty.apply (Ty.path "subtle::Choice") [])
            (Trait := ‚Ñê))) in
      let* Œ±1 : Ty.path "usize" := M.read y in
      let* Œ±2 : Ty.path "usize" :=
        M.alloc ((Integer.of_Z 1) : Ty.path "usize") in
      let* Œ±3 : Ty.path "usize" := M.read (use Œ±2) in
      let* Œ±4 : Ty.apply (Ty.path "subtle::Choice") [] :=
        M.call (Œ±0 (rust_cast (BinOp.Pure.bit_xor Œ±1 Œ±3))) in
      let* Œ±0 : Ty.apply (Ty.path "subtle::Choice") [] := M.alloc Œ±4 in
      M.read Œ±0
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_ct_eq : Instance.t := {
    Notations.double_colon := ct_eq;
  }.
  
  Definition ‚Ñê : Instance.t := [("ct_eq", ct_eq); ("ct_ne", ct_ne)].
End Impl_subtle_ConstantTimeEq_for_usize.
End Impl_subtle_ConstantTimeEq_for_usize.

Module  Impl_subtle_ConstantTimeEq_for_isize.
Section Impl_subtle_ConstantTimeEq_for_isize.
  Definition Self : Ty.t := Ty.path "isize".
  
  (*
              fn ct_eq(&self, other: &$t_i) -> Choice {
                  // Bitcast to unsigned and call that implementation.
                  ( *self as $t_u).ct_eq(&( *other as $t_u))
              }
  *)
  Definition ct_eq (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self; other] =>
      let* self := M.alloc self in
      let* other := M.alloc other in
      let* Œ±0 :
          Ty.function
            [Ty.apply (Ty.path "ref") [Ty.path "usize"];
              Ty.apply (Ty.path "ref") [Ty.path "usize"]]
            (Ty.apply (Ty.path "subtle::Choice") []) :=
        ltac:(M.get_method (fun ‚Ñê =>
          subtle.ConstantTimeEq.ct_eq
            (Self := Ty.path "usize")
            (Trait := ‚Ñê))) in
      let* Œ±1 : Ty.apply (Ty.path "ref") [Ty.path "isize"] := M.read self in
      let* Œ±2 : Ty.path "isize" := M.read (deref Œ±1) in
      let* Œ±3 : Ty.path "usize" := M.alloc (rust_cast Œ±2) in
      let* Œ±4 : Ty.apply (Ty.path "ref") [Ty.path "isize"] := M.read other in
      let* Œ±5 : Ty.path "isize" := M.read (deref Œ±4) in
      let* Œ±6 : Ty.path "usize" := M.alloc (rust_cast Œ±5) in
      M.call (Œ±0 (borrow Œ±3) (borrow Œ±6))
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_ct_eq : Instance.t := {
    Notations.double_colon := ct_eq;
  }.
  
  Definition ‚Ñê : Instance.t := [("ct_eq", ct_eq); ("ct_ne", ct_ne)].
End Impl_subtle_ConstantTimeEq_for_isize.
End Impl_subtle_ConstantTimeEq_for_isize.

Module  ConditionallySelectable.
Section ConditionallySelectable.
  Class Trait (Self : Set) : Type := {
    conditional_select :
      Ty.function
        [Ty.apply (Ty.path "ref") [Self];
          Ty.apply (Ty.path "ref") [Self];
          Ty.apply (Ty.path "subtle::Choice") []]
        Self;
  }.
  
End ConditionallySelectable.
End ConditionallySelectable.

Module  Impl_subtle_ConditionallySelectable_for_u8.
Section Impl_subtle_ConditionallySelectable_for_u8.
  Definition Self : Ty.t := Ty.path "u8".
  
  (*
              fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  a ^ (mask & (a ^ b))
              }
  *)
  Definition conditional_select (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [a; b; choice] =>
      let* a := M.alloc a in
      let* b := M.alloc b in
      let* choice := M.alloc choice in
      let* mask : Ty.path "u8" :=
        let* Œ±0 : Ty.path "u8" :=
          M.call
            ((Ty.apply (Ty.path "subtle::Choice") [])::["unwrap_u8"]
              (borrow choice)) in
        let* Œ±1 : Ty.path "i8" := UnOp.neg (rust_cast Œ±0) in
        M.alloc (rust_cast Œ±1) in
      let* Œ±0 :
          Ty.function
            [Ty.apply (Ty.path "ref") [Ty.path "u8"]; Ty.path "u8"]
            _ :=
        ltac:(M.get_method (fun ‚Ñê =>
          core.ops.bit.BitXor.bitxor
            (Self := Ty.apply (Ty.path "ref") [Ty.path "u8"])
            (Rhs := Ty.path "u8")
            (Trait := ‚Ñê))) in
      let* Œ±1 : Ty.apply (Ty.path "ref") [Ty.path "u8"] := M.read a in
      let* Œ±2 : Ty.path "u8" := M.read mask in
      let* Œ±3 :
          Ty.function
            [Ty.apply (Ty.path "ref") [Ty.path "u8"];
              Ty.apply (Ty.path "ref") [Ty.path "u8"]]
            _ :=
        ltac:(M.get_method (fun ‚Ñê =>
          core.ops.bit.BitXor.bitxor
            (Self := Ty.apply (Ty.path "ref") [Ty.path "u8"])
            (Rhs := Ty.apply (Ty.path "ref") [Ty.path "u8"])
            (Trait := ‚Ñê))) in
      let* Œ±4 : Ty.apply (Ty.path "ref") [Ty.path "u8"] := M.read a in
      let* Œ±5 : Ty.apply (Ty.path "ref") [Ty.path "u8"] := M.read b in
      let* Œ±6 : Ty.path "u8" := M.call (Œ±3 Œ±4 Œ±5) in
      let* Œ±7 : Ty.path "u8" := M.call (Œ±0 Œ±1 (BinOp.Pure.bit_and Œ±2 Œ±6)) in
      let* Œ±0 : Ty.path "u8" := M.alloc Œ±7 in
      M.read Œ±0
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_conditional_select : Instance.t := {
    Notations.double_colon := conditional_select;
  }.
  
  (*
              fn conditional_assign(&mut self, other: &Self, choice: Choice) {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  *self ^= mask & ( *self ^ *other);
              }
  *)
  Definition conditional_assign (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self; other; choice] =>
      let* self := M.alloc self in
      let* other := M.alloc other in
      let* choice := M.alloc choice in
      let* mask : Ty.path "u8" :=
        let* Œ±0 : Ty.path "u8" :=
          M.call
            ((Ty.apply (Ty.path "subtle::Choice") [])::["unwrap_u8"]
              (borrow choice)) in
        let* Œ±1 : Ty.path "i8" := UnOp.neg (rust_cast Œ±0) in
        M.alloc (rust_cast Œ±1) in
      let* _ : Ty.tuple :=
        let* Œ≤ : Ty.path "u8" :=
          let* Œ±0 : Ty.apply (Ty.path "mut_ref") [Ty.path "u8"] :=
            M.read self in
          M.pure (deref Œ±0) in
        let* Œ±0 := M.read Œ≤ in
        let* Œ±1 : Ty.path "u8" := M.read mask in
        let* Œ±2 : Ty.apply (Ty.path "mut_ref") [Ty.path "u8"] := M.read self in
        let* Œ±3 : Ty.path "u8" := M.read (deref Œ±2) in
        let* Œ±4 : Ty.apply (Ty.path "ref") [Ty.path "u8"] := M.read other in
        let* Œ±5 : Ty.path "u8" := M.read (deref Œ±4) in
        assign
          Œ≤
          (BinOp.Pure.bit_xor
            Œ±0
            (BinOp.Pure.bit_and Œ±1 (BinOp.Pure.bit_xor Œ±3 Œ±5))) in
      let* Œ±0 : Ty.path "unit" := M.alloc tt in
      M.read Œ±0
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_conditional_assign : Instance.t := {
    Notations.double_colon := conditional_assign;
  }.
  
  (*
              fn conditional_swap(a: &mut Self, b: &mut Self, choice: Choice) {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  let t = mask & ( *a ^ *b);
                  *a ^= t;
                  *b ^= t;
              }
  *)
  Definition conditional_swap (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [a; b; choice] =>
      let* a := M.alloc a in
      let* b := M.alloc b in
      let* choice := M.alloc choice in
      let* mask : Ty.path "u8" :=
        let* Œ±0 : Ty.path "u8" :=
          M.call
            ((Ty.apply (Ty.path "subtle::Choice") [])::["unwrap_u8"]
              (borrow choice)) in
        let* Œ±1 : Ty.path "i8" := UnOp.neg (rust_cast Œ±0) in
        M.alloc (rust_cast Œ±1) in
      let* t : Ty.path "u8" :=
        let* Œ±0 : Ty.path "u8" := M.read mask in
        let* Œ±1 : Ty.apply (Ty.path "mut_ref") [Ty.path "u8"] := M.read a in
        let* Œ±2 : Ty.path "u8" := M.read (deref Œ±1) in
        let* Œ±3 : Ty.apply (Ty.path "mut_ref") [Ty.path "u8"] := M.read b in
        let* Œ±4 : Ty.path "u8" := M.read (deref Œ±3) in
        M.alloc (BinOp.Pure.bit_and Œ±0 (BinOp.Pure.bit_xor Œ±2 Œ±4)) in
      let* _ : Ty.tuple :=
        let* Œ≤ : Ty.path "u8" :=
          let* Œ±0 : Ty.apply (Ty.path "mut_ref") [Ty.path "u8"] := M.read a in
          M.pure (deref Œ±0) in
        let* Œ±0 := M.read Œ≤ in
        let* Œ±1 : Ty.path "u8" := M.read t in
        assign Œ≤ (BinOp.Pure.bit_xor Œ±0 Œ±1) in
      let* _ : Ty.tuple :=
        let* Œ≤ : Ty.path "u8" :=
          let* Œ±0 : Ty.apply (Ty.path "mut_ref") [Ty.path "u8"] := M.read b in
          M.pure (deref Œ±0) in
        let* Œ±0 := M.read Œ≤ in
        let* Œ±1 : Ty.path "u8" := M.read t in
        assign Œ≤ (BinOp.Pure.bit_xor Œ±0 Œ±1) in
      let* Œ±0 : Ty.path "unit" := M.alloc tt in
      M.read Œ±0
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_conditional_swap : Instance.t := {
    Notations.double_colon := conditional_swap;
  }.
  
  Definition ‚Ñê : Instance.t := [("conditional_select", conditional_select);
    ("conditional_assign", conditional_assign);
    ("conditional_swap", conditional_swap)].
End Impl_subtle_ConditionallySelectable_for_u8.
End Impl_subtle_ConditionallySelectable_for_u8.

Module  Impl_subtle_ConditionallySelectable_for_i8.
Section Impl_subtle_ConditionallySelectable_for_i8.
  Definition Self : Ty.t := Ty.path "i8".
  
  (*
              fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  a ^ (mask & (a ^ b))
              }
  *)
  Definition conditional_select (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [a; b; choice] =>
      let* a := M.alloc a in
      let* b := M.alloc b in
      let* choice := M.alloc choice in
      let* mask : Ty.path "i8" :=
        let* Œ±0 : Ty.path "u8" :=
          M.call
            ((Ty.apply (Ty.path "subtle::Choice") [])::["unwrap_u8"]
              (borrow choice)) in
        let* Œ±1 : Ty.path "i8" := UnOp.neg (rust_cast Œ±0) in
        let* Œ±2 : Ty.path "i8" := M.alloc Œ±1 in
        M.copy (use Œ±2) in
      let* Œ±0 :
          Ty.function
            [Ty.apply (Ty.path "ref") [Ty.path "i8"]; Ty.path "i8"]
            _ :=
        ltac:(M.get_method (fun ‚Ñê =>
          core.ops.bit.BitXor.bitxor
            (Self := Ty.apply (Ty.path "ref") [Ty.path "i8"])
            (Rhs := Ty.path "i8")
            (Trait := ‚Ñê))) in
      let* Œ±1 : Ty.apply (Ty.path "ref") [Ty.path "i8"] := M.read a in
      let* Œ±2 : Ty.path "i8" := M.read mask in
      let* Œ±3 :
          Ty.function
            [Ty.apply (Ty.path "ref") [Ty.path "i8"];
              Ty.apply (Ty.path "ref") [Ty.path "i8"]]
            _ :=
        ltac:(M.get_method (fun ‚Ñê =>
          core.ops.bit.BitXor.bitxor
            (Self := Ty.apply (Ty.path "ref") [Ty.path "i8"])
            (Rhs := Ty.apply (Ty.path "ref") [Ty.path "i8"])
            (Trait := ‚Ñê))) in
      let* Œ±4 : Ty.apply (Ty.path "ref") [Ty.path "i8"] := M.read a in
      let* Œ±5 : Ty.apply (Ty.path "ref") [Ty.path "i8"] := M.read b in
      let* Œ±6 : Ty.path "i8" := M.call (Œ±3 Œ±4 Œ±5) in
      let* Œ±7 : Ty.path "i8" := M.call (Œ±0 Œ±1 (BinOp.Pure.bit_and Œ±2 Œ±6)) in
      let* Œ±0 : Ty.path "i8" := M.alloc Œ±7 in
      M.read Œ±0
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_conditional_select : Instance.t := {
    Notations.double_colon := conditional_select;
  }.
  
  (*
              fn conditional_assign(&mut self, other: &Self, choice: Choice) {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  *self ^= mask & ( *self ^ *other);
              }
  *)
  Definition conditional_assign (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self; other; choice] =>
      let* self := M.alloc self in
      let* other := M.alloc other in
      let* choice := M.alloc choice in
      let* mask : Ty.path "i8" :=
        let* Œ±0 : Ty.path "u8" :=
          M.call
            ((Ty.apply (Ty.path "subtle::Choice") [])::["unwrap_u8"]
              (borrow choice)) in
        let* Œ±1 : Ty.path "i8" := UnOp.neg (rust_cast Œ±0) in
        let* Œ±2 : Ty.path "i8" := M.alloc Œ±1 in
        M.copy (use Œ±2) in
      let* _ : Ty.tuple :=
        let* Œ≤ : Ty.path "i8" :=
          let* Œ±0 : Ty.apply (Ty.path "mut_ref") [Ty.path "i8"] :=
            M.read self in
          M.pure (deref Œ±0) in
        let* Œ±0 := M.read Œ≤ in
        let* Œ±1 : Ty.path "i8" := M.read mask in
        let* Œ±2 : Ty.apply (Ty.path "mut_ref") [Ty.path "i8"] := M.read self in
        let* Œ±3 : Ty.path "i8" := M.read (deref Œ±2) in
        let* Œ±4 : Ty.apply (Ty.path "ref") [Ty.path "i8"] := M.read other in
        let* Œ±5 : Ty.path "i8" := M.read (deref Œ±4) in
        assign
          Œ≤
          (BinOp.Pure.bit_xor
            Œ±0
            (BinOp.Pure.bit_and Œ±1 (BinOp.Pure.bit_xor Œ±3 Œ±5))) in
      let* Œ±0 : Ty.path "unit" := M.alloc tt in
      M.read Œ±0
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_conditional_assign : Instance.t := {
    Notations.double_colon := conditional_assign;
  }.
  
  (*
              fn conditional_swap(a: &mut Self, b: &mut Self, choice: Choice) {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  let t = mask & ( *a ^ *b);
                  *a ^= t;
                  *b ^= t;
              }
  *)
  Definition conditional_swap (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [a; b; choice] =>
      let* a := M.alloc a in
      let* b := M.alloc b in
      let* choice := M.alloc choice in
      let* mask : Ty.path "i8" :=
        let* Œ±0 : Ty.path "u8" :=
          M.call
            ((Ty.apply (Ty.path "subtle::Choice") [])::["unwrap_u8"]
              (borrow choice)) in
        let* Œ±1 : Ty.path "i8" := UnOp.neg (rust_cast Œ±0) in
        let* Œ±2 : Ty.path "i8" := M.alloc Œ±1 in
        M.copy (use Œ±2) in
      let* t : Ty.path "i8" :=
        let* Œ±0 : Ty.path "i8" := M.read mask in
        let* Œ±1 : Ty.apply (Ty.path "mut_ref") [Ty.path "i8"] := M.read a in
        let* Œ±2 : Ty.path "i8" := M.read (deref Œ±1) in
        let* Œ±3 : Ty.apply (Ty.path "mut_ref") [Ty.path "i8"] := M.read b in
        let* Œ±4 : Ty.path "i8" := M.read (deref Œ±3) in
        M.alloc (BinOp.Pure.bit_and Œ±0 (BinOp.Pure.bit_xor Œ±2 Œ±4)) in
      let* _ : Ty.tuple :=
        let* Œ≤ : Ty.path "i8" :=
          let* Œ±0 : Ty.apply (Ty.path "mut_ref") [Ty.path "i8"] := M.read a in
          M.pure (deref Œ±0) in
        let* Œ±0 := M.read Œ≤ in
        let* Œ±1 : Ty.path "i8" := M.read t in
        assign Œ≤ (BinOp.Pure.bit_xor Œ±0 Œ±1) in
      let* _ : Ty.tuple :=
        let* Œ≤ : Ty.path "i8" :=
          let* Œ±0 : Ty.apply (Ty.path "mut_ref") [Ty.path "i8"] := M.read b in
          M.pure (deref Œ±0) in
        let* Œ±0 := M.read Œ≤ in
        let* Œ±1 : Ty.path "i8" := M.read t in
        assign Œ≤ (BinOp.Pure.bit_xor Œ±0 Œ±1) in
      let* Œ±0 : Ty.path "unit" := M.alloc tt in
      M.read Œ±0
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_conditional_swap : Instance.t := {
    Notations.double_colon := conditional_swap;
  }.
  
  Definition ‚Ñê : Instance.t := [("conditional_select", conditional_select);
    ("conditional_assign", conditional_assign);
    ("conditional_swap", conditional_swap)].
End Impl_subtle_ConditionallySelectable_for_i8.
End Impl_subtle_ConditionallySelectable_for_i8.

Module  Impl_subtle_ConditionallySelectable_for_u16.
Section Impl_subtle_ConditionallySelectable_for_u16.
  Definition Self : Ty.t := Ty.path "u16".
  
  (*
              fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  a ^ (mask & (a ^ b))
              }
  *)
  Definition conditional_select (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [a; b; choice] =>
      let* a := M.alloc a in
      let* b := M.alloc b in
      let* choice := M.alloc choice in
      let* mask : Ty.path "u16" :=
        let* Œ±0 : Ty.path "u8" :=
          M.call
            ((Ty.apply (Ty.path "subtle::Choice") [])::["unwrap_u8"]
              (borrow choice)) in
        let* Œ±1 : Ty.path "i16" := UnOp.neg (rust_cast Œ±0) in
        M.alloc (rust_cast Œ±1) in
      let* Œ±0 :
          Ty.function
            [Ty.apply (Ty.path "ref") [Ty.path "u16"]; Ty.path "u16"]
            _ :=
        ltac:(M.get_method (fun ‚Ñê =>
          core.ops.bit.BitXor.bitxor
            (Self := Ty.apply (Ty.path "ref") [Ty.path "u16"])
            (Rhs := Ty.path "u16")
            (Trait := ‚Ñê))) in
      let* Œ±1 : Ty.apply (Ty.path "ref") [Ty.path "u16"] := M.read a in
      let* Œ±2 : Ty.path "u16" := M.read mask in
      let* Œ±3 :
          Ty.function
            [Ty.apply (Ty.path "ref") [Ty.path "u16"];
              Ty.apply (Ty.path "ref") [Ty.path "u16"]]
            _ :=
        ltac:(M.get_method (fun ‚Ñê =>
          core.ops.bit.BitXor.bitxor
            (Self := Ty.apply (Ty.path "ref") [Ty.path "u16"])
            (Rhs := Ty.apply (Ty.path "ref") [Ty.path "u16"])
            (Trait := ‚Ñê))) in
      let* Œ±4 : Ty.apply (Ty.path "ref") [Ty.path "u16"] := M.read a in
      let* Œ±5 : Ty.apply (Ty.path "ref") [Ty.path "u16"] := M.read b in
      let* Œ±6 : Ty.path "u16" := M.call (Œ±3 Œ±4 Œ±5) in
      let* Œ±7 : Ty.path "u16" := M.call (Œ±0 Œ±1 (BinOp.Pure.bit_and Œ±2 Œ±6)) in
      let* Œ±0 : Ty.path "u16" := M.alloc Œ±7 in
      M.read Œ±0
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_conditional_select : Instance.t := {
    Notations.double_colon := conditional_select;
  }.
  
  (*
              fn conditional_assign(&mut self, other: &Self, choice: Choice) {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  *self ^= mask & ( *self ^ *other);
              }
  *)
  Definition conditional_assign (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self; other; choice] =>
      let* self := M.alloc self in
      let* other := M.alloc other in
      let* choice := M.alloc choice in
      let* mask : Ty.path "u16" :=
        let* Œ±0 : Ty.path "u8" :=
          M.call
            ((Ty.apply (Ty.path "subtle::Choice") [])::["unwrap_u8"]
              (borrow choice)) in
        let* Œ±1 : Ty.path "i16" := UnOp.neg (rust_cast Œ±0) in
        M.alloc (rust_cast Œ±1) in
      let* _ : Ty.tuple :=
        let* Œ≤ : Ty.path "u16" :=
          let* Œ±0 : Ty.apply (Ty.path "mut_ref") [Ty.path "u16"] :=
            M.read self in
          M.pure (deref Œ±0) in
        let* Œ±0 := M.read Œ≤ in
        let* Œ±1 : Ty.path "u16" := M.read mask in
        let* Œ±2 : Ty.apply (Ty.path "mut_ref") [Ty.path "u16"] := M.read self in
        let* Œ±3 : Ty.path "u16" := M.read (deref Œ±2) in
        let* Œ±4 : Ty.apply (Ty.path "ref") [Ty.path "u16"] := M.read other in
        let* Œ±5 : Ty.path "u16" := M.read (deref Œ±4) in
        assign
          Œ≤
          (BinOp.Pure.bit_xor
            Œ±0
            (BinOp.Pure.bit_and Œ±1 (BinOp.Pure.bit_xor Œ±3 Œ±5))) in
      let* Œ±0 : Ty.path "unit" := M.alloc tt in
      M.read Œ±0
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_conditional_assign : Instance.t := {
    Notations.double_colon := conditional_assign;
  }.
  
  (*
              fn conditional_swap(a: &mut Self, b: &mut Self, choice: Choice) {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  let t = mask & ( *a ^ *b);
                  *a ^= t;
                  *b ^= t;
              }
  *)
  Definition conditional_swap (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [a; b; choice] =>
      let* a := M.alloc a in
      let* b := M.alloc b in
      let* choice := M.alloc choice in
      let* mask : Ty.path "u16" :=
        let* Œ±0 : Ty.path "u8" :=
          M.call
            ((Ty.apply (Ty.path "subtle::Choice") [])::["unwrap_u8"]
              (borrow choice)) in
        let* Œ±1 : Ty.path "i16" := UnOp.neg (rust_cast Œ±0) in
        M.alloc (rust_cast Œ±1) in
      let* t : Ty.path "u16" :=
        let* Œ±0 : Ty.path "u16" := M.read mask in
        let* Œ±1 : Ty.apply (Ty.path "mut_ref") [Ty.path "u16"] := M.read a in
        let* Œ±2 : Ty.path "u16" := M.read (deref Œ±1) in
        let* Œ±3 : Ty.apply (Ty.path "mut_ref") [Ty.path "u16"] := M.read b in
        let* Œ±4 : Ty.path "u16" := M.read (deref Œ±3) in
        M.alloc (BinOp.Pure.bit_and Œ±0 (BinOp.Pure.bit_xor Œ±2 Œ±4)) in
      let* _ : Ty.tuple :=
        let* Œ≤ : Ty.path "u16" :=
          let* Œ±0 : Ty.apply (Ty.path "mut_ref") [Ty.path "u16"] := M.read a in
          M.pure (deref Œ±0) in
        let* Œ±0 := M.read Œ≤ in
        let* Œ±1 : Ty.path "u16" := M.read t in
        assign Œ≤ (BinOp.Pure.bit_xor Œ±0 Œ±1) in
      let* _ : Ty.tuple :=
        let* Œ≤ : Ty.path "u16" :=
          let* Œ±0 : Ty.apply (Ty.path "mut_ref") [Ty.path "u16"] := M.read b in
          M.pure (deref Œ±0) in
        let* Œ±0 := M.read Œ≤ in
        let* Œ±1 : Ty.path "u16" := M.read t in
        assign Œ≤ (BinOp.Pure.bit_xor Œ±0 Œ±1) in
      let* Œ±0 : Ty.path "unit" := M.alloc tt in
      M.read Œ±0
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_conditional_swap : Instance.t := {
    Notations.double_colon := conditional_swap;
  }.
  
  Definition ‚Ñê : Instance.t := [("conditional_select", conditional_select);
    ("conditional_assign", conditional_assign);
    ("conditional_swap", conditional_swap)].
End Impl_subtle_ConditionallySelectable_for_u16.
End Impl_subtle_ConditionallySelectable_for_u16.

Module  Impl_subtle_ConditionallySelectable_for_i16.
Section Impl_subtle_ConditionallySelectable_for_i16.
  Definition Self : Ty.t := Ty.path "i16".
  
  (*
              fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  a ^ (mask & (a ^ b))
              }
  *)
  Definition conditional_select (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [a; b; choice] =>
      let* a := M.alloc a in
      let* b := M.alloc b in
      let* choice := M.alloc choice in
      let* mask : Ty.path "i16" :=
        let* Œ±0 : Ty.path "u8" :=
          M.call
            ((Ty.apply (Ty.path "subtle::Choice") [])::["unwrap_u8"]
              (borrow choice)) in
        let* Œ±1 : Ty.path "i16" := UnOp.neg (rust_cast Œ±0) in
        let* Œ±2 : Ty.path "i16" := M.alloc Œ±1 in
        M.copy (use Œ±2) in
      let* Œ±0 :
          Ty.function
            [Ty.apply (Ty.path "ref") [Ty.path "i16"]; Ty.path "i16"]
            _ :=
        ltac:(M.get_method (fun ‚Ñê =>
          core.ops.bit.BitXor.bitxor
            (Self := Ty.apply (Ty.path "ref") [Ty.path "i16"])
            (Rhs := Ty.path "i16")
            (Trait := ‚Ñê))) in
      let* Œ±1 : Ty.apply (Ty.path "ref") [Ty.path "i16"] := M.read a in
      let* Œ±2 : Ty.path "i16" := M.read mask in
      let* Œ±3 :
          Ty.function
            [Ty.apply (Ty.path "ref") [Ty.path "i16"];
              Ty.apply (Ty.path "ref") [Ty.path "i16"]]
            _ :=
        ltac:(M.get_method (fun ‚Ñê =>
          core.ops.bit.BitXor.bitxor
            (Self := Ty.apply (Ty.path "ref") [Ty.path "i16"])
            (Rhs := Ty.apply (Ty.path "ref") [Ty.path "i16"])
            (Trait := ‚Ñê))) in
      let* Œ±4 : Ty.apply (Ty.path "ref") [Ty.path "i16"] := M.read a in
      let* Œ±5 : Ty.apply (Ty.path "ref") [Ty.path "i16"] := M.read b in
      let* Œ±6 : Ty.path "i16" := M.call (Œ±3 Œ±4 Œ±5) in
      let* Œ±7 : Ty.path "i16" := M.call (Œ±0 Œ±1 (BinOp.Pure.bit_and Œ±2 Œ±6)) in
      let* Œ±0 : Ty.path "i16" := M.alloc Œ±7 in
      M.read Œ±0
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_conditional_select : Instance.t := {
    Notations.double_colon := conditional_select;
  }.
  
  (*
              fn conditional_assign(&mut self, other: &Self, choice: Choice) {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  *self ^= mask & ( *self ^ *other);
              }
  *)
  Definition conditional_assign (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self; other; choice] =>
      let* self := M.alloc self in
      let* other := M.alloc other in
      let* choice := M.alloc choice in
      let* mask : Ty.path "i16" :=
        let* Œ±0 : Ty.path "u8" :=
          M.call
            ((Ty.apply (Ty.path "subtle::Choice") [])::["unwrap_u8"]
              (borrow choice)) in
        let* Œ±1 : Ty.path "i16" := UnOp.neg (rust_cast Œ±0) in
        let* Œ±2 : Ty.path "i16" := M.alloc Œ±1 in
        M.copy (use Œ±2) in
      let* _ : Ty.tuple :=
        let* Œ≤ : Ty.path "i16" :=
          let* Œ±0 : Ty.apply (Ty.path "mut_ref") [Ty.path "i16"] :=
            M.read self in
          M.pure (deref Œ±0) in
        let* Œ±0 := M.read Œ≤ in
        let* Œ±1 : Ty.path "i16" := M.read mask in
        let* Œ±2 : Ty.apply (Ty.path "mut_ref") [Ty.path "i16"] := M.read self in
        let* Œ±3 : Ty.path "i16" := M.read (deref Œ±2) in
        let* Œ±4 : Ty.apply (Ty.path "ref") [Ty.path "i16"] := M.read other in
        let* Œ±5 : Ty.path "i16" := M.read (deref Œ±4) in
        assign
          Œ≤
          (BinOp.Pure.bit_xor
            Œ±0
            (BinOp.Pure.bit_and Œ±1 (BinOp.Pure.bit_xor Œ±3 Œ±5))) in
      let* Œ±0 : Ty.path "unit" := M.alloc tt in
      M.read Œ±0
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_conditional_assign : Instance.t := {
    Notations.double_colon := conditional_assign;
  }.
  
  (*
              fn conditional_swap(a: &mut Self, b: &mut Self, choice: Choice) {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  let t = mask & ( *a ^ *b);
                  *a ^= t;
                  *b ^= t;
              }
  *)
  Definition conditional_swap (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [a; b; choice] =>
      let* a := M.alloc a in
      let* b := M.alloc b in
      let* choice := M.alloc choice in
      let* mask : Ty.path "i16" :=
        let* Œ±0 : Ty.path "u8" :=
          M.call
            ((Ty.apply (Ty.path "subtle::Choice") [])::["unwrap_u8"]
              (borrow choice)) in
        let* Œ±1 : Ty.path "i16" := UnOp.neg (rust_cast Œ±0) in
        let* Œ±2 : Ty.path "i16" := M.alloc Œ±1 in
        M.copy (use Œ±2) in
      let* t : Ty.path "i16" :=
        let* Œ±0 : Ty.path "i16" := M.read mask in
        let* Œ±1 : Ty.apply (Ty.path "mut_ref") [Ty.path "i16"] := M.read a in
        let* Œ±2 : Ty.path "i16" := M.read (deref Œ±1) in
        let* Œ±3 : Ty.apply (Ty.path "mut_ref") [Ty.path "i16"] := M.read b in
        let* Œ±4 : Ty.path "i16" := M.read (deref Œ±3) in
        M.alloc (BinOp.Pure.bit_and Œ±0 (BinOp.Pure.bit_xor Œ±2 Œ±4)) in
      let* _ : Ty.tuple :=
        let* Œ≤ : Ty.path "i16" :=
          let* Œ±0 : Ty.apply (Ty.path "mut_ref") [Ty.path "i16"] := M.read a in
          M.pure (deref Œ±0) in
        let* Œ±0 := M.read Œ≤ in
        let* Œ±1 : Ty.path "i16" := M.read t in
        assign Œ≤ (BinOp.Pure.bit_xor Œ±0 Œ±1) in
      let* _ : Ty.tuple :=
        let* Œ≤ : Ty.path "i16" :=
          let* Œ±0 : Ty.apply (Ty.path "mut_ref") [Ty.path "i16"] := M.read b in
          M.pure (deref Œ±0) in
        let* Œ±0 := M.read Œ≤ in
        let* Œ±1 : Ty.path "i16" := M.read t in
        assign Œ≤ (BinOp.Pure.bit_xor Œ±0 Œ±1) in
      let* Œ±0 : Ty.path "unit" := M.alloc tt in
      M.read Œ±0
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_conditional_swap : Instance.t := {
    Notations.double_colon := conditional_swap;
  }.
  
  Definition ‚Ñê : Instance.t := [("conditional_select", conditional_select);
    ("conditional_assign", conditional_assign);
    ("conditional_swap", conditional_swap)].
End Impl_subtle_ConditionallySelectable_for_i16.
End Impl_subtle_ConditionallySelectable_for_i16.

Module  Impl_subtle_ConditionallySelectable_for_u32.
Section Impl_subtle_ConditionallySelectable_for_u32.
  Definition Self : Ty.t := Ty.path "u32".
  
  (*
              fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  a ^ (mask & (a ^ b))
              }
  *)
  Definition conditional_select (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [a; b; choice] =>
      let* a := M.alloc a in
      let* b := M.alloc b in
      let* choice := M.alloc choice in
      let* mask : Ty.path "u32" :=
        let* Œ±0 : Ty.path "u8" :=
          M.call
            ((Ty.apply (Ty.path "subtle::Choice") [])::["unwrap_u8"]
              (borrow choice)) in
        let* Œ±1 : Ty.path "i32" := UnOp.neg (rust_cast Œ±0) in
        M.alloc (rust_cast Œ±1) in
      let* Œ±0 :
          Ty.function
            [Ty.apply (Ty.path "ref") [Ty.path "u32"]; Ty.path "u32"]
            _ :=
        ltac:(M.get_method (fun ‚Ñê =>
          core.ops.bit.BitXor.bitxor
            (Self := Ty.apply (Ty.path "ref") [Ty.path "u32"])
            (Rhs := Ty.path "u32")
            (Trait := ‚Ñê))) in
      let* Œ±1 : Ty.apply (Ty.path "ref") [Ty.path "u32"] := M.read a in
      let* Œ±2 : Ty.path "u32" := M.read mask in
      let* Œ±3 :
          Ty.function
            [Ty.apply (Ty.path "ref") [Ty.path "u32"];
              Ty.apply (Ty.path "ref") [Ty.path "u32"]]
            _ :=
        ltac:(M.get_method (fun ‚Ñê =>
          core.ops.bit.BitXor.bitxor
            (Self := Ty.apply (Ty.path "ref") [Ty.path "u32"])
            (Rhs := Ty.apply (Ty.path "ref") [Ty.path "u32"])
            (Trait := ‚Ñê))) in
      let* Œ±4 : Ty.apply (Ty.path "ref") [Ty.path "u32"] := M.read a in
      let* Œ±5 : Ty.apply (Ty.path "ref") [Ty.path "u32"] := M.read b in
      let* Œ±6 : Ty.path "u32" := M.call (Œ±3 Œ±4 Œ±5) in
      let* Œ±7 : Ty.path "u32" := M.call (Œ±0 Œ±1 (BinOp.Pure.bit_and Œ±2 Œ±6)) in
      let* Œ±0 : Ty.path "u32" := M.alloc Œ±7 in
      M.read Œ±0
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_conditional_select : Instance.t := {
    Notations.double_colon := conditional_select;
  }.
  
  (*
              fn conditional_assign(&mut self, other: &Self, choice: Choice) {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  *self ^= mask & ( *self ^ *other);
              }
  *)
  Definition conditional_assign (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self; other; choice] =>
      let* self := M.alloc self in
      let* other := M.alloc other in
      let* choice := M.alloc choice in
      let* mask : Ty.path "u32" :=
        let* Œ±0 : Ty.path "u8" :=
          M.call
            ((Ty.apply (Ty.path "subtle::Choice") [])::["unwrap_u8"]
              (borrow choice)) in
        let* Œ±1 : Ty.path "i32" := UnOp.neg (rust_cast Œ±0) in
        M.alloc (rust_cast Œ±1) in
      let* _ : Ty.tuple :=
        let* Œ≤ : Ty.path "u32" :=
          let* Œ±0 : Ty.apply (Ty.path "mut_ref") [Ty.path "u32"] :=
            M.read self in
          M.pure (deref Œ±0) in
        let* Œ±0 := M.read Œ≤ in
        let* Œ±1 : Ty.path "u32" := M.read mask in
        let* Œ±2 : Ty.apply (Ty.path "mut_ref") [Ty.path "u32"] := M.read self in
        let* Œ±3 : Ty.path "u32" := M.read (deref Œ±2) in
        let* Œ±4 : Ty.apply (Ty.path "ref") [Ty.path "u32"] := M.read other in
        let* Œ±5 : Ty.path "u32" := M.read (deref Œ±4) in
        assign
          Œ≤
          (BinOp.Pure.bit_xor
            Œ±0
            (BinOp.Pure.bit_and Œ±1 (BinOp.Pure.bit_xor Œ±3 Œ±5))) in
      let* Œ±0 : Ty.path "unit" := M.alloc tt in
      M.read Œ±0
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_conditional_assign : Instance.t := {
    Notations.double_colon := conditional_assign;
  }.
  
  (*
              fn conditional_swap(a: &mut Self, b: &mut Self, choice: Choice) {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  let t = mask & ( *a ^ *b);
                  *a ^= t;
                  *b ^= t;
              }
  *)
  Definition conditional_swap (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [a; b; choice] =>
      let* a := M.alloc a in
      let* b := M.alloc b in
      let* choice := M.alloc choice in
      let* mask : Ty.path "u32" :=
        let* Œ±0 : Ty.path "u8" :=
          M.call
            ((Ty.apply (Ty.path "subtle::Choice") [])::["unwrap_u8"]
              (borrow choice)) in
        let* Œ±1 : Ty.path "i32" := UnOp.neg (rust_cast Œ±0) in
        M.alloc (rust_cast Œ±1) in
      let* t : Ty.path "u32" :=
        let* Œ±0 : Ty.path "u32" := M.read mask in
        let* Œ±1 : Ty.apply (Ty.path "mut_ref") [Ty.path "u32"] := M.read a in
        let* Œ±2 : Ty.path "u32" := M.read (deref Œ±1) in
        let* Œ±3 : Ty.apply (Ty.path "mut_ref") [Ty.path "u32"] := M.read b in
        let* Œ±4 : Ty.path "u32" := M.read (deref Œ±3) in
        M.alloc (BinOp.Pure.bit_and Œ±0 (BinOp.Pure.bit_xor Œ±2 Œ±4)) in
      let* _ : Ty.tuple :=
        let* Œ≤ : Ty.path "u32" :=
          let* Œ±0 : Ty.apply (Ty.path "mut_ref") [Ty.path "u32"] := M.read a in
          M.pure (deref Œ±0) in
        let* Œ±0 := M.read Œ≤ in
        let* Œ±1 : Ty.path "u32" := M.read t in
        assign Œ≤ (BinOp.Pure.bit_xor Œ±0 Œ±1) in
      let* _ : Ty.tuple :=
        let* Œ≤ : Ty.path "u32" :=
          let* Œ±0 : Ty.apply (Ty.path "mut_ref") [Ty.path "u32"] := M.read b in
          M.pure (deref Œ±0) in
        let* Œ±0 := M.read Œ≤ in
        let* Œ±1 : Ty.path "u32" := M.read t in
        assign Œ≤ (BinOp.Pure.bit_xor Œ±0 Œ±1) in
      let* Œ±0 : Ty.path "unit" := M.alloc tt in
      M.read Œ±0
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_conditional_swap : Instance.t := {
    Notations.double_colon := conditional_swap;
  }.
  
  Definition ‚Ñê : Instance.t := [("conditional_select", conditional_select);
    ("conditional_assign", conditional_assign);
    ("conditional_swap", conditional_swap)].
End Impl_subtle_ConditionallySelectable_for_u32.
End Impl_subtle_ConditionallySelectable_for_u32.

Module  Impl_subtle_ConditionallySelectable_for_i32.
Section Impl_subtle_ConditionallySelectable_for_i32.
  Definition Self : Ty.t := Ty.path "i32".
  
  (*
              fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  a ^ (mask & (a ^ b))
              }
  *)
  Definition conditional_select (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [a; b; choice] =>
      let* a := M.alloc a in
      let* b := M.alloc b in
      let* choice := M.alloc choice in
      let* mask : Ty.path "i32" :=
        let* Œ±0 : Ty.path "u8" :=
          M.call
            ((Ty.apply (Ty.path "subtle::Choice") [])::["unwrap_u8"]
              (borrow choice)) in
        let* Œ±1 : Ty.path "i32" := UnOp.neg (rust_cast Œ±0) in
        let* Œ±2 : Ty.path "i32" := M.alloc Œ±1 in
        M.copy (use Œ±2) in
      let* Œ±0 :
          Ty.function
            [Ty.apply (Ty.path "ref") [Ty.path "i32"]; Ty.path "i32"]
            _ :=
        ltac:(M.get_method (fun ‚Ñê =>
          core.ops.bit.BitXor.bitxor
            (Self := Ty.apply (Ty.path "ref") [Ty.path "i32"])
            (Rhs := Ty.path "i32")
            (Trait := ‚Ñê))) in
      let* Œ±1 : Ty.apply (Ty.path "ref") [Ty.path "i32"] := M.read a in
      let* Œ±2 : Ty.path "i32" := M.read mask in
      let* Œ±3 :
          Ty.function
            [Ty.apply (Ty.path "ref") [Ty.path "i32"];
              Ty.apply (Ty.path "ref") [Ty.path "i32"]]
            _ :=
        ltac:(M.get_method (fun ‚Ñê =>
          core.ops.bit.BitXor.bitxor
            (Self := Ty.apply (Ty.path "ref") [Ty.path "i32"])
            (Rhs := Ty.apply (Ty.path "ref") [Ty.path "i32"])
            (Trait := ‚Ñê))) in
      let* Œ±4 : Ty.apply (Ty.path "ref") [Ty.path "i32"] := M.read a in
      let* Œ±5 : Ty.apply (Ty.path "ref") [Ty.path "i32"] := M.read b in
      let* Œ±6 : Ty.path "i32" := M.call (Œ±3 Œ±4 Œ±5) in
      let* Œ±7 : Ty.path "i32" := M.call (Œ±0 Œ±1 (BinOp.Pure.bit_and Œ±2 Œ±6)) in
      let* Œ±0 : Ty.path "i32" := M.alloc Œ±7 in
      M.read Œ±0
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_conditional_select : Instance.t := {
    Notations.double_colon := conditional_select;
  }.
  
  (*
              fn conditional_assign(&mut self, other: &Self, choice: Choice) {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  *self ^= mask & ( *self ^ *other);
              }
  *)
  Definition conditional_assign (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self; other; choice] =>
      let* self := M.alloc self in
      let* other := M.alloc other in
      let* choice := M.alloc choice in
      let* mask : Ty.path "i32" :=
        let* Œ±0 : Ty.path "u8" :=
          M.call
            ((Ty.apply (Ty.path "subtle::Choice") [])::["unwrap_u8"]
              (borrow choice)) in
        let* Œ±1 : Ty.path "i32" := UnOp.neg (rust_cast Œ±0) in
        let* Œ±2 : Ty.path "i32" := M.alloc Œ±1 in
        M.copy (use Œ±2) in
      let* _ : Ty.tuple :=
        let* Œ≤ : Ty.path "i32" :=
          let* Œ±0 : Ty.apply (Ty.path "mut_ref") [Ty.path "i32"] :=
            M.read self in
          M.pure (deref Œ±0) in
        let* Œ±0 := M.read Œ≤ in
        let* Œ±1 : Ty.path "i32" := M.read mask in
        let* Œ±2 : Ty.apply (Ty.path "mut_ref") [Ty.path "i32"] := M.read self in
        let* Œ±3 : Ty.path "i32" := M.read (deref Œ±2) in
        let* Œ±4 : Ty.apply (Ty.path "ref") [Ty.path "i32"] := M.read other in
        let* Œ±5 : Ty.path "i32" := M.read (deref Œ±4) in
        assign
          Œ≤
          (BinOp.Pure.bit_xor
            Œ±0
            (BinOp.Pure.bit_and Œ±1 (BinOp.Pure.bit_xor Œ±3 Œ±5))) in
      let* Œ±0 : Ty.path "unit" := M.alloc tt in
      M.read Œ±0
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_conditional_assign : Instance.t := {
    Notations.double_colon := conditional_assign;
  }.
  
  (*
              fn conditional_swap(a: &mut Self, b: &mut Self, choice: Choice) {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  let t = mask & ( *a ^ *b);
                  *a ^= t;
                  *b ^= t;
              }
  *)
  Definition conditional_swap (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [a; b; choice] =>
      let* a := M.alloc a in
      let* b := M.alloc b in
      let* choice := M.alloc choice in
      let* mask : Ty.path "i32" :=
        let* Œ±0 : Ty.path "u8" :=
          M.call
            ((Ty.apply (Ty.path "subtle::Choice") [])::["unwrap_u8"]
              (borrow choice)) in
        let* Œ±1 : Ty.path "i32" := UnOp.neg (rust_cast Œ±0) in
        let* Œ±2 : Ty.path "i32" := M.alloc Œ±1 in
        M.copy (use Œ±2) in
      let* t : Ty.path "i32" :=
        let* Œ±0 : Ty.path "i32" := M.read mask in
        let* Œ±1 : Ty.apply (Ty.path "mut_ref") [Ty.path "i32"] := M.read a in
        let* Œ±2 : Ty.path "i32" := M.read (deref Œ±1) in
        let* Œ±3 : Ty.apply (Ty.path "mut_ref") [Ty.path "i32"] := M.read b in
        let* Œ±4 : Ty.path "i32" := M.read (deref Œ±3) in
        M.alloc (BinOp.Pure.bit_and Œ±0 (BinOp.Pure.bit_xor Œ±2 Œ±4)) in
      let* _ : Ty.tuple :=
        let* Œ≤ : Ty.path "i32" :=
          let* Œ±0 : Ty.apply (Ty.path "mut_ref") [Ty.path "i32"] := M.read a in
          M.pure (deref Œ±0) in
        let* Œ±0 := M.read Œ≤ in
        let* Œ±1 : Ty.path "i32" := M.read t in
        assign Œ≤ (BinOp.Pure.bit_xor Œ±0 Œ±1) in
      let* _ : Ty.tuple :=
        let* Œ≤ : Ty.path "i32" :=
          let* Œ±0 : Ty.apply (Ty.path "mut_ref") [Ty.path "i32"] := M.read b in
          M.pure (deref Œ±0) in
        let* Œ±0 := M.read Œ≤ in
        let* Œ±1 : Ty.path "i32" := M.read t in
        assign Œ≤ (BinOp.Pure.bit_xor Œ±0 Œ±1) in
      let* Œ±0 : Ty.path "unit" := M.alloc tt in
      M.read Œ±0
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_conditional_swap : Instance.t := {
    Notations.double_colon := conditional_swap;
  }.
  
  Definition ‚Ñê : Instance.t := [("conditional_select", conditional_select);
    ("conditional_assign", conditional_assign);
    ("conditional_swap", conditional_swap)].
End Impl_subtle_ConditionallySelectable_for_i32.
End Impl_subtle_ConditionallySelectable_for_i32.

Module  Impl_subtle_ConditionallySelectable_for_u64.
Section Impl_subtle_ConditionallySelectable_for_u64.
  Definition Self : Ty.t := Ty.path "u64".
  
  (*
              fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  a ^ (mask & (a ^ b))
              }
  *)
  Definition conditional_select (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [a; b; choice] =>
      let* a := M.alloc a in
      let* b := M.alloc b in
      let* choice := M.alloc choice in
      let* mask : Ty.path "u64" :=
        let* Œ±0 : Ty.path "u8" :=
          M.call
            ((Ty.apply (Ty.path "subtle::Choice") [])::["unwrap_u8"]
              (borrow choice)) in
        let* Œ±1 : Ty.path "i64" := UnOp.neg (rust_cast Œ±0) in
        M.alloc (rust_cast Œ±1) in
      let* Œ±0 :
          Ty.function
            [Ty.apply (Ty.path "ref") [Ty.path "u64"]; Ty.path "u64"]
            _ :=
        ltac:(M.get_method (fun ‚Ñê =>
          core.ops.bit.BitXor.bitxor
            (Self := Ty.apply (Ty.path "ref") [Ty.path "u64"])
            (Rhs := Ty.path "u64")
            (Trait := ‚Ñê))) in
      let* Œ±1 : Ty.apply (Ty.path "ref") [Ty.path "u64"] := M.read a in
      let* Œ±2 : Ty.path "u64" := M.read mask in
      let* Œ±3 :
          Ty.function
            [Ty.apply (Ty.path "ref") [Ty.path "u64"];
              Ty.apply (Ty.path "ref") [Ty.path "u64"]]
            _ :=
        ltac:(M.get_method (fun ‚Ñê =>
          core.ops.bit.BitXor.bitxor
            (Self := Ty.apply (Ty.path "ref") [Ty.path "u64"])
            (Rhs := Ty.apply (Ty.path "ref") [Ty.path "u64"])
            (Trait := ‚Ñê))) in
      let* Œ±4 : Ty.apply (Ty.path "ref") [Ty.path "u64"] := M.read a in
      let* Œ±5 : Ty.apply (Ty.path "ref") [Ty.path "u64"] := M.read b in
      let* Œ±6 : Ty.path "u64" := M.call (Œ±3 Œ±4 Œ±5) in
      let* Œ±7 : Ty.path "u64" := M.call (Œ±0 Œ±1 (BinOp.Pure.bit_and Œ±2 Œ±6)) in
      let* Œ±0 : Ty.path "u64" := M.alloc Œ±7 in
      M.read Œ±0
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_conditional_select : Instance.t := {
    Notations.double_colon := conditional_select;
  }.
  
  (*
              fn conditional_assign(&mut self, other: &Self, choice: Choice) {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  *self ^= mask & ( *self ^ *other);
              }
  *)
  Definition conditional_assign (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self; other; choice] =>
      let* self := M.alloc self in
      let* other := M.alloc other in
      let* choice := M.alloc choice in
      let* mask : Ty.path "u64" :=
        let* Œ±0 : Ty.path "u8" :=
          M.call
            ((Ty.apply (Ty.path "subtle::Choice") [])::["unwrap_u8"]
              (borrow choice)) in
        let* Œ±1 : Ty.path "i64" := UnOp.neg (rust_cast Œ±0) in
        M.alloc (rust_cast Œ±1) in
      let* _ : Ty.tuple :=
        let* Œ≤ : Ty.path "u64" :=
          let* Œ±0 : Ty.apply (Ty.path "mut_ref") [Ty.path "u64"] :=
            M.read self in
          M.pure (deref Œ±0) in
        let* Œ±0 := M.read Œ≤ in
        let* Œ±1 : Ty.path "u64" := M.read mask in
        let* Œ±2 : Ty.apply (Ty.path "mut_ref") [Ty.path "u64"] := M.read self in
        let* Œ±3 : Ty.path "u64" := M.read (deref Œ±2) in
        let* Œ±4 : Ty.apply (Ty.path "ref") [Ty.path "u64"] := M.read other in
        let* Œ±5 : Ty.path "u64" := M.read (deref Œ±4) in
        assign
          Œ≤
          (BinOp.Pure.bit_xor
            Œ±0
            (BinOp.Pure.bit_and Œ±1 (BinOp.Pure.bit_xor Œ±3 Œ±5))) in
      let* Œ±0 : Ty.path "unit" := M.alloc tt in
      M.read Œ±0
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_conditional_assign : Instance.t := {
    Notations.double_colon := conditional_assign;
  }.
  
  (*
              fn conditional_swap(a: &mut Self, b: &mut Self, choice: Choice) {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  let t = mask & ( *a ^ *b);
                  *a ^= t;
                  *b ^= t;
              }
  *)
  Definition conditional_swap (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [a; b; choice] =>
      let* a := M.alloc a in
      let* b := M.alloc b in
      let* choice := M.alloc choice in
      let* mask : Ty.path "u64" :=
        let* Œ±0 : Ty.path "u8" :=
          M.call
            ((Ty.apply (Ty.path "subtle::Choice") [])::["unwrap_u8"]
              (borrow choice)) in
        let* Œ±1 : Ty.path "i64" := UnOp.neg (rust_cast Œ±0) in
        M.alloc (rust_cast Œ±1) in
      let* t : Ty.path "u64" :=
        let* Œ±0 : Ty.path "u64" := M.read mask in
        let* Œ±1 : Ty.apply (Ty.path "mut_ref") [Ty.path "u64"] := M.read a in
        let* Œ±2 : Ty.path "u64" := M.read (deref Œ±1) in
        let* Œ±3 : Ty.apply (Ty.path "mut_ref") [Ty.path "u64"] := M.read b in
        let* Œ±4 : Ty.path "u64" := M.read (deref Œ±3) in
        M.alloc (BinOp.Pure.bit_and Œ±0 (BinOp.Pure.bit_xor Œ±2 Œ±4)) in
      let* _ : Ty.tuple :=
        let* Œ≤ : Ty.path "u64" :=
          let* Œ±0 : Ty.apply (Ty.path "mut_ref") [Ty.path "u64"] := M.read a in
          M.pure (deref Œ±0) in
        let* Œ±0 := M.read Œ≤ in
        let* Œ±1 : Ty.path "u64" := M.read t in
        assign Œ≤ (BinOp.Pure.bit_xor Œ±0 Œ±1) in
      let* _ : Ty.tuple :=
        let* Œ≤ : Ty.path "u64" :=
          let* Œ±0 : Ty.apply (Ty.path "mut_ref") [Ty.path "u64"] := M.read b in
          M.pure (deref Œ±0) in
        let* Œ±0 := M.read Œ≤ in
        let* Œ±1 : Ty.path "u64" := M.read t in
        assign Œ≤ (BinOp.Pure.bit_xor Œ±0 Œ±1) in
      let* Œ±0 : Ty.path "unit" := M.alloc tt in
      M.read Œ±0
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_conditional_swap : Instance.t := {
    Notations.double_colon := conditional_swap;
  }.
  
  Definition ‚Ñê : Instance.t := [("conditional_select", conditional_select);
    ("conditional_assign", conditional_assign);
    ("conditional_swap", conditional_swap)].
End Impl_subtle_ConditionallySelectable_for_u64.
End Impl_subtle_ConditionallySelectable_for_u64.

Module  Impl_subtle_ConditionallySelectable_for_i64.
Section Impl_subtle_ConditionallySelectable_for_i64.
  Definition Self : Ty.t := Ty.path "i64".
  
  (*
              fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  a ^ (mask & (a ^ b))
              }
  *)
  Definition conditional_select (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [a; b; choice] =>
      let* a := M.alloc a in
      let* b := M.alloc b in
      let* choice := M.alloc choice in
      let* mask : Ty.path "i64" :=
        let* Œ±0 : Ty.path "u8" :=
          M.call
            ((Ty.apply (Ty.path "subtle::Choice") [])::["unwrap_u8"]
              (borrow choice)) in
        let* Œ±1 : Ty.path "i64" := UnOp.neg (rust_cast Œ±0) in
        let* Œ±2 : Ty.path "i64" := M.alloc Œ±1 in
        M.copy (use Œ±2) in
      let* Œ±0 :
          Ty.function
            [Ty.apply (Ty.path "ref") [Ty.path "i64"]; Ty.path "i64"]
            _ :=
        ltac:(M.get_method (fun ‚Ñê =>
          core.ops.bit.BitXor.bitxor
            (Self := Ty.apply (Ty.path "ref") [Ty.path "i64"])
            (Rhs := Ty.path "i64")
            (Trait := ‚Ñê))) in
      let* Œ±1 : Ty.apply (Ty.path "ref") [Ty.path "i64"] := M.read a in
      let* Œ±2 : Ty.path "i64" := M.read mask in
      let* Œ±3 :
          Ty.function
            [Ty.apply (Ty.path "ref") [Ty.path "i64"];
              Ty.apply (Ty.path "ref") [Ty.path "i64"]]
            _ :=
        ltac:(M.get_method (fun ‚Ñê =>
          core.ops.bit.BitXor.bitxor
            (Self := Ty.apply (Ty.path "ref") [Ty.path "i64"])
            (Rhs := Ty.apply (Ty.path "ref") [Ty.path "i64"])
            (Trait := ‚Ñê))) in
      let* Œ±4 : Ty.apply (Ty.path "ref") [Ty.path "i64"] := M.read a in
      let* Œ±5 : Ty.apply (Ty.path "ref") [Ty.path "i64"] := M.read b in
      let* Œ±6 : Ty.path "i64" := M.call (Œ±3 Œ±4 Œ±5) in
      let* Œ±7 : Ty.path "i64" := M.call (Œ±0 Œ±1 (BinOp.Pure.bit_and Œ±2 Œ±6)) in
      let* Œ±0 : Ty.path "i64" := M.alloc Œ±7 in
      M.read Œ±0
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_conditional_select : Instance.t := {
    Notations.double_colon := conditional_select;
  }.
  
  (*
              fn conditional_assign(&mut self, other: &Self, choice: Choice) {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  *self ^= mask & ( *self ^ *other);
              }
  *)
  Definition conditional_assign (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self; other; choice] =>
      let* self := M.alloc self in
      let* other := M.alloc other in
      let* choice := M.alloc choice in
      let* mask : Ty.path "i64" :=
        let* Œ±0 : Ty.path "u8" :=
          M.call
            ((Ty.apply (Ty.path "subtle::Choice") [])::["unwrap_u8"]
              (borrow choice)) in
        let* Œ±1 : Ty.path "i64" := UnOp.neg (rust_cast Œ±0) in
        let* Œ±2 : Ty.path "i64" := M.alloc Œ±1 in
        M.copy (use Œ±2) in
      let* _ : Ty.tuple :=
        let* Œ≤ : Ty.path "i64" :=
          let* Œ±0 : Ty.apply (Ty.path "mut_ref") [Ty.path "i64"] :=
            M.read self in
          M.pure (deref Œ±0) in
        let* Œ±0 := M.read Œ≤ in
        let* Œ±1 : Ty.path "i64" := M.read mask in
        let* Œ±2 : Ty.apply (Ty.path "mut_ref") [Ty.path "i64"] := M.read self in
        let* Œ±3 : Ty.path "i64" := M.read (deref Œ±2) in
        let* Œ±4 : Ty.apply (Ty.path "ref") [Ty.path "i64"] := M.read other in
        let* Œ±5 : Ty.path "i64" := M.read (deref Œ±4) in
        assign
          Œ≤
          (BinOp.Pure.bit_xor
            Œ±0
            (BinOp.Pure.bit_and Œ±1 (BinOp.Pure.bit_xor Œ±3 Œ±5))) in
      let* Œ±0 : Ty.path "unit" := M.alloc tt in
      M.read Œ±0
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_conditional_assign : Instance.t := {
    Notations.double_colon := conditional_assign;
  }.
  
  (*
              fn conditional_swap(a: &mut Self, b: &mut Self, choice: Choice) {
                  // if choice = 0, mask = (-0) = 0000...0000
                  // if choice = 1, mask = (-1) = 1111...1111
                  let mask = -(choice.unwrap_u8() as to_signed_int!($t)) as $t;
                  let t = mask & ( *a ^ *b);
                  *a ^= t;
                  *b ^= t;
              }
  *)
  Definition conditional_swap (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [a; b; choice] =>
      let* a := M.alloc a in
      let* b := M.alloc b in
      let* choice := M.alloc choice in
      let* mask : Ty.path "i64" :=
        let* Œ±0 : Ty.path "u8" :=
          M.call
            ((Ty.apply (Ty.path "subtle::Choice") [])::["unwrap_u8"]
              (borrow choice)) in
        let* Œ±1 : Ty.path "i64" := UnOp.neg (rust_cast Œ±0) in
        let* Œ±2 : Ty.path "i64" := M.alloc Œ±1 in
        M.copy (use Œ±2) in
      let* t : Ty.path "i64" :=
        let* Œ±0 : Ty.path "i64" := M.read mask in
        let* Œ±1 : Ty.apply (Ty.path "mut_ref") [Ty.path "i64"] := M.read a in
        let* Œ±2 : Ty.path "i64" := M.read (deref Œ±1) in
        let* Œ±3 : Ty.apply (Ty.path "mut_ref") [Ty.path "i64"] := M.read b in
        let* Œ±4 : Ty.path "i64" := M.read (deref Œ±3) in
        M.alloc (BinOp.Pure.bit_and Œ±0 (BinOp.Pure.bit_xor Œ±2 Œ±4)) in
      let* _ : Ty.tuple :=
        let* Œ≤ : Ty.path "i64" :=
          let* Œ±0 : Ty.apply (Ty.path "mut_ref") [Ty.path "i64"] := M.read a in
          M.pure (deref Œ±0) in
        let* Œ±0 := M.read Œ≤ in
        let* Œ±1 : Ty.path "i64" := M.read t in
        assign Œ≤ (BinOp.Pure.bit_xor Œ±0 Œ±1) in
      let* _ : Ty.tuple :=
        let* Œ≤ : Ty.path "i64" :=
          let* Œ±0 : Ty.apply (Ty.path "mut_ref") [Ty.path "i64"] := M.read b in
          M.pure (deref Œ±0) in
        let* Œ±0 := M.read Œ≤ in
        let* Œ±1 : Ty.path "i64" := M.read t in
        assign Œ≤ (BinOp.Pure.bit_xor Œ±0 Œ±1) in
      let* Œ±0 : Ty.path "unit" := M.alloc tt in
      M.read Œ±0
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_conditional_swap : Instance.t := {
    Notations.double_colon := conditional_swap;
  }.
  
  Definition ‚Ñê : Instance.t := [("conditional_select", conditional_select);
    ("conditional_assign", conditional_assign);
    ("conditional_swap", conditional_swap)].
End Impl_subtle_ConditionallySelectable_for_i64.
End Impl_subtle_ConditionallySelectable_for_i64.

Module  Impl_subtle_ConditionallySelectable_for_subtle_Choice.
Section Impl_subtle_ConditionallySelectable_for_subtle_Choice.
  Definition Self : Ty.t := Ty.apply (Ty.path "subtle::Choice") [].
  
  (*
      fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {
          Choice(u8::conditional_select(&a.0, &b.0, choice))
      }
  *)
  Definition conditional_select (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [a; b; choice] =>
      let* a := M.alloc a in
      let* b := M.alloc b in
      let* choice := M.alloc choice in
      let* Œ±0 :
          Ty.function
            [Ty.apply (Ty.path "ref") [Ty.path "u8"];
              Ty.apply (Ty.path "ref") [Ty.path "u8"];
              Ty.apply (Ty.path "subtle::Choice") []]
            (Ty.path "u8") :=
        ltac:(M.get_method (fun ‚Ñê =>
          subtle.ConditionallySelectable.conditional_select
            (Self := Ty.path "u8")
            (Trait := ‚Ñê))) in
      let* Œ±1 :
          Ty.apply (Ty.path "ref") [Ty.apply (Ty.path "subtle::Choice") []] :=
        M.read a in
      let* Œ±2 :
          Ty.apply (Ty.path "ref") [Ty.apply (Ty.path "subtle::Choice") []] :=
        M.read b in
      let* Œ±3 : Ty.apply (Ty.path "subtle::Choice") [] := M.read choice in
      let* Œ±4 : Ty.path "u8" :=
        M.call
          (Œ±0
            (borrow (subtle.Choice.Get_0 (deref Œ±1)))
            (borrow (subtle.Choice.Get_0 (deref Œ±2)))
            Œ±3) in
      M.pure (subtle.Choice.Build_t Œ±4)
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_conditional_select : Instance.t := {
    Notations.double_colon := conditional_select;
  }.
  
  Definition ‚Ñê : Instance.t := [("conditional_select", conditional_select);
    ("conditional_assign", conditional_assign);
    ("conditional_swap", conditional_swap)].
End Impl_subtle_ConditionallySelectable_for_subtle_Choice.
End Impl_subtle_ConditionallySelectable_for_subtle_Choice.

Module  ConditionallyNegatable.
Section ConditionallyNegatable.
  Class Trait (Self : Set) : Type := {
    conditional_negate :
      Ty.function
        [Ty.apply (Ty.path "mut_ref") [Self];
          Ty.apply (Ty.path "subtle::Choice") []]
        (Ty.path "unit");
  }.
  
End ConditionallyNegatable.
End ConditionallyNegatable.

Module  Impl_subtle_ConditionallyNegatable_for_T.
Section Impl_subtle_ConditionallyNegatable_for_T.
  Context {T : Set}.
  
  Definition Self : Ty.t := T.
  
  (*
      fn conditional_negate(&mut self, choice: Choice) {
          // Need to cast to eliminate mutability
          let self_neg: T = -(self as &T);
          self.conditional_assign(&self_neg, choice);
      }
  *)
  Definition conditional_negate (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self; choice] =>
      let* self := M.alloc self in
      let* choice := M.alloc choice in
      let* self_neg : T :=
        let* Œ±0 : Ty.function [Ty.apply (Ty.path "ref") [T]] _ :=
          ltac:(M.get_method (fun ‚Ñê =>
            core.ops.arith.Neg.neg
              (Self := Ty.apply (Ty.path "ref") [T])
              (Trait := ‚Ñê))) in
        let* Œ±1 : Ty.apply (Ty.path "mut_ref") [T] := M.read self in
        let* Œ±2 : Ty.apply (Ty.path "ref") [T] := M.alloc (borrow (deref Œ±1)) in
        let* Œ±3 : Ty.apply (Ty.path "ref") [T] := M.read (use Œ±2) in
        let* Œ±4 : T := M.call (Œ±0 Œ±3) in
        M.alloc Œ±4 in
      let* _ : Ty.tuple :=
        let* Œ±0 :
            Ty.function
              [Ty.apply (Ty.path "mut_ref") [T];
                Ty.apply (Ty.path "ref") [T];
                Ty.apply (Ty.path "subtle::Choice") []]
              Ty.tuple :=
          ltac:(M.get_method (fun ‚Ñê =>
            subtle.ConditionallySelectable.conditional_assign
              (Self := T)
              (Trait := ‚Ñê))) in
        let* Œ±1 : Ty.apply (Ty.path "mut_ref") [T] := M.read self in
        let* Œ±2 : Ty.apply (Ty.path "subtle::Choice") [] := M.read choice in
        let* Œ±3 : Ty.tuple := M.call (Œ±0 Œ±1 (borrow self_neg) Œ±2) in
        M.alloc Œ±3 in
      let* Œ±0 : Ty.path "unit" := M.alloc tt in
      M.read Œ±0
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_conditional_negate : Instance.t := {
    Notations.double_colon := conditional_negate;
  }.
  
  Definition ‚Ñê : Instance.t := [("conditional_negate", conditional_negate)].
End Impl_subtle_ConditionallyNegatable_for_T.
End Impl_subtle_ConditionallyNegatable_for_T.



Module  Impl_core_clone_Clone_for_subtle_CtOption_T.
Section Impl_core_clone_Clone_for_subtle_CtOption_T.
  Context {T : Set}.
  
  Definition Self : Ty.t := Ty.apply (Ty.path "subtle::CtOption") [T].
  
  (*
  Clone
  *)
  Definition clone (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self] =>
      let* self := M.alloc self in
      let* Œ±0 : Ty.function [Ty.apply (Ty.path "ref") [T]] T :=
        ltac:(M.get_method (fun ‚Ñê =>
          core.clone.Clone.clone (Self := T) (Trait := ‚Ñê))) in
      let* Œ±1 :
          Ty.apply
            (Ty.path "ref")
            [Ty.apply (Ty.path "subtle::CtOption") [T]] :=
        M.read self in
      let* Œ±2 : T :=
        M.call (Œ±0 (borrow (subtle.CtOption.Get_value (deref Œ±1)))) in
      let* Œ±3 :
          Ty.function
            [Ty.apply (Ty.path "ref") [Ty.apply (Ty.path "subtle::Choice") []]]
            (Ty.apply (Ty.path "subtle::Choice") []) :=
        ltac:(M.get_method (fun ‚Ñê =>
          core.clone.Clone.clone
            (Self := Ty.apply (Ty.path "subtle::Choice") [])
            (Trait := ‚Ñê))) in
      let* Œ±4 :
          Ty.apply
            (Ty.path "ref")
            [Ty.apply (Ty.path "subtle::CtOption") [T]] :=
        M.read self in
      let* Œ±5 : Ty.apply (Ty.path "subtle::Choice") [] :=
        M.call (Œ±3 (borrow (subtle.CtOption.Get_is_some (deref Œ±4)))) in
      M.pure {| subtle.CtOption.value := Œ±2; subtle.CtOption.is_some := Œ±5; |}
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_clone : Instance.t := {
    Notations.double_colon := clone;
  }.
  
  Definition ‚Ñê : Instance.t := [("clone", clone); ("clone_from", clone_from)].
End Impl_core_clone_Clone_for_subtle_CtOption_T.
End Impl_core_clone_Clone_for_subtle_CtOption_T.

Module  Impl_core_marker_Copy_for_subtle_CtOption_T.
Section Impl_core_marker_Copy_for_subtle_CtOption_T.
  Context {T : Set}.
  
  Definition Self : Ty.t := Ty.apply (Ty.path "subtle::CtOption") [T].
  
  Definition ‚Ñê : Instance.t := [].
End Impl_core_marker_Copy_for_subtle_CtOption_T.
End Impl_core_marker_Copy_for_subtle_CtOption_T.

Module  Impl_core_fmt_Debug_for_subtle_CtOption_T.
Section Impl_core_fmt_Debug_for_subtle_CtOption_T.
  Context {T : Set}.
  
  Definition Self : Ty.t := Ty.apply (Ty.path "subtle::CtOption") [T].
  
  (*
  Debug
  *)
  Definition fmt (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self; f] =>
      let* self := M.alloc self in
      let* f := M.alloc f in
      let* Œ±0 :
          Ty.apply
            (Ty.path "mut_ref")
            [Ty.apply (Ty.path "core::fmt::Formatter") []] :=
        M.read f in
      let* Œ±1 : Ty.apply (Ty.path "ref") [Ty.path "str"] :=
        M.read (mk_str "CtOption") in
      let* Œ±2 : Ty.apply (Ty.path "ref") [Ty.path "str"] :=
        M.read (mk_str "value") in
      let* Œ±3 :
          Ty.apply
            (Ty.path "ref")
            [Ty.apply (Ty.path "subtle::CtOption") [T]] :=
        M.read self in
      let* Œ±4 : Ty.apply (Ty.path "ref") [Ty.path "str"] :=
        M.read (mk_str "is_some") in
      let* Œ±5 :
          Ty.apply
            (Ty.path "ref")
            [Ty.apply (Ty.path "subtle::CtOption") [T]] :=
        M.read self in
      let* Œ±6 :
          Ty.apply (Ty.path "ref") [Ty.apply (Ty.path "subtle::Choice") []] :=
        M.alloc (borrow (subtle.CtOption.Get_is_some (deref Œ±5))) in
      M.call
        ((Ty.apply
              (Ty.path "core::fmt::Formatter")
              [])::["debug_struct_field2_finish"]
          Œ±0
          Œ±1
          Œ±2
          (pointer_coercion
            "Unsize"
            (borrow (subtle.CtOption.Get_value (deref Œ±3))))
          Œ±4
          (pointer_coercion "Unsize" (borrow Œ±6)))
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_fmt : Instance.t := {
    Notations.double_colon := fmt;
  }.
  
  Definition ‚Ñê : Instance.t := [("fmt", fmt)].
End Impl_core_fmt_Debug_for_subtle_CtOption_T.
End Impl_core_fmt_Debug_for_subtle_CtOption_T.

Module  Impl_core_convert_From_subtle_CtOption_T_for_core_option_Option_T.
Section Impl_core_convert_From_subtle_CtOption_T_for_core_option_Option_T.
  Context {T : Set}.
  
  Definition Self : Ty.t := Ty.apply (Ty.path "core::option::Option") [T].
  
  (*
      fn from(source: CtOption<T>) -> Option<T> {
          if source.is_some().unwrap_u8() == 1u8 {
              Option::Some(source.value)
          } else {
              None
          }
      }
  *)
  Definition from (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [source] =>
      let* source := M.alloc source in
      let* Œ±0 : Ty.apply (Ty.path "subtle::Choice") [] :=
        M.call
          ((Ty.apply (Ty.path "subtle::CtOption") [T])::["is_some"]
            (borrow source)) in
      let* Œ±1 : Ty.apply (Ty.path "subtle::Choice") [] := M.alloc Œ±0 in
      let* Œ±2 : Ty.path "u8" :=
        M.call
          ((Ty.apply (Ty.path "subtle::Choice") [])::["unwrap_u8"]
            (borrow Œ±1)) in
      let* Œ±3 : Ty.path "bool" :=
        M.alloc (BinOp.Pure.eq Œ±2 ((Integer.of_Z 1) : Ty.path "u8")) in
      let* Œ±4 : Ty.path "bool" := M.read (use Œ±3) in
      let* Œ±5 : Ty.apply (Ty.path "core::option::Option") [T] :=
        if Œ±4 then
          let* Œ±0 : T := M.read (subtle.CtOption.Get_value source) in
          M.alloc (core.option.Option.Some Œ±0)
        else
          M.alloc core.option.Option.None in
      M.read Œ±5
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_from : Instance.t := {
    Notations.double_colon := from;
  }.
  
  Definition ‚Ñê : Instance.t := [("from", from)].
End Impl_core_convert_From_subtle_CtOption_T_for_core_option_Option_T.
End Impl_core_convert_From_subtle_CtOption_T_for_core_option_Option_T.

Module  Impl_subtle_CtOption_T.
Section Impl_subtle_CtOption_T.
  Context {T : Set}.
  
  Definition Self : Set := Ty.apply (Ty.path "subtle::CtOption") [T].
  
  (*
      pub fn new(value: T, is_some: Choice) -> CtOption<T> {
          CtOption {
              value: value,
              is_some: is_some,
          }
      }
  *)
  Definition new (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [value; is_some] =>
      let* value := M.alloc value in
      let* is_some := M.alloc is_some in
      let* Œ±0 : T := M.read value in
      let* Œ±1 : Ty.apply (Ty.path "subtle::Choice") [] := M.read is_some in
      M.pure {| subtle.CtOption.value := Œ±0; subtle.CtOption.is_some := Œ±1; |}
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_new : Instance.t := {
    Notations.double_colon := new;
  }.
  
  (*
      pub fn expect(self, msg: &str) -> T {
          assert_eq!(self.is_some.unwrap_u8(), 1, "{}", msg);
  
          self.value
      }
  *)
  Definition expect (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self; msg] =>
      let* self := M.alloc self in
      let* msg := M.alloc msg in
      let* _ : Ty.tuple :=
        let* Œ±0 : Ty.path "u8" :=
          M.call
            ((Ty.apply (Ty.path "subtle::Choice") [])::["unwrap_u8"]
              (borrow (subtle.CtOption.Get_is_some self))) in
        let* Œ±1 : Ty.path "u8" := M.alloc Œ±0 in
        let* Œ±2 : Ty.path "u8" := M.alloc ((Integer.of_Z 1) : Ty.path "u8") in
        let* Œ±3 :
            Ty.tuple
              (Ty.apply (Ty.path "ref") [Ty.path "u8"])
              (Ty.apply (Ty.path "ref") [Ty.path "u8"]) :=
          M.alloc (borrow Œ±1, borrow Œ±2) in
        match_operator
          Œ±3
          [
            fun Œ≥ =>
              (let* Œ±0 := M.read Œ≥ in
              match Œ±0 with
              | (_, _) =>
                let Œ≥0_0 := Tuple.Access.left Œ≥ in
                let Œ≥0_1 := Tuple.Access.right Œ≥ in
                let* left_val := M.copy Œ≥0_0 in
                let* right_val := M.copy Œ≥0_1 in
                let* Œ±0 : Ty.apply (Ty.path "ref") [Ty.path "u8"] :=
                  M.read left_val in
                let* Œ±1 : Ty.path "u8" := M.read (deref Œ±0) in
                let* Œ±2 : Ty.apply (Ty.path "ref") [Ty.path "u8"] :=
                  M.read right_val in
                let* Œ±3 : Ty.path "u8" := M.read (deref Œ±2) in
                let* Œ±4 : Ty.path "bool" :=
                  M.alloc (UnOp.not (BinOp.Pure.eq Œ±1 Œ±3)) in
                let* Œ±5 : Ty.path "bool" := M.read (use Œ±4) in
                if Œ±5 then
                  let* kind :
                      Ty.apply (Ty.path "core::panicking::AssertKind") [] :=
                    M.alloc core.panicking.AssertKind.Eq in
                  let* Œ±0 :
                      Ty.apply (Ty.path "core::panicking::AssertKind") [] :=
                    M.read kind in
                  let* Œ±1 : Ty.apply (Ty.path "ref") [Ty.path "u8"] :=
                    M.read left_val in
                  let* Œ±2 : Ty.apply (Ty.path "ref") [Ty.path "u8"] :=
                    M.read right_val in
                  let* Œ±3 : Ty.apply (Ty.path "ref") [Ty.path "str"] :=
                    M.read (mk_str "") in
                  let* Œ±4 :
                      Ty.apply
                        (Ty.path "array")
                        [Ty.apply (Ty.path "ref") [Ty.path "str"]] :=
                    M.alloc [ Œ±3 ] in
                  let* Œ±5 : Ty.apply (Ty.path "core::fmt::rt::Argument") [] :=
                    M.call
                      ((Ty.apply
                            (Ty.path "core::fmt::rt::Argument")
                            [])::["new_display"]
                        (borrow msg)) in
                  let* Œ±6 :
                      Ty.apply
                        (Ty.path "array")
                        [Ty.apply (Ty.path "core::fmt::rt::Argument") []] :=
                    M.alloc [ Œ±5 ] in
                  let* Œ±7 : Ty.apply (Ty.path "core::fmt::Arguments") [] :=
                    M.call
                      ((Ty.apply
                            (Ty.path "core::fmt::Arguments")
                            [])::["new_v1"]
                        (pointer_coercion "Unsize" (borrow Œ±4))
                        (pointer_coercion "Unsize" (borrow Œ±6))) in
                  let* Œ±8 : Ty.path "never" :=
                    M.call
                      (core.panicking.assert_failed
                        Œ±0
                        Œ±1
                        Œ±2
                        (core.option.Option.Some Œ±7)) in
                  let* Œ±0 : Ty.path "never" := M.alloc Œ±8 in
                  let* Œ±1 : Ty.path "never" := M.read Œ±0 in
                  let* Œ±2 : Ty.tuple := never_to_any Œ±1 in
                  M.alloc Œ±2
                else
                  M.alloc tt
              end) :
              Ty.tuple
          ] in
      M.read (subtle.CtOption.Get_value self)
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_expect : Instance.t := {
    Notations.double_colon := expect;
  }.
  
  (*
      pub fn unwrap(self) -> T {
          assert_eq!(self.is_some.unwrap_u8(), 1);
  
          self.value
      }
  *)
  Definition unwrap (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self] =>
      let* self := M.alloc self in
      let* _ : Ty.tuple :=
        let* Œ±0 : Ty.path "u8" :=
          M.call
            ((Ty.apply (Ty.path "subtle::Choice") [])::["unwrap_u8"]
              (borrow (subtle.CtOption.Get_is_some self))) in
        let* Œ±1 : Ty.path "u8" := M.alloc Œ±0 in
        let* Œ±2 : Ty.path "u8" := M.alloc ((Integer.of_Z 1) : Ty.path "u8") in
        let* Œ±3 :
            Ty.tuple
              (Ty.apply (Ty.path "ref") [Ty.path "u8"])
              (Ty.apply (Ty.path "ref") [Ty.path "u8"]) :=
          M.alloc (borrow Œ±1, borrow Œ±2) in
        match_operator
          Œ±3
          [
            fun Œ≥ =>
              (let* Œ±0 := M.read Œ≥ in
              match Œ±0 with
              | (_, _) =>
                let Œ≥0_0 := Tuple.Access.left Œ≥ in
                let Œ≥0_1 := Tuple.Access.right Œ≥ in
                let* left_val := M.copy Œ≥0_0 in
                let* right_val := M.copy Œ≥0_1 in
                let* Œ±0 : Ty.apply (Ty.path "ref") [Ty.path "u8"] :=
                  M.read left_val in
                let* Œ±1 : Ty.path "u8" := M.read (deref Œ±0) in
                let* Œ±2 : Ty.apply (Ty.path "ref") [Ty.path "u8"] :=
                  M.read right_val in
                let* Œ±3 : Ty.path "u8" := M.read (deref Œ±2) in
                let* Œ±4 : Ty.path "bool" :=
                  M.alloc (UnOp.not (BinOp.Pure.eq Œ±1 Œ±3)) in
                let* Œ±5 : Ty.path "bool" := M.read (use Œ±4) in
                if Œ±5 then
                  let* kind :
                      Ty.apply (Ty.path "core::panicking::AssertKind") [] :=
                    M.alloc core.panicking.AssertKind.Eq in
                  let* Œ±0 :
                      Ty.apply (Ty.path "core::panicking::AssertKind") [] :=
                    M.read kind in
                  let* Œ±1 : Ty.apply (Ty.path "ref") [Ty.path "u8"] :=
                    M.read left_val in
                  let* Œ±2 : Ty.apply (Ty.path "ref") [Ty.path "u8"] :=
                    M.read right_val in
                  let* Œ±3 : Ty.path "never" :=
                    M.call
                      (core.panicking.assert_failed
                        Œ±0
                        Œ±1
                        Œ±2
                        core.option.Option.None) in
                  let* Œ±0 : Ty.path "never" := M.alloc Œ±3 in
                  let* Œ±1 : Ty.path "never" := M.read Œ±0 in
                  let* Œ±2 : Ty.tuple := never_to_any Œ±1 in
                  M.alloc Œ±2
                else
                  M.alloc tt
              end) :
              Ty.tuple
          ] in
      M.read (subtle.CtOption.Get_value self)
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_unwrap : Instance.t := {
    Notations.double_colon := unwrap;
  }.
  
  (*
      pub fn unwrap_or(self, def: T) -> T
      where
          T: ConditionallySelectable,
      {
          T::conditional_select(&def, &self.value, self.is_some)
      }
  *)
  Definition unwrap_or (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self; def] =>
      let* self := M.alloc self in
      let* def := M.alloc def in
      let* Œ±0 :
          Ty.function
            [Ty.apply (Ty.path "ref") [T];
              Ty.apply (Ty.path "ref") [T];
              Ty.apply (Ty.path "subtle::Choice") []]
            T :=
        ltac:(M.get_method (fun ‚Ñê =>
          subtle.ConditionallySelectable.conditional_select
            (Self := T)
            (Trait := ‚Ñê))) in
      let* Œ±1 : Ty.apply (Ty.path "subtle::Choice") [] :=
        M.read (subtle.CtOption.Get_is_some self) in
      M.call (Œ±0 (borrow def) (borrow (subtle.CtOption.Get_value self)) Œ±1)
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_unwrap_or : Instance.t := {
    Notations.double_colon := unwrap_or;
  }.
  
  (*
      pub fn unwrap_or_else<F>(self, f: F) -> T
      where
          T: ConditionallySelectable,
          F: FnOnce() -> T,
      {
          T::conditional_select(&f(), &self.value, self.is_some)
      }
  *)
  Definition unwrap_or_else (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [F], [self; f] =>
      let* self := M.alloc self in
      let* f := M.alloc f in
      let* Œ±0 :
          Ty.function
            [Ty.apply (Ty.path "ref") [T];
              Ty.apply (Ty.path "ref") [T];
              Ty.apply (Ty.path "subtle::Choice") []]
            T :=
        ltac:(M.get_method (fun ‚Ñê =>
          subtle.ConditionallySelectable.conditional_select
            (Self := T)
            (Trait := ‚Ñê))) in
      let* Œ±1 : Ty.function [F; Ty.tuple] _ :=
        ltac:(M.get_method (fun ‚Ñê =>
          core.ops.function.FnOnce.call_once
            (Self := F)
            (Args := Ty.tuple)
            (Trait := ‚Ñê))) in
      let* Œ±2 : F := M.read f in
      let* Œ±3 : T := M.call (Œ±1 Œ±2 tt) in
      let* Œ±4 : T := M.alloc Œ±3 in
      let* Œ±5 : Ty.apply (Ty.path "subtle::Choice") [] :=
        M.read (subtle.CtOption.Get_is_some self) in
      M.call (Œ±0 (borrow Œ±4) (borrow (subtle.CtOption.Get_value self)) Œ±5)
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_unwrap_or_else {F : Set} : Instance.t := {
    Notations.double_colon := unwrap_or_else (F := F);
  }.
  
  (*
      pub fn is_some(&self) -> Choice {
          self.is_some
      }
  *)
  Definition is_some (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self] =>
      let* self := M.alloc self in
      let* Œ±0 :
          Ty.apply
            (Ty.path "ref")
            [Ty.apply (Ty.path "subtle::CtOption") [T]] :=
        M.read self in
      M.read (subtle.CtOption.Get_is_some (deref Œ±0))
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_is_some : Instance.t := {
    Notations.double_colon := is_some;
  }.
  
  (*
      pub fn is_none(&self) -> Choice {
          !self.is_some
      }
  *)
  Definition is_none (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self] =>
      let* self := M.alloc self in
      let* Œ±0 : Ty.function [Ty.apply (Ty.path "subtle::Choice") []] _ :=
        ltac:(M.get_method (fun ‚Ñê =>
          core.ops.bit.Not.not
            (Self := Ty.apply (Ty.path "subtle::Choice") [])
            (Trait := ‚Ñê))) in
      let* Œ±1 :
          Ty.apply
            (Ty.path "ref")
            [Ty.apply (Ty.path "subtle::CtOption") [T]] :=
        M.read self in
      let* Œ±2 : Ty.apply (Ty.path "subtle::Choice") [] :=
        M.read (subtle.CtOption.Get_is_some (deref Œ±1)) in
      M.call (Œ±0 Œ±2)
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_is_none : Instance.t := {
    Notations.double_colon := is_none;
  }.
  
  (*
      pub fn map<U, F>(self, f: F) -> CtOption<U>
      where
          T: Default + ConditionallySelectable,
          F: FnOnce(T) -> U,
      {
          CtOption::new(
              f(T::conditional_select(
                  &T::default(),
                  &self.value,
                  self.is_some,
              )),
              self.is_some,
          )
      }
  *)
  Definition map (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [U; F], [self; f] =>
      let* self := M.alloc self in
      let* f := M.alloc f in
      let* Œ±0 : Ty.function [F; Ty.tuple T] _ :=
        ltac:(M.get_method (fun ‚Ñê =>
          core.ops.function.FnOnce.call_once
            (Self := F)
            (Args := Ty.tuple T)
            (Trait := ‚Ñê))) in
      let* Œ±1 : F := M.read f in
      let* Œ±2 :
          Ty.function
            [Ty.apply (Ty.path "ref") [T];
              Ty.apply (Ty.path "ref") [T];
              Ty.apply (Ty.path "subtle::Choice") []]
            T :=
        ltac:(M.get_method (fun ‚Ñê =>
          subtle.ConditionallySelectable.conditional_select
            (Self := T)
            (Trait := ‚Ñê))) in
      let* Œ±3 : Ty.function [] T :=
        ltac:(M.get_method (fun ‚Ñê =>
          core.default.Default.default (Self := T) (Trait := ‚Ñê))) in
      let* Œ±4 : T := M.call Œ±3 in
      let* Œ±5 : T := M.alloc Œ±4 in
      let* Œ±6 : Ty.apply (Ty.path "subtle::Choice") [] :=
        M.read (subtle.CtOption.Get_is_some self) in
      let* Œ±7 : T :=
        M.call (Œ±2 (borrow Œ±5) (borrow (subtle.CtOption.Get_value self)) Œ±6) in
      let* Œ±8 : U := M.call (Œ±0 Œ±1 (Œ±7)) in
      let* Œ±9 : Ty.apply (Ty.path "subtle::Choice") [] :=
        M.read (subtle.CtOption.Get_is_some self) in
      M.call ((Ty.apply (Ty.path "subtle::CtOption") [U])::["new"] Œ±8 Œ±9)
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_map {U F : Set} : Instance.t := {
    Notations.double_colon := map (U := U) (F := F);
  }.
  
  (*
      pub fn and_then<U, F>(self, f: F) -> CtOption<U>
      where
          T: Default + ConditionallySelectable,
          F: FnOnce(T) -> CtOption<U>,
      {
          let mut tmp = f(T::conditional_select(
              &T::default(),
              &self.value,
              self.is_some,
          ));
          tmp.is_some &= self.is_some;
  
          tmp
      }
  *)
  Definition and_then (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [U; F], [self; f] =>
      let* self := M.alloc self in
      let* f := M.alloc f in
      let* tmp : Ty.apply (Ty.path "subtle::CtOption") [U] :=
        let* Œ±0 : Ty.function [F; Ty.tuple T] _ :=
          ltac:(M.get_method (fun ‚Ñê =>
            core.ops.function.FnOnce.call_once
              (Self := F)
              (Args := Ty.tuple T)
              (Trait := ‚Ñê))) in
        let* Œ±1 : F := M.read f in
        let* Œ±2 :
            Ty.function
              [Ty.apply (Ty.path "ref") [T];
                Ty.apply (Ty.path "ref") [T];
                Ty.apply (Ty.path "subtle::Choice") []]
              T :=
          ltac:(M.get_method (fun ‚Ñê =>
            subtle.ConditionallySelectable.conditional_select
              (Self := T)
              (Trait := ‚Ñê))) in
        let* Œ±3 : Ty.function [] T :=
          ltac:(M.get_method (fun ‚Ñê =>
            core.default.Default.default (Self := T) (Trait := ‚Ñê))) in
        let* Œ±4 : T := M.call Œ±3 in
        let* Œ±5 : T := M.alloc Œ±4 in
        let* Œ±6 : Ty.apply (Ty.path "subtle::Choice") [] :=
          M.read (subtle.CtOption.Get_is_some self) in
        let* Œ±7 : T :=
          M.call
            (Œ±2 (borrow Œ±5) (borrow (subtle.CtOption.Get_value self)) Œ±6) in
        let* Œ±8 : Ty.apply (Ty.path "subtle::CtOption") [U] :=
          M.call (Œ±0 Œ±1 (Œ±7)) in
        M.alloc Œ±8 in
      let* _ : Ty.tuple :=
        let* Œ±0 :
            Ty.function
              [Ty.apply
                  (Ty.path "mut_ref")
                  [Ty.apply (Ty.path "subtle::Choice") []];
                Ty.apply (Ty.path "subtle::Choice") []]
              Ty.tuple :=
          ltac:(M.get_method (fun ‚Ñê =>
            core.ops.bit.BitAndAssign.bitand_assign
              (Self := Ty.apply (Ty.path "subtle::Choice") [])
              (Rhs := Ty.apply (Ty.path "subtle::Choice") [])
              (Trait := ‚Ñê))) in
        let* Œ±1 : Ty.apply (Ty.path "subtle::Choice") [] :=
          M.read (subtle.CtOption.Get_is_some self) in
        let* Œ±2 : Ty.tuple :=
          M.call (Œ±0 (borrow_mut (subtle.CtOption.Get_is_some tmp)) Œ±1) in
        M.alloc Œ±2 in
      M.read tmp
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_and_then {U F : Set} : Instance.t := {
    Notations.double_colon := and_then (U := U) (F := F);
  }.
  
  (*
      pub fn or_else<F>(self, f: F) -> CtOption<T>
      where
          T: ConditionallySelectable,
          F: FnOnce() -> CtOption<T>,
      {
          let is_none = self.is_none();
          let f = f();
  
          Self::conditional_select(&self, &f, is_none)
      }
  *)
  Definition or_else (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [F], [self; f] =>
      let* self := M.alloc self in
      let* f := M.alloc f in
      let* is_none : Ty.apply (Ty.path "subtle::Choice") [] :=
        let* Œ±0 : Ty.apply (Ty.path "subtle::Choice") [] :=
          M.call
            ((Ty.apply (Ty.path "subtle::CtOption") [T])::["is_none"]
              (borrow self)) in
        M.alloc Œ±0 in
      let* f : Ty.apply (Ty.path "subtle::CtOption") [T] :=
        let* Œ±0 : Ty.function [F; Ty.tuple] _ :=
          ltac:(M.get_method (fun ‚Ñê =>
            core.ops.function.FnOnce.call_once
              (Self := F)
              (Args := Ty.tuple)
              (Trait := ‚Ñê))) in
        let* Œ±1 : F := M.read f in
        let* Œ±2 : Ty.apply (Ty.path "subtle::CtOption") [T] :=
          M.call (Œ±0 Œ±1 tt) in
        M.alloc Œ±2 in
      let* Œ±0 :
          Ty.function
            [Ty.apply
                (Ty.path "ref")
                [Ty.apply (Ty.path "subtle::CtOption") [T]];
              Ty.apply
                (Ty.path "ref")
                [Ty.apply (Ty.path "subtle::CtOption") [T]];
              Ty.apply (Ty.path "subtle::Choice") []]
            (Ty.apply (Ty.path "subtle::CtOption") [T]) :=
        ltac:(M.get_method (fun ‚Ñê =>
          subtle.ConditionallySelectable.conditional_select
            (Self := Ty.apply (Ty.path "subtle::CtOption") [T])
            (Trait := ‚Ñê))) in
      let* Œ±1 : Ty.apply (Ty.path "subtle::Choice") [] := M.read is_none in
      let* Œ±2 : Ty.apply (Ty.path "subtle::CtOption") [T] :=
        M.call (Œ±0 (borrow self) (borrow f) Œ±1) in
      let* Œ±0 : Ty.apply (Ty.path "subtle::CtOption") [T] := M.alloc Œ±2 in
      M.read Œ±0
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_or_else {F : Set} : Instance.t := {
    Notations.double_colon := or_else (F := F);
  }.
End Impl_subtle_CtOption_T.
End Impl_subtle_CtOption_T.

Module  Impl_subtle_ConditionallySelectable_for_subtle_CtOption_T.
Section Impl_subtle_ConditionallySelectable_for_subtle_CtOption_T.
  Context {T : Set}.
  
  Definition Self : Ty.t := Ty.apply (Ty.path "subtle::CtOption") [T].
  
  (*
      fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {
          CtOption::new(
              T::conditional_select(&a.value, &b.value, choice),
              Choice::conditional_select(&a.is_some, &b.is_some, choice),
          )
      }
  *)
  Definition conditional_select (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [a; b; choice] =>
      let* a := M.alloc a in
      let* b := M.alloc b in
      let* choice := M.alloc choice in
      let* Œ±0 :
          Ty.function
            [Ty.apply (Ty.path "ref") [T];
              Ty.apply (Ty.path "ref") [T];
              Ty.apply (Ty.path "subtle::Choice") []]
            T :=
        ltac:(M.get_method (fun ‚Ñê =>
          subtle.ConditionallySelectable.conditional_select
            (Self := T)
            (Trait := ‚Ñê))) in
      let* Œ±1 :
          Ty.apply
            (Ty.path "ref")
            [Ty.apply (Ty.path "subtle::CtOption") [T]] :=
        M.read a in
      let* Œ±2 :
          Ty.apply
            (Ty.path "ref")
            [Ty.apply (Ty.path "subtle::CtOption") [T]] :=
        M.read b in
      let* Œ±3 : Ty.apply (Ty.path "subtle::Choice") [] := M.read choice in
      let* Œ±4 : T :=
        M.call
          (Œ±0
            (borrow (subtle.CtOption.Get_value (deref Œ±1)))
            (borrow (subtle.CtOption.Get_value (deref Œ±2)))
            Œ±3) in
      let* Œ±5 :
          Ty.function
            [Ty.apply (Ty.path "ref") [Ty.apply (Ty.path "subtle::Choice") []];
              Ty.apply (Ty.path "ref") [Ty.apply (Ty.path "subtle::Choice") []];
              Ty.apply (Ty.path "subtle::Choice") []]
            (Ty.apply (Ty.path "subtle::Choice") []) :=
        ltac:(M.get_method (fun ‚Ñê =>
          subtle.ConditionallySelectable.conditional_select
            (Self := Ty.apply (Ty.path "subtle::Choice") [])
            (Trait := ‚Ñê))) in
      let* Œ±6 :
          Ty.apply
            (Ty.path "ref")
            [Ty.apply (Ty.path "subtle::CtOption") [T]] :=
        M.read a in
      let* Œ±7 :
          Ty.apply
            (Ty.path "ref")
            [Ty.apply (Ty.path "subtle::CtOption") [T]] :=
        M.read b in
      let* Œ±8 : Ty.apply (Ty.path "subtle::Choice") [] := M.read choice in
      let* Œ±9 : Ty.apply (Ty.path "subtle::Choice") [] :=
        M.call
          (Œ±5
            (borrow (subtle.CtOption.Get_is_some (deref Œ±6)))
            (borrow (subtle.CtOption.Get_is_some (deref Œ±7)))
            Œ±8) in
      M.call ((Ty.apply (Ty.path "subtle::CtOption") [T])::["new"] Œ±4 Œ±9)
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_conditional_select : Instance.t := {
    Notations.double_colon := conditional_select;
  }.
  
  Definition ‚Ñê : Instance.t := [("conditional_select", conditional_select);
    ("conditional_assign", conditional_assign);
    ("conditional_swap", conditional_swap)].
End Impl_subtle_ConditionallySelectable_for_subtle_CtOption_T.
End Impl_subtle_ConditionallySelectable_for_subtle_CtOption_T.

Module  Impl_subtle_ConstantTimeEq_for_subtle_CtOption_T.
Section Impl_subtle_ConstantTimeEq_for_subtle_CtOption_T.
  Context {T : Set}.
  
  Definition Self : Ty.t := Ty.apply (Ty.path "subtle::CtOption") [T].
  
  (*
      fn ct_eq(&self, rhs: &CtOption<T>) -> Choice {
          let a = self.is_some();
          let b = rhs.is_some();
  
          (a & b & self.value.ct_eq(&rhs.value)) | (!a & !b)
      }
  *)
  Definition ct_eq (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self; rhs] =>
      let* self := M.alloc self in
      let* rhs := M.alloc rhs in
      let* a : Ty.apply (Ty.path "subtle::Choice") [] :=
        let* Œ±0 :
            Ty.apply
              (Ty.path "ref")
              [Ty.apply (Ty.path "subtle::CtOption") [T]] :=
          M.read self in
        let* Œ±1 : Ty.apply (Ty.path "subtle::Choice") [] :=
          M.call
            ((Ty.apply (Ty.path "subtle::CtOption") [T])::["is_some"] Œ±0) in
        M.alloc Œ±1 in
      let* b : Ty.apply (Ty.path "subtle::Choice") [] :=
        let* Œ±0 :
            Ty.apply
              (Ty.path "ref")
              [Ty.apply (Ty.path "subtle::CtOption") [T]] :=
          M.read rhs in
        let* Œ±1 : Ty.apply (Ty.path "subtle::Choice") [] :=
          M.call
            ((Ty.apply (Ty.path "subtle::CtOption") [T])::["is_some"] Œ±0) in
        M.alloc Œ±1 in
      let* Œ±0 :
          Ty.function
            [Ty.apply (Ty.path "subtle::Choice") [];
              Ty.apply (Ty.path "subtle::Choice") []]
            _ :=
        ltac:(M.get_method (fun ‚Ñê =>
          core.ops.bit.BitOr.bitor
            (Self := Ty.apply (Ty.path "subtle::Choice") [])
            (Rhs := Ty.apply (Ty.path "subtle::Choice") [])
            (Trait := ‚Ñê))) in
      let* Œ±1 :
          Ty.function
            [Ty.apply (Ty.path "subtle::Choice") [];
              Ty.apply (Ty.path "subtle::Choice") []]
            _ :=
        ltac:(M.get_method (fun ‚Ñê =>
          core.ops.bit.BitAnd.bitand
            (Self := Ty.apply (Ty.path "subtle::Choice") [])
            (Rhs := Ty.apply (Ty.path "subtle::Choice") [])
            (Trait := ‚Ñê))) in
      let* Œ±2 :
          Ty.function
            [Ty.apply (Ty.path "subtle::Choice") [];
              Ty.apply (Ty.path "subtle::Choice") []]
            _ :=
        ltac:(M.get_method (fun ‚Ñê =>
          core.ops.bit.BitAnd.bitand
            (Self := Ty.apply (Ty.path "subtle::Choice") [])
            (Rhs := Ty.apply (Ty.path "subtle::Choice") [])
            (Trait := ‚Ñê))) in
      let* Œ±3 : Ty.apply (Ty.path "subtle::Choice") [] := M.read a in
      let* Œ±4 : Ty.apply (Ty.path "subtle::Choice") [] := M.read b in
      let* Œ±5 : Ty.apply (Ty.path "subtle::Choice") [] := M.call (Œ±2 Œ±3 Œ±4) in
      let* Œ±6 :
          Ty.function
            [Ty.apply (Ty.path "ref") [T]; Ty.apply (Ty.path "ref") [T]]
            (Ty.apply (Ty.path "subtle::Choice") []) :=
        ltac:(M.get_method (fun ‚Ñê =>
          subtle.ConstantTimeEq.ct_eq (Self := T) (Trait := ‚Ñê))) in
      let* Œ±7 :
          Ty.apply
            (Ty.path "ref")
            [Ty.apply (Ty.path "subtle::CtOption") [T]] :=
        M.read self in
      let* Œ±8 :
          Ty.apply
            (Ty.path "ref")
            [Ty.apply (Ty.path "subtle::CtOption") [T]] :=
        M.read rhs in
      let* Œ±9 : Ty.apply (Ty.path "subtle::Choice") [] :=
        M.call
          (Œ±6
            (borrow (subtle.CtOption.Get_value (deref Œ±7)))
            (borrow (subtle.CtOption.Get_value (deref Œ±8)))) in
      let* Œ±10 : Ty.apply (Ty.path "subtle::Choice") [] := M.call (Œ±1 Œ±5 Œ±9) in
      let* Œ±11 :
          Ty.function
            [Ty.apply (Ty.path "subtle::Choice") [];
              Ty.apply (Ty.path "subtle::Choice") []]
            _ :=
        ltac:(M.get_method (fun ‚Ñê =>
          core.ops.bit.BitAnd.bitand
            (Self := Ty.apply (Ty.path "subtle::Choice") [])
            (Rhs := Ty.apply (Ty.path "subtle::Choice") [])
            (Trait := ‚Ñê))) in
      let* Œ±12 : Ty.function [Ty.apply (Ty.path "subtle::Choice") []] _ :=
        ltac:(M.get_method (fun ‚Ñê =>
          core.ops.bit.Not.not
            (Self := Ty.apply (Ty.path "subtle::Choice") [])
            (Trait := ‚Ñê))) in
      let* Œ±13 : Ty.apply (Ty.path "subtle::Choice") [] := M.read a in
      let* Œ±14 : Ty.apply (Ty.path "subtle::Choice") [] := M.call (Œ±12 Œ±13) in
      let* Œ±15 : Ty.function [Ty.apply (Ty.path "subtle::Choice") []] _ :=
        ltac:(M.get_method (fun ‚Ñê =>
          core.ops.bit.Not.not
            (Self := Ty.apply (Ty.path "subtle::Choice") [])
            (Trait := ‚Ñê))) in
      let* Œ±16 : Ty.apply (Ty.path "subtle::Choice") [] := M.read b in
      let* Œ±17 : Ty.apply (Ty.path "subtle::Choice") [] := M.call (Œ±15 Œ±16) in
      let* Œ±18 : Ty.apply (Ty.path "subtle::Choice") [] :=
        M.call (Œ±11 Œ±14 Œ±17) in
      let* Œ±19 : Ty.apply (Ty.path "subtle::Choice") [] :=
        M.call (Œ±0 Œ±10 Œ±18) in
      let* Œ±0 : Ty.apply (Ty.path "subtle::Choice") [] := M.alloc Œ±19 in
      M.read Œ±0
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_ct_eq : Instance.t := {
    Notations.double_colon := ct_eq;
  }.
  
  Definition ‚Ñê : Instance.t := [("ct_eq", ct_eq); ("ct_ne", ct_ne)].
End Impl_subtle_ConstantTimeEq_for_subtle_CtOption_T.
End Impl_subtle_ConstantTimeEq_for_subtle_CtOption_T.

Module  ConstantTimeGreater.
Section ConstantTimeGreater.
  Class Trait (Self : Set) : Type := {
    ct_gt :
      Ty.function
        [Ty.apply (Ty.path "ref") [Self]; Ty.apply (Ty.path "ref") [Self]]
        (Ty.apply (Ty.path "subtle::Choice") []);
  }.
  
End ConstantTimeGreater.
End ConstantTimeGreater.

Module  Impl_subtle_ConstantTimeGreater_for_u8.
Section Impl_subtle_ConstantTimeGreater_for_u8.
  Definition Self : Ty.t := Ty.path "u8".
  
  (*
              fn ct_gt(&self, other: &$t_u) -> Choice {
                  let gtb = self & !other; // All the bits in self that are greater than their corresponding bits in other.
                  let mut ltb = !self & other; // All the bits in self that are less than their corresponding bits in other.
                  let mut pow = 1;
  
                  // Less-than operator is okay here because it's dependent on the bit-width.
                  while pow < $bit_width {
                      ltb |= ltb >> pow; // Bit-smear the highest set bit to the right.
                      pow += pow;
                  }
                  let mut bit = gtb & !ltb; // Select the highest set bit.
                  let mut pow = 1;
  
                  while pow < $bit_width {
                      bit |= bit >> pow; // Shift it to the right until we end up with either 0 or 1.
                      pow += pow;
                  }
                  // XXX We should possibly do the above flattening to 0 or 1 in the
                  //     Choice constructor rather than making it a debug error?
                  Choice::from((bit & 1) as u8)
              }
  *)
  Definition ct_gt (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self; other] =>
      let* self := M.alloc self in
      let* other := M.alloc other in
      let* gtb : Ty.path "u8" :=
        let* Œ±0 :
            Ty.function
              [Ty.apply (Ty.path "ref") [Ty.path "u8"]; Ty.path "u8"]
              _ :=
          ltac:(M.get_method (fun ‚Ñê =>
            core.ops.bit.BitAnd.bitand
              (Self := Ty.apply (Ty.path "ref") [Ty.path "u8"])
              (Rhs := Ty.path "u8")
              (Trait := ‚Ñê))) in
        let* Œ±1 : Ty.apply (Ty.path "ref") [Ty.path "u8"] := M.read self in
        let* Œ±2 : Ty.function [Ty.apply (Ty.path "ref") [Ty.path "u8"]] _ :=
          ltac:(M.get_method (fun ‚Ñê =>
            core.ops.bit.Not.not
              (Self := Ty.apply (Ty.path "ref") [Ty.path "u8"])
              (Trait := ‚Ñê))) in
        let* Œ±3 : Ty.apply (Ty.path "ref") [Ty.path "u8"] := M.read other in
        let* Œ±4 : Ty.path "u8" := M.call (Œ±2 Œ±3) in
        let* Œ±5 : Ty.path "u8" := M.call (Œ±0 Œ±1 Œ±4) in
        M.alloc Œ±5 in
      let* ltb : Ty.path "u8" :=
        let* Œ±0 :
            Ty.function
              [Ty.path "u8"; Ty.apply (Ty.path "ref") [Ty.path "u8"]]
              _ :=
          ltac:(M.get_method (fun ‚Ñê =>
            core.ops.bit.BitAnd.bitand
              (Self := Ty.path "u8")
              (Rhs := Ty.apply (Ty.path "ref") [Ty.path "u8"])
              (Trait := ‚Ñê))) in
        let* Œ±1 : Ty.function [Ty.apply (Ty.path "ref") [Ty.path "u8"]] _ :=
          ltac:(M.get_method (fun ‚Ñê =>
            core.ops.bit.Not.not
              (Self := Ty.apply (Ty.path "ref") [Ty.path "u8"])
              (Trait := ‚Ñê))) in
        let* Œ±2 : Ty.apply (Ty.path "ref") [Ty.path "u8"] := M.read self in
        let* Œ±3 : Ty.path "u8" := M.call (Œ±1 Œ±2) in
        let* Œ±4 : Ty.apply (Ty.path "ref") [Ty.path "u8"] := M.read other in
        let* Œ±5 : Ty.path "u8" := M.call (Œ±0 Œ±3 Œ±4) in
        M.alloc Œ±5 in
      let* pow : Ty.path "i32" := M.alloc ((Integer.of_Z 1) : Ty.path "i32") in
      let* _ : Ty.tuple :=
        M.loop
          (let* Œ±0 : Ty.path "i32" := M.read pow in
          let* Œ±1 : Ty.path "bool" :=
            M.alloc (BinOp.Pure.lt Œ±0 ((Integer.of_Z 8) : Ty.path "i32")) in
          let* Œ±2 : Ty.path "bool" := M.read (use Œ±1) in
          if Œ±2 then
            let* _ : Ty.tuple :=
              let Œ≤ : Ty.path "u8" := ltb in
              let* Œ±0 := M.read Œ≤ in
              let* Œ±1 : Ty.path "u8" := M.read ltb in
              let* Œ±2 : Ty.path "i32" := M.read pow in
              let* Œ±3 : Ty.path "u8" := BinOp.Panic.shr Œ±1 Œ±2 in
              assign Œ≤ (BinOp.Pure.bit_or Œ±0 Œ±3) in
            let* _ : Ty.tuple :=
              let Œ≤ : Ty.path "i32" := pow in
              let* Œ±0 := M.read Œ≤ in
              let* Œ±1 : Ty.path "i32" := M.read pow in
              let* Œ±2 := BinOp.Panic.add Œ±0 Œ±1 in
              assign Œ≤ Œ±2 in
            M.alloc tt
          else
            let* _ : Ty.tuple :=
              let* Œ±0 : Ty.path "never" := M.break in
              let* Œ±1 : Ty.path "never" := M.read Œ±0 in
              let* Œ±2 : Ty.tuple := never_to_any Œ±1 in
              M.alloc Œ±2 in
            let* Œ±0 : Ty.path "unit" := M.alloc tt in
            let* Œ±1 : Ty.path "never" := M.read Œ±0 in
            let* Œ±2 : Ty.tuple := never_to_any Œ±1 in
            M.alloc Œ±2) in
      let* bit : Ty.path "u8" :=
        let* Œ±0 : Ty.path "u8" := M.read gtb in
        let* Œ±1 : Ty.path "u8" := M.read ltb in
        M.alloc (BinOp.Pure.bit_and Œ±0 (UnOp.not Œ±1)) in
      let* pow : Ty.path "i32" := M.alloc ((Integer.of_Z 1) : Ty.path "i32") in
      let* _ : Ty.tuple :=
        M.loop
          (let* Œ±0 : Ty.path "i32" := M.read pow in
          let* Œ±1 : Ty.path "bool" :=
            M.alloc (BinOp.Pure.lt Œ±0 ((Integer.of_Z 8) : Ty.path "i32")) in
          let* Œ±2 : Ty.path "bool" := M.read (use Œ±1) in
          if Œ±2 then
            let* _ : Ty.tuple :=
              let Œ≤ : Ty.path "u8" := bit in
              let* Œ±0 := M.read Œ≤ in
              let* Œ±1 : Ty.path "u8" := M.read bit in
              let* Œ±2 : Ty.path "i32" := M.read pow in
              let* Œ±3 : Ty.path "u8" := BinOp.Panic.shr Œ±1 Œ±2 in
              assign Œ≤ (BinOp.Pure.bit_or Œ±0 Œ±3) in
            let* _ : Ty.tuple :=
              let Œ≤ : Ty.path "i32" := pow in
              let* Œ±0 := M.read Œ≤ in
              let* Œ±1 : Ty.path "i32" := M.read pow in
              let* Œ±2 := BinOp.Panic.add Œ±0 Œ±1 in
              assign Œ≤ Œ±2 in
            M.alloc tt
          else
            let* _ : Ty.tuple :=
              let* Œ±0 : Ty.path "never" := M.break in
              let* Œ±1 : Ty.path "never" := M.read Œ±0 in
              let* Œ±2 : Ty.tuple := never_to_any Œ±1 in
              M.alloc Œ±2 in
            let* Œ±0 : Ty.path "unit" := M.alloc tt in
            let* Œ±1 : Ty.path "never" := M.read Œ±0 in
            let* Œ±2 : Ty.tuple := never_to_any Œ±1 in
            M.alloc Œ±2) in
      let* Œ±0 :
          Ty.function [Ty.path "u8"] (Ty.apply (Ty.path "subtle::Choice") []) :=
        ltac:(M.get_method (fun ‚Ñê =>
          core.convert.From.from
            (Self := Ty.apply (Ty.path "subtle::Choice") [])
            (T := Ty.path "u8")
            (Trait := ‚Ñê))) in
      let* Œ±1 : Ty.path "u8" := M.read bit in
      let* Œ±2 : Ty.path "u8" :=
        M.alloc (BinOp.Pure.bit_and Œ±1 ((Integer.of_Z 1) : Ty.path "u8")) in
      let* Œ±3 : Ty.path "u8" := M.read (use Œ±2) in
      let* Œ±4 : Ty.apply (Ty.path "subtle::Choice") [] := M.call (Œ±0 Œ±3) in
      let* Œ±0 : Ty.apply (Ty.path "subtle::Choice") [] := M.alloc Œ±4 in
      M.read Œ±0
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_ct_gt : Instance.t := {
    Notations.double_colon := ct_gt;
  }.
  
  Definition ‚Ñê : Instance.t := [("ct_gt", ct_gt)].
End Impl_subtle_ConstantTimeGreater_for_u8.
End Impl_subtle_ConstantTimeGreater_for_u8.

Module  Impl_subtle_ConstantTimeGreater_for_u16.
Section Impl_subtle_ConstantTimeGreater_for_u16.
  Definition Self : Ty.t := Ty.path "u16".
  
  (*
              fn ct_gt(&self, other: &$t_u) -> Choice {
                  let gtb = self & !other; // All the bits in self that are greater than their corresponding bits in other.
                  let mut ltb = !self & other; // All the bits in self that are less than their corresponding bits in other.
                  let mut pow = 1;
  
                  // Less-than operator is okay here because it's dependent on the bit-width.
                  while pow < $bit_width {
                      ltb |= ltb >> pow; // Bit-smear the highest set bit to the right.
                      pow += pow;
                  }
                  let mut bit = gtb & !ltb; // Select the highest set bit.
                  let mut pow = 1;
  
                  while pow < $bit_width {
                      bit |= bit >> pow; // Shift it to the right until we end up with either 0 or 1.
                      pow += pow;
                  }
                  // XXX We should possibly do the above flattening to 0 or 1 in the
                  //     Choice constructor rather than making it a debug error?
                  Choice::from((bit & 1) as u8)
              }
  *)
  Definition ct_gt (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self; other] =>
      let* self := M.alloc self in
      let* other := M.alloc other in
      let* gtb : Ty.path "u16" :=
        let* Œ±0 :
            Ty.function
              [Ty.apply (Ty.path "ref") [Ty.path "u16"]; Ty.path "u16"]
              _ :=
          ltac:(M.get_method (fun ‚Ñê =>
            core.ops.bit.BitAnd.bitand
              (Self := Ty.apply (Ty.path "ref") [Ty.path "u16"])
              (Rhs := Ty.path "u16")
              (Trait := ‚Ñê))) in
        let* Œ±1 : Ty.apply (Ty.path "ref") [Ty.path "u16"] := M.read self in
        let* Œ±2 : Ty.function [Ty.apply (Ty.path "ref") [Ty.path "u16"]] _ :=
          ltac:(M.get_method (fun ‚Ñê =>
            core.ops.bit.Not.not
              (Self := Ty.apply (Ty.path "ref") [Ty.path "u16"])
              (Trait := ‚Ñê))) in
        let* Œ±3 : Ty.apply (Ty.path "ref") [Ty.path "u16"] := M.read other in
        let* Œ±4 : Ty.path "u16" := M.call (Œ±2 Œ±3) in
        let* Œ±5 : Ty.path "u16" := M.call (Œ±0 Œ±1 Œ±4) in
        M.alloc Œ±5 in
      let* ltb : Ty.path "u16" :=
        let* Œ±0 :
            Ty.function
              [Ty.path "u16"; Ty.apply (Ty.path "ref") [Ty.path "u16"]]
              _ :=
          ltac:(M.get_method (fun ‚Ñê =>
            core.ops.bit.BitAnd.bitand
              (Self := Ty.path "u16")
              (Rhs := Ty.apply (Ty.path "ref") [Ty.path "u16"])
              (Trait := ‚Ñê))) in
        let* Œ±1 : Ty.function [Ty.apply (Ty.path "ref") [Ty.path "u16"]] _ :=
          ltac:(M.get_method (fun ‚Ñê =>
            core.ops.bit.Not.not
              (Self := Ty.apply (Ty.path "ref") [Ty.path "u16"])
              (Trait := ‚Ñê))) in
        let* Œ±2 : Ty.apply (Ty.path "ref") [Ty.path "u16"] := M.read self in
        let* Œ±3 : Ty.path "u16" := M.call (Œ±1 Œ±2) in
        let* Œ±4 : Ty.apply (Ty.path "ref") [Ty.path "u16"] := M.read other in
        let* Œ±5 : Ty.path "u16" := M.call (Œ±0 Œ±3 Œ±4) in
        M.alloc Œ±5 in
      let* pow : Ty.path "i32" := M.alloc ((Integer.of_Z 1) : Ty.path "i32") in
      let* _ : Ty.tuple :=
        M.loop
          (let* Œ±0 : Ty.path "i32" := M.read pow in
          let* Œ±1 : Ty.path "bool" :=
            M.alloc (BinOp.Pure.lt Œ±0 ((Integer.of_Z 16) : Ty.path "i32")) in
          let* Œ±2 : Ty.path "bool" := M.read (use Œ±1) in
          if Œ±2 then
            let* _ : Ty.tuple :=
              let Œ≤ : Ty.path "u16" := ltb in
              let* Œ±0 := M.read Œ≤ in
              let* Œ±1 : Ty.path "u16" := M.read ltb in
              let* Œ±2 : Ty.path "i32" := M.read pow in
              let* Œ±3 : Ty.path "u16" := BinOp.Panic.shr Œ±1 Œ±2 in
              assign Œ≤ (BinOp.Pure.bit_or Œ±0 Œ±3) in
            let* _ : Ty.tuple :=
              let Œ≤ : Ty.path "i32" := pow in
              let* Œ±0 := M.read Œ≤ in
              let* Œ±1 : Ty.path "i32" := M.read pow in
              let* Œ±2 := BinOp.Panic.add Œ±0 Œ±1 in
              assign Œ≤ Œ±2 in
            M.alloc tt
          else
            let* _ : Ty.tuple :=
              let* Œ±0 : Ty.path "never" := M.break in
              let* Œ±1 : Ty.path "never" := M.read Œ±0 in
              let* Œ±2 : Ty.tuple := never_to_any Œ±1 in
              M.alloc Œ±2 in
            let* Œ±0 : Ty.path "unit" := M.alloc tt in
            let* Œ±1 : Ty.path "never" := M.read Œ±0 in
            let* Œ±2 : Ty.tuple := never_to_any Œ±1 in
            M.alloc Œ±2) in
      let* bit : Ty.path "u16" :=
        let* Œ±0 : Ty.path "u16" := M.read gtb in
        let* Œ±1 : Ty.path "u16" := M.read ltb in
        M.alloc (BinOp.Pure.bit_and Œ±0 (UnOp.not Œ±1)) in
      let* pow : Ty.path "i32" := M.alloc ((Integer.of_Z 1) : Ty.path "i32") in
      let* _ : Ty.tuple :=
        M.loop
          (let* Œ±0 : Ty.path "i32" := M.read pow in
          let* Œ±1 : Ty.path "bool" :=
            M.alloc (BinOp.Pure.lt Œ±0 ((Integer.of_Z 16) : Ty.path "i32")) in
          let* Œ±2 : Ty.path "bool" := M.read (use Œ±1) in
          if Œ±2 then
            let* _ : Ty.tuple :=
              let Œ≤ : Ty.path "u16" := bit in
              let* Œ±0 := M.read Œ≤ in
              let* Œ±1 : Ty.path "u16" := M.read bit in
              let* Œ±2 : Ty.path "i32" := M.read pow in
              let* Œ±3 : Ty.path "u16" := BinOp.Panic.shr Œ±1 Œ±2 in
              assign Œ≤ (BinOp.Pure.bit_or Œ±0 Œ±3) in
            let* _ : Ty.tuple :=
              let Œ≤ : Ty.path "i32" := pow in
              let* Œ±0 := M.read Œ≤ in
              let* Œ±1 : Ty.path "i32" := M.read pow in
              let* Œ±2 := BinOp.Panic.add Œ±0 Œ±1 in
              assign Œ≤ Œ±2 in
            M.alloc tt
          else
            let* _ : Ty.tuple :=
              let* Œ±0 : Ty.path "never" := M.break in
              let* Œ±1 : Ty.path "never" := M.read Œ±0 in
              let* Œ±2 : Ty.tuple := never_to_any Œ±1 in
              M.alloc Œ±2 in
            let* Œ±0 : Ty.path "unit" := M.alloc tt in
            let* Œ±1 : Ty.path "never" := M.read Œ±0 in
            let* Œ±2 : Ty.tuple := never_to_any Œ±1 in
            M.alloc Œ±2) in
      let* Œ±0 :
          Ty.function [Ty.path "u8"] (Ty.apply (Ty.path "subtle::Choice") []) :=
        ltac:(M.get_method (fun ‚Ñê =>
          core.convert.From.from
            (Self := Ty.apply (Ty.path "subtle::Choice") [])
            (T := Ty.path "u8")
            (Trait := ‚Ñê))) in
      let* Œ±1 : Ty.path "u16" := M.read bit in
      let* Œ±2 : Ty.apply (Ty.path "subtle::Choice") [] :=
        M.call
          (Œ±0
            (rust_cast
              (BinOp.Pure.bit_and Œ±1 ((Integer.of_Z 1) : Ty.path "u16")))) in
      let* Œ±0 : Ty.apply (Ty.path "subtle::Choice") [] := M.alloc Œ±2 in
      M.read Œ±0
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_ct_gt : Instance.t := {
    Notations.double_colon := ct_gt;
  }.
  
  Definition ‚Ñê : Instance.t := [("ct_gt", ct_gt)].
End Impl_subtle_ConstantTimeGreater_for_u16.
End Impl_subtle_ConstantTimeGreater_for_u16.

Module  Impl_subtle_ConstantTimeGreater_for_u32.
Section Impl_subtle_ConstantTimeGreater_for_u32.
  Definition Self : Ty.t := Ty.path "u32".
  
  (*
              fn ct_gt(&self, other: &$t_u) -> Choice {
                  let gtb = self & !other; // All the bits in self that are greater than their corresponding bits in other.
                  let mut ltb = !self & other; // All the bits in self that are less than their corresponding bits in other.
                  let mut pow = 1;
  
                  // Less-than operator is okay here because it's dependent on the bit-width.
                  while pow < $bit_width {
                      ltb |= ltb >> pow; // Bit-smear the highest set bit to the right.
                      pow += pow;
                  }
                  let mut bit = gtb & !ltb; // Select the highest set bit.
                  let mut pow = 1;
  
                  while pow < $bit_width {
                      bit |= bit >> pow; // Shift it to the right until we end up with either 0 or 1.
                      pow += pow;
                  }
                  // XXX We should possibly do the above flattening to 0 or 1 in the
                  //     Choice constructor rather than making it a debug error?
                  Choice::from((bit & 1) as u8)
              }
  *)
  Definition ct_gt (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self; other] =>
      let* self := M.alloc self in
      let* other := M.alloc other in
      let* gtb : Ty.path "u32" :=
        let* Œ±0 :
            Ty.function
              [Ty.apply (Ty.path "ref") [Ty.path "u32"]; Ty.path "u32"]
              _ :=
          ltac:(M.get_method (fun ‚Ñê =>
            core.ops.bit.BitAnd.bitand
              (Self := Ty.apply (Ty.path "ref") [Ty.path "u32"])
              (Rhs := Ty.path "u32")
              (Trait := ‚Ñê))) in
        let* Œ±1 : Ty.apply (Ty.path "ref") [Ty.path "u32"] := M.read self in
        let* Œ±2 : Ty.function [Ty.apply (Ty.path "ref") [Ty.path "u32"]] _ :=
          ltac:(M.get_method (fun ‚Ñê =>
            core.ops.bit.Not.not
              (Self := Ty.apply (Ty.path "ref") [Ty.path "u32"])
              (Trait := ‚Ñê))) in
        let* Œ±3 : Ty.apply (Ty.path "ref") [Ty.path "u32"] := M.read other in
        let* Œ±4 : Ty.path "u32" := M.call (Œ±2 Œ±3) in
        let* Œ±5 : Ty.path "u32" := M.call (Œ±0 Œ±1 Œ±4) in
        M.alloc Œ±5 in
      let* ltb : Ty.path "u32" :=
        let* Œ±0 :
            Ty.function
              [Ty.path "u32"; Ty.apply (Ty.path "ref") [Ty.path "u32"]]
              _ :=
          ltac:(M.get_method (fun ‚Ñê =>
            core.ops.bit.BitAnd.bitand
              (Self := Ty.path "u32")
              (Rhs := Ty.apply (Ty.path "ref") [Ty.path "u32"])
              (Trait := ‚Ñê))) in
        let* Œ±1 : Ty.function [Ty.apply (Ty.path "ref") [Ty.path "u32"]] _ :=
          ltac:(M.get_method (fun ‚Ñê =>
            core.ops.bit.Not.not
              (Self := Ty.apply (Ty.path "ref") [Ty.path "u32"])
              (Trait := ‚Ñê))) in
        let* Œ±2 : Ty.apply (Ty.path "ref") [Ty.path "u32"] := M.read self in
        let* Œ±3 : Ty.path "u32" := M.call (Œ±1 Œ±2) in
        let* Œ±4 : Ty.apply (Ty.path "ref") [Ty.path "u32"] := M.read other in
        let* Œ±5 : Ty.path "u32" := M.call (Œ±0 Œ±3 Œ±4) in
        M.alloc Œ±5 in
      let* pow : Ty.path "i32" := M.alloc ((Integer.of_Z 1) : Ty.path "i32") in
      let* _ : Ty.tuple :=
        M.loop
          (let* Œ±0 : Ty.path "i32" := M.read pow in
          let* Œ±1 : Ty.path "bool" :=
            M.alloc (BinOp.Pure.lt Œ±0 ((Integer.of_Z 32) : Ty.path "i32")) in
          let* Œ±2 : Ty.path "bool" := M.read (use Œ±1) in
          if Œ±2 then
            let* _ : Ty.tuple :=
              let Œ≤ : Ty.path "u32" := ltb in
              let* Œ±0 := M.read Œ≤ in
              let* Œ±1 : Ty.path "u32" := M.read ltb in
              let* Œ±2 : Ty.path "i32" := M.read pow in
              let* Œ±3 : Ty.path "u32" := BinOp.Panic.shr Œ±1 Œ±2 in
              assign Œ≤ (BinOp.Pure.bit_or Œ±0 Œ±3) in
            let* _ : Ty.tuple :=
              let Œ≤ : Ty.path "i32" := pow in
              let* Œ±0 := M.read Œ≤ in
              let* Œ±1 : Ty.path "i32" := M.read pow in
              let* Œ±2 := BinOp.Panic.add Œ±0 Œ±1 in
              assign Œ≤ Œ±2 in
            M.alloc tt
          else
            let* _ : Ty.tuple :=
              let* Œ±0 : Ty.path "never" := M.break in
              let* Œ±1 : Ty.path "never" := M.read Œ±0 in
              let* Œ±2 : Ty.tuple := never_to_any Œ±1 in
              M.alloc Œ±2 in
            let* Œ±0 : Ty.path "unit" := M.alloc tt in
            let* Œ±1 : Ty.path "never" := M.read Œ±0 in
            let* Œ±2 : Ty.tuple := never_to_any Œ±1 in
            M.alloc Œ±2) in
      let* bit : Ty.path "u32" :=
        let* Œ±0 : Ty.path "u32" := M.read gtb in
        let* Œ±1 : Ty.path "u32" := M.read ltb in
        M.alloc (BinOp.Pure.bit_and Œ±0 (UnOp.not Œ±1)) in
      let* pow : Ty.path "i32" := M.alloc ((Integer.of_Z 1) : Ty.path "i32") in
      let* _ : Ty.tuple :=
        M.loop
          (let* Œ±0 : Ty.path "i32" := M.read pow in
          let* Œ±1 : Ty.path "bool" :=
            M.alloc (BinOp.Pure.lt Œ±0 ((Integer.of_Z 32) : Ty.path "i32")) in
          let* Œ±2 : Ty.path "bool" := M.read (use Œ±1) in
          if Œ±2 then
            let* _ : Ty.tuple :=
              let Œ≤ : Ty.path "u32" := bit in
              let* Œ±0 := M.read Œ≤ in
              let* Œ±1 : Ty.path "u32" := M.read bit in
              let* Œ±2 : Ty.path "i32" := M.read pow in
              let* Œ±3 : Ty.path "u32" := BinOp.Panic.shr Œ±1 Œ±2 in
              assign Œ≤ (BinOp.Pure.bit_or Œ±0 Œ±3) in
            let* _ : Ty.tuple :=
              let Œ≤ : Ty.path "i32" := pow in
              let* Œ±0 := M.read Œ≤ in
              let* Œ±1 : Ty.path "i32" := M.read pow in
              let* Œ±2 := BinOp.Panic.add Œ±0 Œ±1 in
              assign Œ≤ Œ±2 in
            M.alloc tt
          else
            let* _ : Ty.tuple :=
              let* Œ±0 : Ty.path "never" := M.break in
              let* Œ±1 : Ty.path "never" := M.read Œ±0 in
              let* Œ±2 : Ty.tuple := never_to_any Œ±1 in
              M.alloc Œ±2 in
            let* Œ±0 : Ty.path "unit" := M.alloc tt in
            let* Œ±1 : Ty.path "never" := M.read Œ±0 in
            let* Œ±2 : Ty.tuple := never_to_any Œ±1 in
            M.alloc Œ±2) in
      let* Œ±0 :
          Ty.function [Ty.path "u8"] (Ty.apply (Ty.path "subtle::Choice") []) :=
        ltac:(M.get_method (fun ‚Ñê =>
          core.convert.From.from
            (Self := Ty.apply (Ty.path "subtle::Choice") [])
            (T := Ty.path "u8")
            (Trait := ‚Ñê))) in
      let* Œ±1 : Ty.path "u32" := M.read bit in
      let* Œ±2 : Ty.apply (Ty.path "subtle::Choice") [] :=
        M.call
          (Œ±0
            (rust_cast
              (BinOp.Pure.bit_and Œ±1 ((Integer.of_Z 1) : Ty.path "u32")))) in
      let* Œ±0 : Ty.apply (Ty.path "subtle::Choice") [] := M.alloc Œ±2 in
      M.read Œ±0
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_ct_gt : Instance.t := {
    Notations.double_colon := ct_gt;
  }.
  
  Definition ‚Ñê : Instance.t := [("ct_gt", ct_gt)].
End Impl_subtle_ConstantTimeGreater_for_u32.
End Impl_subtle_ConstantTimeGreater_for_u32.

Module  Impl_subtle_ConstantTimeGreater_for_u64.
Section Impl_subtle_ConstantTimeGreater_for_u64.
  Definition Self : Ty.t := Ty.path "u64".
  
  (*
              fn ct_gt(&self, other: &$t_u) -> Choice {
                  let gtb = self & !other; // All the bits in self that are greater than their corresponding bits in other.
                  let mut ltb = !self & other; // All the bits in self that are less than their corresponding bits in other.
                  let mut pow = 1;
  
                  // Less-than operator is okay here because it's dependent on the bit-width.
                  while pow < $bit_width {
                      ltb |= ltb >> pow; // Bit-smear the highest set bit to the right.
                      pow += pow;
                  }
                  let mut bit = gtb & !ltb; // Select the highest set bit.
                  let mut pow = 1;
  
                  while pow < $bit_width {
                      bit |= bit >> pow; // Shift it to the right until we end up with either 0 or 1.
                      pow += pow;
                  }
                  // XXX We should possibly do the above flattening to 0 or 1 in the
                  //     Choice constructor rather than making it a debug error?
                  Choice::from((bit & 1) as u8)
              }
  *)
  Definition ct_gt (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self; other] =>
      let* self := M.alloc self in
      let* other := M.alloc other in
      let* gtb : Ty.path "u64" :=
        let* Œ±0 :
            Ty.function
              [Ty.apply (Ty.path "ref") [Ty.path "u64"]; Ty.path "u64"]
              _ :=
          ltac:(M.get_method (fun ‚Ñê =>
            core.ops.bit.BitAnd.bitand
              (Self := Ty.apply (Ty.path "ref") [Ty.path "u64"])
              (Rhs := Ty.path "u64")
              (Trait := ‚Ñê))) in
        let* Œ±1 : Ty.apply (Ty.path "ref") [Ty.path "u64"] := M.read self in
        let* Œ±2 : Ty.function [Ty.apply (Ty.path "ref") [Ty.path "u64"]] _ :=
          ltac:(M.get_method (fun ‚Ñê =>
            core.ops.bit.Not.not
              (Self := Ty.apply (Ty.path "ref") [Ty.path "u64"])
              (Trait := ‚Ñê))) in
        let* Œ±3 : Ty.apply (Ty.path "ref") [Ty.path "u64"] := M.read other in
        let* Œ±4 : Ty.path "u64" := M.call (Œ±2 Œ±3) in
        let* Œ±5 : Ty.path "u64" := M.call (Œ±0 Œ±1 Œ±4) in
        M.alloc Œ±5 in
      let* ltb : Ty.path "u64" :=
        let* Œ±0 :
            Ty.function
              [Ty.path "u64"; Ty.apply (Ty.path "ref") [Ty.path "u64"]]
              _ :=
          ltac:(M.get_method (fun ‚Ñê =>
            core.ops.bit.BitAnd.bitand
              (Self := Ty.path "u64")
              (Rhs := Ty.apply (Ty.path "ref") [Ty.path "u64"])
              (Trait := ‚Ñê))) in
        let* Œ±1 : Ty.function [Ty.apply (Ty.path "ref") [Ty.path "u64"]] _ :=
          ltac:(M.get_method (fun ‚Ñê =>
            core.ops.bit.Not.not
              (Self := Ty.apply (Ty.path "ref") [Ty.path "u64"])
              (Trait := ‚Ñê))) in
        let* Œ±2 : Ty.apply (Ty.path "ref") [Ty.path "u64"] := M.read self in
        let* Œ±3 : Ty.path "u64" := M.call (Œ±1 Œ±2) in
        let* Œ±4 : Ty.apply (Ty.path "ref") [Ty.path "u64"] := M.read other in
        let* Œ±5 : Ty.path "u64" := M.call (Œ±0 Œ±3 Œ±4) in
        M.alloc Œ±5 in
      let* pow : Ty.path "i32" := M.alloc ((Integer.of_Z 1) : Ty.path "i32") in
      let* _ : Ty.tuple :=
        M.loop
          (let* Œ±0 : Ty.path "i32" := M.read pow in
          let* Œ±1 : Ty.path "bool" :=
            M.alloc (BinOp.Pure.lt Œ±0 ((Integer.of_Z 64) : Ty.path "i32")) in
          let* Œ±2 : Ty.path "bool" := M.read (use Œ±1) in
          if Œ±2 then
            let* _ : Ty.tuple :=
              let Œ≤ : Ty.path "u64" := ltb in
              let* Œ±0 := M.read Œ≤ in
              let* Œ±1 : Ty.path "u64" := M.read ltb in
              let* Œ±2 : Ty.path "i32" := M.read pow in
              let* Œ±3 : Ty.path "u64" := BinOp.Panic.shr Œ±1 Œ±2 in
              assign Œ≤ (BinOp.Pure.bit_or Œ±0 Œ±3) in
            let* _ : Ty.tuple :=
              let Œ≤ : Ty.path "i32" := pow in
              let* Œ±0 := M.read Œ≤ in
              let* Œ±1 : Ty.path "i32" := M.read pow in
              let* Œ±2 := BinOp.Panic.add Œ±0 Œ±1 in
              assign Œ≤ Œ±2 in
            M.alloc tt
          else
            let* _ : Ty.tuple :=
              let* Œ±0 : Ty.path "never" := M.break in
              let* Œ±1 : Ty.path "never" := M.read Œ±0 in
              let* Œ±2 : Ty.tuple := never_to_any Œ±1 in
              M.alloc Œ±2 in
            let* Œ±0 : Ty.path "unit" := M.alloc tt in
            let* Œ±1 : Ty.path "never" := M.read Œ±0 in
            let* Œ±2 : Ty.tuple := never_to_any Œ±1 in
            M.alloc Œ±2) in
      let* bit : Ty.path "u64" :=
        let* Œ±0 : Ty.path "u64" := M.read gtb in
        let* Œ±1 : Ty.path "u64" := M.read ltb in
        M.alloc (BinOp.Pure.bit_and Œ±0 (UnOp.not Œ±1)) in
      let* pow : Ty.path "i32" := M.alloc ((Integer.of_Z 1) : Ty.path "i32") in
      let* _ : Ty.tuple :=
        M.loop
          (let* Œ±0 : Ty.path "i32" := M.read pow in
          let* Œ±1 : Ty.path "bool" :=
            M.alloc (BinOp.Pure.lt Œ±0 ((Integer.of_Z 64) : Ty.path "i32")) in
          let* Œ±2 : Ty.path "bool" := M.read (use Œ±1) in
          if Œ±2 then
            let* _ : Ty.tuple :=
              let Œ≤ : Ty.path "u64" := bit in
              let* Œ±0 := M.read Œ≤ in
              let* Œ±1 : Ty.path "u64" := M.read bit in
              let* Œ±2 : Ty.path "i32" := M.read pow in
              let* Œ±3 : Ty.path "u64" := BinOp.Panic.shr Œ±1 Œ±2 in
              assign Œ≤ (BinOp.Pure.bit_or Œ±0 Œ±3) in
            let* _ : Ty.tuple :=
              let Œ≤ : Ty.path "i32" := pow in
              let* Œ±0 := M.read Œ≤ in
              let* Œ±1 : Ty.path "i32" := M.read pow in
              let* Œ±2 := BinOp.Panic.add Œ±0 Œ±1 in
              assign Œ≤ Œ±2 in
            M.alloc tt
          else
            let* _ : Ty.tuple :=
              let* Œ±0 : Ty.path "never" := M.break in
              let* Œ±1 : Ty.path "never" := M.read Œ±0 in
              let* Œ±2 : Ty.tuple := never_to_any Œ±1 in
              M.alloc Œ±2 in
            let* Œ±0 : Ty.path "unit" := M.alloc tt in
            let* Œ±1 : Ty.path "never" := M.read Œ±0 in
            let* Œ±2 : Ty.tuple := never_to_any Œ±1 in
            M.alloc Œ±2) in
      let* Œ±0 :
          Ty.function [Ty.path "u8"] (Ty.apply (Ty.path "subtle::Choice") []) :=
        ltac:(M.get_method (fun ‚Ñê =>
          core.convert.From.from
            (Self := Ty.apply (Ty.path "subtle::Choice") [])
            (T := Ty.path "u8")
            (Trait := ‚Ñê))) in
      let* Œ±1 : Ty.path "u64" := M.read bit in
      let* Œ±2 : Ty.apply (Ty.path "subtle::Choice") [] :=
        M.call
          (Œ±0
            (rust_cast
              (BinOp.Pure.bit_and Œ±1 ((Integer.of_Z 1) : Ty.path "u64")))) in
      let* Œ±0 : Ty.apply (Ty.path "subtle::Choice") [] := M.alloc Œ±2 in
      M.read Œ±0
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_ct_gt : Instance.t := {
    Notations.double_colon := ct_gt;
  }.
  
  Definition ‚Ñê : Instance.t := [("ct_gt", ct_gt)].
End Impl_subtle_ConstantTimeGreater_for_u64.
End Impl_subtle_ConstantTimeGreater_for_u64.

Module  ConstantTimeLess.
Section ConstantTimeLess.
  Unset Primitive Projections.
  Class Trait (Self : Set) : Type := {
  }.
  Global Set Primitive Projections.
End ConstantTimeLess.
End ConstantTimeLess.

Module  Impl_subtle_ConstantTimeLess_for_u8.
Section Impl_subtle_ConstantTimeLess_for_u8.
  Definition Self : Ty.t := Ty.path "u8".
  
  Definition ‚Ñê : Instance.t := [("ct_lt", ct_lt)].
End Impl_subtle_ConstantTimeLess_for_u8.
End Impl_subtle_ConstantTimeLess_for_u8.

Module  Impl_subtle_ConstantTimeLess_for_u16.
Section Impl_subtle_ConstantTimeLess_for_u16.
  Definition Self : Ty.t := Ty.path "u16".
  
  Definition ‚Ñê : Instance.t := [("ct_lt", ct_lt)].
End Impl_subtle_ConstantTimeLess_for_u16.
End Impl_subtle_ConstantTimeLess_for_u16.

Module  Impl_subtle_ConstantTimeLess_for_u32.
Section Impl_subtle_ConstantTimeLess_for_u32.
  Definition Self : Ty.t := Ty.path "u32".
  
  Definition ‚Ñê : Instance.t := [("ct_lt", ct_lt)].
End Impl_subtle_ConstantTimeLess_for_u32.
End Impl_subtle_ConstantTimeLess_for_u32.

Module  Impl_subtle_ConstantTimeLess_for_u64.
Section Impl_subtle_ConstantTimeLess_for_u64.
  Definition Self : Ty.t := Ty.path "u64".
  
  Definition ‚Ñê : Instance.t := [("ct_lt", ct_lt)].
End Impl_subtle_ConstantTimeLess_for_u64.
End Impl_subtle_ConstantTimeLess_for_u64.
