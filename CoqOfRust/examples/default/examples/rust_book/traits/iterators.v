(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.



Module  Impl_core_iter_traits_iterator_Iterator_for_iterators_Fibonacci.
Section Impl_core_iter_traits_iterator_Iterator_for_iterators_Fibonacci.
  Definition Self : Ty.t := Ty.apply (Ty.path "iterators::Fibonacci") [].
  
  (*
      type Item = u32;
  *)
  Definition Item : Set := Ty.path "u32".
  
  (*
      fn next(&mut self) -> Option<Self::Item> {
          let current = self.curr;
  
          self.curr = self.next;
          self.next = current + self.next;
  
          // Since there's no endpoint to a Fibonacci sequence, the `Iterator`
          // will never return `None`, and `Some` is always returned.
          Some(current)
      }
  *)
  Definition next (𝜏 : list Ty.t) (α : list Value.t) : M :=
    match 𝜏, α with
    | [], [self] =>
      let* self := M.alloc self in
      let* current : Ty.path "u32" :=
        let* α0 :
            Ty.apply
              (Ty.path "mut_ref")
              [Ty.apply (Ty.path "iterators::Fibonacci") []] :=
          M.read self in
        M.copy (iterators.Fibonacci.Get_curr (deref α0)) in
      let* _ : Ty.tuple :=
        let* α0 :
            Ty.apply
              (Ty.path "mut_ref")
              [Ty.apply (Ty.path "iterators::Fibonacci") []] :=
          M.read self in
        let* α1 :
            Ty.apply
              (Ty.path "mut_ref")
              [Ty.apply (Ty.path "iterators::Fibonacci") []] :=
          M.read self in
        let* α2 : Ty.path "u32" :=
          M.read (iterators.Fibonacci.Get_next (deref α1)) in
        assign (iterators.Fibonacci.Get_curr (deref α0)) α2 in
      let* _ : Ty.tuple :=
        let* α0 :
            Ty.apply
              (Ty.path "mut_ref")
              [Ty.apply (Ty.path "iterators::Fibonacci") []] :=
          M.read self in
        let* α1 : Ty.path "u32" := M.read current in
        let* α2 :
            Ty.apply
              (Ty.path "mut_ref")
              [Ty.apply (Ty.path "iterators::Fibonacci") []] :=
          M.read self in
        let* α3 : Ty.path "u32" :=
          M.read (iterators.Fibonacci.Get_next (deref α2)) in
        let* α4 : Ty.path "u32" := BinOp.Panic.add α1 α3 in
        assign (iterators.Fibonacci.Get_next (deref α0)) α4 in
      let* α0 : Ty.path "u32" := M.read current in
      let* α0 : Ty.apply (Ty.path "core::option::Option") [Ty.path "u32"] :=
        M.alloc (core.option.Option.Some α0) in
      M.read α0
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_next : Instance.t := {
    Notations.double_colon := next;
  }.
  
  Definition ℐ : Instance.t := [("Item", Item);
    ("next", next);
    ("next_chunk", next_chunk);
    ("size_hint", size_hint);
    ("count", count);
    ("last", last);
    ("advance_by", advance_by);
    ("nth", nth);
    ("step_by", step_by);
    ("chain", chain);
    ("zip", zip);
    ("intersperse", intersperse);
    ("intersperse_with", intersperse_with);
    ("map", map);
    ("for_each", for_each);
    ("filter", filter);
    ("filter_map", filter_map);
    ("enumerate", enumerate);
    ("peekable", peekable);
    ("skip_while", skip_while);
    ("take_while", take_while);
    ("map_while", map_while);
    ("skip", skip);
    ("take", take);
    ("scan", scan);
    ("flat_map", flat_map);
    ("flatten", flatten);
    ("map_windows", map_windows);
    ("fuse", fuse);
    ("inspect", inspect);
    ("by_ref", by_ref);
    ("collect", collect);
    ("try_collect", try_collect);
    ("collect_into", collect_into);
    ("partition", partition);
    ("partition_in_place", partition_in_place);
    ("is_partitioned", is_partitioned);
    ("try_fold", try_fold);
    ("try_for_each", try_for_each);
    ("fold", fold);
    ("reduce", reduce);
    ("try_reduce", try_reduce);
    ("all", all);
    ("any", any);
    ("find", find);
    ("find_map", find_map);
    ("try_find", try_find);
    ("position", position);
    ("rposition", rposition);
    ("max", max);
    ("min", min);
    ("max_by_key", max_by_key);
    ("max_by", max_by);
    ("min_by_key", min_by_key);
    ("min_by", min_by);
    ("rev", rev);
    ("unzip", unzip);
    ("copied", copied);
    ("cloned", cloned);
    ("cycle", cycle);
    ("array_chunks", array_chunks);
    ("sum", sum);
    ("product", product);
    ("cmp", cmp);
    ("cmp_by", cmp_by);
    ("partial_cmp", partial_cmp);
    ("partial_cmp_by", partial_cmp_by);
    ("eq", eq);
    ("eq_by", eq_by);
    ("ne", ne);
    ("lt", lt);
    ("le", le);
    ("gt", gt);
    ("ge", ge);
    ("is_sorted", is_sorted);
    ("is_sorted_by", is_sorted_by);
    ("is_sorted_by_key", is_sorted_by_key);
    ("__iterator_get_unchecked", __iterator_get_unchecked)].
End Impl_core_iter_traits_iterator_Iterator_for_iterators_Fibonacci.
End Impl_core_iter_traits_iterator_Iterator_for_iterators_Fibonacci.

(*
fn fibonacci() -> Fibonacci {
    Fibonacci { curr: 0, next: 1 }
}
*)
Definition fibonacci (𝜏 : list Ty.t) (α : list Value.t) : M :=
  match 𝜏, α with
  | [], [] =>
    M.pure
      {|
        iterators.Fibonacci.curr := (Integer.of_Z 0) : Ty.path "u32";
        iterators.Fibonacci.next := (Integer.of_Z 1) : Ty.path "u32";
      |}
  | _, _ => M.impossible
  end.

(*
fn main() {
    // `0..3` is an `Iterator` that generates: 0, 1, and 2.
    let mut sequence = 0..3;

    println!("Four consecutive `next` calls on 0..3");
    println!("> {:?}", sequence.next());
    println!("> {:?}", sequence.next());
    println!("> {:?}", sequence.next());
    println!("> {:?}", sequence.next());

    // `for` works through an `Iterator` until it returns `None`.
    // Each `Some` value is unwrapped and bound to a variable (here, `i`).
    println!("Iterate through 0..3 using `for`");
    for i in 0..3 {
        println!("> {}", i);
    }

    // The `take(n)` method reduces an `Iterator` to its first `n` terms.
    println!("The first four terms of the Fibonacci sequence are: ");
    for i in fibonacci().take(4) {
        println!("> {}", i);
    }

    // The `skip(n)` method shortens an `Iterator` by dropping its first `n` terms.
    println!("The next four terms of the Fibonacci sequence are: ");
    for i in fibonacci().skip(4).take(4) {
        println!("> {}", i);
    }

    let array = [1u32, 3, 3, 7];

    // The `iter` method produces an `Iterator` over an array/slice.
    println!("Iterate the following array {:?}", &array);
    for i in array.iter() {
        println!("> {}", i);
    }
}
*)
(* #[allow(dead_code)] - function was ignored by the compiler *)
Definition main (𝜏 : list Ty.t) (α : list Value.t) : M :=
  match 𝜏, α with
  | [], [] =>
    let* sequence :
        Ty.apply (Ty.path "core::ops::range::Range") [Ty.path "i32"] :=
      M.alloc
        {|
          core.ops.range.Range.start := (Integer.of_Z 0) : Ty.path "i32";
          core.ops.range.Range.end_ := (Integer.of_Z 3) : Ty.path "i32";
        |} in
    let* _ : Ty.tuple :=
      let* _ : Ty.tuple :=
        let* α0 : Ty.apply (Ty.path "ref") [Ty.path "str"] :=
          M.read (mk_str "Four consecutive `next` calls on 0..3
") in
        let* α1 :
            Ty.apply
              (Ty.path "array")
              [Ty.apply (Ty.path "ref") [Ty.path "str"]] :=
          M.alloc [ α0 ] in
        let* α2 : Ty.apply (Ty.path "core::fmt::Arguments") [] :=
          M.call
            ((Ty.apply (Ty.path "core::fmt::Arguments") [])::["new_const"]
              (pointer_coercion "Unsize" (borrow α1))) in
        let* α3 : Ty.tuple := M.call (std.io.stdio._print α2) in
        M.alloc α3 in
      M.alloc tt in
    let* _ : Ty.tuple :=
      let* _ : Ty.tuple :=
        let* α0 : Ty.apply (Ty.path "ref") [Ty.path "str"] :=
          M.read (mk_str "> ") in
        let* α1 : Ty.apply (Ty.path "ref") [Ty.path "str"] :=
          M.read (mk_str "
") in
        let* α2 :
            Ty.apply
              (Ty.path "array")
              [Ty.apply (Ty.path "ref") [Ty.path "str"]] :=
          M.alloc [ α0; α1 ] in
        let* α3 :
            Ty.function
              [Ty.apply
                  (Ty.path "mut_ref")
                  [Ty.apply
                      (Ty.path "core::ops::range::Range")
                      [Ty.path "i32"]]]
              (Ty.apply (Ty.path "core::option::Option") [_]) :=
          ltac:(M.get_method (fun ℐ =>
            core.iter.traits.iterator.Iterator.next
              (Self :=
                Ty.apply (Ty.path "core::ops::range::Range") [Ty.path "i32"])
              (Trait := ℐ))) in
        let* α4 : Ty.apply (Ty.path "core::option::Option") [Ty.path "i32"] :=
          M.call (α3 (borrow_mut sequence)) in
        let* α5 : Ty.apply (Ty.path "core::option::Option") [Ty.path "i32"] :=
          M.alloc α4 in
        let* α6 : Ty.apply (Ty.path "core::fmt::rt::Argument") [] :=
          M.call
            ((Ty.apply (Ty.path "core::fmt::rt::Argument") [])::["new_debug"]
              (borrow α5)) in
        let* α7 :
            Ty.apply
              (Ty.path "array")
              [Ty.apply (Ty.path "core::fmt::rt::Argument") []] :=
          M.alloc [ α6 ] in
        let* α8 : Ty.apply (Ty.path "core::fmt::Arguments") [] :=
          M.call
            ((Ty.apply (Ty.path "core::fmt::Arguments") [])::["new_v1"]
              (pointer_coercion "Unsize" (borrow α2))
              (pointer_coercion "Unsize" (borrow α7))) in
        let* α9 : Ty.tuple := M.call (std.io.stdio._print α8) in
        M.alloc α9 in
      M.alloc tt in
    let* _ : Ty.tuple :=
      let* _ : Ty.tuple :=
        let* α0 : Ty.apply (Ty.path "ref") [Ty.path "str"] :=
          M.read (mk_str "> ") in
        let* α1 : Ty.apply (Ty.path "ref") [Ty.path "str"] :=
          M.read (mk_str "
") in
        let* α2 :
            Ty.apply
              (Ty.path "array")
              [Ty.apply (Ty.path "ref") [Ty.path "str"]] :=
          M.alloc [ α0; α1 ] in
        let* α3 :
            Ty.function
              [Ty.apply
                  (Ty.path "mut_ref")
                  [Ty.apply
                      (Ty.path "core::ops::range::Range")
                      [Ty.path "i32"]]]
              (Ty.apply (Ty.path "core::option::Option") [_]) :=
          ltac:(M.get_method (fun ℐ =>
            core.iter.traits.iterator.Iterator.next
              (Self :=
                Ty.apply (Ty.path "core::ops::range::Range") [Ty.path "i32"])
              (Trait := ℐ))) in
        let* α4 : Ty.apply (Ty.path "core::option::Option") [Ty.path "i32"] :=
          M.call (α3 (borrow_mut sequence)) in
        let* α5 : Ty.apply (Ty.path "core::option::Option") [Ty.path "i32"] :=
          M.alloc α4 in
        let* α6 : Ty.apply (Ty.path "core::fmt::rt::Argument") [] :=
          M.call
            ((Ty.apply (Ty.path "core::fmt::rt::Argument") [])::["new_debug"]
              (borrow α5)) in
        let* α7 :
            Ty.apply
              (Ty.path "array")
              [Ty.apply (Ty.path "core::fmt::rt::Argument") []] :=
          M.alloc [ α6 ] in
        let* α8 : Ty.apply (Ty.path "core::fmt::Arguments") [] :=
          M.call
            ((Ty.apply (Ty.path "core::fmt::Arguments") [])::["new_v1"]
              (pointer_coercion "Unsize" (borrow α2))
              (pointer_coercion "Unsize" (borrow α7))) in
        let* α9 : Ty.tuple := M.call (std.io.stdio._print α8) in
        M.alloc α9 in
      M.alloc tt in
    let* _ : Ty.tuple :=
      let* _ : Ty.tuple :=
        let* α0 : Ty.apply (Ty.path "ref") [Ty.path "str"] :=
          M.read (mk_str "> ") in
        let* α1 : Ty.apply (Ty.path "ref") [Ty.path "str"] :=
          M.read (mk_str "
") in
        let* α2 :
            Ty.apply
              (Ty.path "array")
              [Ty.apply (Ty.path "ref") [Ty.path "str"]] :=
          M.alloc [ α0; α1 ] in
        let* α3 :
            Ty.function
              [Ty.apply
                  (Ty.path "mut_ref")
                  [Ty.apply
                      (Ty.path "core::ops::range::Range")
                      [Ty.path "i32"]]]
              (Ty.apply (Ty.path "core::option::Option") [_]) :=
          ltac:(M.get_method (fun ℐ =>
            core.iter.traits.iterator.Iterator.next
              (Self :=
                Ty.apply (Ty.path "core::ops::range::Range") [Ty.path "i32"])
              (Trait := ℐ))) in
        let* α4 : Ty.apply (Ty.path "core::option::Option") [Ty.path "i32"] :=
          M.call (α3 (borrow_mut sequence)) in
        let* α5 : Ty.apply (Ty.path "core::option::Option") [Ty.path "i32"] :=
          M.alloc α4 in
        let* α6 : Ty.apply (Ty.path "core::fmt::rt::Argument") [] :=
          M.call
            ((Ty.apply (Ty.path "core::fmt::rt::Argument") [])::["new_debug"]
              (borrow α5)) in
        let* α7 :
            Ty.apply
              (Ty.path "array")
              [Ty.apply (Ty.path "core::fmt::rt::Argument") []] :=
          M.alloc [ α6 ] in
        let* α8 : Ty.apply (Ty.path "core::fmt::Arguments") [] :=
          M.call
            ((Ty.apply (Ty.path "core::fmt::Arguments") [])::["new_v1"]
              (pointer_coercion "Unsize" (borrow α2))
              (pointer_coercion "Unsize" (borrow α7))) in
        let* α9 : Ty.tuple := M.call (std.io.stdio._print α8) in
        M.alloc α9 in
      M.alloc tt in
    let* _ : Ty.tuple :=
      let* _ : Ty.tuple :=
        let* α0 : Ty.apply (Ty.path "ref") [Ty.path "str"] :=
          M.read (mk_str "> ") in
        let* α1 : Ty.apply (Ty.path "ref") [Ty.path "str"] :=
          M.read (mk_str "
") in
        let* α2 :
            Ty.apply
              (Ty.path "array")
              [Ty.apply (Ty.path "ref") [Ty.path "str"]] :=
          M.alloc [ α0; α1 ] in
        let* α3 :
            Ty.function
              [Ty.apply
                  (Ty.path "mut_ref")
                  [Ty.apply
                      (Ty.path "core::ops::range::Range")
                      [Ty.path "i32"]]]
              (Ty.apply (Ty.path "core::option::Option") [_]) :=
          ltac:(M.get_method (fun ℐ =>
            core.iter.traits.iterator.Iterator.next
              (Self :=
                Ty.apply (Ty.path "core::ops::range::Range") [Ty.path "i32"])
              (Trait := ℐ))) in
        let* α4 : Ty.apply (Ty.path "core::option::Option") [Ty.path "i32"] :=
          M.call (α3 (borrow_mut sequence)) in
        let* α5 : Ty.apply (Ty.path "core::option::Option") [Ty.path "i32"] :=
          M.alloc α4 in
        let* α6 : Ty.apply (Ty.path "core::fmt::rt::Argument") [] :=
          M.call
            ((Ty.apply (Ty.path "core::fmt::rt::Argument") [])::["new_debug"]
              (borrow α5)) in
        let* α7 :
            Ty.apply
              (Ty.path "array")
              [Ty.apply (Ty.path "core::fmt::rt::Argument") []] :=
          M.alloc [ α6 ] in
        let* α8 : Ty.apply (Ty.path "core::fmt::Arguments") [] :=
          M.call
            ((Ty.apply (Ty.path "core::fmt::Arguments") [])::["new_v1"]
              (pointer_coercion "Unsize" (borrow α2))
              (pointer_coercion "Unsize" (borrow α7))) in
        let* α9 : Ty.tuple := M.call (std.io.stdio._print α8) in
        M.alloc α9 in
      M.alloc tt in
    let* _ : Ty.tuple :=
      let* _ : Ty.tuple :=
        let* α0 : Ty.apply (Ty.path "ref") [Ty.path "str"] :=
          M.read (mk_str "Iterate through 0..3 using `for`
") in
        let* α1 :
            Ty.apply
              (Ty.path "array")
              [Ty.apply (Ty.path "ref") [Ty.path "str"]] :=
          M.alloc [ α0 ] in
        let* α2 : Ty.apply (Ty.path "core::fmt::Arguments") [] :=
          M.call
            ((Ty.apply (Ty.path "core::fmt::Arguments") [])::["new_const"]
              (pointer_coercion "Unsize" (borrow α1))) in
        let* α3 : Ty.tuple := M.call (std.io.stdio._print α2) in
        M.alloc α3 in
      M.alloc tt in
    let* _ : Ty.tuple :=
      let* α0 :
          Ty.function
            [Ty.apply (Ty.path "core::ops::range::Range") [Ty.path "i32"]]
            _ :=
        ltac:(M.get_method (fun ℐ =>
          core.iter.traits.collect.IntoIterator.into_iter
            (Self :=
              Ty.apply (Ty.path "core::ops::range::Range") [Ty.path "i32"])
            (Trait := ℐ))) in
      let* α1 : Ty.apply (Ty.path "core::ops::range::Range") [Ty.path "i32"] :=
        M.call
          (α0
            {|
              core.ops.range.Range.start := (Integer.of_Z 0) : Ty.path "i32";
              core.ops.range.Range.end_ := (Integer.of_Z 3) : Ty.path "i32";
            |}) in
      let* α2 : Ty.apply (Ty.path "core::ops::range::Range") [Ty.path "i32"] :=
        M.alloc α1 in
      let* α3 : Ty.tuple :=
        match_operator
          α2
          [
            fun γ =>
              (let* iter := M.copy γ in
              M.loop
                (let* _ : Ty.tuple :=
                  let* α0 :
                      Ty.function
                        [Ty.apply
                            (Ty.path "mut_ref")
                            [Ty.apply
                                (Ty.path "core::ops::range::Range")
                                [Ty.path "i32"]]]
                        (Ty.apply (Ty.path "core::option::Option") [_]) :=
                    ltac:(M.get_method (fun ℐ =>
                      core.iter.traits.iterator.Iterator.next
                        (Self :=
                          Ty.apply
                            (Ty.path "core::ops::range::Range")
                            [Ty.path "i32"])
                        (Trait := ℐ))) in
                  let* α1 :
                      Ty.apply
                        (Ty.path "core::option::Option")
                        [Ty.path "i32"] :=
                    M.call (α0 (borrow_mut iter)) in
                  let* α2 :
                      Ty.apply
                        (Ty.path "core::option::Option")
                        [Ty.path "i32"] :=
                    M.alloc α1 in
                  match_operator
                    α2
                    [
                      fun γ =>
                        (let* α0 := M.read γ in
                        match α0 with
                        | core.option.Option.None =>
                          let* α0 : Ty.path "never" := M.break in
                          let* α1 : Ty.path "never" := M.read α0 in
                          let* α2 : Ty.tuple := never_to_any α1 in
                          M.alloc α2
                        | _ => M.break_match
                        end) :
                        Ty.tuple;
                      fun γ =>
                        (let* α0 := M.read γ in
                        match α0 with
                        | core.option.Option.Some _ =>
                          let γ0_0 := core.option.Option.Get_Some_0 γ in
                          let* i := M.copy γ0_0 in
                          let* _ : Ty.tuple :=
                            let* _ : Ty.tuple :=
                              let* α0 :
                                  Ty.apply (Ty.path "ref") [Ty.path "str"] :=
                                M.read (mk_str "> ") in
                              let* α1 :
                                  Ty.apply (Ty.path "ref") [Ty.path "str"] :=
                                M.read (mk_str "
") in
                              let* α2 :
                                  Ty.apply
                                    (Ty.path "array")
                                    [Ty.apply
                                        (Ty.path "ref")
                                        [Ty.path "str"]] :=
                                M.alloc [ α0; α1 ] in
                              let* α3 :
                                  Ty.apply
                                    (Ty.path "core::fmt::rt::Argument")
                                    [] :=
                                M.call
                                  ((Ty.apply
                                        (Ty.path "core::fmt::rt::Argument")
                                        [])::["new_display"]
                                    (borrow i)) in
                              let* α4 :
                                  Ty.apply
                                    (Ty.path "array")
                                    [Ty.apply
                                        (Ty.path "core::fmt::rt::Argument")
                                        []] :=
                                M.alloc [ α3 ] in
                              let* α5 :
                                  Ty.apply
                                    (Ty.path "core::fmt::Arguments")
                                    [] :=
                                M.call
                                  ((Ty.apply
                                        (Ty.path "core::fmt::Arguments")
                                        [])::["new_v1"]
                                    (pointer_coercion "Unsize" (borrow α2))
                                    (pointer_coercion "Unsize" (borrow α4))) in
                              let* α6 : Ty.tuple :=
                                M.call (std.io.stdio._print α5) in
                              M.alloc α6 in
                            M.alloc tt in
                          M.alloc tt
                        | _ => M.break_match
                        end) :
                        Ty.tuple
                    ] in
                M.alloc tt)) :
              Ty.tuple
          ] in
      M.pure (use α3) in
    let* _ : Ty.tuple :=
      let* _ : Ty.tuple :=
        let* α0 : Ty.apply (Ty.path "ref") [Ty.path "str"] :=
          M.read
            (mk_str "The first four terms of the Fibonacci sequence are: 
") in
        let* α1 :
            Ty.apply
              (Ty.path "array")
              [Ty.apply (Ty.path "ref") [Ty.path "str"]] :=
          M.alloc [ α0 ] in
        let* α2 : Ty.apply (Ty.path "core::fmt::Arguments") [] :=
          M.call
            ((Ty.apply (Ty.path "core::fmt::Arguments") [])::["new_const"]
              (pointer_coercion "Unsize" (borrow α1))) in
        let* α3 : Ty.tuple := M.call (std.io.stdio._print α2) in
        M.alloc α3 in
      M.alloc tt in
    let* _ : Ty.tuple :=
      let* α0 :
          Ty.function
            [Ty.apply
                (Ty.path "core::iter::adapters::take::Take")
                [Ty.apply (Ty.path "iterators::Fibonacci") []]]
            _ :=
        ltac:(M.get_method (fun ℐ =>
          core.iter.traits.collect.IntoIterator.into_iter
            (Self :=
              Ty.apply
                (Ty.path "core::iter::adapters::take::Take")
                [Ty.apply (Ty.path "iterators::Fibonacci") []])
            (Trait := ℐ))) in
      let* α1 :
          Ty.function
            [Ty.apply (Ty.path "iterators::Fibonacci") []; Ty.path "usize"]
            (Ty.apply
              (Ty.path "core::iter::adapters::take::Take")
              [Ty.apply (Ty.path "iterators::Fibonacci") []]) :=
        ltac:(M.get_method (fun ℐ =>
          core.iter.traits.iterator.Iterator.take
            (Self := Ty.apply (Ty.path "iterators::Fibonacci") [])
            (Trait := ℐ))) in
      let* α2 : Ty.apply (Ty.path "iterators::Fibonacci") [] :=
        M.call iterators.fibonacci in
      let* α3 :
          Ty.apply
            (Ty.path "core::iter::adapters::take::Take")
            [Ty.apply (Ty.path "iterators::Fibonacci") []] :=
        M.call (α1 α2 ((Integer.of_Z 4) : Ty.path "usize")) in
      let* α4 :
          Ty.apply
            (Ty.path "core::iter::adapters::take::Take")
            [Ty.apply (Ty.path "iterators::Fibonacci") []] :=
        M.call (α0 α3) in
      let* α5 :
          Ty.apply
            (Ty.path "core::iter::adapters::take::Take")
            [Ty.apply (Ty.path "iterators::Fibonacci") []] :=
        M.alloc α4 in
      let* α6 : Ty.tuple :=
        match_operator
          α5
          [
            fun γ =>
              (let* iter := M.copy γ in
              M.loop
                (let* _ : Ty.tuple :=
                  let* α0 :
                      Ty.function
                        [Ty.apply
                            (Ty.path "mut_ref")
                            [Ty.apply
                                (Ty.path "core::iter::adapters::take::Take")
                                [Ty.apply (Ty.path "iterators::Fibonacci") []]]]
                        (Ty.apply (Ty.path "core::option::Option") [_]) :=
                    ltac:(M.get_method (fun ℐ =>
                      core.iter.traits.iterator.Iterator.next
                        (Self :=
                          Ty.apply
                            (Ty.path "core::iter::adapters::take::Take")
                            [Ty.apply (Ty.path "iterators::Fibonacci") []])
                        (Trait := ℐ))) in
                  let* α1 :
                      Ty.apply
                        (Ty.path "core::option::Option")
                        [Ty.path "u32"] :=
                    M.call (α0 (borrow_mut iter)) in
                  let* α2 :
                      Ty.apply
                        (Ty.path "core::option::Option")
                        [Ty.path "u32"] :=
                    M.alloc α1 in
                  match_operator
                    α2
                    [
                      fun γ =>
                        (let* α0 := M.read γ in
                        match α0 with
                        | core.option.Option.None =>
                          let* α0 : Ty.path "never" := M.break in
                          let* α1 : Ty.path "never" := M.read α0 in
                          let* α2 : Ty.tuple := never_to_any α1 in
                          M.alloc α2
                        | _ => M.break_match
                        end) :
                        Ty.tuple;
                      fun γ =>
                        (let* α0 := M.read γ in
                        match α0 with
                        | core.option.Option.Some _ =>
                          let γ0_0 := core.option.Option.Get_Some_0 γ in
                          let* i := M.copy γ0_0 in
                          let* _ : Ty.tuple :=
                            let* _ : Ty.tuple :=
                              let* α0 :
                                  Ty.apply (Ty.path "ref") [Ty.path "str"] :=
                                M.read (mk_str "> ") in
                              let* α1 :
                                  Ty.apply (Ty.path "ref") [Ty.path "str"] :=
                                M.read (mk_str "
") in
                              let* α2 :
                                  Ty.apply
                                    (Ty.path "array")
                                    [Ty.apply
                                        (Ty.path "ref")
                                        [Ty.path "str"]] :=
                                M.alloc [ α0; α1 ] in
                              let* α3 :
                                  Ty.apply
                                    (Ty.path "core::fmt::rt::Argument")
                                    [] :=
                                M.call
                                  ((Ty.apply
                                        (Ty.path "core::fmt::rt::Argument")
                                        [])::["new_display"]
                                    (borrow i)) in
                              let* α4 :
                                  Ty.apply
                                    (Ty.path "array")
                                    [Ty.apply
                                        (Ty.path "core::fmt::rt::Argument")
                                        []] :=
                                M.alloc [ α3 ] in
                              let* α5 :
                                  Ty.apply
                                    (Ty.path "core::fmt::Arguments")
                                    [] :=
                                M.call
                                  ((Ty.apply
                                        (Ty.path "core::fmt::Arguments")
                                        [])::["new_v1"]
                                    (pointer_coercion "Unsize" (borrow α2))
                                    (pointer_coercion "Unsize" (borrow α4))) in
                              let* α6 : Ty.tuple :=
                                M.call (std.io.stdio._print α5) in
                              M.alloc α6 in
                            M.alloc tt in
                          M.alloc tt
                        | _ => M.break_match
                        end) :
                        Ty.tuple
                    ] in
                M.alloc tt)) :
              Ty.tuple
          ] in
      M.pure (use α6) in
    let* _ : Ty.tuple :=
      let* _ : Ty.tuple :=
        let* α0 : Ty.apply (Ty.path "ref") [Ty.path "str"] :=
          M.read
            (mk_str "The next four terms of the Fibonacci sequence are: 
") in
        let* α1 :
            Ty.apply
              (Ty.path "array")
              [Ty.apply (Ty.path "ref") [Ty.path "str"]] :=
          M.alloc [ α0 ] in
        let* α2 : Ty.apply (Ty.path "core::fmt::Arguments") [] :=
          M.call
            ((Ty.apply (Ty.path "core::fmt::Arguments") [])::["new_const"]
              (pointer_coercion "Unsize" (borrow α1))) in
        let* α3 : Ty.tuple := M.call (std.io.stdio._print α2) in
        M.alloc α3 in
      M.alloc tt in
    let* _ : Ty.tuple :=
      let* α0 :
          Ty.function
            [Ty.apply
                (Ty.path "core::iter::adapters::take::Take")
                [Ty.apply
                    (Ty.path "core::iter::adapters::skip::Skip")
                    [Ty.apply (Ty.path "iterators::Fibonacci") []]]]
            _ :=
        ltac:(M.get_method (fun ℐ =>
          core.iter.traits.collect.IntoIterator.into_iter
            (Self :=
              Ty.apply
                (Ty.path "core::iter::adapters::take::Take")
                [Ty.apply
                    (Ty.path "core::iter::adapters::skip::Skip")
                    [Ty.apply (Ty.path "iterators::Fibonacci") []]])
            (Trait := ℐ))) in
      let* α1 :
          Ty.function
            [Ty.apply
                (Ty.path "core::iter::adapters::skip::Skip")
                [Ty.apply (Ty.path "iterators::Fibonacci") []];
              Ty.path "usize"]
            (Ty.apply
              (Ty.path "core::iter::adapters::take::Take")
              [Ty.apply
                  (Ty.path "core::iter::adapters::skip::Skip")
                  [Ty.apply (Ty.path "iterators::Fibonacci") []]]) :=
        ltac:(M.get_method (fun ℐ =>
          core.iter.traits.iterator.Iterator.take
            (Self :=
              Ty.apply
                (Ty.path "core::iter::adapters::skip::Skip")
                [Ty.apply (Ty.path "iterators::Fibonacci") []])
            (Trait := ℐ))) in
      let* α2 :
          Ty.function
            [Ty.apply (Ty.path "iterators::Fibonacci") []; Ty.path "usize"]
            (Ty.apply
              (Ty.path "core::iter::adapters::skip::Skip")
              [Ty.apply (Ty.path "iterators::Fibonacci") []]) :=
        ltac:(M.get_method (fun ℐ =>
          core.iter.traits.iterator.Iterator.skip
            (Self := Ty.apply (Ty.path "iterators::Fibonacci") [])
            (Trait := ℐ))) in
      let* α3 : Ty.apply (Ty.path "iterators::Fibonacci") [] :=
        M.call iterators.fibonacci in
      let* α4 :
          Ty.apply
            (Ty.path "core::iter::adapters::skip::Skip")
            [Ty.apply (Ty.path "iterators::Fibonacci") []] :=
        M.call (α2 α3 ((Integer.of_Z 4) : Ty.path "usize")) in
      let* α5 :
          Ty.apply
            (Ty.path "core::iter::adapters::take::Take")
            [Ty.apply
                (Ty.path "core::iter::adapters::skip::Skip")
                [Ty.apply (Ty.path "iterators::Fibonacci") []]] :=
        M.call (α1 α4 ((Integer.of_Z 4) : Ty.path "usize")) in
      let* α6 :
          Ty.apply
            (Ty.path "core::iter::adapters::take::Take")
            [Ty.apply
                (Ty.path "core::iter::adapters::skip::Skip")
                [Ty.apply (Ty.path "iterators::Fibonacci") []]] :=
        M.call (α0 α5) in
      let* α7 :
          Ty.apply
            (Ty.path "core::iter::adapters::take::Take")
            [Ty.apply
                (Ty.path "core::iter::adapters::skip::Skip")
                [Ty.apply (Ty.path "iterators::Fibonacci") []]] :=
        M.alloc α6 in
      let* α8 : Ty.tuple :=
        match_operator
          α7
          [
            fun γ =>
              (let* iter := M.copy γ in
              M.loop
                (let* _ : Ty.tuple :=
                  let* α0 :
                      Ty.function
                        [Ty.apply
                            (Ty.path "mut_ref")
                            [Ty.apply
                                (Ty.path "core::iter::adapters::take::Take")
                                [Ty.apply
                                    (Ty.path "core::iter::adapters::skip::Skip")
                                    [Ty.apply
                                        (Ty.path "iterators::Fibonacci")
                                        []]]]]
                        (Ty.apply (Ty.path "core::option::Option") [_]) :=
                    ltac:(M.get_method (fun ℐ =>
                      core.iter.traits.iterator.Iterator.next
                        (Self :=
                          Ty.apply
                            (Ty.path "core::iter::adapters::take::Take")
                            [Ty.apply
                                (Ty.path "core::iter::adapters::skip::Skip")
                                [Ty.apply (Ty.path "iterators::Fibonacci") []]])
                        (Trait := ℐ))) in
                  let* α1 :
                      Ty.apply
                        (Ty.path "core::option::Option")
                        [Ty.path "u32"] :=
                    M.call (α0 (borrow_mut iter)) in
                  let* α2 :
                      Ty.apply
                        (Ty.path "core::option::Option")
                        [Ty.path "u32"] :=
                    M.alloc α1 in
                  match_operator
                    α2
                    [
                      fun γ =>
                        (let* α0 := M.read γ in
                        match α0 with
                        | core.option.Option.None =>
                          let* α0 : Ty.path "never" := M.break in
                          let* α1 : Ty.path "never" := M.read α0 in
                          let* α2 : Ty.tuple := never_to_any α1 in
                          M.alloc α2
                        | _ => M.break_match
                        end) :
                        Ty.tuple;
                      fun γ =>
                        (let* α0 := M.read γ in
                        match α0 with
                        | core.option.Option.Some _ =>
                          let γ0_0 := core.option.Option.Get_Some_0 γ in
                          let* i := M.copy γ0_0 in
                          let* _ : Ty.tuple :=
                            let* _ : Ty.tuple :=
                              let* α0 :
                                  Ty.apply (Ty.path "ref") [Ty.path "str"] :=
                                M.read (mk_str "> ") in
                              let* α1 :
                                  Ty.apply (Ty.path "ref") [Ty.path "str"] :=
                                M.read (mk_str "
") in
                              let* α2 :
                                  Ty.apply
                                    (Ty.path "array")
                                    [Ty.apply
                                        (Ty.path "ref")
                                        [Ty.path "str"]] :=
                                M.alloc [ α0; α1 ] in
                              let* α3 :
                                  Ty.apply
                                    (Ty.path "core::fmt::rt::Argument")
                                    [] :=
                                M.call
                                  ((Ty.apply
                                        (Ty.path "core::fmt::rt::Argument")
                                        [])::["new_display"]
                                    (borrow i)) in
                              let* α4 :
                                  Ty.apply
                                    (Ty.path "array")
                                    [Ty.apply
                                        (Ty.path "core::fmt::rt::Argument")
                                        []] :=
                                M.alloc [ α3 ] in
                              let* α5 :
                                  Ty.apply
                                    (Ty.path "core::fmt::Arguments")
                                    [] :=
                                M.call
                                  ((Ty.apply
                                        (Ty.path "core::fmt::Arguments")
                                        [])::["new_v1"]
                                    (pointer_coercion "Unsize" (borrow α2))
                                    (pointer_coercion "Unsize" (borrow α4))) in
                              let* α6 : Ty.tuple :=
                                M.call (std.io.stdio._print α5) in
                              M.alloc α6 in
                            M.alloc tt in
                          M.alloc tt
                        | _ => M.break_match
                        end) :
                        Ty.tuple
                    ] in
                M.alloc tt)) :
              Ty.tuple
          ] in
      M.pure (use α8) in
    let* array_ : Ty.apply (Ty.path "array") [Ty.path "u32"] :=
      M.alloc
        [
          (Integer.of_Z 1) : Ty.path "u32";
          (Integer.of_Z 3) : Ty.path "u32";
          (Integer.of_Z 3) : Ty.path "u32";
          (Integer.of_Z 7) : Ty.path "u32"
        ] in
    let* _ : Ty.tuple :=
      let* _ : Ty.tuple :=
        let* α0 : Ty.apply (Ty.path "ref") [Ty.path "str"] :=
          M.read (mk_str "Iterate the following array ") in
        let* α1 : Ty.apply (Ty.path "ref") [Ty.path "str"] :=
          M.read (mk_str "
") in
        let* α2 :
            Ty.apply
              (Ty.path "array")
              [Ty.apply (Ty.path "ref") [Ty.path "str"]] :=
          M.alloc [ α0; α1 ] in
        let* α3 :
            Ty.apply
              (Ty.path "ref")
              [Ty.apply (Ty.path "array") [Ty.path "u32"]] :=
          M.alloc (borrow array_) in
        let* α4 : Ty.apply (Ty.path "core::fmt::rt::Argument") [] :=
          M.call
            ((Ty.apply (Ty.path "core::fmt::rt::Argument") [])::["new_debug"]
              (borrow α3)) in
        let* α5 :
            Ty.apply
              (Ty.path "array")
              [Ty.apply (Ty.path "core::fmt::rt::Argument") []] :=
          M.alloc [ α4 ] in
        let* α6 : Ty.apply (Ty.path "core::fmt::Arguments") [] :=
          M.call
            ((Ty.apply (Ty.path "core::fmt::Arguments") [])::["new_v1"]
              (pointer_coercion "Unsize" (borrow α2))
              (pointer_coercion "Unsize" (borrow α5))) in
        let* α7 : Ty.tuple := M.call (std.io.stdio._print α6) in
        M.alloc α7 in
      M.alloc tt in
    let* α0 :
        Ty.function
          [Ty.apply (Ty.path "core::slice::iter::Iter") [Ty.path "u32"]]
          _ :=
      ltac:(M.get_method (fun ℐ =>
        core.iter.traits.collect.IntoIterator.into_iter
          (Self := Ty.apply (Ty.path "core::slice::iter::Iter") [Ty.path "u32"])
          (Trait := ℐ))) in
    let* α1 : Ty.apply (Ty.path "core::slice::iter::Iter") [Ty.path "u32"] :=
      M.call
        ((Ty.apply (Ty.path "slice") [Ty.path "u32"])::["iter"]
          (pointer_coercion "Unsize" (borrow array_))) in
    let* α2 : Ty.apply (Ty.path "core::slice::iter::Iter") [Ty.path "u32"] :=
      M.call (α0 α1) in
    let* α3 : Ty.apply (Ty.path "core::slice::iter::Iter") [Ty.path "u32"] :=
      M.alloc α2 in
    let* α4 : Ty.tuple :=
      match_operator
        α3
        [
          fun γ =>
            (let* iter := M.copy γ in
            M.loop
              (let* _ : Ty.tuple :=
                let* α0 :
                    Ty.function
                      [Ty.apply
                          (Ty.path "mut_ref")
                          [Ty.apply
                              (Ty.path "core::slice::iter::Iter")
                              [Ty.path "u32"]]]
                      (Ty.apply (Ty.path "core::option::Option") [_]) :=
                  ltac:(M.get_method (fun ℐ =>
                    core.iter.traits.iterator.Iterator.next
                      (Self :=
                        Ty.apply
                          (Ty.path "core::slice::iter::Iter")
                          [Ty.path "u32"])
                      (Trait := ℐ))) in
                let* α1 :
                    Ty.apply
                      (Ty.path "core::option::Option")
                      [Ty.apply (Ty.path "ref") [Ty.path "u32"]] :=
                  M.call (α0 (borrow_mut iter)) in
                let* α2 :
                    Ty.apply
                      (Ty.path "core::option::Option")
                      [Ty.apply (Ty.path "ref") [Ty.path "u32"]] :=
                  M.alloc α1 in
                match_operator
                  α2
                  [
                    fun γ =>
                      (let* α0 := M.read γ in
                      match α0 with
                      | core.option.Option.None =>
                        let* α0 : Ty.path "never" := M.break in
                        let* α1 : Ty.path "never" := M.read α0 in
                        let* α2 : Ty.tuple := never_to_any α1 in
                        M.alloc α2
                      | _ => M.break_match
                      end) :
                      Ty.tuple;
                    fun γ =>
                      (let* α0 := M.read γ in
                      match α0 with
                      | core.option.Option.Some _ =>
                        let γ0_0 := core.option.Option.Get_Some_0 γ in
                        let* i := M.copy γ0_0 in
                        let* _ : Ty.tuple :=
                          let* _ : Ty.tuple :=
                            let* α0 :
                                Ty.apply (Ty.path "ref") [Ty.path "str"] :=
                              M.read (mk_str "> ") in
                            let* α1 :
                                Ty.apply (Ty.path "ref") [Ty.path "str"] :=
                              M.read (mk_str "
") in
                            let* α2 :
                                Ty.apply
                                  (Ty.path "array")
                                  [Ty.apply (Ty.path "ref") [Ty.path "str"]] :=
                              M.alloc [ α0; α1 ] in
                            let* α3 :
                                Ty.apply
                                  (Ty.path "core::fmt::rt::Argument")
                                  [] :=
                              M.call
                                ((Ty.apply
                                      (Ty.path "core::fmt::rt::Argument")
                                      [])::["new_display"]
                                  (borrow i)) in
                            let* α4 :
                                Ty.apply
                                  (Ty.path "array")
                                  [Ty.apply
                                      (Ty.path "core::fmt::rt::Argument")
                                      []] :=
                              M.alloc [ α3 ] in
                            let* α5 :
                                Ty.apply (Ty.path "core::fmt::Arguments") [] :=
                              M.call
                                ((Ty.apply
                                      (Ty.path "core::fmt::Arguments")
                                      [])::["new_v1"]
                                  (pointer_coercion "Unsize" (borrow α2))
                                  (pointer_coercion "Unsize" (borrow α4))) in
                            let* α6 : Ty.tuple :=
                              M.call (std.io.stdio._print α5) in
                            M.alloc α6 in
                          M.alloc tt in
                        M.alloc tt
                      | _ => M.break_match
                      end) :
                      Ty.tuple
                  ] in
              M.alloc tt)) :
            Ty.tuple
        ] in
    M.read (use α4)
  | _, _ => M.impossible
  end.
