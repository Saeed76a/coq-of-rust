(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.



Module  Impl_core_hash_Hash_for_hash_Person.
Section Impl_core_hash_Hash_for_hash_Person.
  Definition Self : Ty.t := Ty.apply (Ty.path "hash::Person") [].
  
  (*
  Hash
  *)
  Definition hash (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [__H], [self; state] =>
      let* self := M.alloc self in
      let* state := M.alloc state in
      let* _ : Ty.tuple :=
        let* Œ±0 :
            Ty.function
              [Ty.apply (Ty.path "ref") [Ty.path "u32"];
                Ty.apply (Ty.path "mut_ref") [__H]]
              Ty.tuple :=
          ltac:(M.get_method (fun ‚Ñê =>
            core.hash.Hash.hash
              (Self := Ty.path "u32")
              (H := __H)
              (Trait := ‚Ñê))) in
        let* Œ±1 :
            Ty.apply (Ty.path "ref") [Ty.apply (Ty.path "hash::Person") []] :=
          M.read self in
        let* Œ±2 : Ty.apply (Ty.path "mut_ref") [__H] := M.read state in
        let* Œ±3 : Ty.tuple :=
          M.call (Œ±0 (borrow (hash.Person.Get_id (deref Œ±1))) Œ±2) in
        M.alloc Œ±3 in
      let* _ : Ty.tuple :=
        let* Œ±0 :
            Ty.function
              [Ty.apply
                  (Ty.path "ref")
                  [Ty.apply (Ty.path "alloc::string::String") []];
                Ty.apply (Ty.path "mut_ref") [__H]]
              Ty.tuple :=
          ltac:(M.get_method (fun ‚Ñê =>
            core.hash.Hash.hash
              (Self := Ty.apply (Ty.path "alloc::string::String") [])
              (H := __H)
              (Trait := ‚Ñê))) in
        let* Œ±1 :
            Ty.apply (Ty.path "ref") [Ty.apply (Ty.path "hash::Person") []] :=
          M.read self in
        let* Œ±2 : Ty.apply (Ty.path "mut_ref") [__H] := M.read state in
        let* Œ±3 : Ty.tuple :=
          M.call (Œ±0 (borrow (hash.Person.Get_name (deref Œ±1))) Œ±2) in
        M.alloc Œ±3 in
      let* Œ±0 :
          Ty.function
            [Ty.apply (Ty.path "ref") [Ty.path "u64"];
              Ty.apply (Ty.path "mut_ref") [__H]]
            Ty.tuple :=
        ltac:(M.get_method (fun ‚Ñê =>
          core.hash.Hash.hash
            (Self := Ty.path "u64")
            (H := __H)
            (Trait := ‚Ñê))) in
      let* Œ±1 :
          Ty.apply (Ty.path "ref") [Ty.apply (Ty.path "hash::Person") []] :=
        M.read self in
      let* Œ±2 : Ty.apply (Ty.path "mut_ref") [__H] := M.read state in
      let* Œ±3 : Ty.tuple :=
        M.call (Œ±0 (borrow (hash.Person.Get_phone (deref Œ±1))) Œ±2) in
      let* Œ±0 : Ty.tuple := M.alloc Œ±3 in
      M.read Œ±0
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_hash {__H : Set} : Instance.t := {
    Notations.double_colon := hash (__H := __H);
  }.
  
  Definition ‚Ñê : Instance.t := [("hash", hash); ("hash_slice", hash_slice)].
End Impl_core_hash_Hash_for_hash_Person.
End Impl_core_hash_Hash_for_hash_Person.

(*
fn calculate_hash<T: Hash>(t: &T) -> u64 {
    let mut s = DefaultHasher::new();
    t.hash(&mut s);
    s.finish()
}
*)
Definition calculate_hash (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
  match ùúè, Œ± with
  | [T], [t] =>
    let* t := M.alloc t in
    let* s : Ty.apply (Ty.path "std::hash::random::DefaultHasher") [] :=
      let* Œ±0 : Ty.apply (Ty.path "std::hash::random::DefaultHasher") [] :=
        M.call
          (Ty.apply (Ty.path "std::hash::random::DefaultHasher") [])::["new"] in
      M.alloc Œ±0 in
    let* _ : Ty.tuple :=
      let* Œ±0 :
          Ty.function
            [Ty.apply (Ty.path "ref") [T];
              Ty.apply
                (Ty.path "mut_ref")
                [Ty.apply (Ty.path "std::hash::random::DefaultHasher") []]]
            Ty.tuple :=
        ltac:(M.get_method (fun ‚Ñê =>
          core.hash.Hash.hash
            (Self := T)
            (H := Ty.apply (Ty.path "std::hash::random::DefaultHasher") [])
            (Trait := ‚Ñê))) in
      let* Œ±1 : Ty.apply (Ty.path "ref") [T] := M.read t in
      let* Œ±2 : Ty.tuple := M.call (Œ±0 Œ±1 (borrow_mut s)) in
      M.alloc Œ±2 in
    let* Œ±0 :
        Ty.function
          [Ty.apply
              (Ty.path "ref")
              [Ty.apply (Ty.path "std::hash::random::DefaultHasher") []]]
          (Ty.path "u64") :=
      ltac:(M.get_method (fun ‚Ñê =>
        core.hash.Hasher.finish
          (Self := Ty.apply (Ty.path "std::hash::random::DefaultHasher") [])
          (Trait := ‚Ñê))) in
    let* Œ±1 : Ty.path "u64" := M.call (Œ±0 (borrow s)) in
    let* Œ±0 : Ty.path "u64" := M.alloc Œ±1 in
    M.read Œ±0
  | _, _ => M.impossible
  end.

(*
fn main() {
    let person1 = Person {
        id: 5,
        name: "Janet".to_string(),
        phone: 555_666_7777,
    };
    let person2 = Person {
        id: 5,
        name: "Bob".to_string(),
        phone: 555_666_7777,
    };

    assert!(calculate_hash(&person1) != calculate_hash(&person2));
}
*)
(* #[allow(dead_code)] - function was ignored by the compiler *)
Definition main (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
  match ùúè, Œ± with
  | [], [] =>
    let* person1 : Ty.apply (Ty.path "hash::Person") [] :=
      let* Œ±0 :
          Ty.function
            [Ty.apply (Ty.path "ref") [Ty.path "str"]]
            (Ty.apply (Ty.path "alloc::string::String") []) :=
        ltac:(M.get_method (fun ‚Ñê =>
          alloc.string.ToString.to_string
            (Self := Ty.path "str")
            (Trait := ‚Ñê))) in
      let* Œ±1 : Ty.apply (Ty.path "ref") [Ty.path "str"] :=
        M.read (mk_str "Janet") in
      let* Œ±2 : Ty.apply (Ty.path "alloc::string::String") [] :=
        M.call (Œ±0 Œ±1) in
      M.alloc
        {|
          hash.Person.id := (Integer.of_Z 5) : Ty.path "u32";
          hash.Person.name := Œ±2;
          hash.Person.phone := (Integer.of_Z 5556667777) : Ty.path "u64";
        |} in
    let* person2 : Ty.apply (Ty.path "hash::Person") [] :=
      let* Œ±0 :
          Ty.function
            [Ty.apply (Ty.path "ref") [Ty.path "str"]]
            (Ty.apply (Ty.path "alloc::string::String") []) :=
        ltac:(M.get_method (fun ‚Ñê =>
          alloc.string.ToString.to_string
            (Self := Ty.path "str")
            (Trait := ‚Ñê))) in
      let* Œ±1 : Ty.apply (Ty.path "ref") [Ty.path "str"] :=
        M.read (mk_str "Bob") in
      let* Œ±2 : Ty.apply (Ty.path "alloc::string::String") [] :=
        M.call (Œ±0 Œ±1) in
      M.alloc
        {|
          hash.Person.id := (Integer.of_Z 5) : Ty.path "u32";
          hash.Person.name := Œ±2;
          hash.Person.phone := (Integer.of_Z 5556667777) : Ty.path "u64";
        |} in
    let* _ : Ty.tuple :=
      let* Œ±0 : Ty.path "u64" :=
        M.call (hash.calculate_hash (borrow person1)) in
      let* Œ±1 : Ty.path "u64" :=
        M.call (hash.calculate_hash (borrow person2)) in
      let* Œ±2 : Ty.path "bool" := M.alloc (UnOp.not (BinOp.Pure.ne Œ±0 Œ±1)) in
      let* Œ±3 : Ty.path "bool" := M.read (use Œ±2) in
      if Œ±3 then
        let* Œ±0 : Ty.apply (Ty.path "ref") [Ty.path "str"] :=
          M.read
            (mk_str
              "assertion failed: calculate_hash(&person1) != calculate_hash(&person2)") in
        let* Œ±1 : Ty.path "never" := M.call (core.panicking.panic Œ±0) in
        let* Œ±2 : Ty.tuple := never_to_any Œ±1 in
        M.alloc Œ±2
      else
        M.alloc tt in
    let* Œ±0 : Ty.path "unit" := M.alloc tt in
    M.read Œ±0
  | _, _ => M.impossible
  end.
