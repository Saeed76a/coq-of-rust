(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

(* Enum Person *)

Module Impl_core_hash_Hash_for_hash_Person.
  Definition Self : Ty.t := Ty.path "hash::Person".
  
  (*
  Hash
  *)
  Definition hash (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [__H], [self; state] =>
      let* self := M.alloc self in
      let* state := M.alloc state in
      let* _ :=
        let* Œ±0 :=
          ltac:(M.get_method (fun ‚Ñê =>
            core.hash.Hash.hash
              (Self := Ty.path "u32")
              (H := __H)
              (Trait := ‚Ñê))) in
        let* Œ±1 := M.read self in
        let* Œ±2 := M.read state in
        let* Œ±3 :=
          M.call (Œ±0 (borrow ((M.var "hash::Person::Get_id") (deref Œ±1))) Œ±2) in
        M.alloc Œ±3 in
      let* _ :=
        let* Œ±0 :=
          ltac:(M.get_method (fun ‚Ñê =>
            core.hash.Hash.hash
              (Self := Ty.path "alloc::string::String")
              (H := __H)
              (Trait := ‚Ñê))) in
        let* Œ±1 := M.read self in
        let* Œ±2 := M.read state in
        let* Œ±3 :=
          M.call
            (Œ±0 (borrow ((M.var "hash::Person::Get_name") (deref Œ±1))) Œ±2) in
        M.alloc Œ±3 in
      let* Œ±0 :=
        ltac:(M.get_method (fun ‚Ñê =>
          core.hash.Hash.hash
            (Self := Ty.path "u64")
            (H := __H)
            (Trait := ‚Ñê))) in
      let* Œ±1 := M.read self in
      let* Œ±2 := M.read state in
      let* Œ±3 :=
        M.call
          (Œ±0 (borrow ((M.var "hash::Person::Get_phone") (deref Œ±1))) Œ±2) in
      let* Œ±0 := M.alloc Œ±3 in
      M.read Œ±0
    | _, _ => M.impossible
    end.
  
  Definition ‚Ñê : Instance.t := [("hash", InstanceField.Method hash)].
End Impl_core_hash_Hash_for_hash_Person.

(*
fn calculate_hash<T: Hash>(t: &T) -> u64 {
    let mut s = DefaultHasher::new();
    t.hash(&mut s);
    s.finish()
}
*)
Definition calculate_hash (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
  match ùúè, Œ± with
  | [T], [t] =>
    let* t := M.alloc t in
    let* s :=
      let* Œ±0 := M.call (Ty.path "std::hash::random::DefaultHasher")::["new"] in
      M.alloc Œ±0 in
    let* _ :=
      let* Œ±0 :=
        ltac:(M.get_method (fun ‚Ñê =>
          core.hash.Hash.hash
            (Self := T)
            (H := Ty.path "std::hash::random::DefaultHasher")
            (Trait := ‚Ñê))) in
      let* Œ±1 := M.read t in
      let* Œ±2 := M.call (Œ±0 Œ±1 (borrow_mut s)) in
      M.alloc Œ±2 in
    let* Œ±0 :=
      ltac:(M.get_method (fun ‚Ñê =>
        core.hash.Hasher.finish
          (Self := Ty.path "std::hash::random::DefaultHasher")
          (Trait := ‚Ñê))) in
    let* Œ±1 := M.call (Œ±0 (borrow s)) in
    let* Œ±0 := M.alloc Œ±1 in
    M.read Œ±0
  | _, _ => M.impossible
  end.

(*
fn main() {
    let person1 = Person {
        id: 5,
        name: "Janet".to_string(),
        phone: 555_666_7777,
    };
    let person2 = Person {
        id: 5,
        name: "Bob".to_string(),
        phone: 555_666_7777,
    };

    assert!(calculate_hash(&person1) != calculate_hash(&person2));
}
*)
(* #[allow(dead_code)] - function was ignored by the compiler *)
Definition main (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
  match ùúè, Œ± with
  | [], [] =>
    let* person1 :=
      let* Œ±0 :=
        ltac:(M.get_method (fun ‚Ñê =>
          alloc.string.ToString.to_string
            (Self := Ty.path "str")
            (Trait := ‚Ñê))) in
      let* Œ±1 := M.read (mk_str "Janet") in
      let* Œ±2 := M.call (Œ±0 Œ±1) in
      M.alloc
        {|
          hash.Person.id := (Integer.of_Z 5) : Ty.path "u32";
          hash.Person.name := Œ±2;
          hash.Person.phone := (Integer.of_Z 5556667777) : Ty.path "u64";
        |} in
    let* person2 :=
      let* Œ±0 :=
        ltac:(M.get_method (fun ‚Ñê =>
          alloc.string.ToString.to_string
            (Self := Ty.path "str")
            (Trait := ‚Ñê))) in
      let* Œ±1 := M.read (mk_str "Bob") in
      let* Œ±2 := M.call (Œ±0 Œ±1) in
      M.alloc
        {|
          hash.Person.id := (Integer.of_Z 5) : Ty.path "u32";
          hash.Person.name := Œ±2;
          hash.Person.phone := (Integer.of_Z 5556667777) : Ty.path "u64";
        |} in
    let* _ :=
      let* Œ±0 := M.call ((M.var "hash::calculate_hash") (borrow person1)) in
      let* Œ±1 := M.call ((M.var "hash::calculate_hash") (borrow person2)) in
      let* Œ±2 :=
        M.alloc ((M.var "UnOp::not") ((M.var "BinOp::Pure::ne") Œ±0 Œ±1)) in
      let* Œ±3 := M.read (use Œ±2) in
      if Œ±3 then
        let* Œ±0 :=
          M.read
            (mk_str
              "assertion failed: calculate_hash(&person1) != calculate_hash(&person2)") in
        let* Œ±1 := M.call ((M.var "core::panicking::panic") Œ±0) in
        let* Œ±2 := never_to_any Œ±1 in
        M.alloc Œ±2
      else
        M.alloc tt in
    let* Œ±0 := M.alloc tt in
    M.read Œ±0
  | _, _ => M.impossible
  end.
