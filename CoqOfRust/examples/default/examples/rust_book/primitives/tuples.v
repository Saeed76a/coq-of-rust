(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

(*
fn reverse(pair: (i32, bool)) -> (bool, i32) {
    // `let` can be used to bind the members of a tuple to variables
    let (int_param, bool_param) = pair;

    (bool_param, int_param)
}
*)
Definition reverse (𝜏 : list Ty.t) (α : list Value.t) : M :=
  match 𝜏, α with
  | [], [ pair ] =>
    let* pair := M.alloc pair in
    let* α0 :=
      match_operator
        pair
        [
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | (_, _) =>
              let γ0_0 := Tuple.Access.left γ in
              let γ0_1 := Tuple.Access.right γ in
              let* int_param := M.copy γ0_0 in
              let* bool_param := M.copy γ0_1 in
              let* α0 := M.read bool_param in
              let* α1 := M.read int_param in
              M.alloc (α0, α1)
            end)
        ] in
    M.read α0
  | _, _ => M.impossible
  end.

(* Struct Matrix *)

Module Impl_core_fmt_Debug_for_tuples_Matrix.
  (*
  Debug
  *)
  Definition fmt (𝜏 : list Ty.t) (α : list Value.t) : M :=
    match 𝜏, α with
    | [ Self ], [ self; f ] =>
      let* self := M.alloc self in
      let* f := M.alloc f in
      let* α0 := M.read f in
      let* α1 := M.read (mk_str "Matrix") in
      let* α2 := M.read self in
      let* α3 := M.read self in
      let* α4 := M.read self in
      let* α5 := M.read self in
      let* α6 := M.alloc (M.get_struct_tuple α5 3) in
      M.call
        (Ty.path "core::fmt::Formatter")::["debug_tuple_field4_finish"]
        [
          α0;
          α1;
          M.pointer_coercion "Unsize" (M.get_struct_tuple α2 0);
          M.pointer_coercion "Unsize" (M.get_struct_tuple α3 1);
          M.pointer_coercion "Unsize" (M.get_struct_tuple α4 2);
          M.pointer_coercion "Unsize" α6
        ]
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::fmt::Debug"
      (* Self *) (Ty.path "tuples::Matrix")
      (* Trait polymorphic types *) []
      (* Instance *) [ ("fmt", InstanceField.Method fmt) ]
      (* Instance polymorphic types *) [].
End Impl_core_fmt_Debug_for_tuples_Matrix.

(*
fn main() {
    // A tuple with a bunch of different types
    let long_tuple = (1u8, 2u16, 3u32, 4u64,
                      -1i8, -2i16, -3i32, -4i64,
                      0.1f32, 0.2f64,
                      'a', true);

    // Values can be extracted from the tuple using tuple indexing
    println!("long tuple first value: {}", long_tuple.0);
    println!("long tuple second value: {}", long_tuple.1);

    // Tuples can be tuple members
    let tuple_of_tuples = ((1u8, 2u16, 2u32), (4u64, -1i8), -2i16);

    // Tuples are printable
    println!("tuple of tuples: {:?}", tuple_of_tuples);
    
    // But long Tuples (more than 12 elements) cannot be printed
    // let too_long_tuple = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13);
    // println!("too long tuple: {:?}", too_long_tuple);
    // TODO ^ Uncomment the above 2 lines to see the compiler error

    let pair = (1, true);
    println!("pair is {:?}", pair);

    println!("the reversed pair is {:?}", reverse(pair));

    // To create one element tuples, the comma is required to tell them apart
    // from a literal surrounded by parentheses
    println!("one element tuple: {:?}", (5u32,));
    println!("just an integer: {:?}", (5u32));

    //tuples can be destructured to create bindings
    let tuple = (1, "hello", 4.5, true);

    let (a, b, c, d) = tuple;
    println!("{:?}, {:?}, {:?}, {:?}", a, b, c, d);

    let matrix = Matrix(1.1, 1.2, 2.1, 2.2);
    println!("{:?}", matrix);

}
*)
(* #[allow(dead_code)] - function was ignored by the compiler *)
Definition main (𝜏 : list Ty.t) (α : list Value.t) : M :=
  match 𝜏, α with
  | [], [] =>
    let* long_tuple :=
      let* α0 := M.read UnsupportedLiteral in
      let* α1 := M.read UnsupportedLiteral in
      M.alloc
        (Value.Integer Integer.U8 1,
          Value.Integer Integer.U16 2,
          Value.Integer Integer.U32 3,
          Value.Integer Integer.U64 4,
          Value.Integer Integer.I8 (-1),
          Value.Integer Integer.I16 (-2),
          Value.Integer Integer.I32 (-3),
          Value.Integer Integer.I64 (-4),
          α0,
          α1,
          "a"%char,
          true) in
    let* _ :=
      let* _ :=
        let* α0 := M.var "std::io::stdio::_print" in
        let* α1 := M.read (mk_str "long tuple first value: ") in
        let* α2 := M.read (mk_str "
") in
        let* α3 := M.alloc [ α1; α2 ] in
        let* α4 :=
          M.call
            (Ty.path "core::fmt::rt::Argument")::["new_display"]
            [ "Unknown Field" ] in
        let* α5 := M.alloc [ α4 ] in
        let* α6 :=
          M.call
            (Ty.path "core::fmt::Arguments")::["new_v1"]
            [ M.pointer_coercion "Unsize" α3; M.pointer_coercion "Unsize" α5
            ] in
        let* α7 := M.call α0 [ α6 ] in
        M.alloc α7 in
      M.alloc tt in
    let* _ :=
      let* _ :=
        let* α0 := M.var "std::io::stdio::_print" in
        let* α1 := M.read (mk_str "long tuple second value: ") in
        let* α2 := M.read (mk_str "
") in
        let* α3 := M.alloc [ α1; α2 ] in
        let* α4 :=
          M.call
            (Ty.path "core::fmt::rt::Argument")::["new_display"]
            [ "Unknown Field" ] in
        let* α5 := M.alloc [ α4 ] in
        let* α6 :=
          M.call
            (Ty.path "core::fmt::Arguments")::["new_v1"]
            [ M.pointer_coercion "Unsize" α3; M.pointer_coercion "Unsize" α5
            ] in
        let* α7 := M.call α0 [ α6 ] in
        M.alloc α7 in
      M.alloc tt in
    let* tuple_of_tuples :=
      M.alloc
        ((Value.Integer Integer.U8 1,
            Value.Integer Integer.U16 2,
            Value.Integer Integer.U32 2),
          (Value.Integer Integer.U64 4, Value.Integer Integer.I8 (-1)),
          Value.Integer Integer.I16 (-2)) in
    let* _ :=
      let* _ :=
        let* α0 := M.var "std::io::stdio::_print" in
        let* α1 := M.read (mk_str "tuple of tuples: ") in
        let* α2 := M.read (mk_str "
") in
        let* α3 := M.alloc [ α1; α2 ] in
        let* α4 :=
          M.call
            (Ty.path "core::fmt::rt::Argument")::["new_debug"]
            [ tuple_of_tuples ] in
        let* α5 := M.alloc [ α4 ] in
        let* α6 :=
          M.call
            (Ty.path "core::fmt::Arguments")::["new_v1"]
            [ M.pointer_coercion "Unsize" α3; M.pointer_coercion "Unsize" α5
            ] in
        let* α7 := M.call α0 [ α6 ] in
        M.alloc α7 in
      M.alloc tt in
    let* pair := M.alloc (Value.Integer Integer.I32 1, true) in
    let* _ :=
      let* _ :=
        let* α0 := M.var "std::io::stdio::_print" in
        let* α1 := M.read (mk_str "pair is ") in
        let* α2 := M.read (mk_str "
") in
        let* α3 := M.alloc [ α1; α2 ] in
        let* α4 :=
          M.call (Ty.path "core::fmt::rt::Argument")::["new_debug"] [ pair ] in
        let* α5 := M.alloc [ α4 ] in
        let* α6 :=
          M.call
            (Ty.path "core::fmt::Arguments")::["new_v1"]
            [ M.pointer_coercion "Unsize" α3; M.pointer_coercion "Unsize" α5
            ] in
        let* α7 := M.call α0 [ α6 ] in
        M.alloc α7 in
      M.alloc tt in
    let* _ :=
      let* _ :=
        let* α0 := M.var "std::io::stdio::_print" in
        let* α1 := M.read (mk_str "the reversed pair is ") in
        let* α2 := M.read (mk_str "
") in
        let* α3 := M.alloc [ α1; α2 ] in
        let* α4 := M.var "tuples::reverse" in
        let* α5 := M.read pair in
        let* α6 := M.call α4 [ α5 ] in
        let* α7 := M.alloc α6 in
        let* α8 :=
          M.call (Ty.path "core::fmt::rt::Argument")::["new_debug"] [ α7 ] in
        let* α9 := M.alloc [ α8 ] in
        let* α10 :=
          M.call
            (Ty.path "core::fmt::Arguments")::["new_v1"]
            [ M.pointer_coercion "Unsize" α3; M.pointer_coercion "Unsize" α9
            ] in
        let* α11 := M.call α0 [ α10 ] in
        M.alloc α11 in
      M.alloc tt in
    let* _ :=
      let* _ :=
        let* α0 := M.var "std::io::stdio::_print" in
        let* α1 := M.read (mk_str "one element tuple: ") in
        let* α2 := M.read (mk_str "
") in
        let* α3 := M.alloc [ α1; α2 ] in
        let* α4 := M.alloc (Value.Integer Integer.U32 5) in
        let* α5 :=
          M.call (Ty.path "core::fmt::rt::Argument")::["new_debug"] [ α4 ] in
        let* α6 := M.alloc [ α5 ] in
        let* α7 :=
          M.call
            (Ty.path "core::fmt::Arguments")::["new_v1"]
            [ M.pointer_coercion "Unsize" α3; M.pointer_coercion "Unsize" α6
            ] in
        let* α8 := M.call α0 [ α7 ] in
        M.alloc α8 in
      M.alloc tt in
    let* _ :=
      let* _ :=
        let* α0 := M.var "std::io::stdio::_print" in
        let* α1 := M.read (mk_str "just an integer: ") in
        let* α2 := M.read (mk_str "
") in
        let* α3 := M.alloc [ α1; α2 ] in
        let* α4 := M.alloc (Value.Integer Integer.U32 5) in
        let* α5 :=
          M.call (Ty.path "core::fmt::rt::Argument")::["new_debug"] [ α4 ] in
        let* α6 := M.alloc [ α5 ] in
        let* α7 :=
          M.call
            (Ty.path "core::fmt::Arguments")::["new_v1"]
            [ M.pointer_coercion "Unsize" α3; M.pointer_coercion "Unsize" α6
            ] in
        let* α8 := M.call α0 [ α7 ] in
        M.alloc α8 in
      M.alloc tt in
    let* tuple :=
      let* α0 := M.read (mk_str "hello") in
      let* α1 := M.read UnsupportedLiteral in
      M.alloc (Value.Integer Integer.I32 1, α0, α1, true) in
    let* α0 :=
      match_operator
        tuple
        [
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | (_, _, _, _) =>
              let γ0_0 :=
                Tuple.Access.left (Tuple.Access.left (Tuple.Access.left γ)) in
              let γ0_1 :=
                Tuple.Access.right (Tuple.Access.left (Tuple.Access.left γ)) in
              let γ0_2 := Tuple.Access.right (Tuple.Access.left γ) in
              let γ0_3 := Tuple.Access.right γ in
              let* a := M.copy γ0_0 in
              let* b := M.copy γ0_1 in
              let* c := M.copy γ0_2 in
              let* d := M.copy γ0_3 in
              let* _ :=
                let* _ :=
                  let* α0 := M.var "std::io::stdio::_print" in
                  let* α1 := M.read (mk_str "") in
                  let* α2 := M.read (mk_str ", ") in
                  let* α3 := M.read (mk_str ", ") in
                  let* α4 := M.read (mk_str ", ") in
                  let* α5 := M.read (mk_str "
") in
                  let* α6 := M.alloc [ α1; α2; α3; α4; α5 ] in
                  let* α7 :=
                    M.call
                      (Ty.path "core::fmt::rt::Argument")::["new_debug"]
                      [ a ] in
                  let* α8 :=
                    M.call
                      (Ty.path "core::fmt::rt::Argument")::["new_debug"]
                      [ b ] in
                  let* α9 :=
                    M.call
                      (Ty.path "core::fmt::rt::Argument")::["new_debug"]
                      [ c ] in
                  let* α10 :=
                    M.call
                      (Ty.path "core::fmt::rt::Argument")::["new_debug"]
                      [ d ] in
                  let* α11 := M.alloc [ α7; α8; α9; α10 ] in
                  let* α12 :=
                    M.call
                      (Ty.path "core::fmt::Arguments")::["new_v1"]
                      [
                        M.pointer_coercion "Unsize" α6;
                        M.pointer_coercion "Unsize" α11
                      ] in
                  let* α13 := M.call α0 [ α12 ] in
                  M.alloc α13 in
                M.alloc tt in
              let* matrix :=
                let* α0 := M.read UnsupportedLiteral in
                let* α1 := M.read UnsupportedLiteral in
                let* α2 := M.read UnsupportedLiteral in
                let* α3 := M.read UnsupportedLiteral in
                M.alloc
                  (Value.StructTuple "tuples::Matrix" [ α0; α1; α2; α3 ]) in
              let* _ :=
                let* _ :=
                  let* α0 := M.var "std::io::stdio::_print" in
                  let* α1 := M.read (mk_str "") in
                  let* α2 := M.read (mk_str "
") in
                  let* α3 := M.alloc [ α1; α2 ] in
                  let* α4 :=
                    M.call
                      (Ty.path "core::fmt::rt::Argument")::["new_debug"]
                      [ matrix ] in
                  let* α5 := M.alloc [ α4 ] in
                  let* α6 :=
                    M.call
                      (Ty.path "core::fmt::Arguments")::["new_v1"]
                      [
                        M.pointer_coercion "Unsize" α3;
                        M.pointer_coercion "Unsize" α5
                      ] in
                  let* α7 := M.call α0 [ α6 ] in
                  M.alloc α7 in
                M.alloc tt in
              M.alloc tt
            end)
        ] in
    M.read α0
  | _, _ => M.impossible
  end.
