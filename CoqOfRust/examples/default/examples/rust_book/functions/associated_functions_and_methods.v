(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.



Module  Impl_associated_functions_and_methods_Point.
Section Impl_associated_functions_and_methods_Point.
  Definition Self : Set :=
    Ty.apply (Ty.path "associated_functions_and_methods::Point") [].
  
  (*
      fn origin() -> Point {
          Point { y: 0.0, x: 1.0 }
      }
  *)
  Definition origin (𝜏 : list Ty.t) (α : list Value.t) : M :=
    match 𝜏, α with
    | [], [] =>
      let* α0 : Ty.path "f64" := M.read (UnsupportedLiteral : Ty.path "f64") in
      let* α1 : Ty.path "f64" := M.read (UnsupportedLiteral : Ty.path "f64") in
      M.pure
        {|
          associated_functions_and_methods.Point.y := α0;
          associated_functions_and_methods.Point.x := α1;
        |}
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_origin : Instance.t := {
    Notations.double_colon := origin;
  }.
  
  (*
      fn new(x: f64, y: f64) -> Point {
          Point { x: x, y: y }
      }
  *)
  Definition new (𝜏 : list Ty.t) (α : list Value.t) : M :=
    match 𝜏, α with
    | [], [x; y] =>
      let* x := M.alloc x in
      let* y := M.alloc y in
      let* α0 : Ty.path "f64" := M.read x in
      let* α1 : Ty.path "f64" := M.read y in
      M.pure
        {|
          associated_functions_and_methods.Point.x := α0;
          associated_functions_and_methods.Point.y := α1;
        |}
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_new : Instance.t := {
    Notations.double_colon := new;
  }.
End Impl_associated_functions_and_methods_Point.
End Impl_associated_functions_and_methods_Point.



Module  Impl_associated_functions_and_methods_Rectangle.
Section Impl_associated_functions_and_methods_Rectangle.
  Definition Self : Set :=
    Ty.apply (Ty.path "associated_functions_and_methods::Rectangle") [].
  
  (*
      fn get_p1(&self) -> Point {
          self.p1
      }
  *)
  Definition get_p1 (𝜏 : list Ty.t) (α : list Value.t) : M :=
    match 𝜏, α with
    | [], [self] =>
      let* self := M.alloc self in
      let* α0 :
          Ty.apply
            (Ty.path "ref")
            [Ty.apply
                (Ty.path "associated_functions_and_methods::Rectangle")
                []] :=
        M.read self in
      M.read (associated_functions_and_methods.Rectangle.Get_p1 (deref α0))
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_get_p1 : Instance.t := {
    Notations.double_colon := get_p1;
  }.
  
  (*
      fn area(&self) -> f64 {
          // `self` gives access to the struct fields via the dot operator
          let Point { x: x1, y: y1 } = self.p1;
          let Point { x: x2, y: y2 } = self.p2;
  
          // `abs` is a `f64` method that returns the absolute value of the
          // caller
          ((x1 - x2) * (y1 - y2)).abs()
      }
  *)
  Definition area (𝜏 : list Ty.t) (α : list Value.t) : M :=
    match 𝜏, α with
    | [], [self] =>
      let* self := M.alloc self in
      let* α0 :
          Ty.apply
            (Ty.path "ref")
            [Ty.apply
                (Ty.path "associated_functions_and_methods::Rectangle")
                []] :=
        M.read self in
      let* α1 : Ty.path "f64" :=
        match_operator
          (associated_functions_and_methods.Rectangle.Get_p1 (deref α0))
          [
            fun γ =>
              (let* α0 := M.read γ in
              match α0 with
              |
                  {|
                    associated_functions_and_methods.Point.x := _;
                    associated_functions_and_methods.Point.y := _;
                  |}
                  =>
                let γ0_0 := associated_functions_and_methods.Point.Get_x γ in
                let γ0_1 := associated_functions_and_methods.Point.Get_y γ in
                let* x1 := M.copy γ0_0 in
                let* y1 := M.copy γ0_1 in
                let* α0 :
                    Ty.apply
                      (Ty.path "ref")
                      [Ty.apply
                          (Ty.path
                            "associated_functions_and_methods::Rectangle")
                          []] :=
                  M.read self in
                match_operator
                  (associated_functions_and_methods.Rectangle.Get_p2 (deref α0))
                  [
                    fun γ =>
                      (let* α0 := M.read γ in
                      match α0 with
                      |
                          {|
                            associated_functions_and_methods.Point.x := _;
                            associated_functions_and_methods.Point.y := _;
                          |}
                          =>
                        let γ0_0 :=
                          associated_functions_and_methods.Point.Get_x γ in
                        let γ0_1 :=
                          associated_functions_and_methods.Point.Get_y γ in
                        let* x2 := M.copy γ0_0 in
                        let* y2 := M.copy γ0_1 in
                        let* α0 : Ty.path "f64" := M.read x1 in
                        let* α1 : Ty.path "f64" := M.read x2 in
                        let* α2 : Ty.path "f64" := BinOp.Panic.sub α0 α1 in
                        let* α3 : Ty.path "f64" := M.read y1 in
                        let* α4 : Ty.path "f64" := M.read y2 in
                        let* α5 : Ty.path "f64" := BinOp.Panic.sub α3 α4 in
                        let* α6 : Ty.path "f64" := BinOp.Panic.mul α2 α5 in
                        let* α7 : Ty.path "f64" :=
                          M.call ((Ty.path "f64")::["abs"] α6) in
                        M.alloc α7
                      end) :
                      Ty.path "f64"
                  ]
              end) :
              Ty.path "f64"
          ] in
      M.read α1
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_area : Instance.t := {
    Notations.double_colon := area;
  }.
  
  (*
      fn perimeter(&self) -> f64 {
          let Point { x: x1, y: y1 } = self.p1;
          let Point { x: x2, y: y2 } = self.p2;
  
          2.0 * ((x1 - x2).abs() + (y1 - y2).abs())
      }
  *)
  Definition perimeter (𝜏 : list Ty.t) (α : list Value.t) : M :=
    match 𝜏, α with
    | [], [self] =>
      let* self := M.alloc self in
      let* α0 :
          Ty.apply
            (Ty.path "ref")
            [Ty.apply
                (Ty.path "associated_functions_and_methods::Rectangle")
                []] :=
        M.read self in
      let* α1 : Ty.path "f64" :=
        match_operator
          (associated_functions_and_methods.Rectangle.Get_p1 (deref α0))
          [
            fun γ =>
              (let* α0 := M.read γ in
              match α0 with
              |
                  {|
                    associated_functions_and_methods.Point.x := _;
                    associated_functions_and_methods.Point.y := _;
                  |}
                  =>
                let γ0_0 := associated_functions_and_methods.Point.Get_x γ in
                let γ0_1 := associated_functions_and_methods.Point.Get_y γ in
                let* x1 := M.copy γ0_0 in
                let* y1 := M.copy γ0_1 in
                let* α0 :
                    Ty.apply
                      (Ty.path "ref")
                      [Ty.apply
                          (Ty.path
                            "associated_functions_and_methods::Rectangle")
                          []] :=
                  M.read self in
                match_operator
                  (associated_functions_and_methods.Rectangle.Get_p2 (deref α0))
                  [
                    fun γ =>
                      (let* α0 := M.read γ in
                      match α0 with
                      |
                          {|
                            associated_functions_and_methods.Point.x := _;
                            associated_functions_and_methods.Point.y := _;
                          |}
                          =>
                        let γ0_0 :=
                          associated_functions_and_methods.Point.Get_x γ in
                        let γ0_1 :=
                          associated_functions_and_methods.Point.Get_y γ in
                        let* x2 := M.copy γ0_0 in
                        let* y2 := M.copy γ0_1 in
                        let* α0 : Ty.path "f64" :=
                          M.read (UnsupportedLiteral : Ty.path "f64") in
                        let* α1 : Ty.path "f64" := M.read x1 in
                        let* α2 : Ty.path "f64" := M.read x2 in
                        let* α3 : Ty.path "f64" := BinOp.Panic.sub α1 α2 in
                        let* α4 : Ty.path "f64" :=
                          M.call ((Ty.path "f64")::["abs"] α3) in
                        let* α5 : Ty.path "f64" := M.read y1 in
                        let* α6 : Ty.path "f64" := M.read y2 in
                        let* α7 : Ty.path "f64" := BinOp.Panic.sub α5 α6 in
                        let* α8 : Ty.path "f64" :=
                          M.call ((Ty.path "f64")::["abs"] α7) in
                        let* α9 : Ty.path "f64" := BinOp.Panic.add α4 α8 in
                        let* α10 : Ty.path "f64" := BinOp.Panic.mul α0 α9 in
                        M.alloc α10
                      end) :
                      Ty.path "f64"
                  ]
              end) :
              Ty.path "f64"
          ] in
      M.read α1
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_perimeter : Instance.t := {
    Notations.double_colon := perimeter;
  }.
  
  (*
      fn translate(&mut self, x: f64, y: f64) {
          self.p1.x += x;
          self.p2.x += x;
  
          self.p1.y += y;
          self.p2.y += y;
      }
  *)
  Definition translate (𝜏 : list Ty.t) (α : list Value.t) : M :=
    match 𝜏, α with
    | [], [self; x; y] =>
      let* self := M.alloc self in
      let* x := M.alloc x in
      let* y := M.alloc y in
      let* _ : Ty.tuple :=
        let* β : Ty.path "f64" :=
          let* α0 :
              Ty.apply
                (Ty.path "mut_ref")
                [Ty.apply
                    (Ty.path "associated_functions_and_methods::Rectangle")
                    []] :=
            M.read self in
          M.pure
            (associated_functions_and_methods.Point.Get_x
              (associated_functions_and_methods.Rectangle.Get_p1 (deref α0))) in
        let* α0 := M.read β in
        let* α1 : Ty.path "f64" := M.read x in
        let* α2 := BinOp.Panic.add α0 α1 in
        assign β α2 in
      let* _ : Ty.tuple :=
        let* β : Ty.path "f64" :=
          let* α0 :
              Ty.apply
                (Ty.path "mut_ref")
                [Ty.apply
                    (Ty.path "associated_functions_and_methods::Rectangle")
                    []] :=
            M.read self in
          M.pure
            (associated_functions_and_methods.Point.Get_x
              (associated_functions_and_methods.Rectangle.Get_p2 (deref α0))) in
        let* α0 := M.read β in
        let* α1 : Ty.path "f64" := M.read x in
        let* α2 := BinOp.Panic.add α0 α1 in
        assign β α2 in
      let* _ : Ty.tuple :=
        let* β : Ty.path "f64" :=
          let* α0 :
              Ty.apply
                (Ty.path "mut_ref")
                [Ty.apply
                    (Ty.path "associated_functions_and_methods::Rectangle")
                    []] :=
            M.read self in
          M.pure
            (associated_functions_and_methods.Point.Get_y
              (associated_functions_and_methods.Rectangle.Get_p1 (deref α0))) in
        let* α0 := M.read β in
        let* α1 : Ty.path "f64" := M.read y in
        let* α2 := BinOp.Panic.add α0 α1 in
        assign β α2 in
      let* _ : Ty.tuple :=
        let* β : Ty.path "f64" :=
          let* α0 :
              Ty.apply
                (Ty.path "mut_ref")
                [Ty.apply
                    (Ty.path "associated_functions_and_methods::Rectangle")
                    []] :=
            M.read self in
          M.pure
            (associated_functions_and_methods.Point.Get_y
              (associated_functions_and_methods.Rectangle.Get_p2 (deref α0))) in
        let* α0 := M.read β in
        let* α1 : Ty.path "f64" := M.read y in
        let* α2 := BinOp.Panic.add α0 α1 in
        assign β α2 in
      let* α0 : Ty.path "unit" := M.alloc tt in
      M.read α0
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_translate : Instance.t := {
    Notations.double_colon := translate;
  }.
End Impl_associated_functions_and_methods_Rectangle.
End Impl_associated_functions_and_methods_Rectangle.



Module  Impl_associated_functions_and_methods_Pair.
Section Impl_associated_functions_and_methods_Pair.
  Definition Self : Set :=
    Ty.apply (Ty.path "associated_functions_and_methods::Pair") [].
  
  (*
      fn destroy(self) {
          // Destructure `self`
          let Pair(first, second) = self;
  
          println!("Destroying Pair({}, {})", first, second);
  
          // `first` and `second` go out of scope and get freed
      }
  *)
  Definition destroy (𝜏 : list Ty.t) (α : list Value.t) : M :=
    match 𝜏, α with
    | [], [self] =>
      let* self := M.alloc self in
      let* α0 : Ty.tuple :=
        match_operator
          self
          [
            fun γ =>
              (let* α0 := M.read γ in
              match α0 with
              | associated_functions_and_methods.Pair.Build_t _ _ =>
                let γ0_0 := associated_functions_and_methods.Pair.Get_0 γ in
                let γ0_1 := associated_functions_and_methods.Pair.Get_1 γ in
                let* first := M.copy γ0_0 in
                let* second := M.copy γ0_1 in
                let* _ : Ty.tuple :=
                  let* _ : Ty.tuple :=
                    let* α0 : Ty.apply (Ty.path "ref") [Ty.path "str"] :=
                      M.read (mk_str "Destroying Pair(") in
                    let* α1 : Ty.apply (Ty.path "ref") [Ty.path "str"] :=
                      M.read (mk_str ", ") in
                    let* α2 : Ty.apply (Ty.path "ref") [Ty.path "str"] :=
                      M.read (mk_str ")
") in
                    let* α3 :
                        Ty.apply
                          (Ty.path "array")
                          [Ty.apply (Ty.path "ref") [Ty.path "str"]] :=
                      M.alloc [ α0; α1; α2 ] in
                    let* α4 : Ty.apply (Ty.path "core::fmt::rt::Argument") [] :=
                      M.call
                        ((Ty.apply
                              (Ty.path "core::fmt::rt::Argument")
                              [])::["new_display"]
                          (borrow first)) in
                    let* α5 : Ty.apply (Ty.path "core::fmt::rt::Argument") [] :=
                      M.call
                        ((Ty.apply
                              (Ty.path "core::fmt::rt::Argument")
                              [])::["new_display"]
                          (borrow second)) in
                    let* α6 :
                        Ty.apply
                          (Ty.path "array")
                          [Ty.apply (Ty.path "core::fmt::rt::Argument") []] :=
                      M.alloc [ α4; α5 ] in
                    let* α7 : Ty.apply (Ty.path "core::fmt::Arguments") [] :=
                      M.call
                        ((Ty.apply
                              (Ty.path "core::fmt::Arguments")
                              [])::["new_v1"]
                          (pointer_coercion "Unsize" (borrow α3))
                          (pointer_coercion "Unsize" (borrow α6))) in
                    let* α8 : Ty.tuple := M.call (std.io.stdio._print α7) in
                    M.alloc α8 in
                  M.alloc tt in
                M.alloc tt
              end) :
              Ty.path "unit"
          ] in
      M.read α0
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_destroy : Instance.t := {
    Notations.double_colon := destroy;
  }.
End Impl_associated_functions_and_methods_Pair.
End Impl_associated_functions_and_methods_Pair.

(*
fn main() {
    let rectangle = Rectangle {
        // Associated functions are called using double colons
        p1: Point::origin(),
        p2: Point::new(3.0, 4.0),
    };

    // Methods are called using the dot operator
    // Note that the first argument `&self` is implicitly passed, i.e.
    // `rectangle.perimeter()` === `Rectangle::perimeter(&rectangle)`
    println!("Rectangle perimeter: {}", rectangle.perimeter());
    println!("Rectangle area: {}", rectangle.area());

    let mut square = Rectangle {
        p1: Point::origin(),
        p2: Point::new(1.0, 1.0),
    };

    // Error! `rectangle` is immutable, but this method requires a mutable
    // object
    //rectangle.translate(1.0, 0.0);
    // TODO ^ Try uncommenting this line

    // Okay! Mutable objects can call mutable methods
    square.translate(1.0, 1.0);

    let pair = Pair(Box::new(1), Box::new(2));

    pair.destroy();

    // Error! Previous `destroy` call "consumed" `pair`
    //pair.destroy();
    // TODO ^ Try uncommenting this line
}
*)
(* #[allow(dead_code)] - function was ignored by the compiler *)
Definition main (𝜏 : list Ty.t) (α : list Value.t) : M :=
  match 𝜏, α with
  | [], [] =>
    let* rectangle :
        Ty.apply (Ty.path "associated_functions_and_methods::Rectangle") [] :=
      let* α0 :
          Ty.apply (Ty.path "associated_functions_and_methods::Point") [] :=
        M.call
          (Ty.apply
              (Ty.path "associated_functions_and_methods::Point")
              [])::["origin"] in
      let* α1 : Ty.path "f64" := M.read (UnsupportedLiteral : Ty.path "f64") in
      let* α2 : Ty.path "f64" := M.read (UnsupportedLiteral : Ty.path "f64") in
      let* α3 :
          Ty.apply (Ty.path "associated_functions_and_methods::Point") [] :=
        M.call
          ((Ty.apply
                (Ty.path "associated_functions_and_methods::Point")
                [])::["new"]
            α1
            α2) in
      M.alloc
        {|
          associated_functions_and_methods.Rectangle.p1 := α0;
          associated_functions_and_methods.Rectangle.p2 := α3;
        |} in
    let* _ : Ty.tuple :=
      let* _ : Ty.tuple :=
        let* α0 : Ty.apply (Ty.path "ref") [Ty.path "str"] :=
          M.read (mk_str "Rectangle perimeter: ") in
        let* α1 : Ty.apply (Ty.path "ref") [Ty.path "str"] :=
          M.read (mk_str "
") in
        let* α2 :
            Ty.apply
              (Ty.path "array")
              [Ty.apply (Ty.path "ref") [Ty.path "str"]] :=
          M.alloc [ α0; α1 ] in
        let* α3 : Ty.path "f64" :=
          M.call
            ((Ty.apply
                  (Ty.path "associated_functions_and_methods::Rectangle")
                  [])::["perimeter"]
              (borrow rectangle)) in
        let* α4 : Ty.path "f64" := M.alloc α3 in
        let* α5 : Ty.apply (Ty.path "core::fmt::rt::Argument") [] :=
          M.call
            ((Ty.apply (Ty.path "core::fmt::rt::Argument") [])::["new_display"]
              (borrow α4)) in
        let* α6 :
            Ty.apply
              (Ty.path "array")
              [Ty.apply (Ty.path "core::fmt::rt::Argument") []] :=
          M.alloc [ α5 ] in
        let* α7 : Ty.apply (Ty.path "core::fmt::Arguments") [] :=
          M.call
            ((Ty.apply (Ty.path "core::fmt::Arguments") [])::["new_v1"]
              (pointer_coercion "Unsize" (borrow α2))
              (pointer_coercion "Unsize" (borrow α6))) in
        let* α8 : Ty.tuple := M.call (std.io.stdio._print α7) in
        M.alloc α8 in
      M.alloc tt in
    let* _ : Ty.tuple :=
      let* _ : Ty.tuple :=
        let* α0 : Ty.apply (Ty.path "ref") [Ty.path "str"] :=
          M.read (mk_str "Rectangle area: ") in
        let* α1 : Ty.apply (Ty.path "ref") [Ty.path "str"] :=
          M.read (mk_str "
") in
        let* α2 :
            Ty.apply
              (Ty.path "array")
              [Ty.apply (Ty.path "ref") [Ty.path "str"]] :=
          M.alloc [ α0; α1 ] in
        let* α3 : Ty.path "f64" :=
          M.call
            ((Ty.apply
                  (Ty.path "associated_functions_and_methods::Rectangle")
                  [])::["area"]
              (borrow rectangle)) in
        let* α4 : Ty.path "f64" := M.alloc α3 in
        let* α5 : Ty.apply (Ty.path "core::fmt::rt::Argument") [] :=
          M.call
            ((Ty.apply (Ty.path "core::fmt::rt::Argument") [])::["new_display"]
              (borrow α4)) in
        let* α6 :
            Ty.apply
              (Ty.path "array")
              [Ty.apply (Ty.path "core::fmt::rt::Argument") []] :=
          M.alloc [ α5 ] in
        let* α7 : Ty.apply (Ty.path "core::fmt::Arguments") [] :=
          M.call
            ((Ty.apply (Ty.path "core::fmt::Arguments") [])::["new_v1"]
              (pointer_coercion "Unsize" (borrow α2))
              (pointer_coercion "Unsize" (borrow α6))) in
        let* α8 : Ty.tuple := M.call (std.io.stdio._print α7) in
        M.alloc α8 in
      M.alloc tt in
    let* square :
        Ty.apply (Ty.path "associated_functions_and_methods::Rectangle") [] :=
      let* α0 :
          Ty.apply (Ty.path "associated_functions_and_methods::Point") [] :=
        M.call
          (Ty.apply
              (Ty.path "associated_functions_and_methods::Point")
              [])::["origin"] in
      let* α1 : Ty.path "f64" := M.read (UnsupportedLiteral : Ty.path "f64") in
      let* α2 : Ty.path "f64" := M.read (UnsupportedLiteral : Ty.path "f64") in
      let* α3 :
          Ty.apply (Ty.path "associated_functions_and_methods::Point") [] :=
        M.call
          ((Ty.apply
                (Ty.path "associated_functions_and_methods::Point")
                [])::["new"]
            α1
            α2) in
      M.alloc
        {|
          associated_functions_and_methods.Rectangle.p1 := α0;
          associated_functions_and_methods.Rectangle.p2 := α3;
        |} in
    let* _ : Ty.tuple :=
      let* α0 : Ty.path "f64" := M.read (UnsupportedLiteral : Ty.path "f64") in
      let* α1 : Ty.path "f64" := M.read (UnsupportedLiteral : Ty.path "f64") in
      let* α2 : Ty.tuple :=
        M.call
          ((Ty.apply
                (Ty.path "associated_functions_and_methods::Rectangle")
                [])::["translate"]
            (borrow_mut square)
            α0
            α1) in
      M.alloc α2 in
    let* pair :
        Ty.apply (Ty.path "associated_functions_and_methods::Pair") [] :=
      let* α0 :
          Ty.apply
            (Ty.path "alloc::boxed::Box")
            [Ty.path "i32"; Ty.apply (Ty.path "alloc::alloc::Global") []] :=
        M.call
          ((Ty.apply
                (Ty.path "alloc::boxed::Box")
                [Ty.path "i32";
                  Ty.apply (Ty.path "alloc::alloc::Global") []])::["new"]
            ((Integer.of_Z 1) : Ty.path "i32")) in
      let* α1 :
          Ty.apply
            (Ty.path "alloc::boxed::Box")
            [Ty.path "i32"; Ty.apply (Ty.path "alloc::alloc::Global") []] :=
        M.call
          ((Ty.apply
                (Ty.path "alloc::boxed::Box")
                [Ty.path "i32";
                  Ty.apply (Ty.path "alloc::alloc::Global") []])::["new"]
            ((Integer.of_Z 2) : Ty.path "i32")) in
      M.alloc (associated_functions_and_methods.Pair.Build_t α0 α1) in
    let* _ : Ty.tuple :=
      let* α0 :
          Ty.apply (Ty.path "associated_functions_and_methods::Pair") [] :=
        M.read pair in
      let* α1 : Ty.tuple :=
        M.call
          ((Ty.apply
                (Ty.path "associated_functions_and_methods::Pair")
                [])::["destroy"]
            α0) in
      M.alloc α1 in
    let* α0 : Ty.path "unit" := M.alloc tt in
    M.read α0
  | _, _ => M.impossible
  end.
