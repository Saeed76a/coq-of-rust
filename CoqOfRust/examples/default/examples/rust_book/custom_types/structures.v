(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

(* Struct Person *)

Module Impl_core_fmt_Debug_for_structures_Person.
  (*
  Debug
  *)
  Definition fmt (𝜏 : list Ty.t) (α : list Value.t) : M :=
    match 𝜏, α with
    | [ Self ], [ self; f ] =>
      let* self := M.alloc self in
      let* f := M.alloc f in
      let* α0 := M.read f in
      let* α1 := M.read (mk_str "Person") in
      let* α2 := M.read (mk_str "name") in
      let* α3 := M.read self in
      let* α4 := M.read (mk_str "age") in
      let* α5 := M.read self in
      let* α6 := M.alloc (M.get_struct_record α5 "age") in
      M.call
        (Ty.path "core::fmt::Formatter")::["debug_struct_field2_finish"]
        [
          α0;
          α1;
          α2;
          M.pointer_coercion "Unsize" (M.get_struct_record α3 "name");
          α4;
          M.pointer_coercion "Unsize" α6
        ]
    | _, _ => M.impossible
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::fmt::Debug"
      (* Self *) (Ty.path "structures::Person")
      (* Trait polymorphic types *) []
      (* Instance *) [ ("fmt", InstanceField.Method fmt) ]
      (* Instance polymorphic types *) [].
End Impl_core_fmt_Debug_for_structures_Person.

(* Struct Unit *)

(* Struct Pair *)

(* Struct Point *)

(* Struct Rectangle *)

(*
fn main() {
    // Create struct with field init shorthand
    let name = String::from("Peter");
    let age = 27;
    let peter = Person { name, age };

    // Print debug struct
    println!("{:?}", peter);

    // Instantiate a `Point`
    let point: Point = Point { x: 10.3, y: 0.4 };

    // Access the fields of the point
    println!("point coordinates: ({}, {})", point.x, point.y);

    // Make a new point by using struct update syntax to use the fields of our
    // other one
    let bottom_right = Point { x: 5.2, ..point };

    // `bottom_right.y` will be the same as `point.y` because we used that field
    // from `point`
    println!("second point: ({}, {})", bottom_right.x, bottom_right.y);

    // Destructure the point using a `let` binding
    let Point {
        x: left_edge,
        y: top_edge,
    } = point;

    let _rectangle = Rectangle {
        // struct instantiation is an expression too
        top_left: Point {
            x: left_edge,
            y: top_edge,
        },
        bottom_right: bottom_right,
    };

    // Instantiate a unit struct
    let _unit = Unit;

    // Instantiate a tuple struct
    let pair = Pair(1, 0.1);

    // Access the fields of a tuple struct
    println!("pair contains {:?} and {:?}", pair.0, pair.1);

    // Destructure a tuple struct
    let Pair(integer, decimal) = pair;

    println!("pair contains {:?} and {:?}", integer, decimal);
}
*)
(* #[allow(dead_code)] - function was ignored by the compiler *)
Definition main (𝜏 : list Ty.t) (α : list Value.t) : M :=
  match 𝜏, α with
  | [], [] =>
    let* name :=
      let* α0 :=
        M.get_trait_method
          "core::convert::From"
          "from"
          [
            (* Self *) Ty.path "alloc::string::String";
            (* T *) Ty.apply (Ty.path "ref") [ Ty.path "str" ]
          ] in
      let* α1 := M.read (mk_str "Peter") in
      let* α2 := M.call α0 [ α1 ] in
      M.alloc α2 in
    let* age := M.alloc (Value.Integer Integer.U8 27) in
    let* peter :=
      let* α0 := M.read name in
      let* α1 := M.read age in
      M.alloc
        (Value.StructRecord
          "structures::Person"
          [ ("name", α0); ("age", α1) ]) in
    let* _ :=
      let* _ :=
        let* α0 := M.var "std::io::stdio::_print" in
        let* α1 := M.read (mk_str "") in
        let* α2 := M.read (mk_str "
") in
        let* α3 := M.alloc [ α1; α2 ] in
        let* α4 :=
          M.call (Ty.path "core::fmt::rt::Argument")::["new_debug"] [ peter ] in
        let* α5 := M.alloc [ α4 ] in
        let* α6 :=
          M.call
            (Ty.path "core::fmt::Arguments")::["new_v1"]
            [ M.pointer_coercion "Unsize" α3; M.pointer_coercion "Unsize" α5
            ] in
        let* α7 := M.call α0 [ α6 ] in
        M.alloc α7 in
      M.alloc tt in
    let* point :=
      let* α0 := M.read UnsupportedLiteral in
      let* α1 := M.read UnsupportedLiteral in
      M.alloc
        (Value.StructRecord "structures::Point" [ ("x", α0); ("y", α1) ]) in
    let* _ :=
      let* _ :=
        let* α0 := M.var "std::io::stdio::_print" in
        let* α1 := M.read (mk_str "point coordinates: (") in
        let* α2 := M.read (mk_str ", ") in
        let* α3 := M.read (mk_str ")
") in
        let* α4 := M.alloc [ α1; α2; α3 ] in
        let* α5 :=
          M.call
            (Ty.path "core::fmt::rt::Argument")::["new_display"]
            [ M.get_struct_record point "x" ] in
        let* α6 :=
          M.call
            (Ty.path "core::fmt::rt::Argument")::["new_display"]
            [ M.get_struct_record point "y" ] in
        let* α7 := M.alloc [ α5; α6 ] in
        let* α8 :=
          M.call
            (Ty.path "core::fmt::Arguments")::["new_v1"]
            [ M.pointer_coercion "Unsize" α4; M.pointer_coercion "Unsize" α7
            ] in
        let* α9 := M.call α0 [ α8 ] in
        M.alloc α9 in
      M.alloc tt in
    let* bottom_right :=
      let* α0 := M.read UnsupportedLiteral in
      let* α1 := M.read point in
      M.alloc (α1 <| structures.Point.x := α0 |>) in
    let* _ :=
      let* _ :=
        let* α0 := M.var "std::io::stdio::_print" in
        let* α1 := M.read (mk_str "second point: (") in
        let* α2 := M.read (mk_str ", ") in
        let* α3 := M.read (mk_str ")
") in
        let* α4 := M.alloc [ α1; α2; α3 ] in
        let* α5 :=
          M.call
            (Ty.path "core::fmt::rt::Argument")::["new_display"]
            [ M.get_struct_record bottom_right "x" ] in
        let* α6 :=
          M.call
            (Ty.path "core::fmt::rt::Argument")::["new_display"]
            [ M.get_struct_record bottom_right "y" ] in
        let* α7 := M.alloc [ α5; α6 ] in
        let* α8 :=
          M.call
            (Ty.path "core::fmt::Arguments")::["new_v1"]
            [ M.pointer_coercion "Unsize" α4; M.pointer_coercion "Unsize" α7
            ] in
        let* α9 := M.call α0 [ α8 ] in
        M.alloc α9 in
      M.alloc tt in
    let* α0 :=
      match_operator
        point
        [
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | {| structures.Point.x := _; structures.Point.y := _; |} =>
              let* γ0_0 :=
                let* α0 := M.var "structures::Point::Get_x" in
                M.pure (α0 γ) in
              let* γ0_1 :=
                let* α0 := M.var "structures::Point::Get_y" in
                M.pure (α0 γ) in
              let* left_edge := M.copy γ0_0 in
              let* top_edge := M.copy γ0_1 in
              let* _rectangle :=
                let* α0 := M.read left_edge in
                let* α1 := M.read top_edge in
                let* α2 := M.read bottom_right in
                M.alloc
                  (Value.StructRecord
                    "structures::Rectangle"
                    [
                      ("top_left",
                        Value.StructRecord
                          "structures::Point"
                          [ ("x", α0); ("y", α1) ]);
                      ("bottom_right", α2)
                    ]) in
              let* _unit := M.alloc structures.Unit.Build in
              let* pair :=
                let* α0 := M.read UnsupportedLiteral in
                M.alloc
                  (Value.StructTuple
                    "structures::Pair"
                    [ Value.Integer Integer.I32 1; α0 ]) in
              let* _ :=
                let* _ :=
                  let* α0 := M.var "std::io::stdio::_print" in
                  let* α1 := M.read (mk_str "pair contains ") in
                  let* α2 := M.read (mk_str " and ") in
                  let* α3 := M.read (mk_str "
") in
                  let* α4 := M.alloc [ α1; α2; α3 ] in
                  let* α5 :=
                    M.call
                      (Ty.path "core::fmt::rt::Argument")::["new_debug"]
                      [ M.get_struct_tuple pair 0 ] in
                  let* α6 :=
                    M.call
                      (Ty.path "core::fmt::rt::Argument")::["new_debug"]
                      [ M.get_struct_tuple pair 1 ] in
                  let* α7 := M.alloc [ α5; α6 ] in
                  let* α8 :=
                    M.call
                      (Ty.path "core::fmt::Arguments")::["new_v1"]
                      [
                        M.pointer_coercion "Unsize" α4;
                        M.pointer_coercion "Unsize" α7
                      ] in
                  let* α9 := M.call α0 [ α8 ] in
                  M.alloc α9 in
                M.alloc tt in
              match_operator
                pair
                [
                  fun γ =>
                    (let* α0 := M.read γ in
                    match α0 with
                    | structures.Pair.Build_t _ _ =>
                      let* γ0_0 :=
                        let* α0 := M.var "structures::Pair::Get_0" in
                        M.pure (α0 γ) in
                      let* γ0_1 :=
                        let* α0 := M.var "structures::Pair::Get_1" in
                        M.pure (α0 γ) in
                      let* integer := M.copy γ0_0 in
                      let* decimal := M.copy γ0_1 in
                      let* _ :=
                        let* _ :=
                          let* α0 := M.var "std::io::stdio::_print" in
                          let* α1 := M.read (mk_str "pair contains ") in
                          let* α2 := M.read (mk_str " and ") in
                          let* α3 := M.read (mk_str "
") in
                          let* α4 := M.alloc [ α1; α2; α3 ] in
                          let* α5 :=
                            M.call
                              (Ty.path "core::fmt::rt::Argument")::["new_debug"]
                              [ integer ] in
                          let* α6 :=
                            M.call
                              (Ty.path "core::fmt::rt::Argument")::["new_debug"]
                              [ decimal ] in
                          let* α7 := M.alloc [ α5; α6 ] in
                          let* α8 :=
                            M.call
                              (Ty.path "core::fmt::Arguments")::["new_v1"]
                              [
                                M.pointer_coercion "Unsize" α4;
                                M.pointer_coercion "Unsize" α7
                              ] in
                          let* α9 := M.call α0 [ α8 ] in
                          M.alloc α9 in
                        M.alloc tt in
                      M.alloc tt
                    end)
                ]
            end)
        ] in
    M.read α0
  | _, _ => M.impossible
  end.
