(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

(*
fn main() {
    // A counter variable
    let mut n = 1;

    // Loop while `n` is less than 101
    while n < 101 {
        if n % 15 == 0 {
            println!("fizzbuzz");
        } else if n % 3 == 0 {
            println!("fizz");
        } else if n % 5 == 0 {
            println!("buzz");
        } else {
            println!("{}", n);
        }

        // Increment counter
        n += 1;
    }
}
*)
Definition main (𝜏 : list Ty.t) (α : list Value.t) : M :=
  match 𝜏, α with
  | [], [] =>
    let* n := M.alloc (Value.Integer Integer.I32 1) in
    let* α0 :=
      M.loop
        (let* α0 := M.read n in
        let* α1 := M.alloc (BinOp.Pure.lt α0 (Value.Integer Integer.I32 101)) in
        let* α2 := M.read (M.use α1) in
        if Value.is_true α2 then
          let* _ :=
            let* α0 := M.read n in
            let* α1 := BinOp.Panic.rem α0 (Value.Integer Integer.I32 15) in
            let* α2 :=
              M.alloc (BinOp.Pure.eq α1 (Value.Integer Integer.I32 0)) in
            let* α3 := M.read (M.use α2) in
            if Value.is_true α3 then
              let* _ :=
                let* _ :=
                  let* α0 := M.get_function "std::io::stdio::_print" [] in
                  let* α1 :=
                    M.get_associated_function
                      (Ty.path "core::fmt::Arguments")
                      "new_const" in
                  let* α2 := M.read (mk_str "fizzbuzz
") in
                  let* α3 := M.alloc (Value.Array [ α2 ]) in
                  let* α4 := M.call α1 [ M.pointer_coercion (* Unsize *) α3 ] in
                  let* α5 := M.call α0 [ α4 ] in
                  M.alloc α5 in
                M.alloc (Value.Tuple []) in
              M.alloc (Value.Tuple [])
            else
              let* α0 := M.read n in
              let* α1 := BinOp.Panic.rem α0 (Value.Integer Integer.I32 3) in
              let* α2 :=
                M.alloc (BinOp.Pure.eq α1 (Value.Integer Integer.I32 0)) in
              let* α3 := M.read (M.use α2) in
              if Value.is_true α3 then
                let* _ :=
                  let* _ :=
                    let* α0 := M.get_function "std::io::stdio::_print" [] in
                    let* α1 :=
                      M.get_associated_function
                        (Ty.path "core::fmt::Arguments")
                        "new_const" in
                    let* α2 := M.read (mk_str "fizz
") in
                    let* α3 := M.alloc (Value.Array [ α2 ]) in
                    let* α4 :=
                      M.call α1 [ M.pointer_coercion (* Unsize *) α3 ] in
                    let* α5 := M.call α0 [ α4 ] in
                    M.alloc α5 in
                  M.alloc (Value.Tuple []) in
                M.alloc (Value.Tuple [])
              else
                let* α0 := M.read n in
                let* α1 := BinOp.Panic.rem α0 (Value.Integer Integer.I32 5) in
                let* α2 :=
                  M.alloc (BinOp.Pure.eq α1 (Value.Integer Integer.I32 0)) in
                let* α3 := M.read (M.use α2) in
                if Value.is_true α3 then
                  let* _ :=
                    let* _ :=
                      let* α0 := M.get_function "std::io::stdio::_print" [] in
                      let* α1 :=
                        M.get_associated_function
                          (Ty.path "core::fmt::Arguments")
                          "new_const" in
                      let* α2 := M.read (mk_str "buzz
") in
                      let* α3 := M.alloc (Value.Array [ α2 ]) in
                      let* α4 :=
                        M.call α1 [ M.pointer_coercion (* Unsize *) α3 ] in
                      let* α5 := M.call α0 [ α4 ] in
                      M.alloc α5 in
                    M.alloc (Value.Tuple []) in
                  M.alloc (Value.Tuple [])
                else
                  let* _ :=
                    let* _ :=
                      let* α0 := M.get_function "std::io::stdio::_print" [] in
                      let* α1 :=
                        M.get_associated_function
                          (Ty.path "core::fmt::Arguments")
                          "new_v1" in
                      let* α2 := M.read (mk_str "") in
                      let* α3 := M.read (mk_str "
") in
                      let* α4 := M.alloc (Value.Array [ α2; α3 ]) in
                      let* α5 :=
                        M.get_associated_function
                          (Ty.path "core::fmt::rt::Argument")
                          "new_display" in
                      let* α6 := M.call α5 [ n ] in
                      let* α7 := M.alloc (Value.Array [ α6 ]) in
                      let* α8 :=
                        M.call
                          α1
                          [
                            M.pointer_coercion (* Unsize *) α4;
                            M.pointer_coercion (* Unsize *) α7
                          ] in
                      let* α9 := M.call α0 [ α8 ] in
                      M.alloc α9 in
                    M.alloc (Value.Tuple []) in
                  M.alloc (Value.Tuple []) in
          let* _ :=
            let β := n in
            let* α0 := M.read β in
            let* α1 := BinOp.Panic.add α0 (Value.Integer Integer.I32 1) in
            M.assign β α1 in
          M.alloc (Value.Tuple [])
        else
          let* _ :=
            let* α0 := M.break in
            let* α1 := M.read α0 in
            let* α2 := M.never_to_any α1 in
            M.alloc α2 in
          let* α0 := M.alloc (Value.Tuple []) in
          let* α1 := M.read α0 in
          let* α2 := M.never_to_any α1 in
          M.alloc α2) in
    M.read α0
  | _, _ => M.impossible
  end.
