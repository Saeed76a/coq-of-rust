(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.



Module  Impl_core_fmt_Debug_for_combinators_map_Food.
Section Impl_core_fmt_Debug_for_combinators_map_Food.
  Definition Self : Ty.t := Ty.apply (Ty.path "combinators_map::Food") [].
  
  (*
  Debug
  *)
  Definition fmt (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self; f] =>
      let* self := M.alloc self in
      let* f := M.alloc f in
      let* Œ±0 := M.read f in
      let* Œ±1 :=
        match_operator
          self
          [
            fun Œ≥ =>
              (let* Œ≥ :=
                let* Œ±0 := M.read Œ≥ in
                M.pure (deref Œ±0) in
              let* Œ±0 := M.read Œ≥ in
              match Œ±0 with
              | combinators_map.Food.Apple =>
                let* Œ±0 := M.read (mk_str "Apple") in
                M.alloc Œ±0
              | _ => M.break_match
              end) :
              Ty.apply (Ty.path "ref") [Ty.path "str"];
            fun Œ≥ =>
              (let* Œ≥ :=
                let* Œ±0 := M.read Œ≥ in
                M.pure (deref Œ±0) in
              let* Œ±0 := M.read Œ≥ in
              match Œ±0 with
              | combinators_map.Food.Carrot =>
                let* Œ±0 := M.read (mk_str "Carrot") in
                M.alloc Œ±0
              | _ => M.break_match
              end) :
              Ty.apply (Ty.path "ref") [Ty.path "str"];
            fun Œ≥ =>
              (let* Œ≥ :=
                let* Œ±0 := M.read Œ≥ in
                M.pure (deref Œ±0) in
              let* Œ±0 := M.read Œ≥ in
              match Œ±0 with
              | combinators_map.Food.Potato =>
                let* Œ±0 := M.read (mk_str "Potato") in
                M.alloc Œ±0
              | _ => M.break_match
              end) :
              Ty.apply (Ty.path "ref") [Ty.path "str"]
          ] in
      let* Œ±2 := M.read Œ±1 in
      M.call
        ((Ty.apply (Ty.path "core::fmt::Formatter") [])::["write_str"] Œ±0 Œ±2)
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_fmt : Instance.t := {
    Notations.double_colon := fmt;
  }.
  
  Definition ‚Ñê : Instance.t := [("fmt", fmt)].
End Impl_core_fmt_Debug_for_combinators_map_Food.
End Impl_core_fmt_Debug_for_combinators_map_Food.



Module  Impl_core_fmt_Debug_for_combinators_map_Peeled.
Section Impl_core_fmt_Debug_for_combinators_map_Peeled.
  Definition Self : Ty.t := Ty.apply (Ty.path "combinators_map::Peeled") [].
  
  (*
  Debug
  *)
  Definition fmt (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self; f] =>
      let* self := M.alloc self in
      let* f := M.alloc f in
      let* Œ±0 := M.read f in
      let* Œ±1 := M.read (mk_str "Peeled") in
      let* Œ±2 := M.read self in
      let* Œ±3 :=
        M.alloc
          (borrow ((M.var "combinators_map::Peeled::Get_0") (deref Œ±2))) in
      M.call
        ((Ty.apply
              (Ty.path "core::fmt::Formatter")
              [])::["debug_tuple_field1_finish"]
          Œ±0
          Œ±1
          (pointer_coercion "Unsize" (borrow Œ±3)))
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_fmt : Instance.t := {
    Notations.double_colon := fmt;
  }.
  
  Definition ‚Ñê : Instance.t := [("fmt", fmt)].
End Impl_core_fmt_Debug_for_combinators_map_Peeled.
End Impl_core_fmt_Debug_for_combinators_map_Peeled.



Module  Impl_core_fmt_Debug_for_combinators_map_Chopped.
Section Impl_core_fmt_Debug_for_combinators_map_Chopped.
  Definition Self : Ty.t := Ty.apply (Ty.path "combinators_map::Chopped") [].
  
  (*
  Debug
  *)
  Definition fmt (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self; f] =>
      let* self := M.alloc self in
      let* f := M.alloc f in
      let* Œ±0 := M.read f in
      let* Œ±1 := M.read (mk_str "Chopped") in
      let* Œ±2 := M.read self in
      let* Œ±3 :=
        M.alloc
          (borrow ((M.var "combinators_map::Chopped::Get_0") (deref Œ±2))) in
      M.call
        ((Ty.apply
              (Ty.path "core::fmt::Formatter")
              [])::["debug_tuple_field1_finish"]
          Œ±0
          Œ±1
          (pointer_coercion "Unsize" (borrow Œ±3)))
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_fmt : Instance.t := {
    Notations.double_colon := fmt;
  }.
  
  Definition ‚Ñê : Instance.t := [("fmt", fmt)].
End Impl_core_fmt_Debug_for_combinators_map_Chopped.
End Impl_core_fmt_Debug_for_combinators_map_Chopped.



Module  Impl_core_fmt_Debug_for_combinators_map_Cooked.
Section Impl_core_fmt_Debug_for_combinators_map_Cooked.
  Definition Self : Ty.t := Ty.apply (Ty.path "combinators_map::Cooked") [].
  
  (*
  Debug
  *)
  Definition fmt (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
    match ùúè, Œ± with
    | [], [self; f] =>
      let* self := M.alloc self in
      let* f := M.alloc f in
      let* Œ±0 := M.read f in
      let* Œ±1 := M.read (mk_str "Cooked") in
      let* Œ±2 := M.read self in
      let* Œ±3 :=
        M.alloc
          (borrow ((M.var "combinators_map::Cooked::Get_0") (deref Œ±2))) in
      M.call
        ((Ty.apply
              (Ty.path "core::fmt::Formatter")
              [])::["debug_tuple_field1_finish"]
          Œ±0
          Œ±1
          (pointer_coercion "Unsize" (borrow Œ±3)))
    | _, _ => M.impossible
    end.
  
  Definition AssociatedFunction_fmt : Instance.t := {
    Notations.double_colon := fmt;
  }.
  
  Definition ‚Ñê : Instance.t := [("fmt", fmt)].
End Impl_core_fmt_Debug_for_combinators_map_Cooked.
End Impl_core_fmt_Debug_for_combinators_map_Cooked.

(*
fn peel(food: Option<Food>) -> Option<Peeled> {
    match food {
        Some(food) => Some(Peeled(food)),
        None => None,
    }
}
*)
Definition peel (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
  match ùúè, Œ± with
  | [], [food] =>
    let* food := M.alloc food in
    let* Œ±0 :=
      match_operator
        food
        [
          fun Œ≥ =>
            (let* Œ±0 := M.read Œ≥ in
            match Œ±0 with
            | core.option.Option.Some _ =>
              let Œ≥0_0 := (M.var "core::option::Option::Get_Some_0") Œ≥ in
              let* food := M.copy Œ≥0_0 in
              let* Œ±0 := M.read food in
              M.alloc
                (core.option.Option.Some (combinators_map.Peeled.Build_t Œ±0))
            | _ => M.break_match
            end) :
            Ty.apply
              (Ty.path "core::option::Option")
              [Ty.apply (Ty.path "combinators_map::Peeled") []];
          fun Œ≥ =>
            (let* Œ±0 := M.read Œ≥ in
            match Œ±0 with
            | core.option.Option.None => M.alloc core.option.Option.None
            | _ => M.break_match
            end) :
            Ty.apply
              (Ty.path "core::option::Option")
              [Ty.apply (Ty.path "combinators_map::Peeled") []]
        ] in
    M.read Œ±0
  | _, _ => M.impossible
  end.

(*
fn chop(peeled: Option<Peeled>) -> Option<Chopped> {
    match peeled {
        Some(Peeled(food)) => Some(Chopped(food)),
        None => None,
    }
}
*)
Definition chop (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
  match ùúè, Œ± with
  | [], [peeled] =>
    let* peeled := M.alloc peeled in
    let* Œ±0 :=
      match_operator
        peeled
        [
          fun Œ≥ =>
            (let* Œ±0 := M.read Œ≥ in
            match Œ±0 with
            | core.option.Option.Some _ =>
              let Œ≥0_0 := (M.var "core::option::Option::Get_Some_0") Œ≥ in
              let* Œ±0 := M.read Œ≥0_0 in
              match Œ±0 with
              | combinators_map.Peeled.Build_t _ =>
                let Œ≥1_0 := (M.var "combinators_map::Peeled::Get_0") Œ≥0_0 in
                let* food := M.copy Œ≥1_0 in
                let* Œ±0 := M.read food in
                M.alloc
                  (core.option.Option.Some (combinators_map.Chopped.Build_t Œ±0))
              end
            | _ => M.break_match
            end) :
            Ty.apply
              (Ty.path "core::option::Option")
              [Ty.apply (Ty.path "combinators_map::Chopped") []];
          fun Œ≥ =>
            (let* Œ±0 := M.read Œ≥ in
            match Œ±0 with
            | core.option.Option.None => M.alloc core.option.Option.None
            | _ => M.break_match
            end) :
            Ty.apply
              (Ty.path "core::option::Option")
              [Ty.apply (Ty.path "combinators_map::Chopped") []]
        ] in
    M.read Œ±0
  | _, _ => M.impossible
  end.

(*
fn cook(chopped: Option<Chopped>) -> Option<Cooked> {
    chopped.map(|Chopped(food)| Cooked(food))
}
*)
Definition cook (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
  match ùúè, Œ± with
  | [], [chopped] =>
    let* chopped := M.alloc chopped in
    let* Œ±0 := M.read chopped in
    M.call
      ((Ty.apply
            (Ty.path "core::option::Option")
            [Ty.apply (Ty.path "combinators_map::Chopped") []])::["map"]
        Œ±0
        (fun (Œ±0 : Ty.apply (Ty.path "combinators_map::Chopped") []) =>
          (let* Œ±0 := M.alloc Œ±0 in
          match_operator
            Œ±0
            [
              fun Œ≥ =>
                (let* Œ±0 := M.read Œ≥ in
                match Œ±0 with
                | combinators_map.Chopped.Build_t _ =>
                  let Œ≥0_0 := (M.var "combinators_map::Chopped::Get_0") Œ≥ in
                  let* food := M.copy Œ≥0_0 in
                  let* Œ±0 := M.read food in
                  M.pure (combinators_map.Cooked.Build_t Œ±0)
                end) :
                Ty.apply (Ty.path "combinators_map::Cooked") []
            ]) :
          Ty.apply (Ty.path "combinators_map::Cooked") []))
  | _, _ => M.impossible
  end.

(*
fn process(food: Option<Food>) -> Option<Cooked> {
    food.map(|f| Peeled(f))
        .map(|Peeled(f)| Chopped(f))
        .map(|Chopped(f)| Cooked(f))
}
*)
Definition process (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
  match ùúè, Œ± with
  | [], [food] =>
    let* food := M.alloc food in
    let* Œ±0 := M.read food in
    let* Œ±1 :=
      M.call
        ((Ty.apply
              (Ty.path "core::option::Option")
              [Ty.apply (Ty.path "combinators_map::Food") []])::["map"]
          Œ±0
          (fun (Œ±0 : Ty.apply (Ty.path "combinators_map::Food") []) =>
            (let* Œ±0 := M.alloc Œ±0 in
            match_operator
              Œ±0
              [
                fun Œ≥ =>
                  (let* f := M.copy Œ≥ in
                  let* Œ±0 := M.read f in
                  M.pure (combinators_map.Peeled.Build_t Œ±0)) :
                  Ty.apply (Ty.path "combinators_map::Peeled") []
              ]) :
            Ty.apply (Ty.path "combinators_map::Peeled") [])) in
    let* Œ±2 :=
      M.call
        ((Ty.apply
              (Ty.path "core::option::Option")
              [Ty.apply (Ty.path "combinators_map::Peeled") []])::["map"]
          Œ±1
          (fun (Œ±0 : Ty.apply (Ty.path "combinators_map::Peeled") []) =>
            (let* Œ±0 := M.alloc Œ±0 in
            match_operator
              Œ±0
              [
                fun Œ≥ =>
                  (let* Œ±0 := M.read Œ≥ in
                  match Œ±0 with
                  | combinators_map.Peeled.Build_t _ =>
                    let Œ≥0_0 := (M.var "combinators_map::Peeled::Get_0") Œ≥ in
                    let* f := M.copy Œ≥0_0 in
                    let* Œ±0 := M.read f in
                    M.pure (combinators_map.Chopped.Build_t Œ±0)
                  end) :
                  Ty.apply (Ty.path "combinators_map::Chopped") []
              ]) :
            Ty.apply (Ty.path "combinators_map::Chopped") [])) in
    M.call
      ((Ty.apply
            (Ty.path "core::option::Option")
            [Ty.apply (Ty.path "combinators_map::Chopped") []])::["map"]
        Œ±2
        (fun (Œ±0 : Ty.apply (Ty.path "combinators_map::Chopped") []) =>
          (let* Œ±0 := M.alloc Œ±0 in
          match_operator
            Œ±0
            [
              fun Œ≥ =>
                (let* Œ±0 := M.read Œ≥ in
                match Œ±0 with
                | combinators_map.Chopped.Build_t _ =>
                  let Œ≥0_0 := (M.var "combinators_map::Chopped::Get_0") Œ≥ in
                  let* f := M.copy Œ≥0_0 in
                  let* Œ±0 := M.read f in
                  M.pure (combinators_map.Cooked.Build_t Œ±0)
                end) :
                Ty.apply (Ty.path "combinators_map::Cooked") []
            ]) :
          Ty.apply (Ty.path "combinators_map::Cooked") []))
  | _, _ => M.impossible
  end.

(*
fn eat(food: Option<Cooked>) {
    match food {
        Some(food) => println!("Mmm. I love {:?}", food),
        None => println!("Oh no! It wasn't edible."),
    }
}
*)
Definition eat (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
  match ùúè, Œ± with
  | [], [food] =>
    let* food := M.alloc food in
    let* Œ±0 :=
      match_operator
        food
        [
          fun Œ≥ =>
            (let* Œ±0 := M.read Œ≥ in
            match Œ±0 with
            | core.option.Option.Some _ =>
              let Œ≥0_0 := (M.var "core::option::Option::Get_Some_0") Œ≥ in
              let* food := M.copy Œ≥0_0 in
              let* _ :=
                let* Œ±0 := M.read (mk_str "Mmm. I love ") in
                let* Œ±1 := M.read (mk_str "
") in
                let* Œ±2 := M.alloc [ Œ±0; Œ±1 ] in
                let* Œ±3 :=
                  M.call
                    ((Ty.apply
                          (Ty.path "core::fmt::rt::Argument")
                          [])::["new_debug"]
                      (borrow food)) in
                let* Œ±4 := M.alloc [ Œ±3 ] in
                let* Œ±5 :=
                  M.call
                    ((Ty.apply (Ty.path "core::fmt::Arguments") [])::["new_v1"]
                      (pointer_coercion "Unsize" (borrow Œ±2))
                      (pointer_coercion "Unsize" (borrow Œ±4))) in
                let* Œ±6 := M.call ((M.var "std::io::stdio::_print") Œ±5) in
                M.alloc Œ±6 in
              M.alloc tt
            | _ => M.break_match
            end) :
            Ty.tuple;
          fun Œ≥ =>
            (let* Œ±0 := M.read Œ≥ in
            match Œ±0 with
            | core.option.Option.None =>
              let* _ :=
                let* Œ±0 := M.read (mk_str "Oh no! It wasn't edible.
") in
                let* Œ±1 := M.alloc [ Œ±0 ] in
                let* Œ±2 :=
                  M.call
                    ((Ty.apply
                          (Ty.path "core::fmt::Arguments")
                          [])::["new_const"]
                      (pointer_coercion "Unsize" (borrow Œ±1))) in
                let* Œ±3 := M.call ((M.var "std::io::stdio::_print") Œ±2) in
                M.alloc Œ±3 in
              M.alloc tt
            | _ => M.break_match
            end) :
            Ty.tuple
        ] in
    M.read Œ±0
  | _, _ => M.impossible
  end.

(*
fn main() {
    let apple = Some(Food::Apple);
    let carrot = Some(Food::Carrot);
    let potato = None;

    let cooked_apple = cook(chop(peel(apple)));
    let cooked_carrot = cook(chop(peel(carrot)));
    // Let's try the simpler looking `process()` now.
    let cooked_potato = process(potato);

    eat(cooked_apple);
    eat(cooked_carrot);
    eat(cooked_potato);
}
*)
(* #[allow(dead_code)] - function was ignored by the compiler *)
Definition main (ùúè : list Ty.t) (Œ± : list Value.t) : M :=
  match ùúè, Œ± with
  | [], [] =>
    let* apple :=
      M.alloc (core.option.Option.Some combinators_map.Food.Apple) in
    let* carrot :=
      M.alloc (core.option.Option.Some combinators_map.Food.Carrot) in
    let* potato := M.alloc core.option.Option.None in
    let* cooked_apple :=
      let* Œ±0 := M.read apple in
      let* Œ±1 := M.call ((M.var "combinators_map::peel") Œ±0) in
      let* Œ±2 := M.call ((M.var "combinators_map::chop") Œ±1) in
      let* Œ±3 := M.call ((M.var "combinators_map::cook") Œ±2) in
      M.alloc Œ±3 in
    let* cooked_carrot :=
      let* Œ±0 := M.read carrot in
      let* Œ±1 := M.call ((M.var "combinators_map::peel") Œ±0) in
      let* Œ±2 := M.call ((M.var "combinators_map::chop") Œ±1) in
      let* Œ±3 := M.call ((M.var "combinators_map::cook") Œ±2) in
      M.alloc Œ±3 in
    let* cooked_potato :=
      let* Œ±0 := M.read potato in
      let* Œ±1 := M.call ((M.var "combinators_map::process") Œ±0) in
      M.alloc Œ±1 in
    let* _ :=
      let* Œ±0 := M.read cooked_apple in
      let* Œ±1 := M.call ((M.var "combinators_map::eat") Œ±0) in
      M.alloc Œ±1 in
    let* _ :=
      let* Œ±0 := M.read cooked_carrot in
      let* Œ±1 := M.call ((M.var "combinators_map::eat") Œ±0) in
      M.alloc Œ±1 in
    let* _ :=
      let* Œ±0 := M.read cooked_potato in
      let* Œ±1 := M.call ((M.var "combinators_map::eat") Œ±0) in
      M.alloc Œ±1 in
    let* Œ±0 := M.alloc tt in
    M.read Œ±0
  | _, _ => M.impossible
  end.
