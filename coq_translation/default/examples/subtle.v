(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module Choice.
  Unset Primitive Projections.
  Record t : Set := {
    _ : u8;
  }.
  Global Set Primitive Projections.
  
  Global Instance Get_0 : Notation.Dot 0 := {
    Notation.dot '(Build_t x0) := x0;
  }.
End Choice.
Definition Choice := @Choice.t.

Module Impl_core_marker_Copy_for_subtle_Choice.
  Definition Self := subtle.Choice.
  
  Global Instance I : core.marker.Copy.Trait Self := {
  }.
  Global Hint Resolve I : core.
End Impl_core_marker_Copy_for_subtle_Choice.

Module Impl_core_clone_Clone_for_subtle_Choice.
  Definition Self := subtle.Choice.
  
  Definition clone
      `{H' : State.Trait}
      (self : ref Self)
      : M (H := H') subtle.Choice :=
    let _ := tt in
    deref self subtle.Choice.
  
  Global Instance Method_clone `{H' : State.Trait} : Notation.Dot "clone" := {
    Notation.dot := clone;
  }.
  
  Global Instance I : core.clone.Clone.Trait Self := {
    core.clone.Clone.clone `{H' : State.Trait} := clone;
  }.
  Global Hint Resolve I : core.
End Impl_core_clone_Clone_for_subtle_Choice.

Module Impl_core_fmt_Debug_for_subtle_Choice.
  Definition Self := subtle.Choice.
  
  Definition fmt
      `{H' : State.Trait}
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter)
      : M (H := H') core.fmt.Result :=
    let* α0 := deref f core.fmt.Formatter in
    let* α1 := borrow_mut α0 core.fmt.Formatter in
    let* α2 := deref "Choice" str in
    let* α3 := borrow α2 str in
    let* α4 := deref self subtle.Choice in
    let* α5 := borrow α4.["0"] u8 in
    let* α6 := borrow α5 (ref u8) in
    let* α7 := deref α6 (ref u8) in
    let* α8 := borrow α7 (ref u8) in
    let* α9 := pointer_coercion "Unsize" α8 in
    core.fmt.Formatter::["debug_tuple_field1_finish"] α1 α3 α9.
  
  Global Instance Method_fmt `{H' : State.Trait} : Notation.Dot "fmt" := {
    Notation.dot := fmt;
  }.
  
  Global Instance I : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt `{H' : State.Trait} := fmt;
  }.
  Global Hint Resolve I : core.
End Impl_core_fmt_Debug_for_subtle_Choice.

Module Impl_subtle_Choice_4.
  Definition Self := subtle.Choice.
  
  Definition unwrap_u8 `{H' : State.Trait} (self : ref Self) : M (H := H') u8 :=
    let* α0 := deref self subtle.Choice in
    Pure α0.["0"].
  
  Global Instance Method_unwrap_u8 `{H' : State.Trait} :
    Notation.Dot "unwrap_u8" := {
    Notation.dot := unwrap_u8;
  }.
End Impl_subtle_Choice_4.

Module Impl_core_convert_From_for_bool.
  Definition Self := bool.
  
  Definition from
      `{H' : State.Trait}
      (source : subtle.Choice)
      : M (H := H') bool :=
    let* _ :=
      let* α0 := use true in
      if (α0 : bool) then
        let* _ :=
          let* α0 := eq source.["0"] 0 in
          let* α1 := eq source.["0"] 1 in
          let* α2 := bitor α0 α1 in
          let* α3 := not α2 in
          let* α4 := use α3 in
          if (α4 : bool) then
            let* α0 :=
              core.panicking.panic
                "assertion failed: (source.0 == 0u8) | (source.0 == 1u8)" in
            never_to_any α0
          else
            Pure tt in
        Pure tt
      else
        Pure tt in
    ne source.["0"] 0.
  
  Global Instance AssociatedFunction_from `{H' : State.Trait} :
    Notation.DoubleColon Self "from" := {
    Notation.double_colon := from;
  }.
  
  Global Instance I : core.convert.From.Trait Self (T := subtle.Choice) := {
    core.convert.From.from `{H' : State.Trait} := from;
  }.
  Global Hint Resolve I : core.
End Impl_core_convert_From_for_bool.

Module Impl_core_ops_bit_BitAnd_for_subtle_Choice.
  Definition Self := subtle.Choice.
  
  Definition Output : Set := subtle.Choice.
  
  Definition bitand
      `{H' : State.Trait}
      (self : Self)
      (rhs : subtle.Choice)
      : M (H := H') subtle.Choice :=
    let* α0 := bitand self.["0"] rhs.["0"] in
    core.convert.Into.into α0.
  
  Global Instance Method_bitand `{H' : State.Trait} : Notation.Dot "bitand" := {
    Notation.dot := bitand;
  }.
  
  Global Instance I
    : core.ops.bit.BitAnd.Trait Self
        (Rhs := core.ops.bit.BitAnd.Default.Rhs Self)
      := {
    core.ops.bit.BitAnd.Output := Output;
    core.ops.bit.BitAnd.bitand `{H' : State.Trait} := bitand;
  }.
  Global Hint Resolve I : core.
End Impl_core_ops_bit_BitAnd_for_subtle_Choice.

Module Impl_core_ops_bit_BitAndAssign_for_subtle_Choice.
  Definition Self := subtle.Choice.
  
  Definition bitand_assign
      `{H' : State.Trait}
      (self : mut_ref Self)
      (rhs : subtle.Choice)
      : M (H := H') unit :=
    let* _ :=
      let* α0 := deref self subtle.Choice in
      let* α1 := deref self subtle.Choice in
      let* α2 := core.ops.bit.BitAnd.bitand α1 rhs in
      assign α0 α2 in
    Pure tt.
  
  Global Instance Method_bitand_assign `{H' : State.Trait} :
    Notation.Dot "bitand_assign" := {
    Notation.dot := bitand_assign;
  }.
  
  Global Instance I
    : core.ops.bit.BitAndAssign.Trait Self
        (Rhs := core.ops.bit.BitAndAssign.Default.Rhs Self)
      := {
    core.ops.bit.BitAndAssign.bitand_assign `{H' : State.Trait}
      :=
      bitand_assign;
  }.
  Global Hint Resolve I : core.
End Impl_core_ops_bit_BitAndAssign_for_subtle_Choice.

Module Impl_core_ops_bit_BitOr_for_subtle_Choice.
  Definition Self := subtle.Choice.
  
  Definition Output : Set := subtle.Choice.
  
  Definition bitor
      `{H' : State.Trait}
      (self : Self)
      (rhs : subtle.Choice)
      : M (H := H') subtle.Choice :=
    let* α0 := bitor self.["0"] rhs.["0"] in
    core.convert.Into.into α0.
  
  Global Instance Method_bitor `{H' : State.Trait} : Notation.Dot "bitor" := {
    Notation.dot := bitor;
  }.
  
  Global Instance I
    : core.ops.bit.BitOr.Trait Self (Rhs := core.ops.bit.BitOr.Default.Rhs Self)
      := {
    core.ops.bit.BitOr.Output := Output;
    core.ops.bit.BitOr.bitor `{H' : State.Trait} := bitor;
  }.
  Global Hint Resolve I : core.
End Impl_core_ops_bit_BitOr_for_subtle_Choice.

Module Impl_core_ops_bit_BitOrAssign_for_subtle_Choice.
  Definition Self := subtle.Choice.
  
  Definition bitor_assign
      `{H' : State.Trait}
      (self : mut_ref Self)
      (rhs : subtle.Choice)
      : M (H := H') unit :=
    let* _ :=
      let* α0 := deref self subtle.Choice in
      let* α1 := deref self subtle.Choice in
      let* α2 := core.ops.bit.BitOr.bitor α1 rhs in
      assign α0 α2 in
    Pure tt.
  
  Global Instance Method_bitor_assign `{H' : State.Trait} :
    Notation.Dot "bitor_assign" := {
    Notation.dot := bitor_assign;
  }.
  
  Global Instance I
    : core.ops.bit.BitOrAssign.Trait Self
        (Rhs := core.ops.bit.BitOrAssign.Default.Rhs Self)
      := {
    core.ops.bit.BitOrAssign.bitor_assign `{H' : State.Trait} := bitor_assign;
  }.
  Global Hint Resolve I : core.
End Impl_core_ops_bit_BitOrAssign_for_subtle_Choice.

Module Impl_core_ops_bit_BitXor_for_subtle_Choice.
  Definition Self := subtle.Choice.
  
  Definition Output : Set := subtle.Choice.
  
  Definition bitxor
      `{H' : State.Trait}
      (self : Self)
      (rhs : subtle.Choice)
      : M (H := H') subtle.Choice :=
    let* α0 := bitxor self.["0"] rhs.["0"] in
    core.convert.Into.into α0.
  
  Global Instance Method_bitxor `{H' : State.Trait} : Notation.Dot "bitxor" := {
    Notation.dot := bitxor;
  }.
  
  Global Instance I
    : core.ops.bit.BitXor.Trait Self
        (Rhs := core.ops.bit.BitXor.Default.Rhs Self)
      := {
    core.ops.bit.BitXor.Output := Output;
    core.ops.bit.BitXor.bitxor `{H' : State.Trait} := bitxor;
  }.
  Global Hint Resolve I : core.
End Impl_core_ops_bit_BitXor_for_subtle_Choice.

Module Impl_core_ops_bit_BitXorAssign_for_subtle_Choice.
  Definition Self := subtle.Choice.
  
  Definition bitxor_assign
      `{H' : State.Trait}
      (self : mut_ref Self)
      (rhs : subtle.Choice)
      : M (H := H') unit :=
    let* _ :=
      let* α0 := deref self subtle.Choice in
      let* α1 := deref self subtle.Choice in
      let* α2 := core.ops.bit.BitXor.bitxor α1 rhs in
      assign α0 α2 in
    Pure tt.
  
  Global Instance Method_bitxor_assign `{H' : State.Trait} :
    Notation.Dot "bitxor_assign" := {
    Notation.dot := bitxor_assign;
  }.
  
  Global Instance I
    : core.ops.bit.BitXorAssign.Trait Self
        (Rhs := core.ops.bit.BitXorAssign.Default.Rhs Self)
      := {
    core.ops.bit.BitXorAssign.bitxor_assign `{H' : State.Trait}
      :=
      bitxor_assign;
  }.
  Global Hint Resolve I : core.
End Impl_core_ops_bit_BitXorAssign_for_subtle_Choice.

Module Impl_core_ops_bit_Not_for_subtle_Choice.
  Definition Self := subtle.Choice.
  
  Definition Output : Set := subtle.Choice.
  
  Definition not
      `{H' : State.Trait}
      (self : Self)
      : M (H := H') subtle.Choice :=
    let* α0 := not self.["0"] in
    let* α1 := bitand 1 α0 in
    core.convert.Into.into α1.
  
  Global Instance Method_not `{H' : State.Trait} : Notation.Dot "not" := {
    Notation.dot := not;
  }.
  
  Global Instance I : core.ops.bit.Not.Trait Self := {
    core.ops.bit.Not.Output := Output;
    core.ops.bit.Not.not `{H' : State.Trait} := not;
  }.
  Global Hint Resolve I : core.
End Impl_core_ops_bit_Not_for_subtle_Choice.

Definition black_box `{H' : State.Trait} (input : u8) : M (H := H') u8 :=
  let* _ :=
    let* α0 := use true in
    if (α0 : bool) then
      let* _ :=
        let* α0 := eq input 0 in
        let* α1 := eq input 1 in
        let* α2 := bitor α0 α1 in
        let* α3 := not α2 in
        let* α4 := use α3 in
        if (α4 : bool) then
          let* α0 :=
            core.panicking.panic
              "assertion failed: (input == 0u8) | (input == 1u8)" in
          never_to_any α0
        else
          Pure tt in
      Pure tt
    else
      Pure tt in
  let* α0 := borrow input u8 in
  let* α1 := deref α0 u8 in
  let* α2 := addr_of α1 in
  let* α3 := use α2 in
  core.ptr.read_volatile α3.

Module Impl_core_convert_From_for_subtle_Choice.
  Definition Self := subtle.Choice.
  
  Definition from
      `{H' : State.Trait}
      (input : u8)
      : M (H := H') subtle.Choice :=
    let* α0 := subtle.black_box input in
    Pure (subtle.Choice.Build_t α0).
  
  Global Instance AssociatedFunction_from `{H' : State.Trait} :
    Notation.DoubleColon Self "from" := {
    Notation.double_colon := from;
  }.
  
  Global Instance I : core.convert.From.Trait Self (T := u8) := {
    core.convert.From.from `{H' : State.Trait} := from;
  }.
  Global Hint Resolve I : core.
End Impl_core_convert_From_for_subtle_Choice.

Module ConstantTimeEq.
  Class Trait (Self : Set) : Type := {
    ct_eq `{H' : State.Trait}
      :
      (ref Self) -> (ref Self) -> M (H := H') subtle.Choice;
  }.
  
  Global Instance Method_ct_eq `{H' : State.Trait} `(Trait)
    : Notation.Dot "ct_eq" := {
    Notation.dot := ct_eq;
  }.
  Global Instance Method_ct_ne `{H' : State.Trait} `(Trait)
    : Notation.Dot "ct_ne" := {
    Notation.dot (self : ref Self) (other : ref Self)
      :=
      (let* α0 := deref self _ in
      let* α1 := borrow α0 _ in
      let* α2 := deref other _ in
      let* α3 := borrow α2 _ in
      let* α4 := subtle.ConstantTimeEq.ct_eq α1 α3 in
      core.ops.bit.Not.not α4
      : M (H := H') subtle.Choice);
  }.
End ConstantTimeEq.

Module Impl_subtle_ConstantTimeEq_for_Slice_T.
  Section Impl_subtle_ConstantTimeEq_for_Slice_T.
    Context {T : Set}.
    Context `{subtle.ConstantTimeEq.Trait T}.
    Definition Self := Slice T.
    
    Definition ct_eq
        `{H' : State.Trait}
        (self : ref Self)
        (_rhs : ref (Slice T))
        : M (H := H') subtle.Choice :=
      let* len :=
        let* α0 := deref self (Slice _) in
        let* α1 := borrow α0 (Slice _) in
        (Slice _)::["len"] α1 in
      let* _ :=
        let* α0 := deref _rhs (Slice _) in
        let* α1 := borrow α0 (Slice _) in
        let* α2 := (Slice _)::["len"] α1 in
        let* α3 := ne len α2 in
        let* α4 := use α3 in
        if (α4 : bool) then
          let* _ :=
            let* α0 := core.convert.From.from 0 in
            Return α0 in
          never_to_any tt
        else
          Pure tt in
      let x := 1 in
      let* _ :=
        let* α0 := deref self (Slice _) in
        let* α1 := borrow α0 (Slice _) in
        let* α2 := (Slice _)::["iter"] α1 in
        let* α3 := deref _rhs (Slice _) in
        let* α4 := borrow α3 (Slice _) in
        let* α5 := (Slice _)::["iter"] α4 in
        let* α6 := core.iter.traits.iterator.Iterator.zip α2 α5 in
        let* α7 := core.iter.traits.collect.IntoIterator.into_iter α6 in
        let* α8 :=
          match α7 with
          | iter =>
            loop
              (let* _ :=
                let* α0 :=
                  borrow_mut
                    iter
                    (core.iter.adapters.zip.Zip
                      (core.slice.iter.Iter _)
                      (core.slice.iter.Iter _)) in
                let* α1 :=
                  deref
                    α0
                    (core.iter.adapters.zip.Zip
                      (core.slice.iter.Iter _)
                      (core.slice.iter.Iter _)) in
                let* α2 :=
                  borrow_mut
                    α1
                    (core.iter.adapters.zip.Zip
                      (core.slice.iter.Iter _)
                      (core.slice.iter.Iter _)) in
                let* α3 := core.iter.traits.iterator.Iterator.next α2 in
                match α3 with
                | core.option.Option  =>
                  let* α0 := Break in
                  never_to_any α0
                | core.option.Option (ai, bi) =>
                  let* _ :=
                    let* α0 := deref ai _ in
                    let* α1 := borrow α0 _ in
                    let* α2 := deref bi _ in
                    let* α3 := borrow α2 _ in
                    let* α4 := subtle.ConstantTimeEq.ct_eq α1 α3 in
                    let* α5 := borrow α4 subtle.Choice in
                    let* α6 := subtle.Choice::["unwrap_u8"] α5 in
                    assign_op bitand x α6 in
                  Pure tt
                end in
              Pure tt)
          end in
        use α8 in
      core.convert.Into.into x.
    
    Global Instance Method_ct_eq `{H' : State.Trait} : Notation.Dot "ct_eq" := {
      Notation.dot := ct_eq;
    }.
    
    Global Instance I : subtle.ConstantTimeEq.Trait Self := {
      subtle.ConstantTimeEq.ct_eq `{H' : State.Trait} := ct_eq;
    }.
  End Impl_subtle_ConstantTimeEq_for_Slice_T.
  Global Hint Resolve I : core.
End Impl_subtle_ConstantTimeEq_for_Slice_T.

Module Impl_subtle_ConstantTimeEq_for_subtle_Choice.
  Definition Self := subtle.Choice.
  
  Definition ct_eq
      `{H' : State.Trait}
      (self : ref Self)
      (rhs : ref subtle.Choice)
      : M (H := H') subtle.Choice :=
    let* α0 := deref self subtle.Choice in
    let* α1 := deref rhs subtle.Choice in
    let* α2 := core.ops.bit.BitXor.bitxor α0 α1 in
    core.ops.bit.Not.not α2.
  
  Global Instance Method_ct_eq `{H' : State.Trait} : Notation.Dot "ct_eq" := {
    Notation.dot := ct_eq;
  }.
  
  Global Instance I : subtle.ConstantTimeEq.Trait Self := {
    subtle.ConstantTimeEq.ct_eq `{H' : State.Trait} := ct_eq;
  }.
  Global Hint Resolve I : core.
End Impl_subtle_ConstantTimeEq_for_subtle_Choice.

Module Impl_subtle_ConstantTimeEq_for_u8.
  Definition Self := u8.
  
  Definition ct_eq
      `{H' : State.Trait}
      (self : ref Self)
      (other : ref u8)
      : M (H := H') subtle.Choice :=
    let* x := core.ops.bit.BitXor.bitxor self other in
    let* y :=
      let* α0 := u8::["wrapping_neg"] x in
      let* α1 := bitor x α0 in
      let* α2 := sub 8 1 in
      shr α1 α2 in
    let* α0 := use 1 in
    let* α1 := bitxor y α0 in
    let* α2 := use α1 in
    core.convert.Into.into α2.
  
  Global Instance Method_ct_eq `{H' : State.Trait} : Notation.Dot "ct_eq" := {
    Notation.dot := ct_eq;
  }.
  
  Global Instance I : subtle.ConstantTimeEq.Trait Self := {
    subtle.ConstantTimeEq.ct_eq `{H' : State.Trait} := ct_eq;
  }.
  Global Hint Resolve I : core.
End Impl_subtle_ConstantTimeEq_for_u8.

Module Impl_subtle_ConstantTimeEq_for_i8.
  Definition Self := i8.
  
  Definition ct_eq
      `{H' : State.Trait}
      (self : ref Self)
      (other : ref i8)
      : M (H := H') subtle.Choice :=
    let* α0 := deref self i8 in
    let* α1 := cast α0 in
    let* α2 := borrow α1 u8 in
    let* α3 := deref other i8 in
    let* α4 := cast α3 in
    let* α5 := borrow α4 u8 in
    let* α6 := deref α5 u8 in
    let* α7 := borrow α6 u8 in
    subtle.ConstantTimeEq.ct_eq α2 α7.
  
  Global Instance Method_ct_eq `{H' : State.Trait} : Notation.Dot "ct_eq" := {
    Notation.dot := ct_eq;
  }.
  
  Global Instance I : subtle.ConstantTimeEq.Trait Self := {
    subtle.ConstantTimeEq.ct_eq `{H' : State.Trait} := ct_eq;
  }.
  Global Hint Resolve I : core.
End Impl_subtle_ConstantTimeEq_for_i8.

Module Impl_subtle_ConstantTimeEq_for_u16.
  Definition Self := u16.
  
  Definition ct_eq
      `{H' : State.Trait}
      (self : ref Self)
      (other : ref u16)
      : M (H := H') subtle.Choice :=
    let* x := core.ops.bit.BitXor.bitxor self other in
    let* y :=
      let* α0 := u16::["wrapping_neg"] x in
      let* α1 := bitor x α0 in
      let* α2 := sub 16 1 in
      shr α1 α2 in
    let* α0 := use 1 in
    let* α1 := bitxor y α0 in
    let* α2 := cast α1 in
    core.convert.Into.into α2.
  
  Global Instance Method_ct_eq `{H' : State.Trait} : Notation.Dot "ct_eq" := {
    Notation.dot := ct_eq;
  }.
  
  Global Instance I : subtle.ConstantTimeEq.Trait Self := {
    subtle.ConstantTimeEq.ct_eq `{H' : State.Trait} := ct_eq;
  }.
  Global Hint Resolve I : core.
End Impl_subtle_ConstantTimeEq_for_u16.

Module Impl_subtle_ConstantTimeEq_for_i16.
  Definition Self := i16.
  
  Definition ct_eq
      `{H' : State.Trait}
      (self : ref Self)
      (other : ref i16)
      : M (H := H') subtle.Choice :=
    let* α0 := deref self i16 in
    let* α1 := cast α0 in
    let* α2 := borrow α1 u16 in
    let* α3 := deref other i16 in
    let* α4 := cast α3 in
    let* α5 := borrow α4 u16 in
    let* α6 := deref α5 u16 in
    let* α7 := borrow α6 u16 in
    subtle.ConstantTimeEq.ct_eq α2 α7.
  
  Global Instance Method_ct_eq `{H' : State.Trait} : Notation.Dot "ct_eq" := {
    Notation.dot := ct_eq;
  }.
  
  Global Instance I : subtle.ConstantTimeEq.Trait Self := {
    subtle.ConstantTimeEq.ct_eq `{H' : State.Trait} := ct_eq;
  }.
  Global Hint Resolve I : core.
End Impl_subtle_ConstantTimeEq_for_i16.

Module Impl_subtle_ConstantTimeEq_for_u32.
  Definition Self := u32.
  
  Definition ct_eq
      `{H' : State.Trait}
      (self : ref Self)
      (other : ref u32)
      : M (H := H') subtle.Choice :=
    let* x := core.ops.bit.BitXor.bitxor self other in
    let* y :=
      let* α0 := u32::["wrapping_neg"] x in
      let* α1 := bitor x α0 in
      let* α2 := sub 32 1 in
      shr α1 α2 in
    let* α0 := use 1 in
    let* α1 := bitxor y α0 in
    let* α2 := cast α1 in
    core.convert.Into.into α2.
  
  Global Instance Method_ct_eq `{H' : State.Trait} : Notation.Dot "ct_eq" := {
    Notation.dot := ct_eq;
  }.
  
  Global Instance I : subtle.ConstantTimeEq.Trait Self := {
    subtle.ConstantTimeEq.ct_eq `{H' : State.Trait} := ct_eq;
  }.
  Global Hint Resolve I : core.
End Impl_subtle_ConstantTimeEq_for_u32.

Module Impl_subtle_ConstantTimeEq_for_i32.
  Definition Self := i32.
  
  Definition ct_eq
      `{H' : State.Trait}
      (self : ref Self)
      (other : ref i32)
      : M (H := H') subtle.Choice :=
    let* α0 := deref self i32 in
    let* α1 := cast α0 in
    let* α2 := borrow α1 u32 in
    let* α3 := deref other i32 in
    let* α4 := cast α3 in
    let* α5 := borrow α4 u32 in
    let* α6 := deref α5 u32 in
    let* α7 := borrow α6 u32 in
    subtle.ConstantTimeEq.ct_eq α2 α7.
  
  Global Instance Method_ct_eq `{H' : State.Trait} : Notation.Dot "ct_eq" := {
    Notation.dot := ct_eq;
  }.
  
  Global Instance I : subtle.ConstantTimeEq.Trait Self := {
    subtle.ConstantTimeEq.ct_eq `{H' : State.Trait} := ct_eq;
  }.
  Global Hint Resolve I : core.
End Impl_subtle_ConstantTimeEq_for_i32.

Module Impl_subtle_ConstantTimeEq_for_u64.
  Definition Self := u64.
  
  Definition ct_eq
      `{H' : State.Trait}
      (self : ref Self)
      (other : ref u64)
      : M (H := H') subtle.Choice :=
    let* x := core.ops.bit.BitXor.bitxor self other in
    let* y :=
      let* α0 := u64::["wrapping_neg"] x in
      let* α1 := bitor x α0 in
      let* α2 := sub 64 1 in
      shr α1 α2 in
    let* α0 := use 1 in
    let* α1 := bitxor y α0 in
    let* α2 := cast α1 in
    core.convert.Into.into α2.
  
  Global Instance Method_ct_eq `{H' : State.Trait} : Notation.Dot "ct_eq" := {
    Notation.dot := ct_eq;
  }.
  
  Global Instance I : subtle.ConstantTimeEq.Trait Self := {
    subtle.ConstantTimeEq.ct_eq `{H' : State.Trait} := ct_eq;
  }.
  Global Hint Resolve I : core.
End Impl_subtle_ConstantTimeEq_for_u64.

Module Impl_subtle_ConstantTimeEq_for_i64.
  Definition Self := i64.
  
  Definition ct_eq
      `{H' : State.Trait}
      (self : ref Self)
      (other : ref i64)
      : M (H := H') subtle.Choice :=
    let* α0 := deref self i64 in
    let* α1 := cast α0 in
    let* α2 := borrow α1 u64 in
    let* α3 := deref other i64 in
    let* α4 := cast α3 in
    let* α5 := borrow α4 u64 in
    let* α6 := deref α5 u64 in
    let* α7 := borrow α6 u64 in
    subtle.ConstantTimeEq.ct_eq α2 α7.
  
  Global Instance Method_ct_eq `{H' : State.Trait} : Notation.Dot "ct_eq" := {
    Notation.dot := ct_eq;
  }.
  
  Global Instance I : subtle.ConstantTimeEq.Trait Self := {
    subtle.ConstantTimeEq.ct_eq `{H' : State.Trait} := ct_eq;
  }.
  Global Hint Resolve I : core.
End Impl_subtle_ConstantTimeEq_for_i64.

Module Impl_subtle_ConstantTimeEq_for_usize.
  Definition Self := usize.
  
  Definition ct_eq
      `{H' : State.Trait}
      (self : ref Self)
      (other : ref usize)
      : M (H := H') subtle.Choice :=
    let* x := core.ops.bit.BitXor.bitxor self other in
    let* y :=
      let* α0 := usize::["wrapping_neg"] x in
      let* α1 := bitor x α0 in
      let* α2 := core.mem.size_of in
      let* α3 := mul α2 8 in
      let* α4 := sub α3 1 in
      shr α1 α4 in
    let* α0 := use 1 in
    let* α1 := bitxor y α0 in
    let* α2 := cast α1 in
    core.convert.Into.into α2.
  
  Global Instance Method_ct_eq `{H' : State.Trait} : Notation.Dot "ct_eq" := {
    Notation.dot := ct_eq;
  }.
  
  Global Instance I : subtle.ConstantTimeEq.Trait Self := {
    subtle.ConstantTimeEq.ct_eq `{H' : State.Trait} := ct_eq;
  }.
  Global Hint Resolve I : core.
End Impl_subtle_ConstantTimeEq_for_usize.

Module Impl_subtle_ConstantTimeEq_for_isize.
  Definition Self := isize.
  
  Definition ct_eq
      `{H' : State.Trait}
      (self : ref Self)
      (other : ref isize)
      : M (H := H') subtle.Choice :=
    let* α0 := deref self isize in
    let* α1 := cast α0 in
    let* α2 := borrow α1 usize in
    let* α3 := deref other isize in
    let* α4 := cast α3 in
    let* α5 := borrow α4 usize in
    let* α6 := deref α5 usize in
    let* α7 := borrow α6 usize in
    subtle.ConstantTimeEq.ct_eq α2 α7.
  
  Global Instance Method_ct_eq `{H' : State.Trait} : Notation.Dot "ct_eq" := {
    Notation.dot := ct_eq;
  }.
  
  Global Instance I : subtle.ConstantTimeEq.Trait Self := {
    subtle.ConstantTimeEq.ct_eq `{H' : State.Trait} := ct_eq;
  }.
  Global Hint Resolve I : core.
End Impl_subtle_ConstantTimeEq_for_isize.

Module ConditionallySelectable.
  Class Trait (Self : Set) `{core.marker.Copy.Trait Self} : Type := {
    conditional_select `{H' : State.Trait}
      :
      (ref Self) -> (ref Self) -> subtle.Choice -> M (H := H') Self;
  }.
  
  Global Instance Method_conditional_select `{H' : State.Trait} `(Trait)
    : Notation.Dot "conditional_select" := {
    Notation.dot := conditional_select;
  }.
  Global Instance Method_conditional_assign `{H' : State.Trait} `(Trait)
    : Notation.Dot "conditional_assign" := {
    Notation.dot
      (self : mut_ref Self)
      (other : ref Self)
      (choice : subtle.Choice)
      :=
      (let* _ :=
        let* α0 := deref self _ in
        let* α1 := deref self _ in
        let* α2 := borrow α1 _ in
        let* α3 := deref other _ in
        let* α4 := borrow α3 _ in
        let* α5 :=
          subtle.ConditionallySelectable.conditional_select α2 α4 choice in
        assign α0 α5 in
      Pure tt
      : M (H := H') unit);
  }.
  Global Instance Method_conditional_swap `{H' : State.Trait} `(Trait)
    : Notation.Dot "conditional_swap" := {
    Notation.dot (a : mut_ref Self) (b : mut_ref Self) (choice : subtle.Choice)
      :=
      (let* t := deref a _ in
      let* _ :=
        let* α0 := deref a _ in
        let* α1 := borrow_mut α0 _ in
        let* α2 := borrow b (mut_ref _) in
        let* α3 := deref α2 (mut_ref _) in
        let* α4 := deref α3 _ in
        let* α5 := borrow α4 _ in
        subtle.ConditionallySelectable.conditional_assign α1 α5 choice in
      let* _ :=
        let* α0 := deref b _ in
        let* α1 := borrow_mut α0 _ in
        let* α2 := borrow t _ in
        let* α3 := deref α2 _ in
        let* α4 := borrow α3 _ in
        subtle.ConditionallySelectable.conditional_assign α1 α4 choice in
      Pure tt
      : M (H := H') unit);
  }.
End ConditionallySelectable.

Module Impl_subtle_ConditionallySelectable_for_u8.
  Definition Self := u8.
  
  Definition conditional_select
      `{H' : State.Trait}
      (a : ref Self)
      (b : ref Self)
      (choice : subtle.Choice)
      : M (H := H') Self :=
    let* mask :=
      let* α0 := borrow choice subtle.Choice in
      let* α1 := subtle.Choice::["unwrap_u8"] α0 in
      let* α2 := cast α1 in
      let* α3 := neg α2 in
      cast α3 in
    let* α0 := core.ops.bit.BitXor.bitxor a b in
    let* α1 := bitand mask α0 in
    core.ops.bit.BitXor.bitxor a α1.
  
  Global Instance AssociatedFunction_conditional_select `{H' : State.Trait} :
    Notation.DoubleColon Self "conditional_select" := {
    Notation.double_colon := conditional_select;
  }.
  
  Definition conditional_assign
      `{H' : State.Trait}
      (self : mut_ref Self)
      (other : ref Self)
      (choice : subtle.Choice)
      : M (H := H') unit :=
    let* mask :=
      let* α0 := borrow choice subtle.Choice in
      let* α1 := subtle.Choice::["unwrap_u8"] α0 in
      let* α2 := cast α1 in
      let* α3 := neg α2 in
      cast α3 in
    let* _ :=
      let* α0 := deref self u8 in
      let* α1 := deref self u8 in
      let* α2 := deref other u8 in
      let* α3 := bitxor α1 α2 in
      let* α4 := bitand mask α3 in
      assign_op bitxor α0 α4 in
    Pure tt.
  
  Global Instance Method_conditional_assign `{H' : State.Trait} :
    Notation.Dot "conditional_assign" := {
    Notation.dot := conditional_assign;
  }.
  
  Definition conditional_swap
      `{H' : State.Trait}
      (a : mut_ref Self)
      (b : mut_ref Self)
      (choice : subtle.Choice)
      : M (H := H') unit :=
    let* mask :=
      let* α0 := borrow choice subtle.Choice in
      let* α1 := subtle.Choice::["unwrap_u8"] α0 in
      let* α2 := cast α1 in
      let* α3 := neg α2 in
      cast α3 in
    let* t :=
      let* α0 := deref a u8 in
      let* α1 := deref b u8 in
      let* α2 := bitxor α0 α1 in
      bitand mask α2 in
    let* _ :=
      let* α0 := deref a u8 in
      assign_op bitxor α0 t in
    let* _ :=
      let* α0 := deref b u8 in
      assign_op bitxor α0 t in
    Pure tt.
  
  Global Instance AssociatedFunction_conditional_swap `{H' : State.Trait} :
    Notation.DoubleColon Self "conditional_swap" := {
    Notation.double_colon := conditional_swap;
  }.
  
  Global Instance I : subtle.ConditionallySelectable.Trait Self := {
    subtle.ConditionallySelectable.conditional_select `{H' : State.Trait}
      :=
      conditional_select;
  }.
  Global Hint Resolve I : core.
End Impl_subtle_ConditionallySelectable_for_u8.

Module Impl_subtle_ConditionallySelectable_for_i8.
  Definition Self := i8.
  
  Definition conditional_select
      `{H' : State.Trait}
      (a : ref Self)
      (b : ref Self)
      (choice : subtle.Choice)
      : M (H := H') Self :=
    let* mask :=
      let* α0 := borrow choice subtle.Choice in
      let* α1 := subtle.Choice::["unwrap_u8"] α0 in
      let* α2 := cast α1 in
      let* α3 := neg α2 in
      use α3 in
    let* α0 := core.ops.bit.BitXor.bitxor a b in
    let* α1 := bitand mask α0 in
    core.ops.bit.BitXor.bitxor a α1.
  
  Global Instance AssociatedFunction_conditional_select `{H' : State.Trait} :
    Notation.DoubleColon Self "conditional_select" := {
    Notation.double_colon := conditional_select;
  }.
  
  Definition conditional_assign
      `{H' : State.Trait}
      (self : mut_ref Self)
      (other : ref Self)
      (choice : subtle.Choice)
      : M (H := H') unit :=
    let* mask :=
      let* α0 := borrow choice subtle.Choice in
      let* α1 := subtle.Choice::["unwrap_u8"] α0 in
      let* α2 := cast α1 in
      let* α3 := neg α2 in
      use α3 in
    let* _ :=
      let* α0 := deref self i8 in
      let* α1 := deref self i8 in
      let* α2 := deref other i8 in
      let* α3 := bitxor α1 α2 in
      let* α4 := bitand mask α3 in
      assign_op bitxor α0 α4 in
    Pure tt.
  
  Global Instance Method_conditional_assign `{H' : State.Trait} :
    Notation.Dot "conditional_assign" := {
    Notation.dot := conditional_assign;
  }.
  
  Definition conditional_swap
      `{H' : State.Trait}
      (a : mut_ref Self)
      (b : mut_ref Self)
      (choice : subtle.Choice)
      : M (H := H') unit :=
    let* mask :=
      let* α0 := borrow choice subtle.Choice in
      let* α1 := subtle.Choice::["unwrap_u8"] α0 in
      let* α2 := cast α1 in
      let* α3 := neg α2 in
      use α3 in
    let* t :=
      let* α0 := deref a i8 in
      let* α1 := deref b i8 in
      let* α2 := bitxor α0 α1 in
      bitand mask α2 in
    let* _ :=
      let* α0 := deref a i8 in
      assign_op bitxor α0 t in
    let* _ :=
      let* α0 := deref b i8 in
      assign_op bitxor α0 t in
    Pure tt.
  
  Global Instance AssociatedFunction_conditional_swap `{H' : State.Trait} :
    Notation.DoubleColon Self "conditional_swap" := {
    Notation.double_colon := conditional_swap;
  }.
  
  Global Instance I : subtle.ConditionallySelectable.Trait Self := {
    subtle.ConditionallySelectable.conditional_select `{H' : State.Trait}
      :=
      conditional_select;
  }.
  Global Hint Resolve I : core.
End Impl_subtle_ConditionallySelectable_for_i8.

Module Impl_subtle_ConditionallySelectable_for_u16.
  Definition Self := u16.
  
  Definition conditional_select
      `{H' : State.Trait}
      (a : ref Self)
      (b : ref Self)
      (choice : subtle.Choice)
      : M (H := H') Self :=
    let* mask :=
      let* α0 := borrow choice subtle.Choice in
      let* α1 := subtle.Choice::["unwrap_u8"] α0 in
      let* α2 := cast α1 in
      let* α3 := neg α2 in
      cast α3 in
    let* α0 := core.ops.bit.BitXor.bitxor a b in
    let* α1 := bitand mask α0 in
    core.ops.bit.BitXor.bitxor a α1.
  
  Global Instance AssociatedFunction_conditional_select `{H' : State.Trait} :
    Notation.DoubleColon Self "conditional_select" := {
    Notation.double_colon := conditional_select;
  }.
  
  Definition conditional_assign
      `{H' : State.Trait}
      (self : mut_ref Self)
      (other : ref Self)
      (choice : subtle.Choice)
      : M (H := H') unit :=
    let* mask :=
      let* α0 := borrow choice subtle.Choice in
      let* α1 := subtle.Choice::["unwrap_u8"] α0 in
      let* α2 := cast α1 in
      let* α3 := neg α2 in
      cast α3 in
    let* _ :=
      let* α0 := deref self u16 in
      let* α1 := deref self u16 in
      let* α2 := deref other u16 in
      let* α3 := bitxor α1 α2 in
      let* α4 := bitand mask α3 in
      assign_op bitxor α0 α4 in
    Pure tt.
  
  Global Instance Method_conditional_assign `{H' : State.Trait} :
    Notation.Dot "conditional_assign" := {
    Notation.dot := conditional_assign;
  }.
  
  Definition conditional_swap
      `{H' : State.Trait}
      (a : mut_ref Self)
      (b : mut_ref Self)
      (choice : subtle.Choice)
      : M (H := H') unit :=
    let* mask :=
      let* α0 := borrow choice subtle.Choice in
      let* α1 := subtle.Choice::["unwrap_u8"] α0 in
      let* α2 := cast α1 in
      let* α3 := neg α2 in
      cast α3 in
    let* t :=
      let* α0 := deref a u16 in
      let* α1 := deref b u16 in
      let* α2 := bitxor α0 α1 in
      bitand mask α2 in
    let* _ :=
      let* α0 := deref a u16 in
      assign_op bitxor α0 t in
    let* _ :=
      let* α0 := deref b u16 in
      assign_op bitxor α0 t in
    Pure tt.
  
  Global Instance AssociatedFunction_conditional_swap `{H' : State.Trait} :
    Notation.DoubleColon Self "conditional_swap" := {
    Notation.double_colon := conditional_swap;
  }.
  
  Global Instance I : subtle.ConditionallySelectable.Trait Self := {
    subtle.ConditionallySelectable.conditional_select `{H' : State.Trait}
      :=
      conditional_select;
  }.
  Global Hint Resolve I : core.
End Impl_subtle_ConditionallySelectable_for_u16.

Module Impl_subtle_ConditionallySelectable_for_i16.
  Definition Self := i16.
  
  Definition conditional_select
      `{H' : State.Trait}
      (a : ref Self)
      (b : ref Self)
      (choice : subtle.Choice)
      : M (H := H') Self :=
    let* mask :=
      let* α0 := borrow choice subtle.Choice in
      let* α1 := subtle.Choice::["unwrap_u8"] α0 in
      let* α2 := cast α1 in
      let* α3 := neg α2 in
      use α3 in
    let* α0 := core.ops.bit.BitXor.bitxor a b in
    let* α1 := bitand mask α0 in
    core.ops.bit.BitXor.bitxor a α1.
  
  Global Instance AssociatedFunction_conditional_select `{H' : State.Trait} :
    Notation.DoubleColon Self "conditional_select" := {
    Notation.double_colon := conditional_select;
  }.
  
  Definition conditional_assign
      `{H' : State.Trait}
      (self : mut_ref Self)
      (other : ref Self)
      (choice : subtle.Choice)
      : M (H := H') unit :=
    let* mask :=
      let* α0 := borrow choice subtle.Choice in
      let* α1 := subtle.Choice::["unwrap_u8"] α0 in
      let* α2 := cast α1 in
      let* α3 := neg α2 in
      use α3 in
    let* _ :=
      let* α0 := deref self i16 in
      let* α1 := deref self i16 in
      let* α2 := deref other i16 in
      let* α3 := bitxor α1 α2 in
      let* α4 := bitand mask α3 in
      assign_op bitxor α0 α4 in
    Pure tt.
  
  Global Instance Method_conditional_assign `{H' : State.Trait} :
    Notation.Dot "conditional_assign" := {
    Notation.dot := conditional_assign;
  }.
  
  Definition conditional_swap
      `{H' : State.Trait}
      (a : mut_ref Self)
      (b : mut_ref Self)
      (choice : subtle.Choice)
      : M (H := H') unit :=
    let* mask :=
      let* α0 := borrow choice subtle.Choice in
      let* α1 := subtle.Choice::["unwrap_u8"] α0 in
      let* α2 := cast α1 in
      let* α3 := neg α2 in
      use α3 in
    let* t :=
      let* α0 := deref a i16 in
      let* α1 := deref b i16 in
      let* α2 := bitxor α0 α1 in
      bitand mask α2 in
    let* _ :=
      let* α0 := deref a i16 in
      assign_op bitxor α0 t in
    let* _ :=
      let* α0 := deref b i16 in
      assign_op bitxor α0 t in
    Pure tt.
  
  Global Instance AssociatedFunction_conditional_swap `{H' : State.Trait} :
    Notation.DoubleColon Self "conditional_swap" := {
    Notation.double_colon := conditional_swap;
  }.
  
  Global Instance I : subtle.ConditionallySelectable.Trait Self := {
    subtle.ConditionallySelectable.conditional_select `{H' : State.Trait}
      :=
      conditional_select;
  }.
  Global Hint Resolve I : core.
End Impl_subtle_ConditionallySelectable_for_i16.

Module Impl_subtle_ConditionallySelectable_for_u32.
  Definition Self := u32.
  
  Definition conditional_select
      `{H' : State.Trait}
      (a : ref Self)
      (b : ref Self)
      (choice : subtle.Choice)
      : M (H := H') Self :=
    let* mask :=
      let* α0 := borrow choice subtle.Choice in
      let* α1 := subtle.Choice::["unwrap_u8"] α0 in
      let* α2 := cast α1 in
      let* α3 := neg α2 in
      cast α3 in
    let* α0 := core.ops.bit.BitXor.bitxor a b in
    let* α1 := bitand mask α0 in
    core.ops.bit.BitXor.bitxor a α1.
  
  Global Instance AssociatedFunction_conditional_select `{H' : State.Trait} :
    Notation.DoubleColon Self "conditional_select" := {
    Notation.double_colon := conditional_select;
  }.
  
  Definition conditional_assign
      `{H' : State.Trait}
      (self : mut_ref Self)
      (other : ref Self)
      (choice : subtle.Choice)
      : M (H := H') unit :=
    let* mask :=
      let* α0 := borrow choice subtle.Choice in
      let* α1 := subtle.Choice::["unwrap_u8"] α0 in
      let* α2 := cast α1 in
      let* α3 := neg α2 in
      cast α3 in
    let* _ :=
      let* α0 := deref self u32 in
      let* α1 := deref self u32 in
      let* α2 := deref other u32 in
      let* α3 := bitxor α1 α2 in
      let* α4 := bitand mask α3 in
      assign_op bitxor α0 α4 in
    Pure tt.
  
  Global Instance Method_conditional_assign `{H' : State.Trait} :
    Notation.Dot "conditional_assign" := {
    Notation.dot := conditional_assign;
  }.
  
  Definition conditional_swap
      `{H' : State.Trait}
      (a : mut_ref Self)
      (b : mut_ref Self)
      (choice : subtle.Choice)
      : M (H := H') unit :=
    let* mask :=
      let* α0 := borrow choice subtle.Choice in
      let* α1 := subtle.Choice::["unwrap_u8"] α0 in
      let* α2 := cast α1 in
      let* α3 := neg α2 in
      cast α3 in
    let* t :=
      let* α0 := deref a u32 in
      let* α1 := deref b u32 in
      let* α2 := bitxor α0 α1 in
      bitand mask α2 in
    let* _ :=
      let* α0 := deref a u32 in
      assign_op bitxor α0 t in
    let* _ :=
      let* α0 := deref b u32 in
      assign_op bitxor α0 t in
    Pure tt.
  
  Global Instance AssociatedFunction_conditional_swap `{H' : State.Trait} :
    Notation.DoubleColon Self "conditional_swap" := {
    Notation.double_colon := conditional_swap;
  }.
  
  Global Instance I : subtle.ConditionallySelectable.Trait Self := {
    subtle.ConditionallySelectable.conditional_select `{H' : State.Trait}
      :=
      conditional_select;
  }.
  Global Hint Resolve I : core.
End Impl_subtle_ConditionallySelectable_for_u32.

Module Impl_subtle_ConditionallySelectable_for_i32.
  Definition Self := i32.
  
  Definition conditional_select
      `{H' : State.Trait}
      (a : ref Self)
      (b : ref Self)
      (choice : subtle.Choice)
      : M (H := H') Self :=
    let* mask :=
      let* α0 := borrow choice subtle.Choice in
      let* α1 := subtle.Choice::["unwrap_u8"] α0 in
      let* α2 := cast α1 in
      let* α3 := neg α2 in
      use α3 in
    let* α0 := core.ops.bit.BitXor.bitxor a b in
    let* α1 := bitand mask α0 in
    core.ops.bit.BitXor.bitxor a α1.
  
  Global Instance AssociatedFunction_conditional_select `{H' : State.Trait} :
    Notation.DoubleColon Self "conditional_select" := {
    Notation.double_colon := conditional_select;
  }.
  
  Definition conditional_assign
      `{H' : State.Trait}
      (self : mut_ref Self)
      (other : ref Self)
      (choice : subtle.Choice)
      : M (H := H') unit :=
    let* mask :=
      let* α0 := borrow choice subtle.Choice in
      let* α1 := subtle.Choice::["unwrap_u8"] α0 in
      let* α2 := cast α1 in
      let* α3 := neg α2 in
      use α3 in
    let* _ :=
      let* α0 := deref self i32 in
      let* α1 := deref self i32 in
      let* α2 := deref other i32 in
      let* α3 := bitxor α1 α2 in
      let* α4 := bitand mask α3 in
      assign_op bitxor α0 α4 in
    Pure tt.
  
  Global Instance Method_conditional_assign `{H' : State.Trait} :
    Notation.Dot "conditional_assign" := {
    Notation.dot := conditional_assign;
  }.
  
  Definition conditional_swap
      `{H' : State.Trait}
      (a : mut_ref Self)
      (b : mut_ref Self)
      (choice : subtle.Choice)
      : M (H := H') unit :=
    let* mask :=
      let* α0 := borrow choice subtle.Choice in
      let* α1 := subtle.Choice::["unwrap_u8"] α0 in
      let* α2 := cast α1 in
      let* α3 := neg α2 in
      use α3 in
    let* t :=
      let* α0 := deref a i32 in
      let* α1 := deref b i32 in
      let* α2 := bitxor α0 α1 in
      bitand mask α2 in
    let* _ :=
      let* α0 := deref a i32 in
      assign_op bitxor α0 t in
    let* _ :=
      let* α0 := deref b i32 in
      assign_op bitxor α0 t in
    Pure tt.
  
  Global Instance AssociatedFunction_conditional_swap `{H' : State.Trait} :
    Notation.DoubleColon Self "conditional_swap" := {
    Notation.double_colon := conditional_swap;
  }.
  
  Global Instance I : subtle.ConditionallySelectable.Trait Self := {
    subtle.ConditionallySelectable.conditional_select `{H' : State.Trait}
      :=
      conditional_select;
  }.
  Global Hint Resolve I : core.
End Impl_subtle_ConditionallySelectable_for_i32.

Module Impl_subtle_ConditionallySelectable_for_u64.
  Definition Self := u64.
  
  Definition conditional_select
      `{H' : State.Trait}
      (a : ref Self)
      (b : ref Self)
      (choice : subtle.Choice)
      : M (H := H') Self :=
    let* mask :=
      let* α0 := borrow choice subtle.Choice in
      let* α1 := subtle.Choice::["unwrap_u8"] α0 in
      let* α2 := cast α1 in
      let* α3 := neg α2 in
      cast α3 in
    let* α0 := core.ops.bit.BitXor.bitxor a b in
    let* α1 := bitand mask α0 in
    core.ops.bit.BitXor.bitxor a α1.
  
  Global Instance AssociatedFunction_conditional_select `{H' : State.Trait} :
    Notation.DoubleColon Self "conditional_select" := {
    Notation.double_colon := conditional_select;
  }.
  
  Definition conditional_assign
      `{H' : State.Trait}
      (self : mut_ref Self)
      (other : ref Self)
      (choice : subtle.Choice)
      : M (H := H') unit :=
    let* mask :=
      let* α0 := borrow choice subtle.Choice in
      let* α1 := subtle.Choice::["unwrap_u8"] α0 in
      let* α2 := cast α1 in
      let* α3 := neg α2 in
      cast α3 in
    let* _ :=
      let* α0 := deref self u64 in
      let* α1 := deref self u64 in
      let* α2 := deref other u64 in
      let* α3 := bitxor α1 α2 in
      let* α4 := bitand mask α3 in
      assign_op bitxor α0 α4 in
    Pure tt.
  
  Global Instance Method_conditional_assign `{H' : State.Trait} :
    Notation.Dot "conditional_assign" := {
    Notation.dot := conditional_assign;
  }.
  
  Definition conditional_swap
      `{H' : State.Trait}
      (a : mut_ref Self)
      (b : mut_ref Self)
      (choice : subtle.Choice)
      : M (H := H') unit :=
    let* mask :=
      let* α0 := borrow choice subtle.Choice in
      let* α1 := subtle.Choice::["unwrap_u8"] α0 in
      let* α2 := cast α1 in
      let* α3 := neg α2 in
      cast α3 in
    let* t :=
      let* α0 := deref a u64 in
      let* α1 := deref b u64 in
      let* α2 := bitxor α0 α1 in
      bitand mask α2 in
    let* _ :=
      let* α0 := deref a u64 in
      assign_op bitxor α0 t in
    let* _ :=
      let* α0 := deref b u64 in
      assign_op bitxor α0 t in
    Pure tt.
  
  Global Instance AssociatedFunction_conditional_swap `{H' : State.Trait} :
    Notation.DoubleColon Self "conditional_swap" := {
    Notation.double_colon := conditional_swap;
  }.
  
  Global Instance I : subtle.ConditionallySelectable.Trait Self := {
    subtle.ConditionallySelectable.conditional_select `{H' : State.Trait}
      :=
      conditional_select;
  }.
  Global Hint Resolve I : core.
End Impl_subtle_ConditionallySelectable_for_u64.

Module Impl_subtle_ConditionallySelectable_for_i64.
  Definition Self := i64.
  
  Definition conditional_select
      `{H' : State.Trait}
      (a : ref Self)
      (b : ref Self)
      (choice : subtle.Choice)
      : M (H := H') Self :=
    let* mask :=
      let* α0 := borrow choice subtle.Choice in
      let* α1 := subtle.Choice::["unwrap_u8"] α0 in
      let* α2 := cast α1 in
      let* α3 := neg α2 in
      use α3 in
    let* α0 := core.ops.bit.BitXor.bitxor a b in
    let* α1 := bitand mask α0 in
    core.ops.bit.BitXor.bitxor a α1.
  
  Global Instance AssociatedFunction_conditional_select `{H' : State.Trait} :
    Notation.DoubleColon Self "conditional_select" := {
    Notation.double_colon := conditional_select;
  }.
  
  Definition conditional_assign
      `{H' : State.Trait}
      (self : mut_ref Self)
      (other : ref Self)
      (choice : subtle.Choice)
      : M (H := H') unit :=
    let* mask :=
      let* α0 := borrow choice subtle.Choice in
      let* α1 := subtle.Choice::["unwrap_u8"] α0 in
      let* α2 := cast α1 in
      let* α3 := neg α2 in
      use α3 in
    let* _ :=
      let* α0 := deref self i64 in
      let* α1 := deref self i64 in
      let* α2 := deref other i64 in
      let* α3 := bitxor α1 α2 in
      let* α4 := bitand mask α3 in
      assign_op bitxor α0 α4 in
    Pure tt.
  
  Global Instance Method_conditional_assign `{H' : State.Trait} :
    Notation.Dot "conditional_assign" := {
    Notation.dot := conditional_assign;
  }.
  
  Definition conditional_swap
      `{H' : State.Trait}
      (a : mut_ref Self)
      (b : mut_ref Self)
      (choice : subtle.Choice)
      : M (H := H') unit :=
    let* mask :=
      let* α0 := borrow choice subtle.Choice in
      let* α1 := subtle.Choice::["unwrap_u8"] α0 in
      let* α2 := cast α1 in
      let* α3 := neg α2 in
      use α3 in
    let* t :=
      let* α0 := deref a i64 in
      let* α1 := deref b i64 in
      let* α2 := bitxor α0 α1 in
      bitand mask α2 in
    let* _ :=
      let* α0 := deref a i64 in
      assign_op bitxor α0 t in
    let* _ :=
      let* α0 := deref b i64 in
      assign_op bitxor α0 t in
    Pure tt.
  
  Global Instance AssociatedFunction_conditional_swap `{H' : State.Trait} :
    Notation.DoubleColon Self "conditional_swap" := {
    Notation.double_colon := conditional_swap;
  }.
  
  Global Instance I : subtle.ConditionallySelectable.Trait Self := {
    subtle.ConditionallySelectable.conditional_select `{H' : State.Trait}
      :=
      conditional_select;
  }.
  Global Hint Resolve I : core.
End Impl_subtle_ConditionallySelectable_for_i64.

Module Impl_subtle_ConditionallySelectable_for_subtle_Choice.
  Definition Self := subtle.Choice.
  
  Definition conditional_select
      `{H' : State.Trait}
      (a : ref Self)
      (b : ref Self)
      (choice : subtle.Choice)
      : M (H := H') Self :=
    let* α0 := deref a subtle.Choice in
    let* α1 := borrow α0.["0"] u8 in
    let* α2 := deref α1 u8 in
    let* α3 := borrow α2 u8 in
    let* α4 := deref b subtle.Choice in
    let* α5 := borrow α4.["0"] u8 in
    let* α6 := deref α5 u8 in
    let* α7 := borrow α6 u8 in
    let* α8 := subtle.ConditionallySelectable.conditional_select α3 α7 choice in
    Pure (subtle.Choice.Build_t α8).
  
  Global Instance AssociatedFunction_conditional_select `{H' : State.Trait} :
    Notation.DoubleColon Self "conditional_select" := {
    Notation.double_colon := conditional_select;
  }.
  
  Global Instance I : subtle.ConditionallySelectable.Trait Self := {
    subtle.ConditionallySelectable.conditional_select `{H' : State.Trait}
      :=
      conditional_select;
  }.
  Global Hint Resolve I : core.
End Impl_subtle_ConditionallySelectable_for_subtle_Choice.

Module ConditionallyNegatable.
  Class Trait (Self : Set) : Type := {
    conditional_negate `{H' : State.Trait}
      :
      (mut_ref Self) -> subtle.Choice -> M (H := H') unit;
  }.
  
  Global Instance Method_conditional_negate `{H' : State.Trait} `(Trait)
    : Notation.Dot "conditional_negate" := {
    Notation.dot := conditional_negate;
  }.
End ConditionallyNegatable.

Module Impl_subtle_ConditionallyNegatable_for_T.
  Section Impl_subtle_ConditionallyNegatable_for_T.
    Context {T : Set}.
    Context
      `{subtle.ConditionallySelectable.Trait T}
      `{core.ops.arith.Neg.Trait (ref T)}.
    Definition Self := T.
    
    Definition conditional_negate
        `{H' : State.Trait}
        (self : mut_ref Self)
        (choice : subtle.Choice)
        : M (H := H') unit :=
      let* self_neg :=
        let* α0 := deref self _ in
        let* α1 := borrow α0 _ in
        let* α2 := use α1 in
        core.ops.arith.Neg.neg (α2 : (ref _)) in
      let* _ :=
        let* α0 := deref self _ in
        let* α1 := borrow_mut α0 _ in
        let* α2 := borrow self_neg _ in
        let* α3 := deref α2 _ in
        let* α4 := borrow α3 _ in
        subtle.ConditionallySelectable.conditional_assign α1 α4 choice in
      Pure tt.
    
    Global Instance Method_conditional_negate `{H' : State.Trait} :
      Notation.Dot "conditional_negate" := {
      Notation.dot := conditional_negate;
    }.
    
    Global Instance I : subtle.ConditionallyNegatable.Trait Self := {
      subtle.ConditionallyNegatable.conditional_negate `{H' : State.Trait}
        :=
        conditional_negate;
    }.
  End Impl_subtle_ConditionallyNegatable_for_T.
  Global Hint Resolve I : core.
End Impl_subtle_ConditionallyNegatable_for_T.

Module CtOption.
  Section CtOption.
    Context {T : Set}.
    Unset Primitive Projections.
    Record t : Set := {
      value : T;
      is_some : subtle.Choice;
    }.
    Global Set Primitive Projections.
    
    Global Instance Get_value : Notation.Dot "value" := {
      Notation.dot '(Build_t x0 _) := x0;
    }.
    Global Instance Get_AF_value : Notation.DoubleColon t "value" := {
      Notation.double_colon '(Build_t x0 _) := x0;
    }.
    Global Instance Get_is_some : Notation.Dot "is_some" := {
      Notation.dot '(Build_t _ x1) := x1;
    }.
    Global Instance Get_AF_is_some : Notation.DoubleColon t "is_some" := {
      Notation.double_colon '(Build_t _ x1) := x1;
    }.
  End CtOption.
End CtOption.
Definition CtOption (T : Set) : Set := ⟅CtOption.t (T := T)⟆.

Module Impl_core_clone_Clone_for_subtle_CtOption_T.
  Section Impl_core_clone_Clone_for_subtle_CtOption_T.
    Context {T : Set}.
    Context `{core.clone.Clone.Trait T}.
    Definition Self := subtle.CtOption T.
    
    Definition clone
        `{H' : State.Trait}
        (self : ref Self)
        : M (H := H') (subtle.CtOption T) :=
      let* α0 := deref self (subtle.CtOption _) in
      let* α1 := borrow α0.["value"] _ in
      let* α2 := deref α1 _ in
      let* α3 := borrow α2 _ in
      let* α4 := core.clone.Clone.clone α3 in
      let* α5 := deref self (subtle.CtOption _) in
      let* α6 := borrow α5.["is_some"] subtle.Choice in
      let* α7 := deref α6 subtle.Choice in
      let* α8 := borrow α7 subtle.Choice in
      let* α9 := core.clone.Clone.clone α8 in
      Pure {| subtle.CtOption.value := α4; subtle.CtOption.is_some := α9; |}.
    
    Global Instance Method_clone `{H' : State.Trait} : Notation.Dot "clone" := {
      Notation.dot := clone;
    }.
    
    Global Instance I : core.clone.Clone.Trait Self := {
      core.clone.Clone.clone `{H' : State.Trait} := clone;
    }.
  End Impl_core_clone_Clone_for_subtle_CtOption_T.
  Global Hint Resolve I : core.
End Impl_core_clone_Clone_for_subtle_CtOption_T.

Module Impl_core_marker_Copy_for_subtle_CtOption_T.
  Section Impl_core_marker_Copy_for_subtle_CtOption_T.
    Context {T : Set}.
    Context `{core.marker.Copy.Trait T}.
    Definition Self := subtle.CtOption T.
    
    Global Instance I : core.marker.Copy.Trait Self := {
    }.
  End Impl_core_marker_Copy_for_subtle_CtOption_T.
  Global Hint Resolve I : core.
End Impl_core_marker_Copy_for_subtle_CtOption_T.

Module Impl_core_fmt_Debug_for_subtle_CtOption_T.
  Section Impl_core_fmt_Debug_for_subtle_CtOption_T.
    Context {T : Set}.
    Context `{core.fmt.Debug.Trait T}.
    Definition Self := subtle.CtOption T.
    
    Definition fmt
        `{H' : State.Trait}
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter)
        : M (H := H') core.fmt.Result :=
      let* α0 := deref f core.fmt.Formatter in
      let* α1 := borrow_mut α0 core.fmt.Formatter in
      let* α2 := deref "CtOption" str in
      let* α3 := borrow α2 str in
      let* α4 := deref "value" str in
      let* α5 := borrow α4 str in
      let* α6 := deref self (subtle.CtOption _) in
      let* α7 := borrow α6.["value"] _ in
      let* α8 := deref α7 _ in
      let* α9 := borrow α8 _ in
      let* α10 := pointer_coercion "Unsize" α9 in
      let* α11 := deref "is_some" str in
      let* α12 := borrow α11 str in
      let* α13 := deref self (subtle.CtOption _) in
      let* α14 := borrow α13.["is_some"] subtle.Choice in
      let* α15 := borrow α14 (ref subtle.Choice) in
      let* α16 := deref α15 (ref subtle.Choice) in
      let* α17 := borrow α16 (ref subtle.Choice) in
      let* α18 := pointer_coercion "Unsize" α17 in
      core.fmt.Formatter::["debug_struct_field2_finish"] α1 α3 α5 α10 α12 α18.
    
    Global Instance Method_fmt `{H' : State.Trait} : Notation.Dot "fmt" := {
      Notation.dot := fmt;
    }.
    
    Global Instance I : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt `{H' : State.Trait} := fmt;
    }.
  End Impl_core_fmt_Debug_for_subtle_CtOption_T.
  Global Hint Resolve I : core.
End Impl_core_fmt_Debug_for_subtle_CtOption_T.

Module Impl_core_convert_From_for_core_option_Option_T.
  Section Impl_core_convert_From_for_core_option_Option_T.
    Context {T : Set}.
    Definition Self := core.option.Option T.
    
    Definition from
        `{H' : State.Trait}
        (source : subtle.CtOption T)
        : M (H := H') (core.option.Option T) :=
      let* α0 := borrow source (subtle.CtOption _) in
      let* α1 := (subtle.CtOption _)::["is_some"] α0 in
      let* α2 := borrow α1 subtle.Choice in
      let* α3 := subtle.Choice::["unwrap_u8"] α2 in
      let* α4 := eq α3 1 in
      let* α5 := use α4 in
      if (α5 : bool) then
        Pure (core.option.Option.Some source.["value"])
      else
        Pure (core.option.Option.None tt).
    
    Global Instance AssociatedFunction_from `{H' : State.Trait} :
      Notation.DoubleColon Self "from" := {
      Notation.double_colon := from;
    }.
    
    Global Instance I
      : core.convert.From.Trait Self (T := subtle.CtOption T) := {
      core.convert.From.from `{H' : State.Trait} := from;
    }.
  End Impl_core_convert_From_for_core_option_Option_T.
  Global Hint Resolve I : core.
End Impl_core_convert_From_for_core_option_Option_T.

Module Impl_subtle_CtOption_T_4.
  Definition Self := subtle.CtOption T.
  
  Definition new
      `{H' : State.Trait}
      (value : T)
      (is_some : subtle.Choice)
      : M (H := H') (subtle.CtOption T) :=
    Pure
      {| subtle.CtOption.value := value; subtle.CtOption.is_some := is_some; |}.
  
  Global Instance AssociatedFunction_new `{H' : State.Trait} :
    Notation.DoubleColon Self "new" := {
    Notation.double_colon := new;
  }.
  
  Definition expect
      `{H' : State.Trait}
      (self : Self)
      (msg : ref str)
      : M (H := H') T :=
    let* _ :=
      let* α0 := borrow self.["is_some"] subtle.Choice in
      let* α1 := subtle.Choice::["unwrap_u8"] α0 in
      let* α2 := borrow α1 u8 in
      let* α3 := borrow 1 u8 in
      match (α2, α3) with
      | (left_val, right_val) =>
        let* α0 := deref left_val u8 in
        let* α1 := deref right_val u8 in
        let* α2 := eq α0 α1 in
        let* α3 := not α2 in
        let* α4 := use α3 in
        if (α4 : bool) then
          let kind := core.panicking.AssertKind.Eq tt in
          let* _ :=
            let* α0 := deref left_val u8 in
            let* α1 := borrow α0 u8 in
            let* α2 := deref α1 u8 in
            let* α3 := borrow α2 u8 in
            let* α4 := deref right_val u8 in
            let* α5 := borrow α4 u8 in
            let* α6 := deref α5 u8 in
            let* α7 := borrow α6 u8 in
            let* α8 := borrow [ "" ] (list (ref str)) in
            let* α9 := deref α8 (list (ref str)) in
            let* α10 := borrow α9 (list (ref str)) in
            let* α11 := pointer_coercion "Unsize" α10 in
            let* α12 := borrow msg (ref str) in
            let* α13 := deref α12 (ref str) in
            let* α14 := borrow α13 (ref str) in
            let* α15 := core.fmt.rt.Argument::["new_display"] α14 in
            let* α16 := borrow [ α15 ] (list core.fmt.rt.Argument) in
            let* α17 := deref α16 (list core.fmt.rt.Argument) in
            let* α18 := borrow α17 (list core.fmt.rt.Argument) in
            let* α19 := pointer_coercion "Unsize" α18 in
            let* α20 := core.fmt.Arguments::["new_v1"] α11 α19 in
            core.panicking.assert_failed
              kind
              α3
              α7
              (core.option.Option.Some α20) in
          never_to_any tt
        else
          Pure tt
      end in
    Pure self.["value"].
  
  Global Instance Method_expect `{H' : State.Trait} : Notation.Dot "expect" := {
    Notation.dot := expect;
  }.
  
  Definition unwrap `{H' : State.Trait} (self : Self) : M (H := H') T :=
    let* _ :=
      let* α0 := borrow self.["is_some"] subtle.Choice in
      let* α1 := subtle.Choice::["unwrap_u8"] α0 in
      let* α2 := borrow α1 u8 in
      let* α3 := borrow 1 u8 in
      match (α2, α3) with
      | (left_val, right_val) =>
        let* α0 := deref left_val u8 in
        let* α1 := deref right_val u8 in
        let* α2 := eq α0 α1 in
        let* α3 := not α2 in
        let* α4 := use α3 in
        if (α4 : bool) then
          let kind := core.panicking.AssertKind.Eq tt in
          let* _ :=
            let* α0 := deref left_val u8 in
            let* α1 := borrow α0 u8 in
            let* α2 := deref α1 u8 in
            let* α3 := borrow α2 u8 in
            let* α4 := deref right_val u8 in
            let* α5 := borrow α4 u8 in
            let* α6 := deref α5 u8 in
            let* α7 := borrow α6 u8 in
            core.panicking.assert_failed
              kind
              α3
              α7
              (core.option.Option.None tt) in
          never_to_any tt
        else
          Pure tt
      end in
    Pure self.["value"].
  
  Global Instance Method_unwrap `{H' : State.Trait} : Notation.Dot "unwrap" := {
    Notation.dot := unwrap;
  }.
  
  Definition unwrap_or
      `{H' : State.Trait}
      `{subtle.ConditionallySelectable.Trait T}
      (self : Self)
      (def : T)
      : M (H := H') T :=
    let* α0 := borrow def _ in
    let* α1 := deref α0 _ in
    let* α2 := borrow α1 _ in
    let* α3 := borrow self.["value"] _ in
    let* α4 := deref α3 _ in
    let* α5 := borrow α4 _ in
    subtle.ConditionallySelectable.conditional_select α2 α5 self.["is_some"].
  
  Global Instance Method_unwrap_or
      `{H' : State.Trait}
      `{subtle.ConditionallySelectable.Trait T} :
    Notation.Dot "unwrap_or" := {
    Notation.dot := unwrap_or;
  }.
  
  Definition unwrap_or_else
      `{H' : State.Trait}
      {F : Set}
      `{subtle.ConditionallySelectable.Trait T}
      `{core.ops.function.FnOnce.Trait F (Args := unit)}
      (self : Self)
      (f : F)
      : M (H := H') T :=
    let* α0 := core.ops.function.FnOnce.call_once f tt in
    let* α1 := borrow α0 _ in
    let* α2 := deref α1 _ in
    let* α3 := borrow α2 _ in
    let* α4 := borrow self.["value"] _ in
    let* α5 := deref α4 _ in
    let* α6 := borrow α5 _ in
    subtle.ConditionallySelectable.conditional_select α3 α6 self.["is_some"].
  
  Global Instance Method_unwrap_or_else
      `{H' : State.Trait}
      {F : Set}
      `{subtle.ConditionallySelectable.Trait T}
      `{core.ops.function.FnOnce.Trait F (Args := unit)} :
    Notation.Dot "unwrap_or_else" := {
    Notation.dot := unwrap_or_else (F := F);
  }.
  
  Definition is_some
      `{H' : State.Trait}
      (self : ref Self)
      : M (H := H') subtle.Choice :=
    let* α0 := deref self (subtle.CtOption _) in
    Pure α0.["is_some"].
  
  Global Instance Method_is_some `{H' : State.Trait} :
    Notation.Dot "is_some" := {
    Notation.dot := is_some;
  }.
  
  Definition is_none
      `{H' : State.Trait}
      (self : ref Self)
      : M (H := H') subtle.Choice :=
    let* α0 := deref self (subtle.CtOption _) in
    core.ops.bit.Not.not α0.["is_some"].
  
  Global Instance Method_is_none `{H' : State.Trait} :
    Notation.Dot "is_none" := {
    Notation.dot := is_none;
  }.
  
  Definition map
      `{H' : State.Trait}
      {U F : Set}
      `{core.default.Default.Trait T}
      `{subtle.ConditionallySelectable.Trait T}
      `{core.ops.function.FnOnce.Trait F (Args := T)}
      (self : Self)
      (f : F)
      : M (H := H') (subtle.CtOption U) :=
    let* α0 := core.default.Default.default in
    let* α1 := borrow α0 _ in
    let* α2 := deref α1 _ in
    let* α3 := borrow α2 _ in
    let* α4 := borrow self.["value"] _ in
    let* α5 := deref α4 _ in
    let* α6 := borrow α5 _ in
    let* α7 :=
      subtle.ConditionallySelectable.conditional_select
        α3
        α6
        self.["is_some"] in
    let* α8 := core.ops.function.FnOnce.call_once f (α7) in
    (subtle.CtOption _)::["new"] α8 self.["is_some"].
  
  Global Instance Method_map
      `{H' : State.Trait}
      {U F : Set}
      `{core.default.Default.Trait T}
      `{subtle.ConditionallySelectable.Trait T}
      `{core.ops.function.FnOnce.Trait F (Args := T)} :
    Notation.Dot "map" := {
    Notation.dot := map (U := U) (F := F);
  }.
  
  Definition and_then
      `{H' : State.Trait}
      {U F : Set}
      `{core.default.Default.Trait T}
      `{subtle.ConditionallySelectable.Trait T}
      `{core.ops.function.FnOnce.Trait F (Args := T)}
      (self : Self)
      (f : F)
      : M (H := H') (subtle.CtOption U) :=
    let* tmp :=
      let* α0 := core.default.Default.default in
      let* α1 := borrow α0 _ in
      let* α2 := deref α1 _ in
      let* α3 := borrow α2 _ in
      let* α4 := borrow self.["value"] _ in
      let* α5 := deref α4 _ in
      let* α6 := borrow α5 _ in
      let* α7 :=
        subtle.ConditionallySelectable.conditional_select
          α3
          α6
          self.["is_some"] in
      core.ops.function.FnOnce.call_once f (α7) in
    let* _ :=
      let* α0 := borrow_mut tmp.["is_some"] subtle.Choice in
      core.ops.bit.BitAndAssign.bitand_assign α0 self.["is_some"] in
    Pure tmp.
  
  Global Instance Method_and_then
      `{H' : State.Trait}
      {U F : Set}
      `{core.default.Default.Trait T}
      `{subtle.ConditionallySelectable.Trait T}
      `{core.ops.function.FnOnce.Trait F (Args := T)} :
    Notation.Dot "and_then" := {
    Notation.dot := and_then (U := U) (F := F);
  }.
  
  Definition or_else
      `{H' : State.Trait}
      {F : Set}
      `{subtle.ConditionallySelectable.Trait T}
      `{core.ops.function.FnOnce.Trait F (Args := unit)}
      (self : Self)
      (f : F)
      : M (H := H') (subtle.CtOption T) :=
    let* is_none :=
      let* α0 := borrow self (subtle.CtOption _) in
      (subtle.CtOption _)::["is_none"] α0 in
    let* f := core.ops.function.FnOnce.call_once f tt in
    let* α0 := borrow self (subtle.CtOption _) in
    let* α1 := deref α0 (subtle.CtOption _) in
    let* α2 := borrow α1 (subtle.CtOption _) in
    let* α3 := borrow f (subtle.CtOption _) in
    let* α4 := deref α3 (subtle.CtOption _) in
    let* α5 := borrow α4 (subtle.CtOption _) in
    subtle.ConditionallySelectable.conditional_select α2 α5 is_none.
  
  Global Instance Method_or_else
      `{H' : State.Trait}
      {F : Set}
      `{subtle.ConditionallySelectable.Trait T}
      `{core.ops.function.FnOnce.Trait F (Args := unit)} :
    Notation.Dot "or_else" := {
    Notation.dot := or_else (F := F);
  }.
End Impl_subtle_CtOption_T_4.

Module Impl_subtle_ConditionallySelectable_for_subtle_CtOption_T.
  Section Impl_subtle_ConditionallySelectable_for_subtle_CtOption_T.
    Context {T : Set}.
    Context `{subtle.ConditionallySelectable.Trait T}.
    Definition Self := subtle.CtOption T.
    
    Definition conditional_select
        `{H' : State.Trait}
        (a : ref Self)
        (b : ref Self)
        (choice : subtle.Choice)
        : M (H := H') Self :=
      let* α0 := deref a (subtle.CtOption _) in
      let* α1 := borrow α0.["value"] _ in
      let* α2 := deref α1 _ in
      let* α3 := borrow α2 _ in
      let* α4 := deref b (subtle.CtOption _) in
      let* α5 := borrow α4.["value"] _ in
      let* α6 := deref α5 _ in
      let* α7 := borrow α6 _ in
      let* α8 :=
        subtle.ConditionallySelectable.conditional_select α3 α7 choice in
      let* α9 := deref a (subtle.CtOption _) in
      let* α10 := borrow α9.["is_some"] subtle.Choice in
      let* α11 := deref α10 subtle.Choice in
      let* α12 := borrow α11 subtle.Choice in
      let* α13 := deref b (subtle.CtOption _) in
      let* α14 := borrow α13.["is_some"] subtle.Choice in
      let* α15 := deref α14 subtle.Choice in
      let* α16 := borrow α15 subtle.Choice in
      let* α17 :=
        subtle.ConditionallySelectable.conditional_select α12 α16 choice in
      (subtle.CtOption _)::["new"] α8 α17.
    
    Global Instance AssociatedFunction_conditional_select `{H' : State.Trait} :
      Notation.DoubleColon Self "conditional_select" := {
      Notation.double_colon := conditional_select;
    }.
    
    Global Instance I : subtle.ConditionallySelectable.Trait Self := {
      subtle.ConditionallySelectable.conditional_select `{H' : State.Trait}
        :=
        conditional_select;
    }.
  End Impl_subtle_ConditionallySelectable_for_subtle_CtOption_T.
  Global Hint Resolve I : core.
End Impl_subtle_ConditionallySelectable_for_subtle_CtOption_T.

Module Impl_subtle_ConstantTimeEq_for_subtle_CtOption_T.
  Section Impl_subtle_ConstantTimeEq_for_subtle_CtOption_T.
    Context {T : Set}.
    Context `{subtle.ConstantTimeEq.Trait T}.
    Definition Self := subtle.CtOption T.
    
    Definition ct_eq
        `{H' : State.Trait}
        (self : ref Self)
        (rhs : ref (subtle.CtOption T))
        : M (H := H') subtle.Choice :=
      let* a :=
        let* α0 := deref self (subtle.CtOption _) in
        let* α1 := borrow α0 (subtle.CtOption _) in
        (subtle.CtOption _)::["is_some"] α1 in
      let* b :=
        let* α0 := deref rhs (subtle.CtOption _) in
        let* α1 := borrow α0 (subtle.CtOption _) in
        (subtle.CtOption _)::["is_some"] α1 in
      let* α0 := core.ops.bit.BitAnd.bitand a b in
      let* α1 := deref self (subtle.CtOption _) in
      let* α2 := borrow α1.["value"] _ in
      let* α3 := deref rhs (subtle.CtOption _) in
      let* α4 := borrow α3.["value"] _ in
      let* α5 := deref α4 _ in
      let* α6 := borrow α5 _ in
      let* α7 := subtle.ConstantTimeEq.ct_eq α2 α6 in
      let* α8 := core.ops.bit.BitAnd.bitand α0 α7 in
      let* α9 := core.ops.bit.Not.not a in
      let* α10 := core.ops.bit.Not.not b in
      let* α11 := core.ops.bit.BitAnd.bitand α9 α10 in
      core.ops.bit.BitOr.bitor α8 α11.
    
    Global Instance Method_ct_eq `{H' : State.Trait} : Notation.Dot "ct_eq" := {
      Notation.dot := ct_eq;
    }.
    
    Global Instance I : subtle.ConstantTimeEq.Trait Self := {
      subtle.ConstantTimeEq.ct_eq `{H' : State.Trait} := ct_eq;
    }.
  End Impl_subtle_ConstantTimeEq_for_subtle_CtOption_T.
  Global Hint Resolve I : core.
End Impl_subtle_ConstantTimeEq_for_subtle_CtOption_T.

Module ConstantTimeGreater.
  Class Trait (Self : Set) : Type := {
    ct_gt `{H' : State.Trait}
      :
      (ref Self) -> (ref Self) -> M (H := H') subtle.Choice;
  }.
  
  Global Instance Method_ct_gt `{H' : State.Trait} `(Trait)
    : Notation.Dot "ct_gt" := {
    Notation.dot := ct_gt;
  }.
End ConstantTimeGreater.

Module Impl_subtle_ConstantTimeGreater_for_u8.
  Definition Self := u8.
  
  Definition ct_gt
      `{H' : State.Trait}
      (self : ref Self)
      (other : ref u8)
      : M (H := H') subtle.Choice :=
    let* gtb :=
      let* α0 := core.ops.bit.Not.not other in
      core.ops.bit.BitAnd.bitand self α0 in
    let* ltb :=
      let* α0 := core.ops.bit.Not.not self in
      core.ops.bit.BitAnd.bitand α0 other in
    let pow := 1 in
    let* _ :=
      loop
        (let* α0 := lt pow 8 in
        let* α1 := use α0 in
        if (α1 : bool) then
          let* _ :=
            let* α0 := shr ltb pow in
            assign_op bitor ltb α0 in
          let* _ := assign_op add pow pow in
          Pure tt
        else
          let* _ :=
            let* α0 := Break in
            never_to_any α0 in
          never_to_any tt) in
    let* bit :=
      let* α0 := not ltb in
      bitand gtb α0 in
    let pow := 1 in
    let* _ :=
      loop
        (let* α0 := lt pow 8 in
        let* α1 := use α0 in
        if (α1 : bool) then
          let* _ :=
            let* α0 := shr bit pow in
            assign_op bitor bit α0 in
          let* _ := assign_op add pow pow in
          Pure tt
        else
          let* _ :=
            let* α0 := Break in
            never_to_any α0 in
          never_to_any tt) in
    let* α0 := bitand bit 1 in
    let* α1 := use α0 in
    core.convert.From.from α1.
  
  Global Instance Method_ct_gt `{H' : State.Trait} : Notation.Dot "ct_gt" := {
    Notation.dot := ct_gt;
  }.
  
  Global Instance I : subtle.ConstantTimeGreater.Trait Self := {
    subtle.ConstantTimeGreater.ct_gt `{H' : State.Trait} := ct_gt;
  }.
  Global Hint Resolve I : core.
End Impl_subtle_ConstantTimeGreater_for_u8.

Module Impl_subtle_ConstantTimeGreater_for_u16.
  Definition Self := u16.
  
  Definition ct_gt
      `{H' : State.Trait}
      (self : ref Self)
      (other : ref u16)
      : M (H := H') subtle.Choice :=
    let* gtb :=
      let* α0 := core.ops.bit.Not.not other in
      core.ops.bit.BitAnd.bitand self α0 in
    let* ltb :=
      let* α0 := core.ops.bit.Not.not self in
      core.ops.bit.BitAnd.bitand α0 other in
    let pow := 1 in
    let* _ :=
      loop
        (let* α0 := lt pow 16 in
        let* α1 := use α0 in
        if (α1 : bool) then
          let* _ :=
            let* α0 := shr ltb pow in
            assign_op bitor ltb α0 in
          let* _ := assign_op add pow pow in
          Pure tt
        else
          let* _ :=
            let* α0 := Break in
            never_to_any α0 in
          never_to_any tt) in
    let* bit :=
      let* α0 := not ltb in
      bitand gtb α0 in
    let pow := 1 in
    let* _ :=
      loop
        (let* α0 := lt pow 16 in
        let* α1 := use α0 in
        if (α1 : bool) then
          let* _ :=
            let* α0 := shr bit pow in
            assign_op bitor bit α0 in
          let* _ := assign_op add pow pow in
          Pure tt
        else
          let* _ :=
            let* α0 := Break in
            never_to_any α0 in
          never_to_any tt) in
    let* α0 := bitand bit 1 in
    let* α1 := cast α0 in
    core.convert.From.from α1.
  
  Global Instance Method_ct_gt `{H' : State.Trait} : Notation.Dot "ct_gt" := {
    Notation.dot := ct_gt;
  }.
  
  Global Instance I : subtle.ConstantTimeGreater.Trait Self := {
    subtle.ConstantTimeGreater.ct_gt `{H' : State.Trait} := ct_gt;
  }.
  Global Hint Resolve I : core.
End Impl_subtle_ConstantTimeGreater_for_u16.

Module Impl_subtle_ConstantTimeGreater_for_u32.
  Definition Self := u32.
  
  Definition ct_gt
      `{H' : State.Trait}
      (self : ref Self)
      (other : ref u32)
      : M (H := H') subtle.Choice :=
    let* gtb :=
      let* α0 := core.ops.bit.Not.not other in
      core.ops.bit.BitAnd.bitand self α0 in
    let* ltb :=
      let* α0 := core.ops.bit.Not.not self in
      core.ops.bit.BitAnd.bitand α0 other in
    let pow := 1 in
    let* _ :=
      loop
        (let* α0 := lt pow 32 in
        let* α1 := use α0 in
        if (α1 : bool) then
          let* _ :=
            let* α0 := shr ltb pow in
            assign_op bitor ltb α0 in
          let* _ := assign_op add pow pow in
          Pure tt
        else
          let* _ :=
            let* α0 := Break in
            never_to_any α0 in
          never_to_any tt) in
    let* bit :=
      let* α0 := not ltb in
      bitand gtb α0 in
    let pow := 1 in
    let* _ :=
      loop
        (let* α0 := lt pow 32 in
        let* α1 := use α0 in
        if (α1 : bool) then
          let* _ :=
            let* α0 := shr bit pow in
            assign_op bitor bit α0 in
          let* _ := assign_op add pow pow in
          Pure tt
        else
          let* _ :=
            let* α0 := Break in
            never_to_any α0 in
          never_to_any tt) in
    let* α0 := bitand bit 1 in
    let* α1 := cast α0 in
    core.convert.From.from α1.
  
  Global Instance Method_ct_gt `{H' : State.Trait} : Notation.Dot "ct_gt" := {
    Notation.dot := ct_gt;
  }.
  
  Global Instance I : subtle.ConstantTimeGreater.Trait Self := {
    subtle.ConstantTimeGreater.ct_gt `{H' : State.Trait} := ct_gt;
  }.
  Global Hint Resolve I : core.
End Impl_subtle_ConstantTimeGreater_for_u32.

Module Impl_subtle_ConstantTimeGreater_for_u64.
  Definition Self := u64.
  
  Definition ct_gt
      `{H' : State.Trait}
      (self : ref Self)
      (other : ref u64)
      : M (H := H') subtle.Choice :=
    let* gtb :=
      let* α0 := core.ops.bit.Not.not other in
      core.ops.bit.BitAnd.bitand self α0 in
    let* ltb :=
      let* α0 := core.ops.bit.Not.not self in
      core.ops.bit.BitAnd.bitand α0 other in
    let pow := 1 in
    let* _ :=
      loop
        (let* α0 := lt pow 64 in
        let* α1 := use α0 in
        if (α1 : bool) then
          let* _ :=
            let* α0 := shr ltb pow in
            assign_op bitor ltb α0 in
          let* _ := assign_op add pow pow in
          Pure tt
        else
          let* _ :=
            let* α0 := Break in
            never_to_any α0 in
          never_to_any tt) in
    let* bit :=
      let* α0 := not ltb in
      bitand gtb α0 in
    let pow := 1 in
    let* _ :=
      loop
        (let* α0 := lt pow 64 in
        let* α1 := use α0 in
        if (α1 : bool) then
          let* _ :=
            let* α0 := shr bit pow in
            assign_op bitor bit α0 in
          let* _ := assign_op add pow pow in
          Pure tt
        else
          let* _ :=
            let* α0 := Break in
            never_to_any α0 in
          never_to_any tt) in
    let* α0 := bitand bit 1 in
    let* α1 := cast α0 in
    core.convert.From.from α1.
  
  Global Instance Method_ct_gt `{H' : State.Trait} : Notation.Dot "ct_gt" := {
    Notation.dot := ct_gt;
  }.
  
  Global Instance I : subtle.ConstantTimeGreater.Trait Self := {
    subtle.ConstantTimeGreater.ct_gt `{H' : State.Trait} := ct_gt;
  }.
  Global Hint Resolve I : core.
End Impl_subtle_ConstantTimeGreater_for_u64.

Module ConstantTimeLess.
  Unset Primitive Projections.
  Class Trait
      (Self : Set)
      `{subtle.ConstantTimeEq.Trait Self}
      `{subtle.ConstantTimeGreater.Trait Self} :
      Type := {
  }.
  Global Set Primitive Projections.
  Global Instance Method_ct_lt `{H' : State.Trait} `(Trait)
    : Notation.Dot "ct_lt" := {
    Notation.dot (self : ref Self) (other : ref Self)
      :=
      (let* α0 := deref self _ in
      let* α1 := borrow α0 _ in
      let* α2 := deref other _ in
      let* α3 := borrow α2 _ in
      let* α4 := subtle.ConstantTimeGreater.ct_gt α1 α3 in
      let* α5 := core.ops.bit.Not.not α4 in
      let* α6 := deref self _ in
      let* α7 := borrow α6 _ in
      let* α8 := deref other _ in
      let* α9 := borrow α8 _ in
      let* α10 := subtle.ConstantTimeEq.ct_eq α7 α9 in
      let* α11 := core.ops.bit.Not.not α10 in
      core.ops.bit.BitAnd.bitand α5 α11
      : M (H := H') subtle.Choice);
  }.
End ConstantTimeLess.

Module Impl_subtle_ConstantTimeLess_for_u8.
  Definition Self := u8.
  
  Global Instance I : subtle.ConstantTimeLess.Trait Self := {
  }.
  Global Hint Resolve I : core.
End Impl_subtle_ConstantTimeLess_for_u8.

Module Impl_subtle_ConstantTimeLess_for_u16.
  Definition Self := u16.
  
  Global Instance I : subtle.ConstantTimeLess.Trait Self := {
  }.
  Global Hint Resolve I : core.
End Impl_subtle_ConstantTimeLess_for_u16.

Module Impl_subtle_ConstantTimeLess_for_u32.
  Definition Self := u32.
  
  Global Instance I : subtle.ConstantTimeLess.Trait Self := {
  }.
  Global Hint Resolve I : core.
End Impl_subtle_ConstantTimeLess_for_u32.

Module Impl_subtle_ConstantTimeLess_for_u64.
  Definition Self := u64.
  
  Global Instance I : subtle.ConstantTimeLess.Trait Self := {
  }.
  Global Hint Resolve I : core.
End Impl_subtle_ConstantTimeLess_for_u64.
