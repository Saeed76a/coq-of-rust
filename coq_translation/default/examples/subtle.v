(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module Choice.
  Unset Primitive Projections.
  Record t `{State.Trait} : Set := {
    x0 : u8;
  }.
  Global Set Primitive Projections.
  
  Global Instance Get_0 `{State.Trait} : Notation.Dot "0" := {
    Notation.dot x := let* x := M.read x in Pure x.(x0) : M _;
  }.
End Choice.
Definition Choice `{State.Trait} : Set := M.val Choice.t.

Module Impl_core_marker_Copy_for_subtle_Choice.
  Definition Self `{State.Trait} := subtle.Choice.
  
  Global Instance I `{State.Trait} : core.marker.Copy.Trait Self := {
  }.
  Global Hint Resolve I : core.
End Impl_core_marker_Copy_for_subtle_Choice.

Module Impl_core_clone_Clone_for_subtle_Choice.
  Definition Self `{State.Trait} := subtle.Choice.
  
  Definition clone `{State.Trait} (self : ref Self) : M subtle.Choice :=
    let _ := tt in
    deref self subtle.Choice.
  
  Global Instance Method_clone `{State.Trait} : Notation.Dot "clone" := {
    Notation.dot := clone;
  }.
  
  Global Instance I `{State.Trait} : core.clone.Clone.Trait Self := {
    core.clone.Clone.clone := clone;
  }.
  Global Hint Resolve I : core.
End Impl_core_clone_Clone_for_subtle_Choice.

Module Impl_core_fmt_Debug_for_subtle_Choice.
  Definition Self `{State.Trait} := subtle.Choice.
  
  Definition fmt
      `{State.Trait}
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter)
      : M core.fmt.Result :=
    let* α0 := deref f core.fmt.Formatter in
    let* α1 := borrow_mut α0 core.fmt.Formatter in
    let* α2 := deref (mk_str "Choice") str in
    let* α3 := borrow α2 str in
    let* α4 := deref self subtle.Choice in
    let* α5 := α4.["0"] in
    let* α6 := borrow α5 u8 in
    let* α7 := borrow α6 (ref u8) in
    let* α8 := deref α7 (ref u8) in
    let* α9 := borrow α8 (ref u8) in
    let* α10 := pointer_coercion "Unsize" α9 in
    core.fmt.Formatter::["debug_tuple_field1_finish"] α1 α3 α10.
  
  Global Instance Method_fmt `{State.Trait} : Notation.Dot "fmt" := {
    Notation.dot := fmt;
  }.
  
  Global Instance I `{State.Trait} : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
  Global Hint Resolve I : core.
End Impl_core_fmt_Debug_for_subtle_Choice.

Module Impl_subtle_Choice_4.
  Definition Self `{State.Trait} : Set := subtle.Choice.
  
  Definition unwrap_u8 `{State.Trait} (self : ref Self) : M u8 :=
    let* α0 := deref self subtle.Choice in
    α0.["0"].
  
  Global Instance Method_unwrap_u8 `{State.Trait} :
    Notation.Dot "unwrap_u8" := {
    Notation.dot := unwrap_u8;
  }.
End Impl_subtle_Choice_4.

Module Impl_core_convert_From_for_bool.
  Definition Self `{State.Trait} := bool.
  
  Definition from `{State.Trait} (source : subtle.Choice) : M bool :=
    let* _ :=
      let* α0 := true in
      let* α1 := use α0 in
      if (α1 : bool) then
        let* _ :=
          let* α0 := source.["0"] in
          let* α1 := M.alloc 0 in
          let* α2 := eq α0 α1 in
          let* α3 := source.["0"] in
          let* α4 := M.alloc 1 in
          let* α5 := eq α3 α4 in
          let* α6 := bitor α2 α5 in
          let* α7 := not α6 in
          let* α8 := use α7 in
          if (α8 : bool) then
            let* α0 :=
              core.panicking.panic
                (mk_str
                  "assertion failed: (source.0 == 0u8) | (source.0 == 1u8)") in
            never_to_any α0
          else
            Pure tt in
        Pure tt
      else
        Pure tt in
    let* α0 := source.["0"] in
    let* α1 := M.alloc 0 in
    ne α0 α1.
  
  Global Instance AssociatedFunction_from `{State.Trait} :
    Notation.DoubleColon Self "from" := {
    Notation.double_colon := from;
  }.
  
  Global Instance I `{State.Trait}
    : core.convert.From.Trait Self (T := subtle.Choice) := {
    core.convert.From.from := from;
  }.
  Global Hint Resolve I : core.
End Impl_core_convert_From_for_bool.

Module Impl_core_ops_bit_BitAnd_for_subtle_Choice.
  Definition Self `{State.Trait} := subtle.Choice.
  
  Definition Output : Set := subtle.Choice.
  
  Definition bitand
      `{State.Trait}
      (self : Self)
      (rhs : subtle.Choice)
      : M subtle.Choice :=
    let* α0 := self.["0"] in
    let* α1 := rhs.["0"] in
    let* α2 := bitand α0 α1 in
    core.convert.Into.into α2.
  
  Global Instance Method_bitand `{State.Trait} : Notation.Dot "bitand" := {
    Notation.dot := bitand;
  }.
  
  Global Instance I `{State.Trait}
    : core.ops.bit.BitAnd.Trait Self
        (Rhs := core.ops.bit.BitAnd.Default.Rhs Self)
      := {
    core.ops.bit.BitAnd.Output := Output;
    core.ops.bit.BitAnd.bitand := bitand;
  }.
  Global Hint Resolve I : core.
End Impl_core_ops_bit_BitAnd_for_subtle_Choice.

Module Impl_core_ops_bit_BitAndAssign_for_subtle_Choice.
  Definition Self `{State.Trait} := subtle.Choice.
  
  Definition bitand_assign
      `{State.Trait}
      (self : mut_ref Self)
      (rhs : subtle.Choice)
      : M unit :=
    let* _ :=
      let* α0 := deref self subtle.Choice in
      let* α1 := deref self subtle.Choice in
      let* α2 := core.ops.bit.BitAnd.bitand α1 rhs in
      assign α0 α2 in
    Pure tt.
  
  Global Instance Method_bitand_assign `{State.Trait} :
    Notation.Dot "bitand_assign" := {
    Notation.dot := bitand_assign;
  }.
  
  Global Instance I `{State.Trait}
    : core.ops.bit.BitAndAssign.Trait Self
        (Rhs := core.ops.bit.BitAndAssign.Default.Rhs Self)
      := {
    core.ops.bit.BitAndAssign.bitand_assign := bitand_assign;
  }.
  Global Hint Resolve I : core.
End Impl_core_ops_bit_BitAndAssign_for_subtle_Choice.

Module Impl_core_ops_bit_BitOr_for_subtle_Choice.
  Definition Self `{State.Trait} := subtle.Choice.
  
  Definition Output : Set := subtle.Choice.
  
  Definition bitor
      `{State.Trait}
      (self : Self)
      (rhs : subtle.Choice)
      : M subtle.Choice :=
    let* α0 := self.["0"] in
    let* α1 := rhs.["0"] in
    let* α2 := bitor α0 α1 in
    core.convert.Into.into α2.
  
  Global Instance Method_bitor `{State.Trait} : Notation.Dot "bitor" := {
    Notation.dot := bitor;
  }.
  
  Global Instance I `{State.Trait}
    : core.ops.bit.BitOr.Trait Self (Rhs := core.ops.bit.BitOr.Default.Rhs Self)
      := {
    core.ops.bit.BitOr.Output := Output;
    core.ops.bit.BitOr.bitor := bitor;
  }.
  Global Hint Resolve I : core.
End Impl_core_ops_bit_BitOr_for_subtle_Choice.

Module Impl_core_ops_bit_BitOrAssign_for_subtle_Choice.
  Definition Self `{State.Trait} := subtle.Choice.
  
  Definition bitor_assign
      `{State.Trait}
      (self : mut_ref Self)
      (rhs : subtle.Choice)
      : M unit :=
    let* _ :=
      let* α0 := deref self subtle.Choice in
      let* α1 := deref self subtle.Choice in
      let* α2 := core.ops.bit.BitOr.bitor α1 rhs in
      assign α0 α2 in
    Pure tt.
  
  Global Instance Method_bitor_assign `{State.Trait} :
    Notation.Dot "bitor_assign" := {
    Notation.dot := bitor_assign;
  }.
  
  Global Instance I `{State.Trait}
    : core.ops.bit.BitOrAssign.Trait Self
        (Rhs := core.ops.bit.BitOrAssign.Default.Rhs Self)
      := {
    core.ops.bit.BitOrAssign.bitor_assign := bitor_assign;
  }.
  Global Hint Resolve I : core.
End Impl_core_ops_bit_BitOrAssign_for_subtle_Choice.

Module Impl_core_ops_bit_BitXor_for_subtle_Choice.
  Definition Self `{State.Trait} := subtle.Choice.
  
  Definition Output : Set := subtle.Choice.
  
  Definition bitxor
      `{State.Trait}
      (self : Self)
      (rhs : subtle.Choice)
      : M subtle.Choice :=
    let* α0 := self.["0"] in
    let* α1 := rhs.["0"] in
    let* α2 := bitxor α0 α1 in
    core.convert.Into.into α2.
  
  Global Instance Method_bitxor `{State.Trait} : Notation.Dot "bitxor" := {
    Notation.dot := bitxor;
  }.
  
  Global Instance I `{State.Trait}
    : core.ops.bit.BitXor.Trait Self
        (Rhs := core.ops.bit.BitXor.Default.Rhs Self)
      := {
    core.ops.bit.BitXor.Output := Output;
    core.ops.bit.BitXor.bitxor := bitxor;
  }.
  Global Hint Resolve I : core.
End Impl_core_ops_bit_BitXor_for_subtle_Choice.

Module Impl_core_ops_bit_BitXorAssign_for_subtle_Choice.
  Definition Self `{State.Trait} := subtle.Choice.
  
  Definition bitxor_assign
      `{State.Trait}
      (self : mut_ref Self)
      (rhs : subtle.Choice)
      : M unit :=
    let* _ :=
      let* α0 := deref self subtle.Choice in
      let* α1 := deref self subtle.Choice in
      let* α2 := core.ops.bit.BitXor.bitxor α1 rhs in
      assign α0 α2 in
    Pure tt.
  
  Global Instance Method_bitxor_assign `{State.Trait} :
    Notation.Dot "bitxor_assign" := {
    Notation.dot := bitxor_assign;
  }.
  
  Global Instance I `{State.Trait}
    : core.ops.bit.BitXorAssign.Trait Self
        (Rhs := core.ops.bit.BitXorAssign.Default.Rhs Self)
      := {
    core.ops.bit.BitXorAssign.bitxor_assign := bitxor_assign;
  }.
  Global Hint Resolve I : core.
End Impl_core_ops_bit_BitXorAssign_for_subtle_Choice.

Module Impl_core_ops_bit_Not_for_subtle_Choice.
  Definition Self `{State.Trait} := subtle.Choice.
  
  Definition Output : Set := subtle.Choice.
  
  Definition not `{State.Trait} (self : Self) : M subtle.Choice :=
    let* α0 := M.alloc 1 in
    let* α1 := self.["0"] in
    let* α2 := not α1 in
    let* α3 := bitand α0 α2 in
    core.convert.Into.into α3.
  
  Global Instance Method_not `{State.Trait} : Notation.Dot "not" := {
    Notation.dot := not;
  }.
  
  Global Instance I `{State.Trait} : core.ops.bit.Not.Trait Self := {
    core.ops.bit.Not.Output := Output;
    core.ops.bit.Not.not := not;
  }.
  Global Hint Resolve I : core.
End Impl_core_ops_bit_Not_for_subtle_Choice.

Definition black_box `{State.Trait} (input : u8) : M u8 :=
  let* _ :=
    let* α0 := true in
    let* α1 := use α0 in
    if (α1 : bool) then
      let* _ :=
        let* α0 := M.alloc 0 in
        let* α1 := eq input α0 in
        let* α2 := M.alloc 1 in
        let* α3 := eq input α2 in
        let* α4 := bitor α1 α3 in
        let* α5 := not α4 in
        let* α6 := use α5 in
        if (α6 : bool) then
          let* α0 :=
            core.panicking.panic
              (mk_str "assertion failed: (input == 0u8) | (input == 1u8)") in
          never_to_any α0
        else
          Pure tt in
      Pure tt
    else
      Pure tt in
  let* α0 := borrow input u8 in
  let* α1 := deref α0 u8 in
  let* α2 := addr_of α1 in
  let* α3 := use α2 in
  core.ptr.read_volatile α3.

Module Impl_core_convert_From_for_subtle_Choice.
  Definition Self `{State.Trait} := subtle.Choice.
  
  Definition from `{State.Trait} (input : u8) : M subtle.Choice :=
    let* α0 := subtle.black_box input in
    Pure (subtle.Choice.Build_t α0).
  
  Global Instance AssociatedFunction_from `{State.Trait} :
    Notation.DoubleColon Self "from" := {
    Notation.double_colon := from;
  }.
  
  Global Instance I `{State.Trait} : core.convert.From.Trait Self (T := u8) := {
    core.convert.From.from := from;
  }.
  Global Hint Resolve I : core.
End Impl_core_convert_From_for_subtle_Choice.

Module ConstantTimeEq.
  Class Trait (Self : Set) `{State.Trait} : Type := {
    ct_eq : (ref Self) -> (ref Self) -> M subtle.Choice;
  }.
  
  Global Instance Method_ct_eq `{State.Trait} `(Trait)
    : Notation.Dot "ct_eq" := {
    Notation.dot := ct_eq;
  }.
  Global Instance Method_ct_ne `{State.Trait} `(Trait)
    : Notation.Dot "ct_ne" := {
    Notation.dot (self : ref Self) (other : ref Self)
      :=
      (let* α0 := deref self _ in
      let* α1 := borrow α0 _ in
      let* α2 := deref other _ in
      let* α3 := borrow α2 _ in
      let* α4 := subtle.ConstantTimeEq.ct_eq α1 α3 in
      core.ops.bit.Not.not α4
      : M subtle.Choice);
  }.
End ConstantTimeEq.

Module Impl_subtle_ConstantTimeEq_for_Slice_T.
  Section Impl_subtle_ConstantTimeEq_for_Slice_T.
    Context {T : Set}.
    Context `{subtle.ConstantTimeEq.Trait T}.
    Definition Self `{State.Trait} := Slice T.
    
    Definition ct_eq
        `{State.Trait}
        (self : ref Self)
        (_rhs : ref (Slice T))
        : M subtle.Choice :=
      let* len :=
        let* α0 := deref self (Slice _) in
        let* α1 := borrow α0 (Slice _) in
        (Slice _)::["len"] α1 in
      let* _ :=
        let* α0 := deref _rhs (Slice _) in
        let* α1 := borrow α0 (Slice _) in
        let* α2 := (Slice _)::["len"] α1 in
        let* α3 := ne len α2 in
        let* α4 := use α3 in
        if (α4 : bool) then
          let* _ :=
            let* α0 := M.alloc 0 in
            let* α1 := core.convert.From.from α0 in
            Return α1 in
          never_to_any tt
        else
          Pure tt in
      let* x := M.alloc 1 in
      let* _ :=
        let* α0 := deref self (Slice _) in
        let* α1 := borrow α0 (Slice _) in
        let* α2 := (Slice _)::["iter"] α1 in
        let* α3 := deref _rhs (Slice _) in
        let* α4 := borrow α3 (Slice _) in
        let* α5 := (Slice _)::["iter"] α4 in
        let* α6 := core.iter.traits.iterator.Iterator.zip α2 α5 in
        let* α7 := core.iter.traits.collect.IntoIterator.into_iter α6 in
        let* α8 :=
          match α7 with
          | iter =>
            loop
              (let* _ :=
                let* α0 :=
                  borrow_mut
                    iter
                    (core.iter.adapters.zip.Zip
                      (core.slice.iter.Iter _)
                      (core.slice.iter.Iter _)) in
                let* α1 :=
                  deref
                    α0
                    (core.iter.adapters.zip.Zip
                      (core.slice.iter.Iter _)
                      (core.slice.iter.Iter _)) in
                let* α2 :=
                  borrow_mut
                    α1
                    (core.iter.adapters.zip.Zip
                      (core.slice.iter.Iter _)
                      (core.slice.iter.Iter _)) in
                let* α3 := core.iter.traits.iterator.Iterator.next α2 in
                match α3 with
                | core.option.Option  =>
                  let* α0 := Break in
                  never_to_any α0
                | core.option.Option (ai, bi) =>
                  let* _ :=
                    let* α0 := deref ai _ in
                    let* α1 := borrow α0 _ in
                    let* α2 := deref bi _ in
                    let* α3 := borrow α2 _ in
                    let* α4 := subtle.ConstantTimeEq.ct_eq α1 α3 in
                    let* α5 := borrow α4 subtle.Choice in
                    let* α6 := subtle.Choice::["unwrap_u8"] α5 in
                    assign_op bitand x α6 in
                  Pure tt
                end in
              Pure tt)
          end in
        use α8 in
      core.convert.Into.into x.
    
    Global Instance Method_ct_eq `{State.Trait} : Notation.Dot "ct_eq" := {
      Notation.dot := ct_eq;
    }.
    
    Global Instance I `{State.Trait} : subtle.ConstantTimeEq.Trait Self := {
      subtle.ConstantTimeEq.ct_eq := ct_eq;
    }.
  End Impl_subtle_ConstantTimeEq_for_Slice_T.
  Global Hint Resolve I : core.
End Impl_subtle_ConstantTimeEq_for_Slice_T.

Module Impl_subtle_ConstantTimeEq_for_subtle_Choice.
  Definition Self `{State.Trait} := subtle.Choice.
  
  Definition ct_eq
      `{State.Trait}
      (self : ref Self)
      (rhs : ref subtle.Choice)
      : M subtle.Choice :=
    let* α0 := deref self subtle.Choice in
    let* α1 := deref rhs subtle.Choice in
    let* α2 := core.ops.bit.BitXor.bitxor α0 α1 in
    core.ops.bit.Not.not α2.
  
  Global Instance Method_ct_eq `{State.Trait} : Notation.Dot "ct_eq" := {
    Notation.dot := ct_eq;
  }.
  
  Global Instance I `{State.Trait} : subtle.ConstantTimeEq.Trait Self := {
    subtle.ConstantTimeEq.ct_eq := ct_eq;
  }.
  Global Hint Resolve I : core.
End Impl_subtle_ConstantTimeEq_for_subtle_Choice.

Module Impl_subtle_ConstantTimeEq_for_u8.
  Definition Self `{State.Trait} := u8.
  
  Definition ct_eq
      `{State.Trait}
      (self : ref Self)
      (other : ref u8)
      : M subtle.Choice :=
    let* x := core.ops.bit.BitXor.bitxor self other in
    let* y :=
      let* α0 := u8::["wrapping_neg"] x in
      let* α1 := bitor x α0 in
      let* α2 := M.alloc 8 in
      let* α3 := M.alloc 1 in
      let* α4 := sub α2 α3 in
      shr α1 α4 in
    let* α0 := M.alloc 1 in
    let* α1 := use α0 in
    let* α2 := bitxor y α1 in
    let* α3 := use α2 in
    core.convert.Into.into α3.
  
  Global Instance Method_ct_eq `{State.Trait} : Notation.Dot "ct_eq" := {
    Notation.dot := ct_eq;
  }.
  
  Global Instance I `{State.Trait} : subtle.ConstantTimeEq.Trait Self := {
    subtle.ConstantTimeEq.ct_eq := ct_eq;
  }.
  Global Hint Resolve I : core.
End Impl_subtle_ConstantTimeEq_for_u8.

Module Impl_subtle_ConstantTimeEq_for_i8.
  Definition Self `{State.Trait} := i8.
  
  Definition ct_eq
      `{State.Trait}
      (self : ref Self)
      (other : ref i8)
      : M subtle.Choice :=
    let* α0 := deref self i8 in
    let* α1 := cast α0 in
    let* α2 := borrow α1 u8 in
    let* α3 := deref other i8 in
    let* α4 := cast α3 in
    let* α5 := borrow α4 u8 in
    let* α6 := deref α5 u8 in
    let* α7 := borrow α6 u8 in
    subtle.ConstantTimeEq.ct_eq α2 α7.
  
  Global Instance Method_ct_eq `{State.Trait} : Notation.Dot "ct_eq" := {
    Notation.dot := ct_eq;
  }.
  
  Global Instance I `{State.Trait} : subtle.ConstantTimeEq.Trait Self := {
    subtle.ConstantTimeEq.ct_eq := ct_eq;
  }.
  Global Hint Resolve I : core.
End Impl_subtle_ConstantTimeEq_for_i8.

Module Impl_subtle_ConstantTimeEq_for_u16.
  Definition Self `{State.Trait} := u16.
  
  Definition ct_eq
      `{State.Trait}
      (self : ref Self)
      (other : ref u16)
      : M subtle.Choice :=
    let* x := core.ops.bit.BitXor.bitxor self other in
    let* y :=
      let* α0 := u16::["wrapping_neg"] x in
      let* α1 := bitor x α0 in
      let* α2 := M.alloc 16 in
      let* α3 := M.alloc 1 in
      let* α4 := sub α2 α3 in
      shr α1 α4 in
    let* α0 := M.alloc 1 in
    let* α1 := use α0 in
    let* α2 := bitxor y α1 in
    let* α3 := cast α2 in
    core.convert.Into.into α3.
  
  Global Instance Method_ct_eq `{State.Trait} : Notation.Dot "ct_eq" := {
    Notation.dot := ct_eq;
  }.
  
  Global Instance I `{State.Trait} : subtle.ConstantTimeEq.Trait Self := {
    subtle.ConstantTimeEq.ct_eq := ct_eq;
  }.
  Global Hint Resolve I : core.
End Impl_subtle_ConstantTimeEq_for_u16.

Module Impl_subtle_ConstantTimeEq_for_i16.
  Definition Self `{State.Trait} := i16.
  
  Definition ct_eq
      `{State.Trait}
      (self : ref Self)
      (other : ref i16)
      : M subtle.Choice :=
    let* α0 := deref self i16 in
    let* α1 := cast α0 in
    let* α2 := borrow α1 u16 in
    let* α3 := deref other i16 in
    let* α4 := cast α3 in
    let* α5 := borrow α4 u16 in
    let* α6 := deref α5 u16 in
    let* α7 := borrow α6 u16 in
    subtle.ConstantTimeEq.ct_eq α2 α7.
  
  Global Instance Method_ct_eq `{State.Trait} : Notation.Dot "ct_eq" := {
    Notation.dot := ct_eq;
  }.
  
  Global Instance I `{State.Trait} : subtle.ConstantTimeEq.Trait Self := {
    subtle.ConstantTimeEq.ct_eq := ct_eq;
  }.
  Global Hint Resolve I : core.
End Impl_subtle_ConstantTimeEq_for_i16.

Module Impl_subtle_ConstantTimeEq_for_u32.
  Definition Self `{State.Trait} := u32.
  
  Definition ct_eq
      `{State.Trait}
      (self : ref Self)
      (other : ref u32)
      : M subtle.Choice :=
    let* x := core.ops.bit.BitXor.bitxor self other in
    let* y :=
      let* α0 := u32::["wrapping_neg"] x in
      let* α1 := bitor x α0 in
      let* α2 := M.alloc 32 in
      let* α3 := M.alloc 1 in
      let* α4 := sub α2 α3 in
      shr α1 α4 in
    let* α0 := M.alloc 1 in
    let* α1 := use α0 in
    let* α2 := bitxor y α1 in
    let* α3 := cast α2 in
    core.convert.Into.into α3.
  
  Global Instance Method_ct_eq `{State.Trait} : Notation.Dot "ct_eq" := {
    Notation.dot := ct_eq;
  }.
  
  Global Instance I `{State.Trait} : subtle.ConstantTimeEq.Trait Self := {
    subtle.ConstantTimeEq.ct_eq := ct_eq;
  }.
  Global Hint Resolve I : core.
End Impl_subtle_ConstantTimeEq_for_u32.

Module Impl_subtle_ConstantTimeEq_for_i32.
  Definition Self `{State.Trait} := i32.
  
  Definition ct_eq
      `{State.Trait}
      (self : ref Self)
      (other : ref i32)
      : M subtle.Choice :=
    let* α0 := deref self i32 in
    let* α1 := cast α0 in
    let* α2 := borrow α1 u32 in
    let* α3 := deref other i32 in
    let* α4 := cast α3 in
    let* α5 := borrow α4 u32 in
    let* α6 := deref α5 u32 in
    let* α7 := borrow α6 u32 in
    subtle.ConstantTimeEq.ct_eq α2 α7.
  
  Global Instance Method_ct_eq `{State.Trait} : Notation.Dot "ct_eq" := {
    Notation.dot := ct_eq;
  }.
  
  Global Instance I `{State.Trait} : subtle.ConstantTimeEq.Trait Self := {
    subtle.ConstantTimeEq.ct_eq := ct_eq;
  }.
  Global Hint Resolve I : core.
End Impl_subtle_ConstantTimeEq_for_i32.

Module Impl_subtle_ConstantTimeEq_for_u64.
  Definition Self `{State.Trait} := u64.
  
  Definition ct_eq
      `{State.Trait}
      (self : ref Self)
      (other : ref u64)
      : M subtle.Choice :=
    let* x := core.ops.bit.BitXor.bitxor self other in
    let* y :=
      let* α0 := u64::["wrapping_neg"] x in
      let* α1 := bitor x α0 in
      let* α2 := M.alloc 64 in
      let* α3 := M.alloc 1 in
      let* α4 := sub α2 α3 in
      shr α1 α4 in
    let* α0 := M.alloc 1 in
    let* α1 := use α0 in
    let* α2 := bitxor y α1 in
    let* α3 := cast α2 in
    core.convert.Into.into α3.
  
  Global Instance Method_ct_eq `{State.Trait} : Notation.Dot "ct_eq" := {
    Notation.dot := ct_eq;
  }.
  
  Global Instance I `{State.Trait} : subtle.ConstantTimeEq.Trait Self := {
    subtle.ConstantTimeEq.ct_eq := ct_eq;
  }.
  Global Hint Resolve I : core.
End Impl_subtle_ConstantTimeEq_for_u64.

Module Impl_subtle_ConstantTimeEq_for_i64.
  Definition Self `{State.Trait} := i64.
  
  Definition ct_eq
      `{State.Trait}
      (self : ref Self)
      (other : ref i64)
      : M subtle.Choice :=
    let* α0 := deref self i64 in
    let* α1 := cast α0 in
    let* α2 := borrow α1 u64 in
    let* α3 := deref other i64 in
    let* α4 := cast α3 in
    let* α5 := borrow α4 u64 in
    let* α6 := deref α5 u64 in
    let* α7 := borrow α6 u64 in
    subtle.ConstantTimeEq.ct_eq α2 α7.
  
  Global Instance Method_ct_eq `{State.Trait} : Notation.Dot "ct_eq" := {
    Notation.dot := ct_eq;
  }.
  
  Global Instance I `{State.Trait} : subtle.ConstantTimeEq.Trait Self := {
    subtle.ConstantTimeEq.ct_eq := ct_eq;
  }.
  Global Hint Resolve I : core.
End Impl_subtle_ConstantTimeEq_for_i64.

Module Impl_subtle_ConstantTimeEq_for_usize.
  Definition Self `{State.Trait} := usize.
  
  Definition ct_eq
      `{State.Trait}
      (self : ref Self)
      (other : ref usize)
      : M subtle.Choice :=
    let* x := core.ops.bit.BitXor.bitxor self other in
    let* y :=
      let* α0 := usize::["wrapping_neg"] x in
      let* α1 := bitor x α0 in
      let* α2 := core.mem.size_of in
      let* α3 := M.alloc 8 in
      let* α4 := mul α2 α3 in
      let* α5 := M.alloc 1 in
      let* α6 := sub α4 α5 in
      shr α1 α6 in
    let* α0 := M.alloc 1 in
    let* α1 := use α0 in
    let* α2 := bitxor y α1 in
    let* α3 := cast α2 in
    core.convert.Into.into α3.
  
  Global Instance Method_ct_eq `{State.Trait} : Notation.Dot "ct_eq" := {
    Notation.dot := ct_eq;
  }.
  
  Global Instance I `{State.Trait} : subtle.ConstantTimeEq.Trait Self := {
    subtle.ConstantTimeEq.ct_eq := ct_eq;
  }.
  Global Hint Resolve I : core.
End Impl_subtle_ConstantTimeEq_for_usize.

Module Impl_subtle_ConstantTimeEq_for_isize.
  Definition Self `{State.Trait} := isize.
  
  Definition ct_eq
      `{State.Trait}
      (self : ref Self)
      (other : ref isize)
      : M subtle.Choice :=
    let* α0 := deref self isize in
    let* α1 := cast α0 in
    let* α2 := borrow α1 usize in
    let* α3 := deref other isize in
    let* α4 := cast α3 in
    let* α5 := borrow α4 usize in
    let* α6 := deref α5 usize in
    let* α7 := borrow α6 usize in
    subtle.ConstantTimeEq.ct_eq α2 α7.
  
  Global Instance Method_ct_eq `{State.Trait} : Notation.Dot "ct_eq" := {
    Notation.dot := ct_eq;
  }.
  
  Global Instance I `{State.Trait} : subtle.ConstantTimeEq.Trait Self := {
    subtle.ConstantTimeEq.ct_eq := ct_eq;
  }.
  Global Hint Resolve I : core.
End Impl_subtle_ConstantTimeEq_for_isize.

Module ConditionallySelectable.
  Class Trait (Self : Set) `{core.marker.Copy.Trait Self} `{State.Trait} :
      Type := {
    conditional_select : (ref Self) -> (ref Self) -> subtle.Choice -> M Self;
  }.
  
  Global Instance Method_conditional_select `{State.Trait} `(Trait)
    : Notation.Dot "conditional_select" := {
    Notation.dot := conditional_select;
  }.
  Global Instance Method_conditional_assign `{State.Trait} `(Trait)
    : Notation.Dot "conditional_assign" := {
    Notation.dot
      (self : mut_ref Self)
      (other : ref Self)
      (choice : subtle.Choice)
      :=
      (let* _ :=
        let* α0 := deref self _ in
        let* α1 := deref self _ in
        let* α2 := borrow α1 _ in
        let* α3 := deref other _ in
        let* α4 := borrow α3 _ in
        let* α5 :=
          subtle.ConditionallySelectable.conditional_select α2 α4 choice in
        assign α0 α5 in
      Pure tt
      : M unit);
  }.
  Global Instance Method_conditional_swap `{State.Trait} `(Trait)
    : Notation.Dot "conditional_swap" := {
    Notation.dot (a : mut_ref Self) (b : mut_ref Self) (choice : subtle.Choice)
      :=
      (let* t := deref a _ in
      let* _ :=
        let* α0 := deref a _ in
        let* α1 := borrow_mut α0 _ in
        let* α2 := borrow b (mut_ref _) in
        let* α3 := deref α2 (mut_ref _) in
        let* α4 := deref α3 _ in
        let* α5 := borrow α4 _ in
        subtle.ConditionallySelectable.conditional_assign α1 α5 choice in
      let* _ :=
        let* α0 := deref b _ in
        let* α1 := borrow_mut α0 _ in
        let* α2 := borrow t _ in
        let* α3 := deref α2 _ in
        let* α4 := borrow α3 _ in
        subtle.ConditionallySelectable.conditional_assign α1 α4 choice in
      Pure tt
      : M unit);
  }.
End ConditionallySelectable.

Module Impl_subtle_ConditionallySelectable_for_u8.
  Definition Self `{State.Trait} := u8.
  
  Definition conditional_select
      `{State.Trait}
      (a : ref Self)
      (b : ref Self)
      (choice : subtle.Choice)
      : M Self :=
    let* mask :=
      let* α0 := borrow choice subtle.Choice in
      let* α1 := subtle.Choice::["unwrap_u8"] α0 in
      let* α2 := cast α1 in
      let* α3 := neg α2 in
      cast α3 in
    let* α0 := core.ops.bit.BitXor.bitxor a b in
    let* α1 := bitand mask α0 in
    core.ops.bit.BitXor.bitxor a α1.
  
  Global Instance AssociatedFunction_conditional_select `{State.Trait} :
    Notation.DoubleColon Self "conditional_select" := {
    Notation.double_colon := conditional_select;
  }.
  
  Definition conditional_assign
      `{State.Trait}
      (self : mut_ref Self)
      (other : ref Self)
      (choice : subtle.Choice)
      : M unit :=
    let* mask :=
      let* α0 := borrow choice subtle.Choice in
      let* α1 := subtle.Choice::["unwrap_u8"] α0 in
      let* α2 := cast α1 in
      let* α3 := neg α2 in
      cast α3 in
    let* _ :=
      let* α0 := deref self u8 in
      let* α1 := deref self u8 in
      let* α2 := deref other u8 in
      let* α3 := bitxor α1 α2 in
      let* α4 := bitand mask α3 in
      assign_op bitxor α0 α4 in
    Pure tt.
  
  Global Instance Method_conditional_assign `{State.Trait} :
    Notation.Dot "conditional_assign" := {
    Notation.dot := conditional_assign;
  }.
  
  Definition conditional_swap
      `{State.Trait}
      (a : mut_ref Self)
      (b : mut_ref Self)
      (choice : subtle.Choice)
      : M unit :=
    let* mask :=
      let* α0 := borrow choice subtle.Choice in
      let* α1 := subtle.Choice::["unwrap_u8"] α0 in
      let* α2 := cast α1 in
      let* α3 := neg α2 in
      cast α3 in
    let* t :=
      let* α0 := deref a u8 in
      let* α1 := deref b u8 in
      let* α2 := bitxor α0 α1 in
      bitand mask α2 in
    let* _ :=
      let* α0 := deref a u8 in
      assign_op bitxor α0 t in
    let* _ :=
      let* α0 := deref b u8 in
      assign_op bitxor α0 t in
    Pure tt.
  
  Global Instance AssociatedFunction_conditional_swap `{State.Trait} :
    Notation.DoubleColon Self "conditional_swap" := {
    Notation.double_colon := conditional_swap;
  }.
  
  Global Instance I `{State.Trait}
    : subtle.ConditionallySelectable.Trait Self := {
    subtle.ConditionallySelectable.conditional_select := conditional_select;
  }.
  Global Hint Resolve I : core.
End Impl_subtle_ConditionallySelectable_for_u8.

Module Impl_subtle_ConditionallySelectable_for_i8.
  Definition Self `{State.Trait} := i8.
  
  Definition conditional_select
      `{State.Trait}
      (a : ref Self)
      (b : ref Self)
      (choice : subtle.Choice)
      : M Self :=
    let* mask :=
      let* α0 := borrow choice subtle.Choice in
      let* α1 := subtle.Choice::["unwrap_u8"] α0 in
      let* α2 := cast α1 in
      let* α3 := neg α2 in
      use α3 in
    let* α0 := core.ops.bit.BitXor.bitxor a b in
    let* α1 := bitand mask α0 in
    core.ops.bit.BitXor.bitxor a α1.
  
  Global Instance AssociatedFunction_conditional_select `{State.Trait} :
    Notation.DoubleColon Self "conditional_select" := {
    Notation.double_colon := conditional_select;
  }.
  
  Definition conditional_assign
      `{State.Trait}
      (self : mut_ref Self)
      (other : ref Self)
      (choice : subtle.Choice)
      : M unit :=
    let* mask :=
      let* α0 := borrow choice subtle.Choice in
      let* α1 := subtle.Choice::["unwrap_u8"] α0 in
      let* α2 := cast α1 in
      let* α3 := neg α2 in
      use α3 in
    let* _ :=
      let* α0 := deref self i8 in
      let* α1 := deref self i8 in
      let* α2 := deref other i8 in
      let* α3 := bitxor α1 α2 in
      let* α4 := bitand mask α3 in
      assign_op bitxor α0 α4 in
    Pure tt.
  
  Global Instance Method_conditional_assign `{State.Trait} :
    Notation.Dot "conditional_assign" := {
    Notation.dot := conditional_assign;
  }.
  
  Definition conditional_swap
      `{State.Trait}
      (a : mut_ref Self)
      (b : mut_ref Self)
      (choice : subtle.Choice)
      : M unit :=
    let* mask :=
      let* α0 := borrow choice subtle.Choice in
      let* α1 := subtle.Choice::["unwrap_u8"] α0 in
      let* α2 := cast α1 in
      let* α3 := neg α2 in
      use α3 in
    let* t :=
      let* α0 := deref a i8 in
      let* α1 := deref b i8 in
      let* α2 := bitxor α0 α1 in
      bitand mask α2 in
    let* _ :=
      let* α0 := deref a i8 in
      assign_op bitxor α0 t in
    let* _ :=
      let* α0 := deref b i8 in
      assign_op bitxor α0 t in
    Pure tt.
  
  Global Instance AssociatedFunction_conditional_swap `{State.Trait} :
    Notation.DoubleColon Self "conditional_swap" := {
    Notation.double_colon := conditional_swap;
  }.
  
  Global Instance I `{State.Trait}
    : subtle.ConditionallySelectable.Trait Self := {
    subtle.ConditionallySelectable.conditional_select := conditional_select;
  }.
  Global Hint Resolve I : core.
End Impl_subtle_ConditionallySelectable_for_i8.

Module Impl_subtle_ConditionallySelectable_for_u16.
  Definition Self `{State.Trait} := u16.
  
  Definition conditional_select
      `{State.Trait}
      (a : ref Self)
      (b : ref Self)
      (choice : subtle.Choice)
      : M Self :=
    let* mask :=
      let* α0 := borrow choice subtle.Choice in
      let* α1 := subtle.Choice::["unwrap_u8"] α0 in
      let* α2 := cast α1 in
      let* α3 := neg α2 in
      cast α3 in
    let* α0 := core.ops.bit.BitXor.bitxor a b in
    let* α1 := bitand mask α0 in
    core.ops.bit.BitXor.bitxor a α1.
  
  Global Instance AssociatedFunction_conditional_select `{State.Trait} :
    Notation.DoubleColon Self "conditional_select" := {
    Notation.double_colon := conditional_select;
  }.
  
  Definition conditional_assign
      `{State.Trait}
      (self : mut_ref Self)
      (other : ref Self)
      (choice : subtle.Choice)
      : M unit :=
    let* mask :=
      let* α0 := borrow choice subtle.Choice in
      let* α1 := subtle.Choice::["unwrap_u8"] α0 in
      let* α2 := cast α1 in
      let* α3 := neg α2 in
      cast α3 in
    let* _ :=
      let* α0 := deref self u16 in
      let* α1 := deref self u16 in
      let* α2 := deref other u16 in
      let* α3 := bitxor α1 α2 in
      let* α4 := bitand mask α3 in
      assign_op bitxor α0 α4 in
    Pure tt.
  
  Global Instance Method_conditional_assign `{State.Trait} :
    Notation.Dot "conditional_assign" := {
    Notation.dot := conditional_assign;
  }.
  
  Definition conditional_swap
      `{State.Trait}
      (a : mut_ref Self)
      (b : mut_ref Self)
      (choice : subtle.Choice)
      : M unit :=
    let* mask :=
      let* α0 := borrow choice subtle.Choice in
      let* α1 := subtle.Choice::["unwrap_u8"] α0 in
      let* α2 := cast α1 in
      let* α3 := neg α2 in
      cast α3 in
    let* t :=
      let* α0 := deref a u16 in
      let* α1 := deref b u16 in
      let* α2 := bitxor α0 α1 in
      bitand mask α2 in
    let* _ :=
      let* α0 := deref a u16 in
      assign_op bitxor α0 t in
    let* _ :=
      let* α0 := deref b u16 in
      assign_op bitxor α0 t in
    Pure tt.
  
  Global Instance AssociatedFunction_conditional_swap `{State.Trait} :
    Notation.DoubleColon Self "conditional_swap" := {
    Notation.double_colon := conditional_swap;
  }.
  
  Global Instance I `{State.Trait}
    : subtle.ConditionallySelectable.Trait Self := {
    subtle.ConditionallySelectable.conditional_select := conditional_select;
  }.
  Global Hint Resolve I : core.
End Impl_subtle_ConditionallySelectable_for_u16.

Module Impl_subtle_ConditionallySelectable_for_i16.
  Definition Self `{State.Trait} := i16.
  
  Definition conditional_select
      `{State.Trait}
      (a : ref Self)
      (b : ref Self)
      (choice : subtle.Choice)
      : M Self :=
    let* mask :=
      let* α0 := borrow choice subtle.Choice in
      let* α1 := subtle.Choice::["unwrap_u8"] α0 in
      let* α2 := cast α1 in
      let* α3 := neg α2 in
      use α3 in
    let* α0 := core.ops.bit.BitXor.bitxor a b in
    let* α1 := bitand mask α0 in
    core.ops.bit.BitXor.bitxor a α1.
  
  Global Instance AssociatedFunction_conditional_select `{State.Trait} :
    Notation.DoubleColon Self "conditional_select" := {
    Notation.double_colon := conditional_select;
  }.
  
  Definition conditional_assign
      `{State.Trait}
      (self : mut_ref Self)
      (other : ref Self)
      (choice : subtle.Choice)
      : M unit :=
    let* mask :=
      let* α0 := borrow choice subtle.Choice in
      let* α1 := subtle.Choice::["unwrap_u8"] α0 in
      let* α2 := cast α1 in
      let* α3 := neg α2 in
      use α3 in
    let* _ :=
      let* α0 := deref self i16 in
      let* α1 := deref self i16 in
      let* α2 := deref other i16 in
      let* α3 := bitxor α1 α2 in
      let* α4 := bitand mask α3 in
      assign_op bitxor α0 α4 in
    Pure tt.
  
  Global Instance Method_conditional_assign `{State.Trait} :
    Notation.Dot "conditional_assign" := {
    Notation.dot := conditional_assign;
  }.
  
  Definition conditional_swap
      `{State.Trait}
      (a : mut_ref Self)
      (b : mut_ref Self)
      (choice : subtle.Choice)
      : M unit :=
    let* mask :=
      let* α0 := borrow choice subtle.Choice in
      let* α1 := subtle.Choice::["unwrap_u8"] α0 in
      let* α2 := cast α1 in
      let* α3 := neg α2 in
      use α3 in
    let* t :=
      let* α0 := deref a i16 in
      let* α1 := deref b i16 in
      let* α2 := bitxor α0 α1 in
      bitand mask α2 in
    let* _ :=
      let* α0 := deref a i16 in
      assign_op bitxor α0 t in
    let* _ :=
      let* α0 := deref b i16 in
      assign_op bitxor α0 t in
    Pure tt.
  
  Global Instance AssociatedFunction_conditional_swap `{State.Trait} :
    Notation.DoubleColon Self "conditional_swap" := {
    Notation.double_colon := conditional_swap;
  }.
  
  Global Instance I `{State.Trait}
    : subtle.ConditionallySelectable.Trait Self := {
    subtle.ConditionallySelectable.conditional_select := conditional_select;
  }.
  Global Hint Resolve I : core.
End Impl_subtle_ConditionallySelectable_for_i16.

Module Impl_subtle_ConditionallySelectable_for_u32.
  Definition Self `{State.Trait} := u32.
  
  Definition conditional_select
      `{State.Trait}
      (a : ref Self)
      (b : ref Self)
      (choice : subtle.Choice)
      : M Self :=
    let* mask :=
      let* α0 := borrow choice subtle.Choice in
      let* α1 := subtle.Choice::["unwrap_u8"] α0 in
      let* α2 := cast α1 in
      let* α3 := neg α2 in
      cast α3 in
    let* α0 := core.ops.bit.BitXor.bitxor a b in
    let* α1 := bitand mask α0 in
    core.ops.bit.BitXor.bitxor a α1.
  
  Global Instance AssociatedFunction_conditional_select `{State.Trait} :
    Notation.DoubleColon Self "conditional_select" := {
    Notation.double_colon := conditional_select;
  }.
  
  Definition conditional_assign
      `{State.Trait}
      (self : mut_ref Self)
      (other : ref Self)
      (choice : subtle.Choice)
      : M unit :=
    let* mask :=
      let* α0 := borrow choice subtle.Choice in
      let* α1 := subtle.Choice::["unwrap_u8"] α0 in
      let* α2 := cast α1 in
      let* α3 := neg α2 in
      cast α3 in
    let* _ :=
      let* α0 := deref self u32 in
      let* α1 := deref self u32 in
      let* α2 := deref other u32 in
      let* α3 := bitxor α1 α2 in
      let* α4 := bitand mask α3 in
      assign_op bitxor α0 α4 in
    Pure tt.
  
  Global Instance Method_conditional_assign `{State.Trait} :
    Notation.Dot "conditional_assign" := {
    Notation.dot := conditional_assign;
  }.
  
  Definition conditional_swap
      `{State.Trait}
      (a : mut_ref Self)
      (b : mut_ref Self)
      (choice : subtle.Choice)
      : M unit :=
    let* mask :=
      let* α0 := borrow choice subtle.Choice in
      let* α1 := subtle.Choice::["unwrap_u8"] α0 in
      let* α2 := cast α1 in
      let* α3 := neg α2 in
      cast α3 in
    let* t :=
      let* α0 := deref a u32 in
      let* α1 := deref b u32 in
      let* α2 := bitxor α0 α1 in
      bitand mask α2 in
    let* _ :=
      let* α0 := deref a u32 in
      assign_op bitxor α0 t in
    let* _ :=
      let* α0 := deref b u32 in
      assign_op bitxor α0 t in
    Pure tt.
  
  Global Instance AssociatedFunction_conditional_swap `{State.Trait} :
    Notation.DoubleColon Self "conditional_swap" := {
    Notation.double_colon := conditional_swap;
  }.
  
  Global Instance I `{State.Trait}
    : subtle.ConditionallySelectable.Trait Self := {
    subtle.ConditionallySelectable.conditional_select := conditional_select;
  }.
  Global Hint Resolve I : core.
End Impl_subtle_ConditionallySelectable_for_u32.

Module Impl_subtle_ConditionallySelectable_for_i32.
  Definition Self `{State.Trait} := i32.
  
  Definition conditional_select
      `{State.Trait}
      (a : ref Self)
      (b : ref Self)
      (choice : subtle.Choice)
      : M Self :=
    let* mask :=
      let* α0 := borrow choice subtle.Choice in
      let* α1 := subtle.Choice::["unwrap_u8"] α0 in
      let* α2 := cast α1 in
      let* α3 := neg α2 in
      use α3 in
    let* α0 := core.ops.bit.BitXor.bitxor a b in
    let* α1 := bitand mask α0 in
    core.ops.bit.BitXor.bitxor a α1.
  
  Global Instance AssociatedFunction_conditional_select `{State.Trait} :
    Notation.DoubleColon Self "conditional_select" := {
    Notation.double_colon := conditional_select;
  }.
  
  Definition conditional_assign
      `{State.Trait}
      (self : mut_ref Self)
      (other : ref Self)
      (choice : subtle.Choice)
      : M unit :=
    let* mask :=
      let* α0 := borrow choice subtle.Choice in
      let* α1 := subtle.Choice::["unwrap_u8"] α0 in
      let* α2 := cast α1 in
      let* α3 := neg α2 in
      use α3 in
    let* _ :=
      let* α0 := deref self i32 in
      let* α1 := deref self i32 in
      let* α2 := deref other i32 in
      let* α3 := bitxor α1 α2 in
      let* α4 := bitand mask α3 in
      assign_op bitxor α0 α4 in
    Pure tt.
  
  Global Instance Method_conditional_assign `{State.Trait} :
    Notation.Dot "conditional_assign" := {
    Notation.dot := conditional_assign;
  }.
  
  Definition conditional_swap
      `{State.Trait}
      (a : mut_ref Self)
      (b : mut_ref Self)
      (choice : subtle.Choice)
      : M unit :=
    let* mask :=
      let* α0 := borrow choice subtle.Choice in
      let* α1 := subtle.Choice::["unwrap_u8"] α0 in
      let* α2 := cast α1 in
      let* α3 := neg α2 in
      use α3 in
    let* t :=
      let* α0 := deref a i32 in
      let* α1 := deref b i32 in
      let* α2 := bitxor α0 α1 in
      bitand mask α2 in
    let* _ :=
      let* α0 := deref a i32 in
      assign_op bitxor α0 t in
    let* _ :=
      let* α0 := deref b i32 in
      assign_op bitxor α0 t in
    Pure tt.
  
  Global Instance AssociatedFunction_conditional_swap `{State.Trait} :
    Notation.DoubleColon Self "conditional_swap" := {
    Notation.double_colon := conditional_swap;
  }.
  
  Global Instance I `{State.Trait}
    : subtle.ConditionallySelectable.Trait Self := {
    subtle.ConditionallySelectable.conditional_select := conditional_select;
  }.
  Global Hint Resolve I : core.
End Impl_subtle_ConditionallySelectable_for_i32.

Module Impl_subtle_ConditionallySelectable_for_u64.
  Definition Self `{State.Trait} := u64.
  
  Definition conditional_select
      `{State.Trait}
      (a : ref Self)
      (b : ref Self)
      (choice : subtle.Choice)
      : M Self :=
    let* mask :=
      let* α0 := borrow choice subtle.Choice in
      let* α1 := subtle.Choice::["unwrap_u8"] α0 in
      let* α2 := cast α1 in
      let* α3 := neg α2 in
      cast α3 in
    let* α0 := core.ops.bit.BitXor.bitxor a b in
    let* α1 := bitand mask α0 in
    core.ops.bit.BitXor.bitxor a α1.
  
  Global Instance AssociatedFunction_conditional_select `{State.Trait} :
    Notation.DoubleColon Self "conditional_select" := {
    Notation.double_colon := conditional_select;
  }.
  
  Definition conditional_assign
      `{State.Trait}
      (self : mut_ref Self)
      (other : ref Self)
      (choice : subtle.Choice)
      : M unit :=
    let* mask :=
      let* α0 := borrow choice subtle.Choice in
      let* α1 := subtle.Choice::["unwrap_u8"] α0 in
      let* α2 := cast α1 in
      let* α3 := neg α2 in
      cast α3 in
    let* _ :=
      let* α0 := deref self u64 in
      let* α1 := deref self u64 in
      let* α2 := deref other u64 in
      let* α3 := bitxor α1 α2 in
      let* α4 := bitand mask α3 in
      assign_op bitxor α0 α4 in
    Pure tt.
  
  Global Instance Method_conditional_assign `{State.Trait} :
    Notation.Dot "conditional_assign" := {
    Notation.dot := conditional_assign;
  }.
  
  Definition conditional_swap
      `{State.Trait}
      (a : mut_ref Self)
      (b : mut_ref Self)
      (choice : subtle.Choice)
      : M unit :=
    let* mask :=
      let* α0 := borrow choice subtle.Choice in
      let* α1 := subtle.Choice::["unwrap_u8"] α0 in
      let* α2 := cast α1 in
      let* α3 := neg α2 in
      cast α3 in
    let* t :=
      let* α0 := deref a u64 in
      let* α1 := deref b u64 in
      let* α2 := bitxor α0 α1 in
      bitand mask α2 in
    let* _ :=
      let* α0 := deref a u64 in
      assign_op bitxor α0 t in
    let* _ :=
      let* α0 := deref b u64 in
      assign_op bitxor α0 t in
    Pure tt.
  
  Global Instance AssociatedFunction_conditional_swap `{State.Trait} :
    Notation.DoubleColon Self "conditional_swap" := {
    Notation.double_colon := conditional_swap;
  }.
  
  Global Instance I `{State.Trait}
    : subtle.ConditionallySelectable.Trait Self := {
    subtle.ConditionallySelectable.conditional_select := conditional_select;
  }.
  Global Hint Resolve I : core.
End Impl_subtle_ConditionallySelectable_for_u64.

Module Impl_subtle_ConditionallySelectable_for_i64.
  Definition Self `{State.Trait} := i64.
  
  Definition conditional_select
      `{State.Trait}
      (a : ref Self)
      (b : ref Self)
      (choice : subtle.Choice)
      : M Self :=
    let* mask :=
      let* α0 := borrow choice subtle.Choice in
      let* α1 := subtle.Choice::["unwrap_u8"] α0 in
      let* α2 := cast α1 in
      let* α3 := neg α2 in
      use α3 in
    let* α0 := core.ops.bit.BitXor.bitxor a b in
    let* α1 := bitand mask α0 in
    core.ops.bit.BitXor.bitxor a α1.
  
  Global Instance AssociatedFunction_conditional_select `{State.Trait} :
    Notation.DoubleColon Self "conditional_select" := {
    Notation.double_colon := conditional_select;
  }.
  
  Definition conditional_assign
      `{State.Trait}
      (self : mut_ref Self)
      (other : ref Self)
      (choice : subtle.Choice)
      : M unit :=
    let* mask :=
      let* α0 := borrow choice subtle.Choice in
      let* α1 := subtle.Choice::["unwrap_u8"] α0 in
      let* α2 := cast α1 in
      let* α3 := neg α2 in
      use α3 in
    let* _ :=
      let* α0 := deref self i64 in
      let* α1 := deref self i64 in
      let* α2 := deref other i64 in
      let* α3 := bitxor α1 α2 in
      let* α4 := bitand mask α3 in
      assign_op bitxor α0 α4 in
    Pure tt.
  
  Global Instance Method_conditional_assign `{State.Trait} :
    Notation.Dot "conditional_assign" := {
    Notation.dot := conditional_assign;
  }.
  
  Definition conditional_swap
      `{State.Trait}
      (a : mut_ref Self)
      (b : mut_ref Self)
      (choice : subtle.Choice)
      : M unit :=
    let* mask :=
      let* α0 := borrow choice subtle.Choice in
      let* α1 := subtle.Choice::["unwrap_u8"] α0 in
      let* α2 := cast α1 in
      let* α3 := neg α2 in
      use α3 in
    let* t :=
      let* α0 := deref a i64 in
      let* α1 := deref b i64 in
      let* α2 := bitxor α0 α1 in
      bitand mask α2 in
    let* _ :=
      let* α0 := deref a i64 in
      assign_op bitxor α0 t in
    let* _ :=
      let* α0 := deref b i64 in
      assign_op bitxor α0 t in
    Pure tt.
  
  Global Instance AssociatedFunction_conditional_swap `{State.Trait} :
    Notation.DoubleColon Self "conditional_swap" := {
    Notation.double_colon := conditional_swap;
  }.
  
  Global Instance I `{State.Trait}
    : subtle.ConditionallySelectable.Trait Self := {
    subtle.ConditionallySelectable.conditional_select := conditional_select;
  }.
  Global Hint Resolve I : core.
End Impl_subtle_ConditionallySelectable_for_i64.

Module Impl_subtle_ConditionallySelectable_for_subtle_Choice.
  Definition Self `{State.Trait} := subtle.Choice.
  
  Definition conditional_select
      `{State.Trait}
      (a : ref Self)
      (b : ref Self)
      (choice : subtle.Choice)
      : M Self :=
    let* α0 := deref a subtle.Choice in
    let* α1 := α0.["0"] in
    let* α2 := borrow α1 u8 in
    let* α3 := deref α2 u8 in
    let* α4 := borrow α3 u8 in
    let* α5 := deref b subtle.Choice in
    let* α6 := α5.["0"] in
    let* α7 := borrow α6 u8 in
    let* α8 := deref α7 u8 in
    let* α9 := borrow α8 u8 in
    let* α10 :=
      subtle.ConditionallySelectable.conditional_select α4 α9 choice in
    Pure (subtle.Choice.Build_t α10).
  
  Global Instance AssociatedFunction_conditional_select `{State.Trait} :
    Notation.DoubleColon Self "conditional_select" := {
    Notation.double_colon := conditional_select;
  }.
  
  Global Instance I `{State.Trait}
    : subtle.ConditionallySelectable.Trait Self := {
    subtle.ConditionallySelectable.conditional_select := conditional_select;
  }.
  Global Hint Resolve I : core.
End Impl_subtle_ConditionallySelectable_for_subtle_Choice.

Module ConditionallyNegatable.
  Class Trait (Self : Set) `{State.Trait} : Type := {
    conditional_negate : (mut_ref Self) -> subtle.Choice -> M unit;
  }.
  
  Global Instance Method_conditional_negate `{State.Trait} `(Trait)
    : Notation.Dot "conditional_negate" := {
    Notation.dot := conditional_negate;
  }.
End ConditionallyNegatable.

Module Impl_subtle_ConditionallyNegatable_for_T.
  Section Impl_subtle_ConditionallyNegatable_for_T.
    Context {T : Set}.
    Context
      `{subtle.ConditionallySelectable.Trait T}
      `{core.ops.arith.Neg.Trait (ref T)}.
    Definition Self `{State.Trait} := T.
    
    Definition conditional_negate
        `{State.Trait}
        (self : mut_ref Self)
        (choice : subtle.Choice)
        : M unit :=
      let* self_neg :=
        let* α0 := deref self _ in
        let* α1 := borrow α0 _ in
        let* α2 := use α1 in
        core.ops.arith.Neg.neg (α2 : (ref _)) in
      let* _ :=
        let* α0 := deref self _ in
        let* α1 := borrow_mut α0 _ in
        let* α2 := borrow self_neg _ in
        let* α3 := deref α2 _ in
        let* α4 := borrow α3 _ in
        subtle.ConditionallySelectable.conditional_assign α1 α4 choice in
      Pure tt.
    
    Global Instance Method_conditional_negate `{State.Trait} :
      Notation.Dot "conditional_negate" := {
      Notation.dot := conditional_negate;
    }.
    
    Global Instance I `{State.Trait}
      : subtle.ConditionallyNegatable.Trait Self := {
      subtle.ConditionallyNegatable.conditional_negate := conditional_negate;
    }.
  End Impl_subtle_ConditionallyNegatable_for_T.
  Global Hint Resolve I : core.
End Impl_subtle_ConditionallyNegatable_for_T.

Module CtOption.
  Section CtOption.
    Context {T : Set}.
    Unset Primitive Projections.
    Record t `{State.Trait} : Set := {
      value : T;
      is_some : subtle.Choice;
    }.
    Global Set Primitive Projections.
    
    Global Instance Get_value `{State.Trait} : Notation.Dot "value" := {
      Notation.dot x := let* x := M.read x in Pure x.(value) : M _;
    }.
    Global Instance Get_AF_value `{State.Trait}
      : Notation.DoubleColon t "value" := {
      Notation.double_colon x := let* x := M.read x in Pure x.(value) : M _;
    }.
    Global Instance Get_is_some `{State.Trait} : Notation.Dot "is_some" := {
      Notation.dot x := let* x := M.read x in Pure x.(is_some) : M _;
    }.
    Global Instance Get_AF_is_some `{State.Trait}
      : Notation.DoubleColon t "is_some" := {
      Notation.double_colon x := let* x := M.read x in Pure x.(is_some) : M _;
    }.
  End CtOption.
End CtOption.
Definition CtOption (T : Set) `{State.Trait} : Set :=
  M.val (CtOption.t (T := T)).

Module Impl_core_clone_Clone_for_subtle_CtOption_T.
  Section Impl_core_clone_Clone_for_subtle_CtOption_T.
    Context {T : Set}.
    Context `{core.clone.Clone.Trait T}.
    Definition Self `{State.Trait} := subtle.CtOption T.
    
    Definition clone `{State.Trait} (self : ref Self) : M (subtle.CtOption T) :=
      let* α0 := deref self (subtle.CtOption _) in
      let* α1 := α0.["value"] in
      let* α2 := borrow α1 _ in
      let* α3 := deref α2 _ in
      let* α4 := borrow α3 _ in
      let* α5 := core.clone.Clone.clone α4 in
      let* α6 := deref self (subtle.CtOption _) in
      let* α7 := α6.["is_some"] in
      let* α8 := borrow α7 subtle.Choice in
      let* α9 := deref α8 subtle.Choice in
      let* α10 := borrow α9 subtle.Choice in
      let* α11 := core.clone.Clone.clone α10 in
      M.alloc
        {| subtle.CtOption.value := α5; subtle.CtOption.is_some := α11; |}.
    
    Global Instance Method_clone `{State.Trait} : Notation.Dot "clone" := {
      Notation.dot := clone;
    }.
    
    Global Instance I `{State.Trait} : core.clone.Clone.Trait Self := {
      core.clone.Clone.clone := clone;
    }.
  End Impl_core_clone_Clone_for_subtle_CtOption_T.
  Global Hint Resolve I : core.
End Impl_core_clone_Clone_for_subtle_CtOption_T.

Module Impl_core_marker_Copy_for_subtle_CtOption_T.
  Section Impl_core_marker_Copy_for_subtle_CtOption_T.
    Context {T : Set}.
    Context `{core.marker.Copy.Trait T}.
    Definition Self `{State.Trait} := subtle.CtOption T.
    
    Global Instance I `{State.Trait} : core.marker.Copy.Trait Self := {
    }.
  End Impl_core_marker_Copy_for_subtle_CtOption_T.
  Global Hint Resolve I : core.
End Impl_core_marker_Copy_for_subtle_CtOption_T.

Module Impl_core_fmt_Debug_for_subtle_CtOption_T.
  Section Impl_core_fmt_Debug_for_subtle_CtOption_T.
    Context {T : Set}.
    Context `{core.fmt.Debug.Trait T}.
    Definition Self `{State.Trait} := subtle.CtOption T.
    
    Definition fmt
        `{State.Trait}
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter)
        : M core.fmt.Result :=
      let* α0 := deref f core.fmt.Formatter in
      let* α1 := borrow_mut α0 core.fmt.Formatter in
      let* α2 := deref (mk_str "CtOption") str in
      let* α3 := borrow α2 str in
      let* α4 := deref (mk_str "value") str in
      let* α5 := borrow α4 str in
      let* α6 := deref self (subtle.CtOption _) in
      let* α7 := α6.["value"] in
      let* α8 := borrow α7 _ in
      let* α9 := deref α8 _ in
      let* α10 := borrow α9 _ in
      let* α11 := pointer_coercion "Unsize" α10 in
      let* α12 := deref (mk_str "is_some") str in
      let* α13 := borrow α12 str in
      let* α14 := deref self (subtle.CtOption _) in
      let* α15 := α14.["is_some"] in
      let* α16 := borrow α15 subtle.Choice in
      let* α17 := borrow α16 (ref subtle.Choice) in
      let* α18 := deref α17 (ref subtle.Choice) in
      let* α19 := borrow α18 (ref subtle.Choice) in
      let* α20 := pointer_coercion "Unsize" α19 in
      core.fmt.Formatter::["debug_struct_field2_finish"] α1 α3 α5 α11 α13 α20.
    
    Global Instance Method_fmt `{State.Trait} : Notation.Dot "fmt" := {
      Notation.dot := fmt;
    }.
    
    Global Instance I `{State.Trait} : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
  End Impl_core_fmt_Debug_for_subtle_CtOption_T.
  Global Hint Resolve I : core.
End Impl_core_fmt_Debug_for_subtle_CtOption_T.

Module Impl_core_convert_From_for_core_option_Option_T.
  Section Impl_core_convert_From_for_core_option_Option_T.
    Context {T : Set}.
    Definition Self `{State.Trait} := core.option.Option T.
    
    Definition from
        `{State.Trait}
        (source : subtle.CtOption T)
        : M (core.option.Option T) :=
      let* α0 := borrow source (subtle.CtOption _) in
      let* α1 := (subtle.CtOption _)::["is_some"] α0 in
      let* α2 := borrow α1 subtle.Choice in
      let* α3 := subtle.Choice::["unwrap_u8"] α2 in
      let* α4 := M.alloc 1 in
      let* α5 := eq α3 α4 in
      let* α6 := use α5 in
      if (α6 : bool) then
        let* α0 := source.["value"] in
        Pure (core.option.Option.Some α0)
      else
        Pure (core.option.Option.None tt).
    
    Global Instance AssociatedFunction_from `{State.Trait} :
      Notation.DoubleColon Self "from" := {
      Notation.double_colon := from;
    }.
    
    Global Instance I `{State.Trait}
      : core.convert.From.Trait Self (T := subtle.CtOption T) := {
      core.convert.From.from := from;
    }.
  End Impl_core_convert_From_for_core_option_Option_T.
  Global Hint Resolve I : core.
End Impl_core_convert_From_for_core_option_Option_T.

Module Impl_subtle_CtOption_T_4.
  Definition Self `{State.Trait} : Set := subtle.CtOption T.
  
  Definition new
      `{State.Trait}
      (value : T)
      (is_some : subtle.Choice)
      : M (subtle.CtOption T) :=
    M.alloc
      {| subtle.CtOption.value := value; subtle.CtOption.is_some := is_some; |}.
  
  Global Instance AssociatedFunction_new `{State.Trait} :
    Notation.DoubleColon Self "new" := {
    Notation.double_colon := new;
  }.
  
  Definition expect `{State.Trait} (self : Self) (msg : ref str) : M T :=
    let* _ :=
      let* α0 := self.["is_some"] in
      let* α1 := borrow α0 subtle.Choice in
      let* α2 := subtle.Choice::["unwrap_u8"] α1 in
      let* α3 := borrow α2 u8 in
      let* α4 := M.alloc 1 in
      let* α5 := borrow α4 u8 in
      match (α3, α5) with
      | (left_val, right_val) =>
        let* α0 := deref left_val u8 in
        let* α1 := deref right_val u8 in
        let* α2 := eq α0 α1 in
        let* α3 := not α2 in
        let* α4 := use α3 in
        if (α4 : bool) then
          let kind := core.panicking.AssertKind.Eq tt in
          let* _ :=
            let* α0 := deref left_val u8 in
            let* α1 := borrow α0 u8 in
            let* α2 := deref α1 u8 in
            let* α3 := borrow α2 u8 in
            let* α4 := deref right_val u8 in
            let* α5 := borrow α4 u8 in
            let* α6 := deref α5 u8 in
            let* α7 := borrow α6 u8 in
            let* α8 := borrow [ mk_str "" ] (list (ref str)) in
            let* α9 := deref α8 (list (ref str)) in
            let* α10 := borrow α9 (list (ref str)) in
            let* α11 := pointer_coercion "Unsize" α10 in
            let* α12 := borrow msg (ref str) in
            let* α13 := deref α12 (ref str) in
            let* α14 := borrow α13 (ref str) in
            let* α15 := core.fmt.rt.Argument::["new_display"] α14 in
            let* α16 := borrow [ α15 ] (list core.fmt.rt.Argument) in
            let* α17 := deref α16 (list core.fmt.rt.Argument) in
            let* α18 := borrow α17 (list core.fmt.rt.Argument) in
            let* α19 := pointer_coercion "Unsize" α18 in
            let* α20 := core.fmt.Arguments::["new_v1"] α11 α19 in
            core.panicking.assert_failed
              kind
              α3
              α7
              (core.option.Option.Some α20) in
          never_to_any tt
        else
          Pure tt
      end in
    self.["value"].
  
  Global Instance Method_expect `{State.Trait} : Notation.Dot "expect" := {
    Notation.dot := expect;
  }.
  
  Definition unwrap `{State.Trait} (self : Self) : M T :=
    let* _ :=
      let* α0 := self.["is_some"] in
      let* α1 := borrow α0 subtle.Choice in
      let* α2 := subtle.Choice::["unwrap_u8"] α1 in
      let* α3 := borrow α2 u8 in
      let* α4 := M.alloc 1 in
      let* α5 := borrow α4 u8 in
      match (α3, α5) with
      | (left_val, right_val) =>
        let* α0 := deref left_val u8 in
        let* α1 := deref right_val u8 in
        let* α2 := eq α0 α1 in
        let* α3 := not α2 in
        let* α4 := use α3 in
        if (α4 : bool) then
          let kind := core.panicking.AssertKind.Eq tt in
          let* _ :=
            let* α0 := deref left_val u8 in
            let* α1 := borrow α0 u8 in
            let* α2 := deref α1 u8 in
            let* α3 := borrow α2 u8 in
            let* α4 := deref right_val u8 in
            let* α5 := borrow α4 u8 in
            let* α6 := deref α5 u8 in
            let* α7 := borrow α6 u8 in
            core.panicking.assert_failed
              kind
              α3
              α7
              (core.option.Option.None tt) in
          never_to_any tt
        else
          Pure tt
      end in
    self.["value"].
  
  Global Instance Method_unwrap `{State.Trait} : Notation.Dot "unwrap" := {
    Notation.dot := unwrap;
  }.
  
  Definition unwrap_or
      `{State.Trait}
      `{subtle.ConditionallySelectable.Trait T}
      (self : Self)
      (def : T)
      : M T :=
    let* α0 := borrow def _ in
    let* α1 := deref α0 _ in
    let* α2 := borrow α1 _ in
    let* α3 := self.["value"] in
    let* α4 := borrow α3 _ in
    let* α5 := deref α4 _ in
    let* α6 := borrow α5 _ in
    let* α7 := self.["is_some"] in
    subtle.ConditionallySelectable.conditional_select α2 α6 α7.
  
  Global Instance Method_unwrap_or
      `{State.Trait}
      `{subtle.ConditionallySelectable.Trait T} :
    Notation.Dot "unwrap_or" := {
    Notation.dot := unwrap_or;
  }.
  
  Definition unwrap_or_else
      `{State.Trait}
      {F : Set}
      `{subtle.ConditionallySelectable.Trait T}
      `{core.ops.function.FnOnce.Trait F (Args := unit)}
      (self : Self)
      (f : F)
      : M T :=
    let* α0 := core.ops.function.FnOnce.call_once f tt in
    let* α1 := borrow α0 _ in
    let* α2 := deref α1 _ in
    let* α3 := borrow α2 _ in
    let* α4 := self.["value"] in
    let* α5 := borrow α4 _ in
    let* α6 := deref α5 _ in
    let* α7 := borrow α6 _ in
    let* α8 := self.["is_some"] in
    subtle.ConditionallySelectable.conditional_select α3 α7 α8.
  
  Global Instance Method_unwrap_or_else
      `{State.Trait}
      {F : Set}
      `{subtle.ConditionallySelectable.Trait T}
      `{core.ops.function.FnOnce.Trait F (Args := unit)} :
    Notation.Dot "unwrap_or_else" := {
    Notation.dot := unwrap_or_else (F := F);
  }.
  
  Definition is_some `{State.Trait} (self : ref Self) : M subtle.Choice :=
    let* α0 := deref self (subtle.CtOption _) in
    α0.["is_some"].
  
  Global Instance Method_is_some `{State.Trait} : Notation.Dot "is_some" := {
    Notation.dot := is_some;
  }.
  
  Definition is_none `{State.Trait} (self : ref Self) : M subtle.Choice :=
    let* α0 := deref self (subtle.CtOption _) in
    let* α1 := α0.["is_some"] in
    core.ops.bit.Not.not α1.
  
  Global Instance Method_is_none `{State.Trait} : Notation.Dot "is_none" := {
    Notation.dot := is_none;
  }.
  
  Definition map
      `{State.Trait}
      {U F : Set}
      `{core.default.Default.Trait T}
      `{subtle.ConditionallySelectable.Trait T}
      `{core.ops.function.FnOnce.Trait F (Args := T)}
      (self : Self)
      (f : F)
      : M (subtle.CtOption U) :=
    let* α0 := core.default.Default.default in
    let* α1 := borrow α0 _ in
    let* α2 := deref α1 _ in
    let* α3 := borrow α2 _ in
    let* α4 := self.["value"] in
    let* α5 := borrow α4 _ in
    let* α6 := deref α5 _ in
    let* α7 := borrow α6 _ in
    let* α8 := self.["is_some"] in
    let* α9 := subtle.ConditionallySelectable.conditional_select α3 α7 α8 in
    let* α10 := core.ops.function.FnOnce.call_once f (α9) in
    let* α11 := self.["is_some"] in
    (subtle.CtOption _)::["new"] α10 α11.
  
  Global Instance Method_map
      `{State.Trait}
      {U F : Set}
      `{core.default.Default.Trait T}
      `{subtle.ConditionallySelectable.Trait T}
      `{core.ops.function.FnOnce.Trait F (Args := T)} :
    Notation.Dot "map" := {
    Notation.dot := map (U := U) (F := F);
  }.
  
  Definition and_then
      `{State.Trait}
      {U F : Set}
      `{core.default.Default.Trait T}
      `{subtle.ConditionallySelectable.Trait T}
      `{core.ops.function.FnOnce.Trait F (Args := T)}
      (self : Self)
      (f : F)
      : M (subtle.CtOption U) :=
    let* tmp :=
      let* α0 := core.default.Default.default in
      let* α1 := borrow α0 _ in
      let* α2 := deref α1 _ in
      let* α3 := borrow α2 _ in
      let* α4 := self.["value"] in
      let* α5 := borrow α4 _ in
      let* α6 := deref α5 _ in
      let* α7 := borrow α6 _ in
      let* α8 := self.["is_some"] in
      let* α9 := subtle.ConditionallySelectable.conditional_select α3 α7 α8 in
      core.ops.function.FnOnce.call_once f (α9) in
    let* _ :=
      let* α0 := tmp.["is_some"] in
      let* α1 := borrow_mut α0 subtle.Choice in
      let* α2 := self.["is_some"] in
      core.ops.bit.BitAndAssign.bitand_assign α1 α2 in
    Pure tmp.
  
  Global Instance Method_and_then
      `{State.Trait}
      {U F : Set}
      `{core.default.Default.Trait T}
      `{subtle.ConditionallySelectable.Trait T}
      `{core.ops.function.FnOnce.Trait F (Args := T)} :
    Notation.Dot "and_then" := {
    Notation.dot := and_then (U := U) (F := F);
  }.
  
  Definition or_else
      `{State.Trait}
      {F : Set}
      `{subtle.ConditionallySelectable.Trait T}
      `{core.ops.function.FnOnce.Trait F (Args := unit)}
      (self : Self)
      (f : F)
      : M (subtle.CtOption T) :=
    let* is_none :=
      let* α0 := borrow self (subtle.CtOption _) in
      (subtle.CtOption _)::["is_none"] α0 in
    let* f := core.ops.function.FnOnce.call_once f tt in
    let* α0 := borrow self (subtle.CtOption _) in
    let* α1 := deref α0 (subtle.CtOption _) in
    let* α2 := borrow α1 (subtle.CtOption _) in
    let* α3 := borrow f (subtle.CtOption _) in
    let* α4 := deref α3 (subtle.CtOption _) in
    let* α5 := borrow α4 (subtle.CtOption _) in
    subtle.ConditionallySelectable.conditional_select α2 α5 is_none.
  
  Global Instance Method_or_else
      `{State.Trait}
      {F : Set}
      `{subtle.ConditionallySelectable.Trait T}
      `{core.ops.function.FnOnce.Trait F (Args := unit)} :
    Notation.Dot "or_else" := {
    Notation.dot := or_else (F := F);
  }.
End Impl_subtle_CtOption_T_4.

Module Impl_subtle_ConditionallySelectable_for_subtle_CtOption_T.
  Section Impl_subtle_ConditionallySelectable_for_subtle_CtOption_T.
    Context {T : Set}.
    Context `{subtle.ConditionallySelectable.Trait T}.
    Definition Self `{State.Trait} := subtle.CtOption T.
    
    Definition conditional_select
        `{State.Trait}
        (a : ref Self)
        (b : ref Self)
        (choice : subtle.Choice)
        : M Self :=
      let* α0 := deref a (subtle.CtOption _) in
      let* α1 := α0.["value"] in
      let* α2 := borrow α1 _ in
      let* α3 := deref α2 _ in
      let* α4 := borrow α3 _ in
      let* α5 := deref b (subtle.CtOption _) in
      let* α6 := α5.["value"] in
      let* α7 := borrow α6 _ in
      let* α8 := deref α7 _ in
      let* α9 := borrow α8 _ in
      let* α10 :=
        subtle.ConditionallySelectable.conditional_select α4 α9 choice in
      let* α11 := deref a (subtle.CtOption _) in
      let* α12 := α11.["is_some"] in
      let* α13 := borrow α12 subtle.Choice in
      let* α14 := deref α13 subtle.Choice in
      let* α15 := borrow α14 subtle.Choice in
      let* α16 := deref b (subtle.CtOption _) in
      let* α17 := α16.["is_some"] in
      let* α18 := borrow α17 subtle.Choice in
      let* α19 := deref α18 subtle.Choice in
      let* α20 := borrow α19 subtle.Choice in
      let* α21 :=
        subtle.ConditionallySelectable.conditional_select α15 α20 choice in
      (subtle.CtOption _)::["new"] α10 α21.
    
    Global Instance AssociatedFunction_conditional_select `{State.Trait} :
      Notation.DoubleColon Self "conditional_select" := {
      Notation.double_colon := conditional_select;
    }.
    
    Global Instance I `{State.Trait}
      : subtle.ConditionallySelectable.Trait Self := {
      subtle.ConditionallySelectable.conditional_select := conditional_select;
    }.
  End Impl_subtle_ConditionallySelectable_for_subtle_CtOption_T.
  Global Hint Resolve I : core.
End Impl_subtle_ConditionallySelectable_for_subtle_CtOption_T.

Module Impl_subtle_ConstantTimeEq_for_subtle_CtOption_T.
  Section Impl_subtle_ConstantTimeEq_for_subtle_CtOption_T.
    Context {T : Set}.
    Context `{subtle.ConstantTimeEq.Trait T}.
    Definition Self `{State.Trait} := subtle.CtOption T.
    
    Definition ct_eq
        `{State.Trait}
        (self : ref Self)
        (rhs : ref (subtle.CtOption T))
        : M subtle.Choice :=
      let* a :=
        let* α0 := deref self (subtle.CtOption _) in
        let* α1 := borrow α0 (subtle.CtOption _) in
        (subtle.CtOption _)::["is_some"] α1 in
      let* b :=
        let* α0 := deref rhs (subtle.CtOption _) in
        let* α1 := borrow α0 (subtle.CtOption _) in
        (subtle.CtOption _)::["is_some"] α1 in
      let* α0 := core.ops.bit.BitAnd.bitand a b in
      let* α1 := deref self (subtle.CtOption _) in
      let* α2 := α1.["value"] in
      let* α3 := borrow α2 _ in
      let* α4 := deref rhs (subtle.CtOption _) in
      let* α5 := α4.["value"] in
      let* α6 := borrow α5 _ in
      let* α7 := deref α6 _ in
      let* α8 := borrow α7 _ in
      let* α9 := subtle.ConstantTimeEq.ct_eq α3 α8 in
      let* α10 := core.ops.bit.BitAnd.bitand α0 α9 in
      let* α11 := core.ops.bit.Not.not a in
      let* α12 := core.ops.bit.Not.not b in
      let* α13 := core.ops.bit.BitAnd.bitand α11 α12 in
      core.ops.bit.BitOr.bitor α10 α13.
    
    Global Instance Method_ct_eq `{State.Trait} : Notation.Dot "ct_eq" := {
      Notation.dot := ct_eq;
    }.
    
    Global Instance I `{State.Trait} : subtle.ConstantTimeEq.Trait Self := {
      subtle.ConstantTimeEq.ct_eq := ct_eq;
    }.
  End Impl_subtle_ConstantTimeEq_for_subtle_CtOption_T.
  Global Hint Resolve I : core.
End Impl_subtle_ConstantTimeEq_for_subtle_CtOption_T.

Module ConstantTimeGreater.
  Class Trait (Self : Set) `{State.Trait} : Type := {
    ct_gt : (ref Self) -> (ref Self) -> M subtle.Choice;
  }.
  
  Global Instance Method_ct_gt `{State.Trait} `(Trait)
    : Notation.Dot "ct_gt" := {
    Notation.dot := ct_gt;
  }.
End ConstantTimeGreater.

Module Impl_subtle_ConstantTimeGreater_for_u8.
  Definition Self `{State.Trait} := u8.
  
  Definition ct_gt
      `{State.Trait}
      (self : ref Self)
      (other : ref u8)
      : M subtle.Choice :=
    let* gtb :=
      let* α0 := core.ops.bit.Not.not other in
      core.ops.bit.BitAnd.bitand self α0 in
    let* ltb :=
      let* α0 := core.ops.bit.Not.not self in
      core.ops.bit.BitAnd.bitand α0 other in
    let* pow := M.alloc 1 in
    let* _ :=
      loop
        (let* α0 := M.alloc 8 in
        let* α1 := lt pow α0 in
        let* α2 := use α1 in
        if (α2 : bool) then
          let* _ :=
            let* α0 := shr ltb pow in
            assign_op bitor ltb α0 in
          let* _ := assign_op add pow pow in
          Pure tt
        else
          let* _ :=
            let* α0 := Break in
            never_to_any α0 in
          never_to_any tt) in
    let* bit :=
      let* α0 := not ltb in
      bitand gtb α0 in
    let* pow := M.alloc 1 in
    let* _ :=
      loop
        (let* α0 := M.alloc 8 in
        let* α1 := lt pow α0 in
        let* α2 := use α1 in
        if (α2 : bool) then
          let* _ :=
            let* α0 := shr bit pow in
            assign_op bitor bit α0 in
          let* _ := assign_op add pow pow in
          Pure tt
        else
          let* _ :=
            let* α0 := Break in
            never_to_any α0 in
          never_to_any tt) in
    let* α0 := M.alloc 1 in
    let* α1 := bitand bit α0 in
    let* α2 := use α1 in
    core.convert.From.from α2.
  
  Global Instance Method_ct_gt `{State.Trait} : Notation.Dot "ct_gt" := {
    Notation.dot := ct_gt;
  }.
  
  Global Instance I `{State.Trait} : subtle.ConstantTimeGreater.Trait Self := {
    subtle.ConstantTimeGreater.ct_gt := ct_gt;
  }.
  Global Hint Resolve I : core.
End Impl_subtle_ConstantTimeGreater_for_u8.

Module Impl_subtle_ConstantTimeGreater_for_u16.
  Definition Self `{State.Trait} := u16.
  
  Definition ct_gt
      `{State.Trait}
      (self : ref Self)
      (other : ref u16)
      : M subtle.Choice :=
    let* gtb :=
      let* α0 := core.ops.bit.Not.not other in
      core.ops.bit.BitAnd.bitand self α0 in
    let* ltb :=
      let* α0 := core.ops.bit.Not.not self in
      core.ops.bit.BitAnd.bitand α0 other in
    let* pow := M.alloc 1 in
    let* _ :=
      loop
        (let* α0 := M.alloc 16 in
        let* α1 := lt pow α0 in
        let* α2 := use α1 in
        if (α2 : bool) then
          let* _ :=
            let* α0 := shr ltb pow in
            assign_op bitor ltb α0 in
          let* _ := assign_op add pow pow in
          Pure tt
        else
          let* _ :=
            let* α0 := Break in
            never_to_any α0 in
          never_to_any tt) in
    let* bit :=
      let* α0 := not ltb in
      bitand gtb α0 in
    let* pow := M.alloc 1 in
    let* _ :=
      loop
        (let* α0 := M.alloc 16 in
        let* α1 := lt pow α0 in
        let* α2 := use α1 in
        if (α2 : bool) then
          let* _ :=
            let* α0 := shr bit pow in
            assign_op bitor bit α0 in
          let* _ := assign_op add pow pow in
          Pure tt
        else
          let* _ :=
            let* α0 := Break in
            never_to_any α0 in
          never_to_any tt) in
    let* α0 := M.alloc 1 in
    let* α1 := bitand bit α0 in
    let* α2 := cast α1 in
    core.convert.From.from α2.
  
  Global Instance Method_ct_gt `{State.Trait} : Notation.Dot "ct_gt" := {
    Notation.dot := ct_gt;
  }.
  
  Global Instance I `{State.Trait} : subtle.ConstantTimeGreater.Trait Self := {
    subtle.ConstantTimeGreater.ct_gt := ct_gt;
  }.
  Global Hint Resolve I : core.
End Impl_subtle_ConstantTimeGreater_for_u16.

Module Impl_subtle_ConstantTimeGreater_for_u32.
  Definition Self `{State.Trait} := u32.
  
  Definition ct_gt
      `{State.Trait}
      (self : ref Self)
      (other : ref u32)
      : M subtle.Choice :=
    let* gtb :=
      let* α0 := core.ops.bit.Not.not other in
      core.ops.bit.BitAnd.bitand self α0 in
    let* ltb :=
      let* α0 := core.ops.bit.Not.not self in
      core.ops.bit.BitAnd.bitand α0 other in
    let* pow := M.alloc 1 in
    let* _ :=
      loop
        (let* α0 := M.alloc 32 in
        let* α1 := lt pow α0 in
        let* α2 := use α1 in
        if (α2 : bool) then
          let* _ :=
            let* α0 := shr ltb pow in
            assign_op bitor ltb α0 in
          let* _ := assign_op add pow pow in
          Pure tt
        else
          let* _ :=
            let* α0 := Break in
            never_to_any α0 in
          never_to_any tt) in
    let* bit :=
      let* α0 := not ltb in
      bitand gtb α0 in
    let* pow := M.alloc 1 in
    let* _ :=
      loop
        (let* α0 := M.alloc 32 in
        let* α1 := lt pow α0 in
        let* α2 := use α1 in
        if (α2 : bool) then
          let* _ :=
            let* α0 := shr bit pow in
            assign_op bitor bit α0 in
          let* _ := assign_op add pow pow in
          Pure tt
        else
          let* _ :=
            let* α0 := Break in
            never_to_any α0 in
          never_to_any tt) in
    let* α0 := M.alloc 1 in
    let* α1 := bitand bit α0 in
    let* α2 := cast α1 in
    core.convert.From.from α2.
  
  Global Instance Method_ct_gt `{State.Trait} : Notation.Dot "ct_gt" := {
    Notation.dot := ct_gt;
  }.
  
  Global Instance I `{State.Trait} : subtle.ConstantTimeGreater.Trait Self := {
    subtle.ConstantTimeGreater.ct_gt := ct_gt;
  }.
  Global Hint Resolve I : core.
End Impl_subtle_ConstantTimeGreater_for_u32.

Module Impl_subtle_ConstantTimeGreater_for_u64.
  Definition Self `{State.Trait} := u64.
  
  Definition ct_gt
      `{State.Trait}
      (self : ref Self)
      (other : ref u64)
      : M subtle.Choice :=
    let* gtb :=
      let* α0 := core.ops.bit.Not.not other in
      core.ops.bit.BitAnd.bitand self α0 in
    let* ltb :=
      let* α0 := core.ops.bit.Not.not self in
      core.ops.bit.BitAnd.bitand α0 other in
    let* pow := M.alloc 1 in
    let* _ :=
      loop
        (let* α0 := M.alloc 64 in
        let* α1 := lt pow α0 in
        let* α2 := use α1 in
        if (α2 : bool) then
          let* _ :=
            let* α0 := shr ltb pow in
            assign_op bitor ltb α0 in
          let* _ := assign_op add pow pow in
          Pure tt
        else
          let* _ :=
            let* α0 := Break in
            never_to_any α0 in
          never_to_any tt) in
    let* bit :=
      let* α0 := not ltb in
      bitand gtb α0 in
    let* pow := M.alloc 1 in
    let* _ :=
      loop
        (let* α0 := M.alloc 64 in
        let* α1 := lt pow α0 in
        let* α2 := use α1 in
        if (α2 : bool) then
          let* _ :=
            let* α0 := shr bit pow in
            assign_op bitor bit α0 in
          let* _ := assign_op add pow pow in
          Pure tt
        else
          let* _ :=
            let* α0 := Break in
            never_to_any α0 in
          never_to_any tt) in
    let* α0 := M.alloc 1 in
    let* α1 := bitand bit α0 in
    let* α2 := cast α1 in
    core.convert.From.from α2.
  
  Global Instance Method_ct_gt `{State.Trait} : Notation.Dot "ct_gt" := {
    Notation.dot := ct_gt;
  }.
  
  Global Instance I `{State.Trait} : subtle.ConstantTimeGreater.Trait Self := {
    subtle.ConstantTimeGreater.ct_gt := ct_gt;
  }.
  Global Hint Resolve I : core.
End Impl_subtle_ConstantTimeGreater_for_u64.

Module ConstantTimeLess.
  Unset Primitive Projections.
  Class Trait
      (Self : Set)
      `{subtle.ConstantTimeEq.Trait Self}
      `{subtle.ConstantTimeGreater.Trait Self}
      `{State.Trait} :
      Type := {
  }.
  Global Set Primitive Projections.
  Global Instance Method_ct_lt `{State.Trait} `(Trait)
    : Notation.Dot "ct_lt" := {
    Notation.dot (self : ref Self) (other : ref Self)
      :=
      (let* α0 := deref self _ in
      let* α1 := borrow α0 _ in
      let* α2 := deref other _ in
      let* α3 := borrow α2 _ in
      let* α4 := subtle.ConstantTimeGreater.ct_gt α1 α3 in
      let* α5 := core.ops.bit.Not.not α4 in
      let* α6 := deref self _ in
      let* α7 := borrow α6 _ in
      let* α8 := deref other _ in
      let* α9 := borrow α8 _ in
      let* α10 := subtle.ConstantTimeEq.ct_eq α7 α9 in
      let* α11 := core.ops.bit.Not.not α10 in
      core.ops.bit.BitAnd.bitand α5 α11
      : M subtle.Choice);
  }.
End ConstantTimeLess.

Module Impl_subtle_ConstantTimeLess_for_u8.
  Definition Self `{State.Trait} := u8.
  
  Global Instance I `{State.Trait} : subtle.ConstantTimeLess.Trait Self := {
  }.
  Global Hint Resolve I : core.
End Impl_subtle_ConstantTimeLess_for_u8.

Module Impl_subtle_ConstantTimeLess_for_u16.
  Definition Self `{State.Trait} := u16.
  
  Global Instance I `{State.Trait} : subtle.ConstantTimeLess.Trait Self := {
  }.
  Global Hint Resolve I : core.
End Impl_subtle_ConstantTimeLess_for_u16.

Module Impl_subtle_ConstantTimeLess_for_u32.
  Definition Self `{State.Trait} := u32.
  
  Global Instance I `{State.Trait} : subtle.ConstantTimeLess.Trait Self := {
  }.
  Global Hint Resolve I : core.
End Impl_subtle_ConstantTimeLess_for_u32.

Module Impl_subtle_ConstantTimeLess_for_u64.
  Definition Self `{State.Trait} := u64.
  
  Global Instance I `{State.Trait} : subtle.ConstantTimeLess.Trait Self := {
  }.
  Global Hint Resolve I : core.
End Impl_subtle_ConstantTimeLess_for_u64.
