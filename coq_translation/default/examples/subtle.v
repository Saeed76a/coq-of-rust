(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module  Choice.
Section Choice.
  Record t : Set := {
    x0 : u8.t;
  }.
  
  Global Instance Get_0 : Notation.Dot "0" := {
    Notation.dot x := let* x := M.read x in M.alloc x.(x0) : M _;
  }.
End Choice.
End Choice.
Definition Choice : Set := M.Val Choice.t.

Module  Impl_core_marker_Copy_for_subtle_Choice_t.
Section Impl_core_marker_Copy_for_subtle_Choice_t.
  Ltac Self := exact subtle.Choice.t.
  
  Global Instance ℐ : core.marker.Copy.Trait ltac:(Self) := {
  }.
End Impl_core_marker_Copy_for_subtle_Choice_t.
End Impl_core_marker_Copy_for_subtle_Choice_t.

Module  Impl_core_clone_Clone_for_subtle_Choice_t.
Section Impl_core_clone_Clone_for_subtle_Choice_t.
  Ltac Self := exact subtle.Choice.t.
  
  Definition clone
      (self : M.Val (ref ltac:(Self)))
      : M (M.Val subtle.Choice.t) :=
    M.function_body
      (let* _ : ltac:(refine (M.Val unit)) := M.alloc tt in
      deref self).
  
  Global Instance AssociatedFunction_clone :
    Notation.DoubleColon ltac:(Self) "clone" := {
    Notation.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait ltac:(Self) := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_subtle_Choice_t.
End Impl_core_clone_Clone_for_subtle_Choice_t.

Module  Impl_core_fmt_Debug_for_subtle_Choice_t.
Section Impl_core_fmt_Debug_for_subtle_Choice_t.
  Ltac Self := exact subtle.Choice.t.
  
  Definition fmt
      (self : M.Val (ref ltac:(Self)))
      (f : M.Val (mut_ref core.fmt.Formatter.t))
      : M (M.Val ltac:(core.fmt.Result)) :=
    M.function_body
      (let* α0 : ltac:(refine (M.Val core.fmt.Formatter.t)) := deref f in
      let* α1 : ltac:(refine (M.Val (mut_ref core.fmt.Formatter.t))) :=
        borrow_mut α0 in
      let* α2 : ltac:(refine (M.Val str)) := deref (mk_str "Choice") in
      let* α3 : ltac:(refine (M.Val (ref str))) := borrow α2 in
      let* α4 : ltac:(refine (M.Val subtle.Choice.t)) := deref self in
      let* α5 : ltac:(refine (M.Val u8.t)) := α4.["0"] in
      let* α6 : ltac:(refine (M.Val (ref u8.t))) := borrow α5 in
      let* α7 : ltac:(refine (M.Val (ref (ref u8.t)))) := borrow α6 in
      let* α8 : ltac:(refine (M.Val (ref type not implemented))) :=
        pointer_coercion "Unsize" α7 in
      core.fmt.Formatter.t::["debug_tuple_field1_finish"] α1 α3 α8).
  
  Global Instance AssociatedFunction_fmt :
    Notation.DoubleColon ltac:(Self) "fmt" := {
    Notation.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait ltac:(Self) := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_subtle_Choice_t.
End Impl_core_fmt_Debug_for_subtle_Choice_t.

Module  Impl_subtle_Choice_t.
Section Impl_subtle_Choice_t.
  Ltac Self := exact subtle.Choice.t.
  
  Definition unwrap_u8 (self : M.Val (ref ltac:(Self))) : M (M.Val u8.t) :=
    M.function_body
      (let* α0 : ltac:(refine (M.Val subtle.Choice.t)) := deref self in
      α0.["0"]).
  
  Global Instance AssociatedFunction_unwrap_u8 :
    Notation.DoubleColon ltac:(Self) "unwrap_u8" := {
    Notation.double_colon := unwrap_u8;
  }.
End Impl_subtle_Choice_t.
End Impl_subtle_Choice_t.

Module  Impl_core_convert_From_subtle_Choice_t_for_bool_t.
Section Impl_core_convert_From_subtle_Choice_t_for_bool_t.
  Ltac Self := exact bool.t.
  
  Definition from (source : M.Val subtle.Choice.t) : M (M.Val bool.t) :=
    M.function_body
      (let* _ : ltac:(refine (M.Val unit)) :=
        let* α0 : ltac:(refine (M.Val bool.t)) := M.alloc true in
        let* α1 : ltac:(refine (M.Val bool.t)) := use α0 in
        let* α2 := M.read α1 in
        if (α2 : bool) then
          let* _ : ltac:(refine (M.Val unit)) :=
            let* α0 : ltac:(refine (M.Val u8.t)) := source.["0"] in
            let* α1 : ltac:(refine (M.Val u8.t)) := M.alloc 0 in
            let* α2 : ltac:(refine (M.Val bool.t)) := BinOp.eq α0 α1 in
            let* α3 : ltac:(refine (M.Val u8.t)) := source.["0"] in
            let* α4 : ltac:(refine (M.Val u8.t)) := M.alloc 1 in
            let* α5 : ltac:(refine (M.Val bool.t)) := BinOp.eq α3 α4 in
            let* α6 : ltac:(refine (M.Val bool.t)) := BinOp.bit_or α2 α5 in
            let* α7 : ltac:(refine (M.Val bool.t)) := UnOp.not α6 in
            let* α8 : ltac:(refine (M.Val bool.t)) := use α7 in
            let* α9 := M.read α8 in
            if (α9 : bool) then
              let* α0 : ltac:(refine (M.Val never.t)) :=
                core.panicking.panic
                  (mk_str
                    "assertion failed: (source.0 == 0u8) | (source.0 == 1u8)") in
              never_to_any α0
            else
              M.alloc tt in
          M.alloc tt
        else
          M.alloc tt in
      let* α0 : ltac:(refine (M.Val u8.t)) := source.["0"] in
      let* α1 : ltac:(refine (M.Val u8.t)) := M.alloc 0 in
      BinOp.ne α0 α1).
  
  Global Instance AssociatedFunction_from :
    Notation.DoubleColon ltac:(Self) "from" := {
    Notation.double_colon := from;
  }.
  
  Global Instance ℐ :
    core.convert.From.Trait ltac:(Self) (T := subtle.Choice.t) := {
    core.convert.From.from := from;
  }.
End Impl_core_convert_From_subtle_Choice_t_for_bool_t.
End Impl_core_convert_From_subtle_Choice_t_for_bool_t.

Module  Impl_core_ops_bit_BitAnd_for_subtle_Choice_t.
Section Impl_core_ops_bit_BitAnd_for_subtle_Choice_t.
  Ltac Self := exact subtle.Choice.t.
  
  Definition Output : Set := subtle.Choice.t.
  
  Definition bitand
      (self : M.Val ltac:(Self))
      (rhs : M.Val subtle.Choice.t)
      : M (M.Val subtle.Choice.t) :=
    M.function_body
      (let* α0 : ltac:(refine (M.Val u8.t)) := self.["0"] in
      let* α1 : ltac:(refine (M.Val u8.t)) := rhs.["0"] in
      let* α2 : ltac:(refine (M.Val u8.t)) := BinOp.bit_and α0 α1 in
      (core.convert.Into.into (Self := u8.t) (Trait := ltac:(refine _))) α2).
  
  Global Instance AssociatedFunction_bitand :
    Notation.DoubleColon ltac:(Self) "bitand" := {
    Notation.double_colon := bitand;
  }.
  
  Global Instance ℐ :
    core.ops.bit.BitAnd.Trait ltac:(Self)
      (Rhs := core.ops.bit.BitAnd.Default.Rhs ltac:(Self)) := {
    core.ops.bit.BitAnd.Output := Output;
    core.ops.bit.BitAnd.bitand := bitand;
  }.
End Impl_core_ops_bit_BitAnd_for_subtle_Choice_t.
End Impl_core_ops_bit_BitAnd_for_subtle_Choice_t.

Module  Impl_core_ops_bit_BitAndAssign_for_subtle_Choice_t.
Section Impl_core_ops_bit_BitAndAssign_for_subtle_Choice_t.
  Ltac Self := exact subtle.Choice.t.
  
  Definition bitand_assign
      (self : M.Val (mut_ref ltac:(Self)))
      (rhs : M.Val subtle.Choice.t)
      : M (M.Val unit) :=
    M.function_body
      (let* _ : ltac:(refine (M.Val unit)) :=
        let* α0 : ltac:(refine (M.Val subtle.Choice.t)) := deref self in
        let* α1 : ltac:(refine (M.Val subtle.Choice.t)) := deref self in
        let* α2 : ltac:(refine (M.Val subtle.Choice.t)) :=
          (core.ops.bit.BitAnd.bitand
              (Self := subtle.Choice.t)
              (Trait := ltac:(refine _)))
            α1
            rhs in
        assign α0 α2 in
      M.alloc tt).
  
  Global Instance AssociatedFunction_bitand_assign :
    Notation.DoubleColon ltac:(Self) "bitand_assign" := {
    Notation.double_colon := bitand_assign;
  }.
  
  Global Instance ℐ :
    core.ops.bit.BitAndAssign.Trait ltac:(Self)
      (Rhs := core.ops.bit.BitAndAssign.Default.Rhs ltac:(Self)) := {
    core.ops.bit.BitAndAssign.bitand_assign := bitand_assign;
  }.
End Impl_core_ops_bit_BitAndAssign_for_subtle_Choice_t.
End Impl_core_ops_bit_BitAndAssign_for_subtle_Choice_t.

Module  Impl_core_ops_bit_BitOr_for_subtle_Choice_t.
Section Impl_core_ops_bit_BitOr_for_subtle_Choice_t.
  Ltac Self := exact subtle.Choice.t.
  
  Definition Output : Set := subtle.Choice.t.
  
  Definition bitor
      (self : M.Val ltac:(Self))
      (rhs : M.Val subtle.Choice.t)
      : M (M.Val subtle.Choice.t) :=
    M.function_body
      (let* α0 : ltac:(refine (M.Val u8.t)) := self.["0"] in
      let* α1 : ltac:(refine (M.Val u8.t)) := rhs.["0"] in
      let* α2 : ltac:(refine (M.Val u8.t)) := BinOp.bit_or α0 α1 in
      (core.convert.Into.into (Self := u8.t) (Trait := ltac:(refine _))) α2).
  
  Global Instance AssociatedFunction_bitor :
    Notation.DoubleColon ltac:(Self) "bitor" := {
    Notation.double_colon := bitor;
  }.
  
  Global Instance ℐ :
    core.ops.bit.BitOr.Trait ltac:(Self)
      (Rhs := core.ops.bit.BitOr.Default.Rhs ltac:(Self)) := {
    core.ops.bit.BitOr.Output := Output;
    core.ops.bit.BitOr.bitor := bitor;
  }.
End Impl_core_ops_bit_BitOr_for_subtle_Choice_t.
End Impl_core_ops_bit_BitOr_for_subtle_Choice_t.

Module  Impl_core_ops_bit_BitOrAssign_for_subtle_Choice_t.
Section Impl_core_ops_bit_BitOrAssign_for_subtle_Choice_t.
  Ltac Self := exact subtle.Choice.t.
  
  Definition bitor_assign
      (self : M.Val (mut_ref ltac:(Self)))
      (rhs : M.Val subtle.Choice.t)
      : M (M.Val unit) :=
    M.function_body
      (let* _ : ltac:(refine (M.Val unit)) :=
        let* α0 : ltac:(refine (M.Val subtle.Choice.t)) := deref self in
        let* α1 : ltac:(refine (M.Val subtle.Choice.t)) := deref self in
        let* α2 : ltac:(refine (M.Val subtle.Choice.t)) :=
          (core.ops.bit.BitOr.bitor
              (Self := subtle.Choice.t)
              (Trait := ltac:(refine _)))
            α1
            rhs in
        assign α0 α2 in
      M.alloc tt).
  
  Global Instance AssociatedFunction_bitor_assign :
    Notation.DoubleColon ltac:(Self) "bitor_assign" := {
    Notation.double_colon := bitor_assign;
  }.
  
  Global Instance ℐ :
    core.ops.bit.BitOrAssign.Trait ltac:(Self)
      (Rhs := core.ops.bit.BitOrAssign.Default.Rhs ltac:(Self)) := {
    core.ops.bit.BitOrAssign.bitor_assign := bitor_assign;
  }.
End Impl_core_ops_bit_BitOrAssign_for_subtle_Choice_t.
End Impl_core_ops_bit_BitOrAssign_for_subtle_Choice_t.

Module  Impl_core_ops_bit_BitXor_for_subtle_Choice_t.
Section Impl_core_ops_bit_BitXor_for_subtle_Choice_t.
  Ltac Self := exact subtle.Choice.t.
  
  Definition Output : Set := subtle.Choice.t.
  
  Definition bitxor
      (self : M.Val ltac:(Self))
      (rhs : M.Val subtle.Choice.t)
      : M (M.Val subtle.Choice.t) :=
    M.function_body
      (let* α0 : ltac:(refine (M.Val u8.t)) := self.["0"] in
      let* α1 : ltac:(refine (M.Val u8.t)) := rhs.["0"] in
      let* α2 : ltac:(refine (M.Val u8.t)) := BinOp.bit_xor α0 α1 in
      (core.convert.Into.into (Self := u8.t) (Trait := ltac:(refine _))) α2).
  
  Global Instance AssociatedFunction_bitxor :
    Notation.DoubleColon ltac:(Self) "bitxor" := {
    Notation.double_colon := bitxor;
  }.
  
  Global Instance ℐ :
    core.ops.bit.BitXor.Trait ltac:(Self)
      (Rhs := core.ops.bit.BitXor.Default.Rhs ltac:(Self)) := {
    core.ops.bit.BitXor.Output := Output;
    core.ops.bit.BitXor.bitxor := bitxor;
  }.
End Impl_core_ops_bit_BitXor_for_subtle_Choice_t.
End Impl_core_ops_bit_BitXor_for_subtle_Choice_t.

Module  Impl_core_ops_bit_BitXorAssign_for_subtle_Choice_t.
Section Impl_core_ops_bit_BitXorAssign_for_subtle_Choice_t.
  Ltac Self := exact subtle.Choice.t.
  
  Definition bitxor_assign
      (self : M.Val (mut_ref ltac:(Self)))
      (rhs : M.Val subtle.Choice.t)
      : M (M.Val unit) :=
    M.function_body
      (let* _ : ltac:(refine (M.Val unit)) :=
        let* α0 : ltac:(refine (M.Val subtle.Choice.t)) := deref self in
        let* α1 : ltac:(refine (M.Val subtle.Choice.t)) := deref self in
        let* α2 : ltac:(refine (M.Val subtle.Choice.t)) :=
          (core.ops.bit.BitXor.bitxor
              (Self := subtle.Choice.t)
              (Trait := ltac:(refine _)))
            α1
            rhs in
        assign α0 α2 in
      M.alloc tt).
  
  Global Instance AssociatedFunction_bitxor_assign :
    Notation.DoubleColon ltac:(Self) "bitxor_assign" := {
    Notation.double_colon := bitxor_assign;
  }.
  
  Global Instance ℐ :
    core.ops.bit.BitXorAssign.Trait ltac:(Self)
      (Rhs := core.ops.bit.BitXorAssign.Default.Rhs ltac:(Self)) := {
    core.ops.bit.BitXorAssign.bitxor_assign := bitxor_assign;
  }.
End Impl_core_ops_bit_BitXorAssign_for_subtle_Choice_t.
End Impl_core_ops_bit_BitXorAssign_for_subtle_Choice_t.

Module  Impl_core_ops_bit_Not_for_subtle_Choice_t.
Section Impl_core_ops_bit_Not_for_subtle_Choice_t.
  Ltac Self := exact subtle.Choice.t.
  
  Definition Output : Set := subtle.Choice.t.
  
  Definition not (self : M.Val ltac:(Self)) : M (M.Val subtle.Choice.t) :=
    M.function_body
      (let* α0 : ltac:(refine (M.Val u8.t)) := M.alloc 1 in
      let* α1 : ltac:(refine (M.Val u8.t)) := self.["0"] in
      let* α2 : ltac:(refine (M.Val u8.t)) := UnOp.not α1 in
      let* α3 : ltac:(refine (M.Val u8.t)) := BinOp.bit_and α0 α2 in
      (core.convert.Into.into (Self := u8.t) (Trait := ltac:(refine _))) α3).
  
  Global Instance AssociatedFunction_not :
    Notation.DoubleColon ltac:(Self) "not" := {
    Notation.double_colon := not;
  }.
  
  Global Instance ℐ : core.ops.bit.Not.Trait ltac:(Self) := {
    core.ops.bit.Not.Output := Output;
    core.ops.bit.Not.not := not;
  }.
End Impl_core_ops_bit_Not_for_subtle_Choice_t.
End Impl_core_ops_bit_Not_for_subtle_Choice_t.

Definition black_box (input : M.Val u8.t) : M (M.Val u8.t) :=
  M.function_body
    (let* _ : ltac:(refine (M.Val unit)) :=
      let* α0 : ltac:(refine (M.Val bool.t)) := M.alloc true in
      let* α1 : ltac:(refine (M.Val bool.t)) := use α0 in
      let* α2 := M.read α1 in
      if (α2 : bool) then
        let* _ : ltac:(refine (M.Val unit)) :=
          let* α0 : ltac:(refine (M.Val u8.t)) := M.alloc 0 in
          let* α1 : ltac:(refine (M.Val bool.t)) := BinOp.eq input α0 in
          let* α2 : ltac:(refine (M.Val u8.t)) := M.alloc 1 in
          let* α3 : ltac:(refine (M.Val bool.t)) := BinOp.eq input α2 in
          let* α4 : ltac:(refine (M.Val bool.t)) := BinOp.bit_or α1 α3 in
          let* α5 : ltac:(refine (M.Val bool.t)) := UnOp.not α4 in
          let* α6 : ltac:(refine (M.Val bool.t)) := use α5 in
          let* α7 := M.read α6 in
          if (α7 : bool) then
            let* α0 : ltac:(refine (M.Val never.t)) :=
              core.panicking.panic
                (mk_str "assertion failed: (input == 0u8) | (input == 1u8)") in
            never_to_any α0
          else
            M.alloc tt in
        M.alloc tt
      else
        M.alloc tt in
    let* α0 : ltac:(refine (M.Val (ref u8.t))) := addr_of input in
    let* α1 : ltac:(refine (M.Val (ref u8.t))) := use α0 in
    core.ptr.read_volatile α1).

Module  Impl_core_convert_From_u8_t_for_subtle_Choice_t.
Section Impl_core_convert_From_u8_t_for_subtle_Choice_t.
  Ltac Self := exact subtle.Choice.t.
  
  Definition from (input : M.Val u8.t) : M (M.Val subtle.Choice.t) :=
    M.function_body
      (let* α0 : ltac:(refine (M.Val u8.t)) := subtle.black_box input in
      let* α1 := M.read α0 in
      M.alloc (subtle.Choice.Build_t α1)).
  
  Global Instance AssociatedFunction_from :
    Notation.DoubleColon ltac:(Self) "from" := {
    Notation.double_colon := from;
  }.
  
  Global Instance ℐ : core.convert.From.Trait ltac:(Self) (T := u8.t) := {
    core.convert.From.from := from;
  }.
End Impl_core_convert_From_u8_t_for_subtle_Choice_t.
End Impl_core_convert_From_u8_t_for_subtle_Choice_t.

Module  ConstantTimeEq.
Section ConstantTimeEq.
  Class Trait (Self : Set) : Type := {
    ct_eq : (ref ltac:(Self)) -> (ref ltac:(Self)) -> M subtle.Choice.t;
  }.
  
End ConstantTimeEq.
End ConstantTimeEq.

Module  Impl_subtle_ConstantTimeEq_for_slice_T.
Section Impl_subtle_ConstantTimeEq_for_slice_T.
  Context {T : Set}.
  
  Context {ℋ_0 : subtle.ConstantTimeEq.Trait T}.
  
  Ltac Self := exact (slice T).
  
  Definition ct_eq
      (self : M.Val (ref ltac:(Self)))
      (_rhs : M.Val (ref (slice T)))
      : M (M.Val subtle.Choice.t) :=
    M.function_body
      (let* len : ltac:(refine (M.Val usize.t)) :=
        let* α0 : ltac:(refine (M.Val (slice T))) := deref self in
        let* α1 : ltac:(refine (M.Val (ref (slice T)))) := borrow α0 in
        (slice T)::["len"] α1 in
      let* _ : ltac:(refine (M.Val unit)) :=
        let* α0 : ltac:(refine (M.Val (slice T))) := deref _rhs in
        let* α1 : ltac:(refine (M.Val (ref (slice T)))) := borrow α0 in
        let* α2 : ltac:(refine (M.Val usize.t)) := (slice T)::["len"] α1 in
        let* α3 : ltac:(refine (M.Val bool.t)) := BinOp.ne len α2 in
        let* α4 : ltac:(refine (M.Val bool.t)) := use α3 in
        let* α5 := M.read α4 in
        if (α5 : bool) then
          let* _ : ltac:(refine (M.Val never.t)) :=
            let* α0 : ltac:(refine (M.Val u8.t)) := M.alloc 0 in
            let* α1 : ltac:(refine (M.Val subtle.Choice.t)) :=
              (core.convert.From.from
                  (Self := subtle.Choice.t)
                  (Trait := ltac:(refine _)))
                α0 in
            M.return_ α1 in
          let* α0 : ltac:(refine (M.Val unit)) := M.alloc tt in
          never_to_any α0
        else
          M.alloc tt in
      let* x : ltac:(refine (M.Val u8.t)) := M.alloc 1 in
      let* _ : ltac:(refine (M.Val unit)) :=
        let* α0 : ltac:(refine (M.Val (slice T))) := deref self in
        let* α1 : ltac:(refine (M.Val (ref (slice T)))) := borrow α0 in
        let* α2 : ltac:(refine (M.Val (core.slice.iter.Iter.t T))) :=
          (slice T)::["iter"] α1 in
        let* α3 : ltac:(refine (M.Val (slice T))) := deref _rhs in
        let* α4 : ltac:(refine (M.Val (ref (slice T)))) := borrow α3 in
        let* α5 : ltac:(refine (M.Val (core.slice.iter.Iter.t T))) :=
          (slice T)::["iter"] α4 in
        let* α6 :
            ltac:(refine
              (M.Val
                (core.iter.adapters.zip.Zip.t
                  (core.slice.iter.Iter.t T)
                  (core.slice.iter.Iter.t T)))) :=
          (core.iter.traits.iterator.Iterator.zip
              (Self := core.slice.iter.Iter.t T)
              (Trait := ltac:(refine _)))
            α2
            α5 in
        let* α7 :
            ltac:(refine
              (M.Val
                (core.iter.adapters.zip.Zip.t
                  (core.slice.iter.Iter.t T)
                  (core.slice.iter.Iter.t T)))) :=
          (core.iter.traits.collect.IntoIterator.into_iter
              (Self :=
                core.iter.adapters.zip.Zip.t
                  (core.slice.iter.Iter.t T)
                  (core.slice.iter.Iter.t T))
              (Trait := ltac:(refine _)))
            α6 in
        let* α8 := M.read α7 in
        let* α9 : ltac:(refine (M.Val unit)) :=
          match α8 with
          | iter =>
            let* iter := M.alloc iter in
            loop
              (let* _ : ltac:(refine (M.Val unit)) :=
                let* α0 :
                    ltac:(refine
                      (M.Val
                        (mut_ref
                          (core.iter.adapters.zip.Zip.t
                            (core.slice.iter.Iter.t T)
                            (core.slice.iter.Iter.t T))))) :=
                  borrow_mut iter in
                let* α1 :
                    ltac:(refine
                      (M.Val (core.option.Option.t ((ref T) * (ref T))))) :=
                  (core.iter.traits.iterator.Iterator.next
                      (Self :=
                        core.iter.adapters.zip.Zip.t
                          (core.slice.iter.Iter.t T)
                          (core.slice.iter.Iter.t T))
                      (Trait := ltac:(refine _)))
                    α0 in
                let* α2 := M.read α1 in
                match α2 with
                | core.option.Option.None  =>
                  let* α0 : ltac:(refine (M.Val never.t)) := Break in
                  never_to_any α0
                | core.option.Option.Some (ai, bi) =>
                  let* bi := M.alloc bi in
                  let* ai := M.alloc ai in
                  let* _ : ltac:(refine (M.Val unit)) :=
                    let* α0 : ltac:(refine (M.Val T)) := deref ai in
                    let* α1 : ltac:(refine (M.Val (ref T))) := borrow α0 in
                    let* α2 : ltac:(refine (M.Val T)) := deref bi in
                    let* α3 : ltac:(refine (M.Val (ref T))) := borrow α2 in
                    let* α4 : ltac:(refine (M.Val subtle.Choice.t)) :=
                      (subtle.ConstantTimeEq.ct_eq
                          (Self := T)
                          (Trait := ltac:(refine _)))
                        α1
                        α3 in
                    let* α5 : ltac:(refine (M.Val (ref subtle.Choice.t))) :=
                      borrow α4 in
                    let* α6 : ltac:(refine (M.Val u8.t)) :=
                      subtle.Choice.t::["unwrap_u8"] α5 in
                    assign_op bitand x α6 in
                  M.alloc tt
                end in
              M.alloc tt)
          end in
        use α9 in
      (core.convert.Into.into (Self := u8.t) (Trait := ltac:(refine _))) x).
  
  Global Instance AssociatedFunction_ct_eq :
    Notation.DoubleColon ltac:(Self) "ct_eq" := {
    Notation.double_colon := ct_eq;
  }.
  
  Global Instance ℐ : subtle.ConstantTimeEq.Required.Trait ltac:(Self) := {
    subtle.ConstantTimeEq.ct_eq := ct_eq;
    subtle.ConstantTimeEq.ct_ne := Datatypes.None;
  }.
End Impl_subtle_ConstantTimeEq_for_slice_T.
End Impl_subtle_ConstantTimeEq_for_slice_T.

Module  Impl_subtle_ConstantTimeEq_for_subtle_Choice_t.
Section Impl_subtle_ConstantTimeEq_for_subtle_Choice_t.
  Ltac Self := exact subtle.Choice.t.
  
  Definition ct_eq
      (self : M.Val (ref ltac:(Self)))
      (rhs : M.Val (ref subtle.Choice.t))
      : M (M.Val subtle.Choice.t) :=
    M.function_body
      (let* α0 : ltac:(refine (M.Val subtle.Choice.t)) := deref self in
      let* α1 : ltac:(refine (M.Val subtle.Choice.t)) := deref rhs in
      let* α2 : ltac:(refine (M.Val subtle.Choice.t)) :=
        (core.ops.bit.BitXor.bitxor
            (Self := subtle.Choice.t)
            (Trait := ltac:(refine _)))
          α0
          α1 in
      (core.ops.bit.Not.not
          (Self := subtle.Choice.t)
          (Trait := ltac:(refine _)))
        α2).
  
  Global Instance AssociatedFunction_ct_eq :
    Notation.DoubleColon ltac:(Self) "ct_eq" := {
    Notation.double_colon := ct_eq;
  }.
  
  Global Instance ℐ : subtle.ConstantTimeEq.Required.Trait ltac:(Self) := {
    subtle.ConstantTimeEq.ct_eq := ct_eq;
    subtle.ConstantTimeEq.ct_ne := Datatypes.None;
  }.
End Impl_subtle_ConstantTimeEq_for_subtle_Choice_t.
End Impl_subtle_ConstantTimeEq_for_subtle_Choice_t.

Module  Impl_subtle_ConstantTimeEq_for_u8_t.
Section Impl_subtle_ConstantTimeEq_for_u8_t.
  Ltac Self := exact u8.t.
  
  Definition ct_eq
      (self : M.Val (ref ltac:(Self)))
      (other : M.Val (ref u8.t))
      : M (M.Val subtle.Choice.t) :=
    M.function_body
      (let* x : ltac:(refine (M.Val u8.t)) :=
        (core.ops.bit.BitXor.bitxor
            (Self := ref u8.t)
            (Trait := ltac:(refine _)))
          self
          other in
      let* y : ltac:(refine (M.Val u8.t)) :=
        let* α0 : ltac:(refine (M.Val u8.t)) := u8.t::["wrapping_neg"] x in
        let* α1 : ltac:(refine (M.Val u8.t)) := BinOp.bit_or x α0 in
        let* α2 : ltac:(refine (M.Val i32.t)) := M.alloc 8 in
        let* α3 : ltac:(refine (M.Val i32.t)) := M.alloc 1 in
        let* α4 : ltac:(refine (M.Val i32.t)) := BinOp.sub α2 α3 in
        BinOp.shr α1 α4 in
      let* α0 : ltac:(refine (M.Val u8.t)) := M.alloc 1 in
      let* α1 : ltac:(refine (M.Val u8.t)) := use α0 in
      let* α2 : ltac:(refine (M.Val u8.t)) := BinOp.bit_xor y α1 in
      let* α3 : ltac:(refine (M.Val u8.t)) := use α2 in
      (core.convert.Into.into (Self := u8.t) (Trait := ltac:(refine _))) α3).
  
  Global Instance AssociatedFunction_ct_eq :
    Notation.DoubleColon ltac:(Self) "ct_eq" := {
    Notation.double_colon := ct_eq;
  }.
  
  Global Instance ℐ : subtle.ConstantTimeEq.Required.Trait ltac:(Self) := {
    subtle.ConstantTimeEq.ct_eq := ct_eq;
    subtle.ConstantTimeEq.ct_ne := Datatypes.None;
  }.
End Impl_subtle_ConstantTimeEq_for_u8_t.
End Impl_subtle_ConstantTimeEq_for_u8_t.

Module  Impl_subtle_ConstantTimeEq_for_i8_t.
Section Impl_subtle_ConstantTimeEq_for_i8_t.
  Ltac Self := exact i8.t.
  
  Definition ct_eq
      (self : M.Val (ref ltac:(Self)))
      (other : M.Val (ref i8.t))
      : M (M.Val subtle.Choice.t) :=
    M.function_body
      (let* α0 : ltac:(refine (M.Val i8.t)) := deref self in
      let* α1 : ltac:(refine (M.Val u8.t)) := cast α0 in
      let* α2 : ltac:(refine (M.Val (ref u8.t))) := borrow α1 in
      let* α3 : ltac:(refine (M.Val i8.t)) := deref other in
      let* α4 : ltac:(refine (M.Val u8.t)) := cast α3 in
      let* α5 : ltac:(refine (M.Val (ref u8.t))) := borrow α4 in
      (subtle.ConstantTimeEq.ct_eq (Self := u8.t) (Trait := ltac:(refine _)))
        α2
        α5).
  
  Global Instance AssociatedFunction_ct_eq :
    Notation.DoubleColon ltac:(Self) "ct_eq" := {
    Notation.double_colon := ct_eq;
  }.
  
  Global Instance ℐ : subtle.ConstantTimeEq.Required.Trait ltac:(Self) := {
    subtle.ConstantTimeEq.ct_eq := ct_eq;
    subtle.ConstantTimeEq.ct_ne := Datatypes.None;
  }.
End Impl_subtle_ConstantTimeEq_for_i8_t.
End Impl_subtle_ConstantTimeEq_for_i8_t.

Module  Impl_subtle_ConstantTimeEq_for_u16_t.
Section Impl_subtle_ConstantTimeEq_for_u16_t.
  Ltac Self := exact u16.t.
  
  Definition ct_eq
      (self : M.Val (ref ltac:(Self)))
      (other : M.Val (ref u16.t))
      : M (M.Val subtle.Choice.t) :=
    M.function_body
      (let* x : ltac:(refine (M.Val u16.t)) :=
        (core.ops.bit.BitXor.bitxor
            (Self := ref u16.t)
            (Trait := ltac:(refine _)))
          self
          other in
      let* y : ltac:(refine (M.Val u16.t)) :=
        let* α0 : ltac:(refine (M.Val u16.t)) := u16.t::["wrapping_neg"] x in
        let* α1 : ltac:(refine (M.Val u16.t)) := BinOp.bit_or x α0 in
        let* α2 : ltac:(refine (M.Val i32.t)) := M.alloc 16 in
        let* α3 : ltac:(refine (M.Val i32.t)) := M.alloc 1 in
        let* α4 : ltac:(refine (M.Val i32.t)) := BinOp.sub α2 α3 in
        BinOp.shr α1 α4 in
      let* α0 : ltac:(refine (M.Val u16.t)) := M.alloc 1 in
      let* α1 : ltac:(refine (M.Val u16.t)) := use α0 in
      let* α2 : ltac:(refine (M.Val u16.t)) := BinOp.bit_xor y α1 in
      let* α3 : ltac:(refine (M.Val u8.t)) := cast α2 in
      (core.convert.Into.into (Self := u8.t) (Trait := ltac:(refine _))) α3).
  
  Global Instance AssociatedFunction_ct_eq :
    Notation.DoubleColon ltac:(Self) "ct_eq" := {
    Notation.double_colon := ct_eq;
  }.
  
  Global Instance ℐ : subtle.ConstantTimeEq.Required.Trait ltac:(Self) := {
    subtle.ConstantTimeEq.ct_eq := ct_eq;
    subtle.ConstantTimeEq.ct_ne := Datatypes.None;
  }.
End Impl_subtle_ConstantTimeEq_for_u16_t.
End Impl_subtle_ConstantTimeEq_for_u16_t.

Module  Impl_subtle_ConstantTimeEq_for_i16_t.
Section Impl_subtle_ConstantTimeEq_for_i16_t.
  Ltac Self := exact i16.t.
  
  Definition ct_eq
      (self : M.Val (ref ltac:(Self)))
      (other : M.Val (ref i16.t))
      : M (M.Val subtle.Choice.t) :=
    M.function_body
      (let* α0 : ltac:(refine (M.Val i16.t)) := deref self in
      let* α1 : ltac:(refine (M.Val u16.t)) := cast α0 in
      let* α2 : ltac:(refine (M.Val (ref u16.t))) := borrow α1 in
      let* α3 : ltac:(refine (M.Val i16.t)) := deref other in
      let* α4 : ltac:(refine (M.Val u16.t)) := cast α3 in
      let* α5 : ltac:(refine (M.Val (ref u16.t))) := borrow α4 in
      (subtle.ConstantTimeEq.ct_eq (Self := u16.t) (Trait := ltac:(refine _)))
        α2
        α5).
  
  Global Instance AssociatedFunction_ct_eq :
    Notation.DoubleColon ltac:(Self) "ct_eq" := {
    Notation.double_colon := ct_eq;
  }.
  
  Global Instance ℐ : subtle.ConstantTimeEq.Required.Trait ltac:(Self) := {
    subtle.ConstantTimeEq.ct_eq := ct_eq;
    subtle.ConstantTimeEq.ct_ne := Datatypes.None;
  }.
End Impl_subtle_ConstantTimeEq_for_i16_t.
End Impl_subtle_ConstantTimeEq_for_i16_t.

Module  Impl_subtle_ConstantTimeEq_for_u32_t.
Section Impl_subtle_ConstantTimeEq_for_u32_t.
  Ltac Self := exact u32.t.
  
  Definition ct_eq
      (self : M.Val (ref ltac:(Self)))
      (other : M.Val (ref u32.t))
      : M (M.Val subtle.Choice.t) :=
    M.function_body
      (let* x : ltac:(refine (M.Val u32.t)) :=
        (core.ops.bit.BitXor.bitxor
            (Self := ref u32.t)
            (Trait := ltac:(refine _)))
          self
          other in
      let* y : ltac:(refine (M.Val u32.t)) :=
        let* α0 : ltac:(refine (M.Val u32.t)) := u32.t::["wrapping_neg"] x in
        let* α1 : ltac:(refine (M.Val u32.t)) := BinOp.bit_or x α0 in
        let* α2 : ltac:(refine (M.Val i32.t)) := M.alloc 32 in
        let* α3 : ltac:(refine (M.Val i32.t)) := M.alloc 1 in
        let* α4 : ltac:(refine (M.Val i32.t)) := BinOp.sub α2 α3 in
        BinOp.shr α1 α4 in
      let* α0 : ltac:(refine (M.Val u32.t)) := M.alloc 1 in
      let* α1 : ltac:(refine (M.Val u32.t)) := use α0 in
      let* α2 : ltac:(refine (M.Val u32.t)) := BinOp.bit_xor y α1 in
      let* α3 : ltac:(refine (M.Val u8.t)) := cast α2 in
      (core.convert.Into.into (Self := u8.t) (Trait := ltac:(refine _))) α3).
  
  Global Instance AssociatedFunction_ct_eq :
    Notation.DoubleColon ltac:(Self) "ct_eq" := {
    Notation.double_colon := ct_eq;
  }.
  
  Global Instance ℐ : subtle.ConstantTimeEq.Required.Trait ltac:(Self) := {
    subtle.ConstantTimeEq.ct_eq := ct_eq;
    subtle.ConstantTimeEq.ct_ne := Datatypes.None;
  }.
End Impl_subtle_ConstantTimeEq_for_u32_t.
End Impl_subtle_ConstantTimeEq_for_u32_t.

Module  Impl_subtle_ConstantTimeEq_for_i32_t.
Section Impl_subtle_ConstantTimeEq_for_i32_t.
  Ltac Self := exact i32.t.
  
  Definition ct_eq
      (self : M.Val (ref ltac:(Self)))
      (other : M.Val (ref i32.t))
      : M (M.Val subtle.Choice.t) :=
    M.function_body
      (let* α0 : ltac:(refine (M.Val i32.t)) := deref self in
      let* α1 : ltac:(refine (M.Val u32.t)) := cast α0 in
      let* α2 : ltac:(refine (M.Val (ref u32.t))) := borrow α1 in
      let* α3 : ltac:(refine (M.Val i32.t)) := deref other in
      let* α4 : ltac:(refine (M.Val u32.t)) := cast α3 in
      let* α5 : ltac:(refine (M.Val (ref u32.t))) := borrow α4 in
      (subtle.ConstantTimeEq.ct_eq (Self := u32.t) (Trait := ltac:(refine _)))
        α2
        α5).
  
  Global Instance AssociatedFunction_ct_eq :
    Notation.DoubleColon ltac:(Self) "ct_eq" := {
    Notation.double_colon := ct_eq;
  }.
  
  Global Instance ℐ : subtle.ConstantTimeEq.Required.Trait ltac:(Self) := {
    subtle.ConstantTimeEq.ct_eq := ct_eq;
    subtle.ConstantTimeEq.ct_ne := Datatypes.None;
  }.
End Impl_subtle_ConstantTimeEq_for_i32_t.
End Impl_subtle_ConstantTimeEq_for_i32_t.

Module  Impl_subtle_ConstantTimeEq_for_u64_t.
Section Impl_subtle_ConstantTimeEq_for_u64_t.
  Ltac Self := exact u64.t.
  
  Definition ct_eq
      (self : M.Val (ref ltac:(Self)))
      (other : M.Val (ref u64.t))
      : M (M.Val subtle.Choice.t) :=
    M.function_body
      (let* x : ltac:(refine (M.Val u64.t)) :=
        (core.ops.bit.BitXor.bitxor
            (Self := ref u64.t)
            (Trait := ltac:(refine _)))
          self
          other in
      let* y : ltac:(refine (M.Val u64.t)) :=
        let* α0 : ltac:(refine (M.Val u64.t)) := u64.t::["wrapping_neg"] x in
        let* α1 : ltac:(refine (M.Val u64.t)) := BinOp.bit_or x α0 in
        let* α2 : ltac:(refine (M.Val i32.t)) := M.alloc 64 in
        let* α3 : ltac:(refine (M.Val i32.t)) := M.alloc 1 in
        let* α4 : ltac:(refine (M.Val i32.t)) := BinOp.sub α2 α3 in
        BinOp.shr α1 α4 in
      let* α0 : ltac:(refine (M.Val u64.t)) := M.alloc 1 in
      let* α1 : ltac:(refine (M.Val u64.t)) := use α0 in
      let* α2 : ltac:(refine (M.Val u64.t)) := BinOp.bit_xor y α1 in
      let* α3 : ltac:(refine (M.Val u8.t)) := cast α2 in
      (core.convert.Into.into (Self := u8.t) (Trait := ltac:(refine _))) α3).
  
  Global Instance AssociatedFunction_ct_eq :
    Notation.DoubleColon ltac:(Self) "ct_eq" := {
    Notation.double_colon := ct_eq;
  }.
  
  Global Instance ℐ : subtle.ConstantTimeEq.Required.Trait ltac:(Self) := {
    subtle.ConstantTimeEq.ct_eq := ct_eq;
    subtle.ConstantTimeEq.ct_ne := Datatypes.None;
  }.
End Impl_subtle_ConstantTimeEq_for_u64_t.
End Impl_subtle_ConstantTimeEq_for_u64_t.

Module  Impl_subtle_ConstantTimeEq_for_i64_t.
Section Impl_subtle_ConstantTimeEq_for_i64_t.
  Ltac Self := exact i64.t.
  
  Definition ct_eq
      (self : M.Val (ref ltac:(Self)))
      (other : M.Val (ref i64.t))
      : M (M.Val subtle.Choice.t) :=
    M.function_body
      (let* α0 : ltac:(refine (M.Val i64.t)) := deref self in
      let* α1 : ltac:(refine (M.Val u64.t)) := cast α0 in
      let* α2 : ltac:(refine (M.Val (ref u64.t))) := borrow α1 in
      let* α3 : ltac:(refine (M.Val i64.t)) := deref other in
      let* α4 : ltac:(refine (M.Val u64.t)) := cast α3 in
      let* α5 : ltac:(refine (M.Val (ref u64.t))) := borrow α4 in
      (subtle.ConstantTimeEq.ct_eq (Self := u64.t) (Trait := ltac:(refine _)))
        α2
        α5).
  
  Global Instance AssociatedFunction_ct_eq :
    Notation.DoubleColon ltac:(Self) "ct_eq" := {
    Notation.double_colon := ct_eq;
  }.
  
  Global Instance ℐ : subtle.ConstantTimeEq.Required.Trait ltac:(Self) := {
    subtle.ConstantTimeEq.ct_eq := ct_eq;
    subtle.ConstantTimeEq.ct_ne := Datatypes.None;
  }.
End Impl_subtle_ConstantTimeEq_for_i64_t.
End Impl_subtle_ConstantTimeEq_for_i64_t.

Module  Impl_subtle_ConstantTimeEq_for_usize_t.
Section Impl_subtle_ConstantTimeEq_for_usize_t.
  Ltac Self := exact usize.t.
  
  Definition ct_eq
      (self : M.Val (ref ltac:(Self)))
      (other : M.Val (ref usize.t))
      : M (M.Val subtle.Choice.t) :=
    M.function_body
      (let* x : ltac:(refine (M.Val usize.t)) :=
        (core.ops.bit.BitXor.bitxor
            (Self := ref usize.t)
            (Trait := ltac:(refine _)))
          self
          other in
      let* y : ltac:(refine (M.Val usize.t)) :=
        let* α0 : ltac:(refine (M.Val usize.t)) :=
          usize.t::["wrapping_neg"] x in
        let* α1 : ltac:(refine (M.Val usize.t)) := BinOp.bit_or x α0 in
        let* α2 : ltac:(refine (M.Val usize.t)) := core.mem.size_of in
        let* α3 : ltac:(refine (M.Val usize.t)) := M.alloc 8 in
        let* α4 : ltac:(refine (M.Val usize.t)) := BinOp.mul α2 α3 in
        let* α5 : ltac:(refine (M.Val usize.t)) := M.alloc 1 in
        let* α6 : ltac:(refine (M.Val usize.t)) := BinOp.sub α4 α5 in
        BinOp.shr α1 α6 in
      let* α0 : ltac:(refine (M.Val usize.t)) := M.alloc 1 in
      let* α1 : ltac:(refine (M.Val usize.t)) := use α0 in
      let* α2 : ltac:(refine (M.Val usize.t)) := BinOp.bit_xor y α1 in
      let* α3 : ltac:(refine (M.Val u8.t)) := cast α2 in
      (core.convert.Into.into (Self := u8.t) (Trait := ltac:(refine _))) α3).
  
  Global Instance AssociatedFunction_ct_eq :
    Notation.DoubleColon ltac:(Self) "ct_eq" := {
    Notation.double_colon := ct_eq;
  }.
  
  Global Instance ℐ : subtle.ConstantTimeEq.Required.Trait ltac:(Self) := {
    subtle.ConstantTimeEq.ct_eq := ct_eq;
    subtle.ConstantTimeEq.ct_ne := Datatypes.None;
  }.
End Impl_subtle_ConstantTimeEq_for_usize_t.
End Impl_subtle_ConstantTimeEq_for_usize_t.

Module  Impl_subtle_ConstantTimeEq_for_isize_t.
Section Impl_subtle_ConstantTimeEq_for_isize_t.
  Ltac Self := exact isize.t.
  
  Definition ct_eq
      (self : M.Val (ref ltac:(Self)))
      (other : M.Val (ref isize.t))
      : M (M.Val subtle.Choice.t) :=
    M.function_body
      (let* α0 : ltac:(refine (M.Val isize.t)) := deref self in
      let* α1 : ltac:(refine (M.Val usize.t)) := cast α0 in
      let* α2 : ltac:(refine (M.Val (ref usize.t))) := borrow α1 in
      let* α3 : ltac:(refine (M.Val isize.t)) := deref other in
      let* α4 : ltac:(refine (M.Val usize.t)) := cast α3 in
      let* α5 : ltac:(refine (M.Val (ref usize.t))) := borrow α4 in
      (subtle.ConstantTimeEq.ct_eq (Self := usize.t) (Trait := ltac:(refine _)))
        α2
        α5).
  
  Global Instance AssociatedFunction_ct_eq :
    Notation.DoubleColon ltac:(Self) "ct_eq" := {
    Notation.double_colon := ct_eq;
  }.
  
  Global Instance ℐ : subtle.ConstantTimeEq.Required.Trait ltac:(Self) := {
    subtle.ConstantTimeEq.ct_eq := ct_eq;
    subtle.ConstantTimeEq.ct_ne := Datatypes.None;
  }.
End Impl_subtle_ConstantTimeEq_for_isize_t.
End Impl_subtle_ConstantTimeEq_for_isize_t.

Module  ConditionallySelectable.
Section ConditionallySelectable.
  Class Trait (Self : Set) : Type := {
    ℒ_0 :: core.marker.Copy.Trait Self;
    conditional_select :
      (ref ltac:(Self)) ->
        (ref ltac:(Self)) ->
        subtle.Choice.t ->
        M ltac:(Self);
  }.
  
End ConditionallySelectable.
End ConditionallySelectable.

Module  Impl_subtle_ConditionallySelectable_for_u8_t.
Section Impl_subtle_ConditionallySelectable_for_u8_t.
  Ltac Self := exact u8.t.
  
  Definition conditional_select
      (a : M.Val (ref ltac:(Self)))
      (b : M.Val (ref ltac:(Self)))
      (choice : M.Val subtle.Choice.t)
      : M (M.Val ltac:(Self)) :=
    M.function_body
      (let* mask : ltac:(refine (M.Val u8.t)) :=
        let* α0 : ltac:(refine (M.Val (ref subtle.Choice.t))) :=
          borrow choice in
        let* α1 : ltac:(refine (M.Val u8.t)) :=
          subtle.Choice.t::["unwrap_u8"] α0 in
        let* α2 : ltac:(refine (M.Val i8.t)) := cast α1 in
        let* α3 : ltac:(refine (M.Val i8.t)) := UnOp.neg α2 in
        cast α3 in
      let* α0 : ltac:(refine (M.Val u8.t)) :=
        (core.ops.bit.BitXor.bitxor
            (Self := ref u8.t)
            (Trait := ltac:(refine _)))
          a
          b in
      let* α1 : ltac:(refine (M.Val u8.t)) := BinOp.bit_and mask α0 in
      (core.ops.bit.BitXor.bitxor (Self := ref u8.t) (Trait := ltac:(refine _)))
        a
        α1).
  
  Global Instance AssociatedFunction_conditional_select :
    Notation.DoubleColon ltac:(Self) "conditional_select" := {
    Notation.double_colon := conditional_select;
  }.
  
  Definition conditional_assign
      (self : M.Val (mut_ref ltac:(Self)))
      (other : M.Val (ref ltac:(Self)))
      (choice : M.Val subtle.Choice.t)
      : M (M.Val unit) :=
    M.function_body
      (let* mask : ltac:(refine (M.Val u8.t)) :=
        let* α0 : ltac:(refine (M.Val (ref subtle.Choice.t))) :=
          borrow choice in
        let* α1 : ltac:(refine (M.Val u8.t)) :=
          subtle.Choice.t::["unwrap_u8"] α0 in
        let* α2 : ltac:(refine (M.Val i8.t)) := cast α1 in
        let* α3 : ltac:(refine (M.Val i8.t)) := UnOp.neg α2 in
        cast α3 in
      let* _ : ltac:(refine (M.Val unit)) :=
        let* α0 : ltac:(refine (M.Val u8.t)) := deref self in
        let* α1 : ltac:(refine (M.Val u8.t)) := deref self in
        let* α2 : ltac:(refine (M.Val u8.t)) := deref other in
        let* α3 : ltac:(refine (M.Val u8.t)) := BinOp.bit_xor α1 α2 in
        let* α4 : ltac:(refine (M.Val u8.t)) := BinOp.bit_and mask α3 in
        assign_op bitxor α0 α4 in
      M.alloc tt).
  
  Global Instance AssociatedFunction_conditional_assign :
    Notation.DoubleColon ltac:(Self) "conditional_assign" := {
    Notation.double_colon := conditional_assign;
  }.
  
  Definition conditional_swap
      (a : M.Val (mut_ref ltac:(Self)))
      (b : M.Val (mut_ref ltac:(Self)))
      (choice : M.Val subtle.Choice.t)
      : M (M.Val unit) :=
    M.function_body
      (let* mask : ltac:(refine (M.Val u8.t)) :=
        let* α0 : ltac:(refine (M.Val (ref subtle.Choice.t))) :=
          borrow choice in
        let* α1 : ltac:(refine (M.Val u8.t)) :=
          subtle.Choice.t::["unwrap_u8"] α0 in
        let* α2 : ltac:(refine (M.Val i8.t)) := cast α1 in
        let* α3 : ltac:(refine (M.Val i8.t)) := UnOp.neg α2 in
        cast α3 in
      let* t : ltac:(refine (M.Val u8.t)) :=
        let* α0 : ltac:(refine (M.Val u8.t)) := deref a in
        let* α1 : ltac:(refine (M.Val u8.t)) := deref b in
        let* α2 : ltac:(refine (M.Val u8.t)) := BinOp.bit_xor α0 α1 in
        BinOp.bit_and mask α2 in
      let* _ : ltac:(refine (M.Val unit)) :=
        let* α0 : ltac:(refine (M.Val u8.t)) := deref a in
        assign_op bitxor α0 t in
      let* _ : ltac:(refine (M.Val unit)) :=
        let* α0 : ltac:(refine (M.Val u8.t)) := deref b in
        assign_op bitxor α0 t in
      M.alloc tt).
  
  Global Instance AssociatedFunction_conditional_swap :
    Notation.DoubleColon ltac:(Self) "conditional_swap" := {
    Notation.double_colon := conditional_swap;
  }.
  
  Global Instance ℐ :
    subtle.ConditionallySelectable.Required.Trait ltac:(Self) := {
    subtle.ConditionallySelectable.conditional_select := conditional_select;
    subtle.ConditionallySelectable.conditional_assign :=
      Datatypes.Some conditional_assign;
    subtle.ConditionallySelectable.conditional_swap :=
      Datatypes.Some conditional_swap;
  }.
End Impl_subtle_ConditionallySelectable_for_u8_t.
End Impl_subtle_ConditionallySelectable_for_u8_t.

Module  Impl_subtle_ConditionallySelectable_for_i8_t.
Section Impl_subtle_ConditionallySelectable_for_i8_t.
  Ltac Self := exact i8.t.
  
  Definition conditional_select
      (a : M.Val (ref ltac:(Self)))
      (b : M.Val (ref ltac:(Self)))
      (choice : M.Val subtle.Choice.t)
      : M (M.Val ltac:(Self)) :=
    M.function_body
      (let* mask : ltac:(refine (M.Val i8.t)) :=
        let* α0 : ltac:(refine (M.Val (ref subtle.Choice.t))) :=
          borrow choice in
        let* α1 : ltac:(refine (M.Val u8.t)) :=
          subtle.Choice.t::["unwrap_u8"] α0 in
        let* α2 : ltac:(refine (M.Val i8.t)) := cast α1 in
        let* α3 : ltac:(refine (M.Val i8.t)) := UnOp.neg α2 in
        use α3 in
      let* α0 : ltac:(refine (M.Val i8.t)) :=
        (core.ops.bit.BitXor.bitxor
            (Self := ref i8.t)
            (Trait := ltac:(refine _)))
          a
          b in
      let* α1 : ltac:(refine (M.Val i8.t)) := BinOp.bit_and mask α0 in
      (core.ops.bit.BitXor.bitxor (Self := ref i8.t) (Trait := ltac:(refine _)))
        a
        α1).
  
  Global Instance AssociatedFunction_conditional_select :
    Notation.DoubleColon ltac:(Self) "conditional_select" := {
    Notation.double_colon := conditional_select;
  }.
  
  Definition conditional_assign
      (self : M.Val (mut_ref ltac:(Self)))
      (other : M.Val (ref ltac:(Self)))
      (choice : M.Val subtle.Choice.t)
      : M (M.Val unit) :=
    M.function_body
      (let* mask : ltac:(refine (M.Val i8.t)) :=
        let* α0 : ltac:(refine (M.Val (ref subtle.Choice.t))) :=
          borrow choice in
        let* α1 : ltac:(refine (M.Val u8.t)) :=
          subtle.Choice.t::["unwrap_u8"] α0 in
        let* α2 : ltac:(refine (M.Val i8.t)) := cast α1 in
        let* α3 : ltac:(refine (M.Val i8.t)) := UnOp.neg α2 in
        use α3 in
      let* _ : ltac:(refine (M.Val unit)) :=
        let* α0 : ltac:(refine (M.Val i8.t)) := deref self in
        let* α1 : ltac:(refine (M.Val i8.t)) := deref self in
        let* α2 : ltac:(refine (M.Val i8.t)) := deref other in
        let* α3 : ltac:(refine (M.Val i8.t)) := BinOp.bit_xor α1 α2 in
        let* α4 : ltac:(refine (M.Val i8.t)) := BinOp.bit_and mask α3 in
        assign_op bitxor α0 α4 in
      M.alloc tt).
  
  Global Instance AssociatedFunction_conditional_assign :
    Notation.DoubleColon ltac:(Self) "conditional_assign" := {
    Notation.double_colon := conditional_assign;
  }.
  
  Definition conditional_swap
      (a : M.Val (mut_ref ltac:(Self)))
      (b : M.Val (mut_ref ltac:(Self)))
      (choice : M.Val subtle.Choice.t)
      : M (M.Val unit) :=
    M.function_body
      (let* mask : ltac:(refine (M.Val i8.t)) :=
        let* α0 : ltac:(refine (M.Val (ref subtle.Choice.t))) :=
          borrow choice in
        let* α1 : ltac:(refine (M.Val u8.t)) :=
          subtle.Choice.t::["unwrap_u8"] α0 in
        let* α2 : ltac:(refine (M.Val i8.t)) := cast α1 in
        let* α3 : ltac:(refine (M.Val i8.t)) := UnOp.neg α2 in
        use α3 in
      let* t : ltac:(refine (M.Val i8.t)) :=
        let* α0 : ltac:(refine (M.Val i8.t)) := deref a in
        let* α1 : ltac:(refine (M.Val i8.t)) := deref b in
        let* α2 : ltac:(refine (M.Val i8.t)) := BinOp.bit_xor α0 α1 in
        BinOp.bit_and mask α2 in
      let* _ : ltac:(refine (M.Val unit)) :=
        let* α0 : ltac:(refine (M.Val i8.t)) := deref a in
        assign_op bitxor α0 t in
      let* _ : ltac:(refine (M.Val unit)) :=
        let* α0 : ltac:(refine (M.Val i8.t)) := deref b in
        assign_op bitxor α0 t in
      M.alloc tt).
  
  Global Instance AssociatedFunction_conditional_swap :
    Notation.DoubleColon ltac:(Self) "conditional_swap" := {
    Notation.double_colon := conditional_swap;
  }.
  
  Global Instance ℐ :
    subtle.ConditionallySelectable.Required.Trait ltac:(Self) := {
    subtle.ConditionallySelectable.conditional_select := conditional_select;
    subtle.ConditionallySelectable.conditional_assign :=
      Datatypes.Some conditional_assign;
    subtle.ConditionallySelectable.conditional_swap :=
      Datatypes.Some conditional_swap;
  }.
End Impl_subtle_ConditionallySelectable_for_i8_t.
End Impl_subtle_ConditionallySelectable_for_i8_t.

Module  Impl_subtle_ConditionallySelectable_for_u16_t.
Section Impl_subtle_ConditionallySelectable_for_u16_t.
  Ltac Self := exact u16.t.
  
  Definition conditional_select
      (a : M.Val (ref ltac:(Self)))
      (b : M.Val (ref ltac:(Self)))
      (choice : M.Val subtle.Choice.t)
      : M (M.Val ltac:(Self)) :=
    M.function_body
      (let* mask : ltac:(refine (M.Val u16.t)) :=
        let* α0 : ltac:(refine (M.Val (ref subtle.Choice.t))) :=
          borrow choice in
        let* α1 : ltac:(refine (M.Val u8.t)) :=
          subtle.Choice.t::["unwrap_u8"] α0 in
        let* α2 : ltac:(refine (M.Val i16.t)) := cast α1 in
        let* α3 : ltac:(refine (M.Val i16.t)) := UnOp.neg α2 in
        cast α3 in
      let* α0 : ltac:(refine (M.Val u16.t)) :=
        (core.ops.bit.BitXor.bitxor
            (Self := ref u16.t)
            (Trait := ltac:(refine _)))
          a
          b in
      let* α1 : ltac:(refine (M.Val u16.t)) := BinOp.bit_and mask α0 in
      (core.ops.bit.BitXor.bitxor
          (Self := ref u16.t)
          (Trait := ltac:(refine _)))
        a
        α1).
  
  Global Instance AssociatedFunction_conditional_select :
    Notation.DoubleColon ltac:(Self) "conditional_select" := {
    Notation.double_colon := conditional_select;
  }.
  
  Definition conditional_assign
      (self : M.Val (mut_ref ltac:(Self)))
      (other : M.Val (ref ltac:(Self)))
      (choice : M.Val subtle.Choice.t)
      : M (M.Val unit) :=
    M.function_body
      (let* mask : ltac:(refine (M.Val u16.t)) :=
        let* α0 : ltac:(refine (M.Val (ref subtle.Choice.t))) :=
          borrow choice in
        let* α1 : ltac:(refine (M.Val u8.t)) :=
          subtle.Choice.t::["unwrap_u8"] α0 in
        let* α2 : ltac:(refine (M.Val i16.t)) := cast α1 in
        let* α3 : ltac:(refine (M.Val i16.t)) := UnOp.neg α2 in
        cast α3 in
      let* _ : ltac:(refine (M.Val unit)) :=
        let* α0 : ltac:(refine (M.Val u16.t)) := deref self in
        let* α1 : ltac:(refine (M.Val u16.t)) := deref self in
        let* α2 : ltac:(refine (M.Val u16.t)) := deref other in
        let* α3 : ltac:(refine (M.Val u16.t)) := BinOp.bit_xor α1 α2 in
        let* α4 : ltac:(refine (M.Val u16.t)) := BinOp.bit_and mask α3 in
        assign_op bitxor α0 α4 in
      M.alloc tt).
  
  Global Instance AssociatedFunction_conditional_assign :
    Notation.DoubleColon ltac:(Self) "conditional_assign" := {
    Notation.double_colon := conditional_assign;
  }.
  
  Definition conditional_swap
      (a : M.Val (mut_ref ltac:(Self)))
      (b : M.Val (mut_ref ltac:(Self)))
      (choice : M.Val subtle.Choice.t)
      : M (M.Val unit) :=
    M.function_body
      (let* mask : ltac:(refine (M.Val u16.t)) :=
        let* α0 : ltac:(refine (M.Val (ref subtle.Choice.t))) :=
          borrow choice in
        let* α1 : ltac:(refine (M.Val u8.t)) :=
          subtle.Choice.t::["unwrap_u8"] α0 in
        let* α2 : ltac:(refine (M.Val i16.t)) := cast α1 in
        let* α3 : ltac:(refine (M.Val i16.t)) := UnOp.neg α2 in
        cast α3 in
      let* t : ltac:(refine (M.Val u16.t)) :=
        let* α0 : ltac:(refine (M.Val u16.t)) := deref a in
        let* α1 : ltac:(refine (M.Val u16.t)) := deref b in
        let* α2 : ltac:(refine (M.Val u16.t)) := BinOp.bit_xor α0 α1 in
        BinOp.bit_and mask α2 in
      let* _ : ltac:(refine (M.Val unit)) :=
        let* α0 : ltac:(refine (M.Val u16.t)) := deref a in
        assign_op bitxor α0 t in
      let* _ : ltac:(refine (M.Val unit)) :=
        let* α0 : ltac:(refine (M.Val u16.t)) := deref b in
        assign_op bitxor α0 t in
      M.alloc tt).
  
  Global Instance AssociatedFunction_conditional_swap :
    Notation.DoubleColon ltac:(Self) "conditional_swap" := {
    Notation.double_colon := conditional_swap;
  }.
  
  Global Instance ℐ :
    subtle.ConditionallySelectable.Required.Trait ltac:(Self) := {
    subtle.ConditionallySelectable.conditional_select := conditional_select;
    subtle.ConditionallySelectable.conditional_assign :=
      Datatypes.Some conditional_assign;
    subtle.ConditionallySelectable.conditional_swap :=
      Datatypes.Some conditional_swap;
  }.
End Impl_subtle_ConditionallySelectable_for_u16_t.
End Impl_subtle_ConditionallySelectable_for_u16_t.

Module  Impl_subtle_ConditionallySelectable_for_i16_t.
Section Impl_subtle_ConditionallySelectable_for_i16_t.
  Ltac Self := exact i16.t.
  
  Definition conditional_select
      (a : M.Val (ref ltac:(Self)))
      (b : M.Val (ref ltac:(Self)))
      (choice : M.Val subtle.Choice.t)
      : M (M.Val ltac:(Self)) :=
    M.function_body
      (let* mask : ltac:(refine (M.Val i16.t)) :=
        let* α0 : ltac:(refine (M.Val (ref subtle.Choice.t))) :=
          borrow choice in
        let* α1 : ltac:(refine (M.Val u8.t)) :=
          subtle.Choice.t::["unwrap_u8"] α0 in
        let* α2 : ltac:(refine (M.Val i16.t)) := cast α1 in
        let* α3 : ltac:(refine (M.Val i16.t)) := UnOp.neg α2 in
        use α3 in
      let* α0 : ltac:(refine (M.Val i16.t)) :=
        (core.ops.bit.BitXor.bitxor
            (Self := ref i16.t)
            (Trait := ltac:(refine _)))
          a
          b in
      let* α1 : ltac:(refine (M.Val i16.t)) := BinOp.bit_and mask α0 in
      (core.ops.bit.BitXor.bitxor
          (Self := ref i16.t)
          (Trait := ltac:(refine _)))
        a
        α1).
  
  Global Instance AssociatedFunction_conditional_select :
    Notation.DoubleColon ltac:(Self) "conditional_select" := {
    Notation.double_colon := conditional_select;
  }.
  
  Definition conditional_assign
      (self : M.Val (mut_ref ltac:(Self)))
      (other : M.Val (ref ltac:(Self)))
      (choice : M.Val subtle.Choice.t)
      : M (M.Val unit) :=
    M.function_body
      (let* mask : ltac:(refine (M.Val i16.t)) :=
        let* α0 : ltac:(refine (M.Val (ref subtle.Choice.t))) :=
          borrow choice in
        let* α1 : ltac:(refine (M.Val u8.t)) :=
          subtle.Choice.t::["unwrap_u8"] α0 in
        let* α2 : ltac:(refine (M.Val i16.t)) := cast α1 in
        let* α3 : ltac:(refine (M.Val i16.t)) := UnOp.neg α2 in
        use α3 in
      let* _ : ltac:(refine (M.Val unit)) :=
        let* α0 : ltac:(refine (M.Val i16.t)) := deref self in
        let* α1 : ltac:(refine (M.Val i16.t)) := deref self in
        let* α2 : ltac:(refine (M.Val i16.t)) := deref other in
        let* α3 : ltac:(refine (M.Val i16.t)) := BinOp.bit_xor α1 α2 in
        let* α4 : ltac:(refine (M.Val i16.t)) := BinOp.bit_and mask α3 in
        assign_op bitxor α0 α4 in
      M.alloc tt).
  
  Global Instance AssociatedFunction_conditional_assign :
    Notation.DoubleColon ltac:(Self) "conditional_assign" := {
    Notation.double_colon := conditional_assign;
  }.
  
  Definition conditional_swap
      (a : M.Val (mut_ref ltac:(Self)))
      (b : M.Val (mut_ref ltac:(Self)))
      (choice : M.Val subtle.Choice.t)
      : M (M.Val unit) :=
    M.function_body
      (let* mask : ltac:(refine (M.Val i16.t)) :=
        let* α0 : ltac:(refine (M.Val (ref subtle.Choice.t))) :=
          borrow choice in
        let* α1 : ltac:(refine (M.Val u8.t)) :=
          subtle.Choice.t::["unwrap_u8"] α0 in
        let* α2 : ltac:(refine (M.Val i16.t)) := cast α1 in
        let* α3 : ltac:(refine (M.Val i16.t)) := UnOp.neg α2 in
        use α3 in
      let* t : ltac:(refine (M.Val i16.t)) :=
        let* α0 : ltac:(refine (M.Val i16.t)) := deref a in
        let* α1 : ltac:(refine (M.Val i16.t)) := deref b in
        let* α2 : ltac:(refine (M.Val i16.t)) := BinOp.bit_xor α0 α1 in
        BinOp.bit_and mask α2 in
      let* _ : ltac:(refine (M.Val unit)) :=
        let* α0 : ltac:(refine (M.Val i16.t)) := deref a in
        assign_op bitxor α0 t in
      let* _ : ltac:(refine (M.Val unit)) :=
        let* α0 : ltac:(refine (M.Val i16.t)) := deref b in
        assign_op bitxor α0 t in
      M.alloc tt).
  
  Global Instance AssociatedFunction_conditional_swap :
    Notation.DoubleColon ltac:(Self) "conditional_swap" := {
    Notation.double_colon := conditional_swap;
  }.
  
  Global Instance ℐ :
    subtle.ConditionallySelectable.Required.Trait ltac:(Self) := {
    subtle.ConditionallySelectable.conditional_select := conditional_select;
    subtle.ConditionallySelectable.conditional_assign :=
      Datatypes.Some conditional_assign;
    subtle.ConditionallySelectable.conditional_swap :=
      Datatypes.Some conditional_swap;
  }.
End Impl_subtle_ConditionallySelectable_for_i16_t.
End Impl_subtle_ConditionallySelectable_for_i16_t.

Module  Impl_subtle_ConditionallySelectable_for_u32_t.
Section Impl_subtle_ConditionallySelectable_for_u32_t.
  Ltac Self := exact u32.t.
  
  Definition conditional_select
      (a : M.Val (ref ltac:(Self)))
      (b : M.Val (ref ltac:(Self)))
      (choice : M.Val subtle.Choice.t)
      : M (M.Val ltac:(Self)) :=
    M.function_body
      (let* mask : ltac:(refine (M.Val u32.t)) :=
        let* α0 : ltac:(refine (M.Val (ref subtle.Choice.t))) :=
          borrow choice in
        let* α1 : ltac:(refine (M.Val u8.t)) :=
          subtle.Choice.t::["unwrap_u8"] α0 in
        let* α2 : ltac:(refine (M.Val i32.t)) := cast α1 in
        let* α3 : ltac:(refine (M.Val i32.t)) := UnOp.neg α2 in
        cast α3 in
      let* α0 : ltac:(refine (M.Val u32.t)) :=
        (core.ops.bit.BitXor.bitxor
            (Self := ref u32.t)
            (Trait := ltac:(refine _)))
          a
          b in
      let* α1 : ltac:(refine (M.Val u32.t)) := BinOp.bit_and mask α0 in
      (core.ops.bit.BitXor.bitxor
          (Self := ref u32.t)
          (Trait := ltac:(refine _)))
        a
        α1).
  
  Global Instance AssociatedFunction_conditional_select :
    Notation.DoubleColon ltac:(Self) "conditional_select" := {
    Notation.double_colon := conditional_select;
  }.
  
  Definition conditional_assign
      (self : M.Val (mut_ref ltac:(Self)))
      (other : M.Val (ref ltac:(Self)))
      (choice : M.Val subtle.Choice.t)
      : M (M.Val unit) :=
    M.function_body
      (let* mask : ltac:(refine (M.Val u32.t)) :=
        let* α0 : ltac:(refine (M.Val (ref subtle.Choice.t))) :=
          borrow choice in
        let* α1 : ltac:(refine (M.Val u8.t)) :=
          subtle.Choice.t::["unwrap_u8"] α0 in
        let* α2 : ltac:(refine (M.Val i32.t)) := cast α1 in
        let* α3 : ltac:(refine (M.Val i32.t)) := UnOp.neg α2 in
        cast α3 in
      let* _ : ltac:(refine (M.Val unit)) :=
        let* α0 : ltac:(refine (M.Val u32.t)) := deref self in
        let* α1 : ltac:(refine (M.Val u32.t)) := deref self in
        let* α2 : ltac:(refine (M.Val u32.t)) := deref other in
        let* α3 : ltac:(refine (M.Val u32.t)) := BinOp.bit_xor α1 α2 in
        let* α4 : ltac:(refine (M.Val u32.t)) := BinOp.bit_and mask α3 in
        assign_op bitxor α0 α4 in
      M.alloc tt).
  
  Global Instance AssociatedFunction_conditional_assign :
    Notation.DoubleColon ltac:(Self) "conditional_assign" := {
    Notation.double_colon := conditional_assign;
  }.
  
  Definition conditional_swap
      (a : M.Val (mut_ref ltac:(Self)))
      (b : M.Val (mut_ref ltac:(Self)))
      (choice : M.Val subtle.Choice.t)
      : M (M.Val unit) :=
    M.function_body
      (let* mask : ltac:(refine (M.Val u32.t)) :=
        let* α0 : ltac:(refine (M.Val (ref subtle.Choice.t))) :=
          borrow choice in
        let* α1 : ltac:(refine (M.Val u8.t)) :=
          subtle.Choice.t::["unwrap_u8"] α0 in
        let* α2 : ltac:(refine (M.Val i32.t)) := cast α1 in
        let* α3 : ltac:(refine (M.Val i32.t)) := UnOp.neg α2 in
        cast α3 in
      let* t : ltac:(refine (M.Val u32.t)) :=
        let* α0 : ltac:(refine (M.Val u32.t)) := deref a in
        let* α1 : ltac:(refine (M.Val u32.t)) := deref b in
        let* α2 : ltac:(refine (M.Val u32.t)) := BinOp.bit_xor α0 α1 in
        BinOp.bit_and mask α2 in
      let* _ : ltac:(refine (M.Val unit)) :=
        let* α0 : ltac:(refine (M.Val u32.t)) := deref a in
        assign_op bitxor α0 t in
      let* _ : ltac:(refine (M.Val unit)) :=
        let* α0 : ltac:(refine (M.Val u32.t)) := deref b in
        assign_op bitxor α0 t in
      M.alloc tt).
  
  Global Instance AssociatedFunction_conditional_swap :
    Notation.DoubleColon ltac:(Self) "conditional_swap" := {
    Notation.double_colon := conditional_swap;
  }.
  
  Global Instance ℐ :
    subtle.ConditionallySelectable.Required.Trait ltac:(Self) := {
    subtle.ConditionallySelectable.conditional_select := conditional_select;
    subtle.ConditionallySelectable.conditional_assign :=
      Datatypes.Some conditional_assign;
    subtle.ConditionallySelectable.conditional_swap :=
      Datatypes.Some conditional_swap;
  }.
End Impl_subtle_ConditionallySelectable_for_u32_t.
End Impl_subtle_ConditionallySelectable_for_u32_t.

Module  Impl_subtle_ConditionallySelectable_for_i32_t.
Section Impl_subtle_ConditionallySelectable_for_i32_t.
  Ltac Self := exact i32.t.
  
  Definition conditional_select
      (a : M.Val (ref ltac:(Self)))
      (b : M.Val (ref ltac:(Self)))
      (choice : M.Val subtle.Choice.t)
      : M (M.Val ltac:(Self)) :=
    M.function_body
      (let* mask : ltac:(refine (M.Val i32.t)) :=
        let* α0 : ltac:(refine (M.Val (ref subtle.Choice.t))) :=
          borrow choice in
        let* α1 : ltac:(refine (M.Val u8.t)) :=
          subtle.Choice.t::["unwrap_u8"] α0 in
        let* α2 : ltac:(refine (M.Val i32.t)) := cast α1 in
        let* α3 : ltac:(refine (M.Val i32.t)) := UnOp.neg α2 in
        use α3 in
      let* α0 : ltac:(refine (M.Val i32.t)) :=
        (core.ops.bit.BitXor.bitxor
            (Self := ref i32.t)
            (Trait := ltac:(refine _)))
          a
          b in
      let* α1 : ltac:(refine (M.Val i32.t)) := BinOp.bit_and mask α0 in
      (core.ops.bit.BitXor.bitxor
          (Self := ref i32.t)
          (Trait := ltac:(refine _)))
        a
        α1).
  
  Global Instance AssociatedFunction_conditional_select :
    Notation.DoubleColon ltac:(Self) "conditional_select" := {
    Notation.double_colon := conditional_select;
  }.
  
  Definition conditional_assign
      (self : M.Val (mut_ref ltac:(Self)))
      (other : M.Val (ref ltac:(Self)))
      (choice : M.Val subtle.Choice.t)
      : M (M.Val unit) :=
    M.function_body
      (let* mask : ltac:(refine (M.Val i32.t)) :=
        let* α0 : ltac:(refine (M.Val (ref subtle.Choice.t))) :=
          borrow choice in
        let* α1 : ltac:(refine (M.Val u8.t)) :=
          subtle.Choice.t::["unwrap_u8"] α0 in
        let* α2 : ltac:(refine (M.Val i32.t)) := cast α1 in
        let* α3 : ltac:(refine (M.Val i32.t)) := UnOp.neg α2 in
        use α3 in
      let* _ : ltac:(refine (M.Val unit)) :=
        let* α0 : ltac:(refine (M.Val i32.t)) := deref self in
        let* α1 : ltac:(refine (M.Val i32.t)) := deref self in
        let* α2 : ltac:(refine (M.Val i32.t)) := deref other in
        let* α3 : ltac:(refine (M.Val i32.t)) := BinOp.bit_xor α1 α2 in
        let* α4 : ltac:(refine (M.Val i32.t)) := BinOp.bit_and mask α3 in
        assign_op bitxor α0 α4 in
      M.alloc tt).
  
  Global Instance AssociatedFunction_conditional_assign :
    Notation.DoubleColon ltac:(Self) "conditional_assign" := {
    Notation.double_colon := conditional_assign;
  }.
  
  Definition conditional_swap
      (a : M.Val (mut_ref ltac:(Self)))
      (b : M.Val (mut_ref ltac:(Self)))
      (choice : M.Val subtle.Choice.t)
      : M (M.Val unit) :=
    M.function_body
      (let* mask : ltac:(refine (M.Val i32.t)) :=
        let* α0 : ltac:(refine (M.Val (ref subtle.Choice.t))) :=
          borrow choice in
        let* α1 : ltac:(refine (M.Val u8.t)) :=
          subtle.Choice.t::["unwrap_u8"] α0 in
        let* α2 : ltac:(refine (M.Val i32.t)) := cast α1 in
        let* α3 : ltac:(refine (M.Val i32.t)) := UnOp.neg α2 in
        use α3 in
      let* t : ltac:(refine (M.Val i32.t)) :=
        let* α0 : ltac:(refine (M.Val i32.t)) := deref a in
        let* α1 : ltac:(refine (M.Val i32.t)) := deref b in
        let* α2 : ltac:(refine (M.Val i32.t)) := BinOp.bit_xor α0 α1 in
        BinOp.bit_and mask α2 in
      let* _ : ltac:(refine (M.Val unit)) :=
        let* α0 : ltac:(refine (M.Val i32.t)) := deref a in
        assign_op bitxor α0 t in
      let* _ : ltac:(refine (M.Val unit)) :=
        let* α0 : ltac:(refine (M.Val i32.t)) := deref b in
        assign_op bitxor α0 t in
      M.alloc tt).
  
  Global Instance AssociatedFunction_conditional_swap :
    Notation.DoubleColon ltac:(Self) "conditional_swap" := {
    Notation.double_colon := conditional_swap;
  }.
  
  Global Instance ℐ :
    subtle.ConditionallySelectable.Required.Trait ltac:(Self) := {
    subtle.ConditionallySelectable.conditional_select := conditional_select;
    subtle.ConditionallySelectable.conditional_assign :=
      Datatypes.Some conditional_assign;
    subtle.ConditionallySelectable.conditional_swap :=
      Datatypes.Some conditional_swap;
  }.
End Impl_subtle_ConditionallySelectable_for_i32_t.
End Impl_subtle_ConditionallySelectable_for_i32_t.

Module  Impl_subtle_ConditionallySelectable_for_u64_t.
Section Impl_subtle_ConditionallySelectable_for_u64_t.
  Ltac Self := exact u64.t.
  
  Definition conditional_select
      (a : M.Val (ref ltac:(Self)))
      (b : M.Val (ref ltac:(Self)))
      (choice : M.Val subtle.Choice.t)
      : M (M.Val ltac:(Self)) :=
    M.function_body
      (let* mask : ltac:(refine (M.Val u64.t)) :=
        let* α0 : ltac:(refine (M.Val (ref subtle.Choice.t))) :=
          borrow choice in
        let* α1 : ltac:(refine (M.Val u8.t)) :=
          subtle.Choice.t::["unwrap_u8"] α0 in
        let* α2 : ltac:(refine (M.Val i64.t)) := cast α1 in
        let* α3 : ltac:(refine (M.Val i64.t)) := UnOp.neg α2 in
        cast α3 in
      let* α0 : ltac:(refine (M.Val u64.t)) :=
        (core.ops.bit.BitXor.bitxor
            (Self := ref u64.t)
            (Trait := ltac:(refine _)))
          a
          b in
      let* α1 : ltac:(refine (M.Val u64.t)) := BinOp.bit_and mask α0 in
      (core.ops.bit.BitXor.bitxor
          (Self := ref u64.t)
          (Trait := ltac:(refine _)))
        a
        α1).
  
  Global Instance AssociatedFunction_conditional_select :
    Notation.DoubleColon ltac:(Self) "conditional_select" := {
    Notation.double_colon := conditional_select;
  }.
  
  Definition conditional_assign
      (self : M.Val (mut_ref ltac:(Self)))
      (other : M.Val (ref ltac:(Self)))
      (choice : M.Val subtle.Choice.t)
      : M (M.Val unit) :=
    M.function_body
      (let* mask : ltac:(refine (M.Val u64.t)) :=
        let* α0 : ltac:(refine (M.Val (ref subtle.Choice.t))) :=
          borrow choice in
        let* α1 : ltac:(refine (M.Val u8.t)) :=
          subtle.Choice.t::["unwrap_u8"] α0 in
        let* α2 : ltac:(refine (M.Val i64.t)) := cast α1 in
        let* α3 : ltac:(refine (M.Val i64.t)) := UnOp.neg α2 in
        cast α3 in
      let* _ : ltac:(refine (M.Val unit)) :=
        let* α0 : ltac:(refine (M.Val u64.t)) := deref self in
        let* α1 : ltac:(refine (M.Val u64.t)) := deref self in
        let* α2 : ltac:(refine (M.Val u64.t)) := deref other in
        let* α3 : ltac:(refine (M.Val u64.t)) := BinOp.bit_xor α1 α2 in
        let* α4 : ltac:(refine (M.Val u64.t)) := BinOp.bit_and mask α3 in
        assign_op bitxor α0 α4 in
      M.alloc tt).
  
  Global Instance AssociatedFunction_conditional_assign :
    Notation.DoubleColon ltac:(Self) "conditional_assign" := {
    Notation.double_colon := conditional_assign;
  }.
  
  Definition conditional_swap
      (a : M.Val (mut_ref ltac:(Self)))
      (b : M.Val (mut_ref ltac:(Self)))
      (choice : M.Val subtle.Choice.t)
      : M (M.Val unit) :=
    M.function_body
      (let* mask : ltac:(refine (M.Val u64.t)) :=
        let* α0 : ltac:(refine (M.Val (ref subtle.Choice.t))) :=
          borrow choice in
        let* α1 : ltac:(refine (M.Val u8.t)) :=
          subtle.Choice.t::["unwrap_u8"] α0 in
        let* α2 : ltac:(refine (M.Val i64.t)) := cast α1 in
        let* α3 : ltac:(refine (M.Val i64.t)) := UnOp.neg α2 in
        cast α3 in
      let* t : ltac:(refine (M.Val u64.t)) :=
        let* α0 : ltac:(refine (M.Val u64.t)) := deref a in
        let* α1 : ltac:(refine (M.Val u64.t)) := deref b in
        let* α2 : ltac:(refine (M.Val u64.t)) := BinOp.bit_xor α0 α1 in
        BinOp.bit_and mask α2 in
      let* _ : ltac:(refine (M.Val unit)) :=
        let* α0 : ltac:(refine (M.Val u64.t)) := deref a in
        assign_op bitxor α0 t in
      let* _ : ltac:(refine (M.Val unit)) :=
        let* α0 : ltac:(refine (M.Val u64.t)) := deref b in
        assign_op bitxor α0 t in
      M.alloc tt).
  
  Global Instance AssociatedFunction_conditional_swap :
    Notation.DoubleColon ltac:(Self) "conditional_swap" := {
    Notation.double_colon := conditional_swap;
  }.
  
  Global Instance ℐ :
    subtle.ConditionallySelectable.Required.Trait ltac:(Self) := {
    subtle.ConditionallySelectable.conditional_select := conditional_select;
    subtle.ConditionallySelectable.conditional_assign :=
      Datatypes.Some conditional_assign;
    subtle.ConditionallySelectable.conditional_swap :=
      Datatypes.Some conditional_swap;
  }.
End Impl_subtle_ConditionallySelectable_for_u64_t.
End Impl_subtle_ConditionallySelectable_for_u64_t.

Module  Impl_subtle_ConditionallySelectable_for_i64_t.
Section Impl_subtle_ConditionallySelectable_for_i64_t.
  Ltac Self := exact i64.t.
  
  Definition conditional_select
      (a : M.Val (ref ltac:(Self)))
      (b : M.Val (ref ltac:(Self)))
      (choice : M.Val subtle.Choice.t)
      : M (M.Val ltac:(Self)) :=
    M.function_body
      (let* mask : ltac:(refine (M.Val i64.t)) :=
        let* α0 : ltac:(refine (M.Val (ref subtle.Choice.t))) :=
          borrow choice in
        let* α1 : ltac:(refine (M.Val u8.t)) :=
          subtle.Choice.t::["unwrap_u8"] α0 in
        let* α2 : ltac:(refine (M.Val i64.t)) := cast α1 in
        let* α3 : ltac:(refine (M.Val i64.t)) := UnOp.neg α2 in
        use α3 in
      let* α0 : ltac:(refine (M.Val i64.t)) :=
        (core.ops.bit.BitXor.bitxor
            (Self := ref i64.t)
            (Trait := ltac:(refine _)))
          a
          b in
      let* α1 : ltac:(refine (M.Val i64.t)) := BinOp.bit_and mask α0 in
      (core.ops.bit.BitXor.bitxor
          (Self := ref i64.t)
          (Trait := ltac:(refine _)))
        a
        α1).
  
  Global Instance AssociatedFunction_conditional_select :
    Notation.DoubleColon ltac:(Self) "conditional_select" := {
    Notation.double_colon := conditional_select;
  }.
  
  Definition conditional_assign
      (self : M.Val (mut_ref ltac:(Self)))
      (other : M.Val (ref ltac:(Self)))
      (choice : M.Val subtle.Choice.t)
      : M (M.Val unit) :=
    M.function_body
      (let* mask : ltac:(refine (M.Val i64.t)) :=
        let* α0 : ltac:(refine (M.Val (ref subtle.Choice.t))) :=
          borrow choice in
        let* α1 : ltac:(refine (M.Val u8.t)) :=
          subtle.Choice.t::["unwrap_u8"] α0 in
        let* α2 : ltac:(refine (M.Val i64.t)) := cast α1 in
        let* α3 : ltac:(refine (M.Val i64.t)) := UnOp.neg α2 in
        use α3 in
      let* _ : ltac:(refine (M.Val unit)) :=
        let* α0 : ltac:(refine (M.Val i64.t)) := deref self in
        let* α1 : ltac:(refine (M.Val i64.t)) := deref self in
        let* α2 : ltac:(refine (M.Val i64.t)) := deref other in
        let* α3 : ltac:(refine (M.Val i64.t)) := BinOp.bit_xor α1 α2 in
        let* α4 : ltac:(refine (M.Val i64.t)) := BinOp.bit_and mask α3 in
        assign_op bitxor α0 α4 in
      M.alloc tt).
  
  Global Instance AssociatedFunction_conditional_assign :
    Notation.DoubleColon ltac:(Self) "conditional_assign" := {
    Notation.double_colon := conditional_assign;
  }.
  
  Definition conditional_swap
      (a : M.Val (mut_ref ltac:(Self)))
      (b : M.Val (mut_ref ltac:(Self)))
      (choice : M.Val subtle.Choice.t)
      : M (M.Val unit) :=
    M.function_body
      (let* mask : ltac:(refine (M.Val i64.t)) :=
        let* α0 : ltac:(refine (M.Val (ref subtle.Choice.t))) :=
          borrow choice in
        let* α1 : ltac:(refine (M.Val u8.t)) :=
          subtle.Choice.t::["unwrap_u8"] α0 in
        let* α2 : ltac:(refine (M.Val i64.t)) := cast α1 in
        let* α3 : ltac:(refine (M.Val i64.t)) := UnOp.neg α2 in
        use α3 in
      let* t : ltac:(refine (M.Val i64.t)) :=
        let* α0 : ltac:(refine (M.Val i64.t)) := deref a in
        let* α1 : ltac:(refine (M.Val i64.t)) := deref b in
        let* α2 : ltac:(refine (M.Val i64.t)) := BinOp.bit_xor α0 α1 in
        BinOp.bit_and mask α2 in
      let* _ : ltac:(refine (M.Val unit)) :=
        let* α0 : ltac:(refine (M.Val i64.t)) := deref a in
        assign_op bitxor α0 t in
      let* _ : ltac:(refine (M.Val unit)) :=
        let* α0 : ltac:(refine (M.Val i64.t)) := deref b in
        assign_op bitxor α0 t in
      M.alloc tt).
  
  Global Instance AssociatedFunction_conditional_swap :
    Notation.DoubleColon ltac:(Self) "conditional_swap" := {
    Notation.double_colon := conditional_swap;
  }.
  
  Global Instance ℐ :
    subtle.ConditionallySelectable.Required.Trait ltac:(Self) := {
    subtle.ConditionallySelectable.conditional_select := conditional_select;
    subtle.ConditionallySelectable.conditional_assign :=
      Datatypes.Some conditional_assign;
    subtle.ConditionallySelectable.conditional_swap :=
      Datatypes.Some conditional_swap;
  }.
End Impl_subtle_ConditionallySelectable_for_i64_t.
End Impl_subtle_ConditionallySelectable_for_i64_t.

Module  Impl_subtle_ConditionallySelectable_for_subtle_Choice_t.
Section Impl_subtle_ConditionallySelectable_for_subtle_Choice_t.
  Ltac Self := exact subtle.Choice.t.
  
  Definition conditional_select
      (a : M.Val (ref ltac:(Self)))
      (b : M.Val (ref ltac:(Self)))
      (choice : M.Val subtle.Choice.t)
      : M (M.Val ltac:(Self)) :=
    M.function_body
      (let* α0 : ltac:(refine (M.Val subtle.Choice.t)) := deref a in
      let* α1 : ltac:(refine (M.Val u8.t)) := α0.["0"] in
      let* α2 : ltac:(refine (M.Val (ref u8.t))) := borrow α1 in
      let* α3 : ltac:(refine (M.Val subtle.Choice.t)) := deref b in
      let* α4 : ltac:(refine (M.Val u8.t)) := α3.["0"] in
      let* α5 : ltac:(refine (M.Val (ref u8.t))) := borrow α4 in
      let* α6 : ltac:(refine (M.Val u8.t)) :=
        (subtle.ConditionallySelectable.conditional_select
            (Self := u8.t)
            (Trait := ltac:(refine _)))
          α2
          α5
          choice in
      let* α7 := M.read α6 in
      M.alloc (subtle.Choice.Build_t α7)).
  
  Global Instance AssociatedFunction_conditional_select :
    Notation.DoubleColon ltac:(Self) "conditional_select" := {
    Notation.double_colon := conditional_select;
  }.
  
  Global Instance ℐ :
    subtle.ConditionallySelectable.Required.Trait ltac:(Self) := {
    subtle.ConditionallySelectable.conditional_select := conditional_select;
    subtle.ConditionallySelectable.conditional_assign := Datatypes.None;
    subtle.ConditionallySelectable.conditional_swap := Datatypes.None;
  }.
End Impl_subtle_ConditionallySelectable_for_subtle_Choice_t.
End Impl_subtle_ConditionallySelectable_for_subtle_Choice_t.

Module  ConditionallyNegatable.
Section ConditionallyNegatable.
  Class Trait (Self : Set) : Type := {
    conditional_negate : (mut_ref ltac:(Self)) -> subtle.Choice.t -> M unit;
  }.
  
End ConditionallyNegatable.
End ConditionallyNegatable.

Module  Impl_subtle_ConditionallyNegatable_for_T.
Section Impl_subtle_ConditionallyNegatable_for_T.
  Context {T : Set}.
  
  Context
    {ℋ_0 : subtle.ConditionallySelectable.Trait T}
    {ℋ_1 : core.ops.arith.Neg.Trait (ref T)}.
  
  Ltac Self := exact T.
  
  Definition conditional_negate
      (self : M.Val (mut_ref ltac:(Self)))
      (choice : M.Val subtle.Choice.t)
      : M (M.Val unit) :=
    M.function_body
      (let* self_neg : ltac:(refine (M.Val T)) :=
        let* α0 : ltac:(refine (M.Val T)) := deref self in
        let* α1 : ltac:(refine (M.Val (ref T))) := borrow α0 in
        let* α2 : ltac:(refine (M.Val (ref T))) := use α1 in
        (core.ops.arith.Neg.neg (Self := ref T) (Trait := ltac:(refine _)))
          α2 in
      let* _ : ltac:(refine (M.Val unit)) :=
        let* α0 : ltac:(refine (M.Val T)) := deref self in
        let* α1 : ltac:(refine (M.Val (mut_ref T))) := borrow_mut α0 in
        let* α2 : ltac:(refine (M.Val (ref T))) := borrow self_neg in
        (subtle.ConditionallySelectable.conditional_assign
            (Self := T)
            (Trait := ltac:(refine _)))
          α1
          α2
          choice in
      M.alloc tt).
  
  Global Instance AssociatedFunction_conditional_negate :
    Notation.DoubleColon ltac:(Self) "conditional_negate" := {
    Notation.double_colon := conditional_negate;
  }.
  
  Global Instance ℐ : subtle.ConditionallyNegatable.Trait ltac:(Self) := {
    subtle.ConditionallyNegatable.conditional_negate := conditional_negate;
  }.
End Impl_subtle_ConditionallyNegatable_for_T.
End Impl_subtle_ConditionallyNegatable_for_T.

Module  CtOption.
Section CtOption.
  Context (T : Set).
  
  Record t : Set := {
    value : T;
    is_some : subtle.Choice.t;
  }.
  
  Global Instance Get_value : Notation.Dot "value" := {
    Notation.dot x := let* x := M.read x in M.alloc x.(value) : M _;
  }.
  Global Instance Get_AF_value : Notation.DoubleColon t "value" := {
    Notation.double_colon x := let* x := M.read x in M.alloc x.(value) : M _;
  }.
  Global Instance Get_is_some : Notation.Dot "is_some" := {
    Notation.dot x := let* x := M.read x in M.alloc x.(is_some) : M _;
  }.
  Global Instance Get_AF_is_some : Notation.DoubleColon t "is_some" := {
    Notation.double_colon x := let* x := M.read x in M.alloc x.(is_some) : M _;
  }.
End CtOption.
End CtOption.
Definition CtOption (T : Set) : Set := M.Val (CtOption.t T).

Module  Impl_core_clone_Clone_for_subtle_CtOption_t_T.
Section Impl_core_clone_Clone_for_subtle_CtOption_t_T.
  Context {T : Set}.
  
  Context {ℋ_0 : core.clone.Clone.Trait T}.
  
  Ltac Self := exact (subtle.CtOption.t T).
  
  Definition clone
      (self : M.Val (ref ltac:(Self)))
      : M (M.Val (subtle.CtOption.t T)) :=
    M.function_body
      (let* α0 : ltac:(refine (M.Val (subtle.CtOption.t T))) := deref self in
      let* α1 : ltac:(refine (M.Val T)) := α0.["value"] in
      let* α2 : ltac:(refine (M.Val (ref T))) := borrow α1 in
      let* α3 : ltac:(refine (M.Val T)) :=
        (core.clone.Clone.clone (Self := T) (Trait := ltac:(refine _))) α2 in
      let* α4 := M.read α3 in
      let* α5 : ltac:(refine (M.Val (subtle.CtOption.t T))) := deref self in
      let* α6 : ltac:(refine (M.Val subtle.Choice.t)) := α5.["is_some"] in
      let* α7 : ltac:(refine (M.Val (ref subtle.Choice.t))) := borrow α6 in
      let* α8 : ltac:(refine (M.Val subtle.Choice.t)) :=
        (core.clone.Clone.clone
            (Self := subtle.Choice.t)
            (Trait := ltac:(refine _)))
          α7 in
      let* α9 := M.read α8 in
      M.alloc
        {| subtle.CtOption.value := α4; subtle.CtOption.is_some := α9; |}).
  
  Global Instance AssociatedFunction_clone :
    Notation.DoubleColon ltac:(Self) "clone" := {
    Notation.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait ltac:(Self) := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_subtle_CtOption_t_T.
End Impl_core_clone_Clone_for_subtle_CtOption_t_T.

Module  Impl_core_marker_Copy_for_subtle_CtOption_t_T.
Section Impl_core_marker_Copy_for_subtle_CtOption_t_T.
  Context {T : Set}.
  
  Context {ℋ_0 : core.marker.Copy.Trait T}.
  
  Ltac Self := exact (subtle.CtOption.t T).
  
  Global Instance ℐ : core.marker.Copy.Trait ltac:(Self) := {
  }.
End Impl_core_marker_Copy_for_subtle_CtOption_t_T.
End Impl_core_marker_Copy_for_subtle_CtOption_t_T.

Module  Impl_core_fmt_Debug_for_subtle_CtOption_t_T.
Section Impl_core_fmt_Debug_for_subtle_CtOption_t_T.
  Context {T : Set}.
  
  Context {ℋ_0 : core.fmt.Debug.Trait T}.
  
  Ltac Self := exact (subtle.CtOption.t T).
  
  Definition fmt
      (self : M.Val (ref ltac:(Self)))
      (f : M.Val (mut_ref core.fmt.Formatter.t))
      : M (M.Val ltac:(core.fmt.Result)) :=
    M.function_body
      (let* α0 : ltac:(refine (M.Val core.fmt.Formatter.t)) := deref f in
      let* α1 : ltac:(refine (M.Val (mut_ref core.fmt.Formatter.t))) :=
        borrow_mut α0 in
      let* α2 : ltac:(refine (M.Val str)) := deref (mk_str "CtOption") in
      let* α3 : ltac:(refine (M.Val (ref str))) := borrow α2 in
      let* α4 : ltac:(refine (M.Val str)) := deref (mk_str "value") in
      let* α5 : ltac:(refine (M.Val (ref str))) := borrow α4 in
      let* α6 : ltac:(refine (M.Val (subtle.CtOption.t T))) := deref self in
      let* α7 : ltac:(refine (M.Val T)) := α6.["value"] in
      let* α8 : ltac:(refine (M.Val (ref T))) := borrow α7 in
      let* α9 : ltac:(refine (M.Val (ref type not implemented))) :=
        pointer_coercion "Unsize" α8 in
      let* α10 : ltac:(refine (M.Val str)) := deref (mk_str "is_some") in
      let* α11 : ltac:(refine (M.Val (ref str))) := borrow α10 in
      let* α12 : ltac:(refine (M.Val (subtle.CtOption.t T))) := deref self in
      let* α13 : ltac:(refine (M.Val subtle.Choice.t)) := α12.["is_some"] in
      let* α14 : ltac:(refine (M.Val (ref subtle.Choice.t))) := borrow α13 in
      let* α15 : ltac:(refine (M.Val (ref (ref subtle.Choice.t)))) :=
        borrow α14 in
      let* α16 : ltac:(refine (M.Val (ref type not implemented))) :=
        pointer_coercion "Unsize" α15 in
      core.fmt.Formatter.t::["debug_struct_field2_finish"] α1 α3 α5 α9 α11 α16).
  
  Global Instance AssociatedFunction_fmt :
    Notation.DoubleColon ltac:(Self) "fmt" := {
    Notation.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait ltac:(Self) := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_subtle_CtOption_t_T.
End Impl_core_fmt_Debug_for_subtle_CtOption_t_T.

Module  Impl_core_convert_From_subtle_CtOption_t_T_for_core_option_Option_t_T.
Section Impl_core_convert_From_subtle_CtOption_t_T_for_core_option_Option_t_T.
  Context {T : Set}.
  
  Ltac Self := exact (core.option.Option.t T).
  
  Definition from
      (source : M.Val (subtle.CtOption.t T))
      : M (M.Val (core.option.Option.t T)) :=
    M.function_body
      (let* α0 : ltac:(refine (M.Val (ref (subtle.CtOption.t T)))) :=
        borrow source in
      let* α1 : ltac:(refine (M.Val subtle.Choice.t)) :=
        (subtle.CtOption.t T)::["is_some"] α0 in
      let* α2 : ltac:(refine (M.Val (ref subtle.Choice.t))) := borrow α1 in
      let* α3 : ltac:(refine (M.Val u8.t)) :=
        subtle.Choice.t::["unwrap_u8"] α2 in
      let* α4 : ltac:(refine (M.Val u8.t)) := M.alloc 1 in
      let* α5 : ltac:(refine (M.Val bool.t)) := BinOp.eq α3 α4 in
      let* α6 : ltac:(refine (M.Val bool.t)) := use α5 in
      let* α7 := M.read α6 in
      if (α7 : bool) then
        let* α0 : ltac:(refine (M.Val T)) := source.["value"] in
        let* α1 := M.read α0 in
        M.alloc (core.option.Option.Some α1)
      else
        M.alloc core.option.Option.None).
  
  Global Instance AssociatedFunction_from :
    Notation.DoubleColon ltac:(Self) "from" := {
    Notation.double_colon := from;
  }.
  
  Global Instance ℐ :
    core.convert.From.Trait ltac:(Self) (T := subtle.CtOption.t T) := {
    core.convert.From.from := from;
  }.
End Impl_core_convert_From_subtle_CtOption_t_T_for_core_option_Option_t_T.
End Impl_core_convert_From_subtle_CtOption_t_T_for_core_option_Option_t_T.

Module  Impl_subtle_CtOption_t_T.
Section Impl_subtle_CtOption_t_T.
  Context {T : Set}.
  
  Ltac Self := exact (subtle.CtOption.t T).
  
  Definition new
      (value : M.Val T)
      (is_some : M.Val subtle.Choice.t)
      : M (M.Val (subtle.CtOption.t T)) :=
    M.function_body
      (let* α0 := M.read value in
      let* α1 := M.read is_some in
      M.alloc
        {| subtle.CtOption.value := α0; subtle.CtOption.is_some := α1; |}).
  
  Global Instance AssociatedFunction_new :
    Notation.DoubleColon ltac:(Self) "new" := {
    Notation.double_colon := new;
  }.
  
  Definition expect
      (self : M.Val ltac:(Self))
      (msg : M.Val (ref str.t))
      : M (M.Val T) :=
    M.function_body
      (let* _ : ltac:(refine (M.Val unit)) :=
        let* α0 : ltac:(refine (M.Val subtle.Choice.t)) := self.["is_some"] in
        let* α1 : ltac:(refine (M.Val (ref subtle.Choice.t))) := borrow α0 in
        let* α2 : ltac:(refine (M.Val u8.t)) :=
          subtle.Choice.t::["unwrap_u8"] α1 in
        let* α3 : ltac:(refine (M.Val (ref u8.t))) := borrow α2 in
        let* α4 := M.read α3 in
        let* α5 : ltac:(refine (M.Val u8.t)) := M.alloc 1 in
        let* α6 : ltac:(refine (M.Val (ref u8.t))) := borrow α5 in
        let* α7 := M.read α6 in
        let* α8 : ltac:(refine (M.Val ((ref u8.t) * (ref u8.t)))) :=
          M.alloc (α4, α7) in
        let* α9 := M.read α8 in
        match α9 with
        | (left_val, right_val) =>
          let* right_val := M.alloc right_val in
          let* left_val := M.alloc left_val in
          let* α0 : ltac:(refine (M.Val u8.t)) := deref left_val in
          let* α1 : ltac:(refine (M.Val u8.t)) := deref right_val in
          let* α2 : ltac:(refine (M.Val bool.t)) := BinOp.eq α0 α1 in
          let* α3 : ltac:(refine (M.Val bool.t)) := UnOp.not α2 in
          let* α4 : ltac:(refine (M.Val bool.t)) := use α3 in
          let* α5 := M.read α4 in
          if (α5 : bool) then
            let* kind : ltac:(refine (M.Val core.panicking.AssertKind.t)) :=
              M.alloc core.panicking.AssertKind.Eq in
            let* _ : ltac:(refine (M.Val never.t)) :=
              let* α0 : ltac:(refine (M.Val u8.t)) := deref left_val in
              let* α1 : ltac:(refine (M.Val (ref u8.t))) := borrow α0 in
              let* α2 : ltac:(refine (M.Val u8.t)) := deref right_val in
              let* α3 : ltac:(refine (M.Val (ref u8.t))) := borrow α2 in
              let* α4 : ltac:(refine (M.Val (array (ref str)))) :=
                M.alloc [ mk_str "" ] in
              let* α5 : ltac:(refine (M.Val (ref (array (ref str))))) :=
                borrow α4 in
              let* α6 : ltac:(refine (M.Val (ref (slice (ref str))))) :=
                pointer_coercion "Unsize" α5 in
              let* α7 : ltac:(refine (M.Val (ref (ref str)))) := borrow msg in
              let* α8 : ltac:(refine (M.Val core.fmt.rt.Argument.t)) :=
                core.fmt.rt.Argument.t::["new_display"] α7 in
              let* α9 : ltac:(refine (M.Val (array core.fmt.rt.Argument.t))) :=
                M.alloc [ α8 ] in
              let* α10 :
                  ltac:(refine (M.Val (ref (array core.fmt.rt.Argument.t)))) :=
                borrow α9 in
              let* α11 :
                  ltac:(refine (M.Val (ref (slice core.fmt.rt.Argument.t)))) :=
                pointer_coercion "Unsize" α10 in
              let* α12 : ltac:(refine (M.Val core.fmt.Arguments.t)) :=
                core.fmt.Arguments.t::["new_v1"] α6 α11 in
              let* α13 := M.read α12 in
              let* α14 :
                  ltac:(refine
                    (M.Val (core.option.Option.t core.fmt.Arguments.t))) :=
                M.alloc (core.option.Option.Some α13) in
              core.panicking.assert_failed kind α1 α3 α14 in
            let* α0 : ltac:(refine (M.Val unit)) := M.alloc tt in
            never_to_any α0
          else
            M.alloc tt
        end in
      self.["value"]).
  
  Global Instance AssociatedFunction_expect :
    Notation.DoubleColon ltac:(Self) "expect" := {
    Notation.double_colon := expect;
  }.
  
  Definition unwrap (self : M.Val ltac:(Self)) : M (M.Val T) :=
    M.function_body
      (let* _ : ltac:(refine (M.Val unit)) :=
        let* α0 : ltac:(refine (M.Val subtle.Choice.t)) := self.["is_some"] in
        let* α1 : ltac:(refine (M.Val (ref subtle.Choice.t))) := borrow α0 in
        let* α2 : ltac:(refine (M.Val u8.t)) :=
          subtle.Choice.t::["unwrap_u8"] α1 in
        let* α3 : ltac:(refine (M.Val (ref u8.t))) := borrow α2 in
        let* α4 := M.read α3 in
        let* α5 : ltac:(refine (M.Val u8.t)) := M.alloc 1 in
        let* α6 : ltac:(refine (M.Val (ref u8.t))) := borrow α5 in
        let* α7 := M.read α6 in
        let* α8 : ltac:(refine (M.Val ((ref u8.t) * (ref u8.t)))) :=
          M.alloc (α4, α7) in
        let* α9 := M.read α8 in
        match α9 with
        | (left_val, right_val) =>
          let* right_val := M.alloc right_val in
          let* left_val := M.alloc left_val in
          let* α0 : ltac:(refine (M.Val u8.t)) := deref left_val in
          let* α1 : ltac:(refine (M.Val u8.t)) := deref right_val in
          let* α2 : ltac:(refine (M.Val bool.t)) := BinOp.eq α0 α1 in
          let* α3 : ltac:(refine (M.Val bool.t)) := UnOp.not α2 in
          let* α4 : ltac:(refine (M.Val bool.t)) := use α3 in
          let* α5 := M.read α4 in
          if (α5 : bool) then
            let* kind : ltac:(refine (M.Val core.panicking.AssertKind.t)) :=
              M.alloc core.panicking.AssertKind.Eq in
            let* _ : ltac:(refine (M.Val never.t)) :=
              let* α0 : ltac:(refine (M.Val u8.t)) := deref left_val in
              let* α1 : ltac:(refine (M.Val (ref u8.t))) := borrow α0 in
              let* α2 : ltac:(refine (M.Val u8.t)) := deref right_val in
              let* α3 : ltac:(refine (M.Val (ref u8.t))) := borrow α2 in
              let* α4 :
                  ltac:(refine
                    (M.Val (core.option.Option.t core.fmt.Arguments.t))) :=
                M.alloc core.option.Option.None in
              core.panicking.assert_failed kind α1 α3 α4 in
            let* α0 : ltac:(refine (M.Val unit)) := M.alloc tt in
            never_to_any α0
          else
            M.alloc tt
        end in
      self.["value"]).
  
  Global Instance AssociatedFunction_unwrap :
    Notation.DoubleColon ltac:(Self) "unwrap" := {
    Notation.double_colon := unwrap;
  }.
  
  Definition unwrap_or
      {ℋ_0 : subtle.ConditionallySelectable.Trait T}
      (self : M.Val ltac:(Self))
      (def : M.Val T)
      : M (M.Val T) :=
    M.function_body
      (let* α0 : ltac:(refine (M.Val (ref T))) := borrow def in
      let* α1 : ltac:(refine (M.Val T)) := self.["value"] in
      let* α2 : ltac:(refine (M.Val (ref T))) := borrow α1 in
      let* α3 : ltac:(refine (M.Val subtle.Choice.t)) := self.["is_some"] in
      (subtle.ConditionallySelectable.conditional_select
          (Self := T)
          (Trait := ltac:(refine _)))
        α0
        α2
        α3).
  
  Global Instance AssociatedFunction_unwrap_or
      {ℋ_0 : subtle.ConditionallySelectable.Trait T} :
    Notation.DoubleColon ltac:(Self) "unwrap_or" := {
    Notation.double_colon := unwrap_or;
  }.
  
  Definition unwrap_or_else
      {F : Set}
      {ℋ_0 : subtle.ConditionallySelectable.Trait T}
      {ℋ_1 : core.ops.function.FnOnce.Trait F (Args := unit)}
      (self : M.Val ltac:(Self))
      (f : M.Val F)
      : M (M.Val T) :=
    M.function_body
      (let* α0 : ltac:(refine (M.Val unit)) := M.alloc tt in
      let* α1 : ltac:(refine (M.Val T)) :=
        (core.ops.function.FnOnce.call_once
            (Self := F)
            (Trait := ltac:(refine _)))
          f
          α0 in
      let* α2 : ltac:(refine (M.Val (ref T))) := borrow α1 in
      let* α3 : ltac:(refine (M.Val T)) := self.["value"] in
      let* α4 : ltac:(refine (M.Val (ref T))) := borrow α3 in
      let* α5 : ltac:(refine (M.Val subtle.Choice.t)) := self.["is_some"] in
      (subtle.ConditionallySelectable.conditional_select
          (Self := T)
          (Trait := ltac:(refine _)))
        α2
        α4
        α5).
  
  Global Instance AssociatedFunction_unwrap_or_else
      {F : Set}
      {ℋ_0 : subtle.ConditionallySelectable.Trait T}
      {ℋ_1 : core.ops.function.FnOnce.Trait F (Args := unit)} :
    Notation.DoubleColon ltac:(Self) "unwrap_or_else" := {
    Notation.double_colon := unwrap_or_else (F := F);
  }.
  
  Definition is_some
      (self : M.Val (ref ltac:(Self)))
      : M (M.Val subtle.Choice.t) :=
    M.function_body
      (let* α0 : ltac:(refine (M.Val (subtle.CtOption.t T))) := deref self in
      α0.["is_some"]).
  
  Global Instance AssociatedFunction_is_some :
    Notation.DoubleColon ltac:(Self) "is_some" := {
    Notation.double_colon := is_some;
  }.
  
  Definition is_none
      (self : M.Val (ref ltac:(Self)))
      : M (M.Val subtle.Choice.t) :=
    M.function_body
      (let* α0 : ltac:(refine (M.Val (subtle.CtOption.t T))) := deref self in
      let* α1 : ltac:(refine (M.Val subtle.Choice.t)) := α0.["is_some"] in
      (core.ops.bit.Not.not
          (Self := subtle.Choice.t)
          (Trait := ltac:(refine _)))
        α1).
  
  Global Instance AssociatedFunction_is_none :
    Notation.DoubleColon ltac:(Self) "is_none" := {
    Notation.double_colon := is_none;
  }.
  
  Definition map
      {U F : Set}
      {ℋ_0 : core.default.Default.Trait T}
      {ℋ_1 : subtle.ConditionallySelectable.Trait T}
      {ℋ_2 : core.ops.function.FnOnce.Trait F (Args := T)}
      (self : M.Val ltac:(Self))
      (f : M.Val F)
      : M (M.Val (subtle.CtOption.t U)) :=
    M.function_body
      (let* α0 : ltac:(refine (M.Val T)) :=
        core.default.Default.default (Self := T) (Trait := ltac:(refine _)) in
      let* α1 : ltac:(refine (M.Val (ref T))) := borrow α0 in
      let* α2 : ltac:(refine (M.Val T)) := self.["value"] in
      let* α3 : ltac:(refine (M.Val (ref T))) := borrow α2 in
      let* α4 : ltac:(refine (M.Val subtle.Choice.t)) := self.["is_some"] in
      let* α5 : ltac:(refine (M.Val T)) :=
        (subtle.ConditionallySelectable.conditional_select
            (Self := T)
            (Trait := ltac:(refine _)))
          α1
          α3
          α4 in
      let* α6 := M.read α5 in
      let* α7 : ltac:(refine (M.Val T)) := M.alloc (α6) in
      let* α8 : ltac:(refine (M.Val U)) :=
        (core.ops.function.FnOnce.call_once
            (Self := F)
            (Trait := ltac:(refine _)))
          f
          α7 in
      let* α9 : ltac:(refine (M.Val subtle.Choice.t)) := self.["is_some"] in
      (subtle.CtOption.t U)::["new"] α8 α9).
  
  Global Instance AssociatedFunction_map
      {U F : Set}
      {ℋ_0 : core.default.Default.Trait T}
      {ℋ_1 : subtle.ConditionallySelectable.Trait T}
      {ℋ_2 : core.ops.function.FnOnce.Trait F (Args := T)} :
    Notation.DoubleColon ltac:(Self) "map" := {
    Notation.double_colon := map (U := U) (F := F);
  }.
  
  Definition and_then
      {U F : Set}
      {ℋ_0 : core.default.Default.Trait T}
      {ℋ_1 : subtle.ConditionallySelectable.Trait T}
      {ℋ_2 : core.ops.function.FnOnce.Trait F (Args := T)}
      (self : M.Val ltac:(Self))
      (f : M.Val F)
      : M (M.Val (subtle.CtOption.t U)) :=
    M.function_body
      (let* tmp : ltac:(refine (M.Val (subtle.CtOption.t U))) :=
        let* α0 : ltac:(refine (M.Val T)) :=
          core.default.Default.default (Self := T) (Trait := ltac:(refine _)) in
        let* α1 : ltac:(refine (M.Val (ref T))) := borrow α0 in
        let* α2 : ltac:(refine (M.Val T)) := self.["value"] in
        let* α3 : ltac:(refine (M.Val (ref T))) := borrow α2 in
        let* α4 : ltac:(refine (M.Val subtle.Choice.t)) := self.["is_some"] in
        let* α5 : ltac:(refine (M.Val T)) :=
          (subtle.ConditionallySelectable.conditional_select
              (Self := T)
              (Trait := ltac:(refine _)))
            α1
            α3
            α4 in
        let* α6 := M.read α5 in
        let* α7 : ltac:(refine (M.Val T)) := M.alloc (α6) in
        (core.ops.function.FnOnce.call_once
            (Self := F)
            (Trait := ltac:(refine _)))
          f
          α7 in
      let* _ : ltac:(refine (M.Val unit)) :=
        let* α0 : ltac:(refine (M.Val subtle.Choice.t)) := tmp.["is_some"] in
        let* α1 : ltac:(refine (M.Val (mut_ref subtle.Choice.t))) :=
          borrow_mut α0 in
        let* α2 : ltac:(refine (M.Val subtle.Choice.t)) := self.["is_some"] in
        (core.ops.bit.BitAndAssign.bitand_assign
            (Self := subtle.Choice.t)
            (Trait := ltac:(refine _)))
          α1
          α2 in
      M.pure tmp).
  
  Global Instance AssociatedFunction_and_then
      {U F : Set}
      {ℋ_0 : core.default.Default.Trait T}
      {ℋ_1 : subtle.ConditionallySelectable.Trait T}
      {ℋ_2 : core.ops.function.FnOnce.Trait F (Args := T)} :
    Notation.DoubleColon ltac:(Self) "and_then" := {
    Notation.double_colon := and_then (U := U) (F := F);
  }.
  
  Definition or_else
      {F : Set}
      {ℋ_0 : subtle.ConditionallySelectable.Trait T}
      {ℋ_1 : core.ops.function.FnOnce.Trait F (Args := unit)}
      (self : M.Val ltac:(Self))
      (f : M.Val F)
      : M (M.Val (subtle.CtOption.t T)) :=
    M.function_body
      (let* is_none : ltac:(refine (M.Val subtle.Choice.t)) :=
        let* α0 : ltac:(refine (M.Val (ref (subtle.CtOption.t T)))) :=
          borrow self in
        (subtle.CtOption.t T)::["is_none"] α0 in
      let* f : ltac:(refine (M.Val (subtle.CtOption.t T))) :=
        let* α0 : ltac:(refine (M.Val unit)) := M.alloc tt in
        (core.ops.function.FnOnce.call_once
            (Self := F)
            (Trait := ltac:(refine _)))
          f
          α0 in
      let* α0 : ltac:(refine (M.Val (ref (subtle.CtOption.t T)))) :=
        borrow self in
      let* α1 : ltac:(refine (M.Val (ref (subtle.CtOption.t T)))) := borrow f in
      (subtle.ConditionallySelectable.conditional_select
          (Self := subtle.CtOption.t T)
          (Trait := ltac:(refine _)))
        α0
        α1
        is_none).
  
  Global Instance AssociatedFunction_or_else
      {F : Set}
      {ℋ_0 : subtle.ConditionallySelectable.Trait T}
      {ℋ_1 : core.ops.function.FnOnce.Trait F (Args := unit)} :
    Notation.DoubleColon ltac:(Self) "or_else" := {
    Notation.double_colon := or_else (F := F);
  }.
End Impl_subtle_CtOption_t_T.
End Impl_subtle_CtOption_t_T.

Module  Impl_subtle_ConditionallySelectable_for_subtle_CtOption_t_T.
Section Impl_subtle_ConditionallySelectable_for_subtle_CtOption_t_T.
  Context {T : Set}.
  
  Context {ℋ_0 : subtle.ConditionallySelectable.Trait T}.
  
  Ltac Self := exact (subtle.CtOption.t T).
  
  Definition conditional_select
      (a : M.Val (ref ltac:(Self)))
      (b : M.Val (ref ltac:(Self)))
      (choice : M.Val subtle.Choice.t)
      : M (M.Val ltac:(Self)) :=
    M.function_body
      (let* α0 : ltac:(refine (M.Val (subtle.CtOption.t T))) := deref a in
      let* α1 : ltac:(refine (M.Val T)) := α0.["value"] in
      let* α2 : ltac:(refine (M.Val (ref T))) := borrow α1 in
      let* α3 : ltac:(refine (M.Val (subtle.CtOption.t T))) := deref b in
      let* α4 : ltac:(refine (M.Val T)) := α3.["value"] in
      let* α5 : ltac:(refine (M.Val (ref T))) := borrow α4 in
      let* α6 : ltac:(refine (M.Val T)) :=
        (subtle.ConditionallySelectable.conditional_select
            (Self := T)
            (Trait := ltac:(refine _)))
          α2
          α5
          choice in
      let* α7 : ltac:(refine (M.Val (subtle.CtOption.t T))) := deref a in
      let* α8 : ltac:(refine (M.Val subtle.Choice.t)) := α7.["is_some"] in
      let* α9 : ltac:(refine (M.Val (ref subtle.Choice.t))) := borrow α8 in
      let* α10 : ltac:(refine (M.Val (subtle.CtOption.t T))) := deref b in
      let* α11 : ltac:(refine (M.Val subtle.Choice.t)) := α10.["is_some"] in
      let* α12 : ltac:(refine (M.Val (ref subtle.Choice.t))) := borrow α11 in
      let* α13 : ltac:(refine (M.Val subtle.Choice.t)) :=
        (subtle.ConditionallySelectable.conditional_select
            (Self := subtle.Choice.t)
            (Trait := ltac:(refine _)))
          α9
          α12
          choice in
      (subtle.CtOption.t T)::["new"] α6 α13).
  
  Global Instance AssociatedFunction_conditional_select :
    Notation.DoubleColon ltac:(Self) "conditional_select" := {
    Notation.double_colon := conditional_select;
  }.
  
  Global Instance ℐ :
    subtle.ConditionallySelectable.Required.Trait ltac:(Self) := {
    subtle.ConditionallySelectable.conditional_select := conditional_select;
    subtle.ConditionallySelectable.conditional_assign := Datatypes.None;
    subtle.ConditionallySelectable.conditional_swap := Datatypes.None;
  }.
End Impl_subtle_ConditionallySelectable_for_subtle_CtOption_t_T.
End Impl_subtle_ConditionallySelectable_for_subtle_CtOption_t_T.

Module  Impl_subtle_ConstantTimeEq_for_subtle_CtOption_t_T.
Section Impl_subtle_ConstantTimeEq_for_subtle_CtOption_t_T.
  Context {T : Set}.
  
  Context {ℋ_0 : subtle.ConstantTimeEq.Trait T}.
  
  Ltac Self := exact (subtle.CtOption.t T).
  
  Definition ct_eq
      (self : M.Val (ref ltac:(Self)))
      (rhs : M.Val (ref (subtle.CtOption.t T)))
      : M (M.Val subtle.Choice.t) :=
    M.function_body
      (let* a : ltac:(refine (M.Val subtle.Choice.t)) :=
        let* α0 : ltac:(refine (M.Val (subtle.CtOption.t T))) := deref self in
        let* α1 : ltac:(refine (M.Val (ref (subtle.CtOption.t T)))) :=
          borrow α0 in
        (subtle.CtOption.t T)::["is_some"] α1 in
      let* b : ltac:(refine (M.Val subtle.Choice.t)) :=
        let* α0 : ltac:(refine (M.Val (subtle.CtOption.t T))) := deref rhs in
        let* α1 : ltac:(refine (M.Val (ref (subtle.CtOption.t T)))) :=
          borrow α0 in
        (subtle.CtOption.t T)::["is_some"] α1 in
      let* α0 : ltac:(refine (M.Val subtle.Choice.t)) :=
        (core.ops.bit.BitAnd.bitand
            (Self := subtle.Choice.t)
            (Trait := ltac:(refine _)))
          a
          b in
      let* α1 : ltac:(refine (M.Val (subtle.CtOption.t T))) := deref self in
      let* α2 : ltac:(refine (M.Val T)) := α1.["value"] in
      let* α3 : ltac:(refine (M.Val (ref T))) := borrow α2 in
      let* α4 : ltac:(refine (M.Val (subtle.CtOption.t T))) := deref rhs in
      let* α5 : ltac:(refine (M.Val T)) := α4.["value"] in
      let* α6 : ltac:(refine (M.Val (ref T))) := borrow α5 in
      let* α7 : ltac:(refine (M.Val subtle.Choice.t)) :=
        (subtle.ConstantTimeEq.ct_eq (Self := T) (Trait := ltac:(refine _)))
          α3
          α6 in
      let* α8 : ltac:(refine (M.Val subtle.Choice.t)) :=
        (core.ops.bit.BitAnd.bitand
            (Self := subtle.Choice.t)
            (Trait := ltac:(refine _)))
          α0
          α7 in
      let* α9 : ltac:(refine (M.Val subtle.Choice.t)) :=
        (core.ops.bit.Not.not
            (Self := subtle.Choice.t)
            (Trait := ltac:(refine _)))
          a in
      let* α10 : ltac:(refine (M.Val subtle.Choice.t)) :=
        (core.ops.bit.Not.not
            (Self := subtle.Choice.t)
            (Trait := ltac:(refine _)))
          b in
      let* α11 : ltac:(refine (M.Val subtle.Choice.t)) :=
        (core.ops.bit.BitAnd.bitand
            (Self := subtle.Choice.t)
            (Trait := ltac:(refine _)))
          α9
          α10 in
      (core.ops.bit.BitOr.bitor
          (Self := subtle.Choice.t)
          (Trait := ltac:(refine _)))
        α8
        α11).
  
  Global Instance AssociatedFunction_ct_eq :
    Notation.DoubleColon ltac:(Self) "ct_eq" := {
    Notation.double_colon := ct_eq;
  }.
  
  Global Instance ℐ : subtle.ConstantTimeEq.Required.Trait ltac:(Self) := {
    subtle.ConstantTimeEq.ct_eq := ct_eq;
    subtle.ConstantTimeEq.ct_ne := Datatypes.None;
  }.
End Impl_subtle_ConstantTimeEq_for_subtle_CtOption_t_T.
End Impl_subtle_ConstantTimeEq_for_subtle_CtOption_t_T.

Module  ConstantTimeGreater.
Section ConstantTimeGreater.
  Class Trait (Self : Set) : Type := {
    ct_gt : (ref ltac:(Self)) -> (ref ltac:(Self)) -> M subtle.Choice.t;
  }.
  
End ConstantTimeGreater.
End ConstantTimeGreater.

Module  Impl_subtle_ConstantTimeGreater_for_u8_t.
Section Impl_subtle_ConstantTimeGreater_for_u8_t.
  Ltac Self := exact u8.t.
  
  Definition ct_gt
      (self : M.Val (ref ltac:(Self)))
      (other : M.Val (ref u8.t))
      : M (M.Val subtle.Choice.t) :=
    M.function_body
      (let* gtb : ltac:(refine (M.Val u8.t)) :=
        let* α0 : ltac:(refine (M.Val u8.t)) :=
          (core.ops.bit.Not.not (Self := ref u8.t) (Trait := ltac:(refine _)))
            other in
        (core.ops.bit.BitAnd.bitand
            (Self := ref u8.t)
            (Trait := ltac:(refine _)))
          self
          α0 in
      let* ltb : ltac:(refine (M.Val u8.t)) :=
        let* α0 : ltac:(refine (M.Val u8.t)) :=
          (core.ops.bit.Not.not (Self := ref u8.t) (Trait := ltac:(refine _)))
            self in
        (core.ops.bit.BitAnd.bitand (Self := u8.t) (Trait := ltac:(refine _)))
          α0
          other in
      let* pow : ltac:(refine (M.Val i32.t)) := M.alloc 1 in
      let* _ : ltac:(refine (M.Val unit)) :=
        loop
          (let* α0 : ltac:(refine (M.Val i32.t)) := M.alloc 8 in
          let* α1 : ltac:(refine (M.Val bool.t)) := BinOp.lt pow α0 in
          let* α2 : ltac:(refine (M.Val bool.t)) := use α1 in
          let* α3 := M.read α2 in
          if (α3 : bool) then
            let* _ : ltac:(refine (M.Val unit)) :=
              let* α0 : ltac:(refine (M.Val u8.t)) := BinOp.shr ltb pow in
              assign_op bitor ltb α0 in
            let* _ : ltac:(refine (M.Val unit)) := assign_op add pow pow in
            M.alloc tt
          else
            let* _ : ltac:(refine (M.Val unit)) :=
              let* α0 : ltac:(refine (M.Val never.t)) := Break in
              never_to_any α0 in
            let* α0 : ltac:(refine (M.Val unit)) := M.alloc tt in
            never_to_any α0) in
      let* bit : ltac:(refine (M.Val u8.t)) :=
        let* α0 : ltac:(refine (M.Val u8.t)) := UnOp.not ltb in
        BinOp.bit_and gtb α0 in
      let* pow : ltac:(refine (M.Val i32.t)) := M.alloc 1 in
      let* _ : ltac:(refine (M.Val unit)) :=
        loop
          (let* α0 : ltac:(refine (M.Val i32.t)) := M.alloc 8 in
          let* α1 : ltac:(refine (M.Val bool.t)) := BinOp.lt pow α0 in
          let* α2 : ltac:(refine (M.Val bool.t)) := use α1 in
          let* α3 := M.read α2 in
          if (α3 : bool) then
            let* _ : ltac:(refine (M.Val unit)) :=
              let* α0 : ltac:(refine (M.Val u8.t)) := BinOp.shr bit pow in
              assign_op bitor bit α0 in
            let* _ : ltac:(refine (M.Val unit)) := assign_op add pow pow in
            M.alloc tt
          else
            let* _ : ltac:(refine (M.Val unit)) :=
              let* α0 : ltac:(refine (M.Val never.t)) := Break in
              never_to_any α0 in
            let* α0 : ltac:(refine (M.Val unit)) := M.alloc tt in
            never_to_any α0) in
      let* α0 : ltac:(refine (M.Val u8.t)) := M.alloc 1 in
      let* α1 : ltac:(refine (M.Val u8.t)) := BinOp.bit_and bit α0 in
      let* α2 : ltac:(refine (M.Val u8.t)) := use α1 in
      (core.convert.From.from
          (Self := subtle.Choice.t)
          (Trait := ltac:(refine _)))
        α2).
  
  Global Instance AssociatedFunction_ct_gt :
    Notation.DoubleColon ltac:(Self) "ct_gt" := {
    Notation.double_colon := ct_gt;
  }.
  
  Global Instance ℐ : subtle.ConstantTimeGreater.Trait ltac:(Self) := {
    subtle.ConstantTimeGreater.ct_gt := ct_gt;
  }.
End Impl_subtle_ConstantTimeGreater_for_u8_t.
End Impl_subtle_ConstantTimeGreater_for_u8_t.

Module  Impl_subtle_ConstantTimeGreater_for_u16_t.
Section Impl_subtle_ConstantTimeGreater_for_u16_t.
  Ltac Self := exact u16.t.
  
  Definition ct_gt
      (self : M.Val (ref ltac:(Self)))
      (other : M.Val (ref u16.t))
      : M (M.Val subtle.Choice.t) :=
    M.function_body
      (let* gtb : ltac:(refine (M.Val u16.t)) :=
        let* α0 : ltac:(refine (M.Val u16.t)) :=
          (core.ops.bit.Not.not (Self := ref u16.t) (Trait := ltac:(refine _)))
            other in
        (core.ops.bit.BitAnd.bitand
            (Self := ref u16.t)
            (Trait := ltac:(refine _)))
          self
          α0 in
      let* ltb : ltac:(refine (M.Val u16.t)) :=
        let* α0 : ltac:(refine (M.Val u16.t)) :=
          (core.ops.bit.Not.not (Self := ref u16.t) (Trait := ltac:(refine _)))
            self in
        (core.ops.bit.BitAnd.bitand (Self := u16.t) (Trait := ltac:(refine _)))
          α0
          other in
      let* pow : ltac:(refine (M.Val i32.t)) := M.alloc 1 in
      let* _ : ltac:(refine (M.Val unit)) :=
        loop
          (let* α0 : ltac:(refine (M.Val i32.t)) := M.alloc 16 in
          let* α1 : ltac:(refine (M.Val bool.t)) := BinOp.lt pow α0 in
          let* α2 : ltac:(refine (M.Val bool.t)) := use α1 in
          let* α3 := M.read α2 in
          if (α3 : bool) then
            let* _ : ltac:(refine (M.Val unit)) :=
              let* α0 : ltac:(refine (M.Val u16.t)) := BinOp.shr ltb pow in
              assign_op bitor ltb α0 in
            let* _ : ltac:(refine (M.Val unit)) := assign_op add pow pow in
            M.alloc tt
          else
            let* _ : ltac:(refine (M.Val unit)) :=
              let* α0 : ltac:(refine (M.Val never.t)) := Break in
              never_to_any α0 in
            let* α0 : ltac:(refine (M.Val unit)) := M.alloc tt in
            never_to_any α0) in
      let* bit : ltac:(refine (M.Val u16.t)) :=
        let* α0 : ltac:(refine (M.Val u16.t)) := UnOp.not ltb in
        BinOp.bit_and gtb α0 in
      let* pow : ltac:(refine (M.Val i32.t)) := M.alloc 1 in
      let* _ : ltac:(refine (M.Val unit)) :=
        loop
          (let* α0 : ltac:(refine (M.Val i32.t)) := M.alloc 16 in
          let* α1 : ltac:(refine (M.Val bool.t)) := BinOp.lt pow α0 in
          let* α2 : ltac:(refine (M.Val bool.t)) := use α1 in
          let* α3 := M.read α2 in
          if (α3 : bool) then
            let* _ : ltac:(refine (M.Val unit)) :=
              let* α0 : ltac:(refine (M.Val u16.t)) := BinOp.shr bit pow in
              assign_op bitor bit α0 in
            let* _ : ltac:(refine (M.Val unit)) := assign_op add pow pow in
            M.alloc tt
          else
            let* _ : ltac:(refine (M.Val unit)) :=
              let* α0 : ltac:(refine (M.Val never.t)) := Break in
              never_to_any α0 in
            let* α0 : ltac:(refine (M.Val unit)) := M.alloc tt in
            never_to_any α0) in
      let* α0 : ltac:(refine (M.Val u16.t)) := M.alloc 1 in
      let* α1 : ltac:(refine (M.Val u16.t)) := BinOp.bit_and bit α0 in
      let* α2 : ltac:(refine (M.Val u8.t)) := cast α1 in
      (core.convert.From.from
          (Self := subtle.Choice.t)
          (Trait := ltac:(refine _)))
        α2).
  
  Global Instance AssociatedFunction_ct_gt :
    Notation.DoubleColon ltac:(Self) "ct_gt" := {
    Notation.double_colon := ct_gt;
  }.
  
  Global Instance ℐ : subtle.ConstantTimeGreater.Trait ltac:(Self) := {
    subtle.ConstantTimeGreater.ct_gt := ct_gt;
  }.
End Impl_subtle_ConstantTimeGreater_for_u16_t.
End Impl_subtle_ConstantTimeGreater_for_u16_t.

Module  Impl_subtle_ConstantTimeGreater_for_u32_t.
Section Impl_subtle_ConstantTimeGreater_for_u32_t.
  Ltac Self := exact u32.t.
  
  Definition ct_gt
      (self : M.Val (ref ltac:(Self)))
      (other : M.Val (ref u32.t))
      : M (M.Val subtle.Choice.t) :=
    M.function_body
      (let* gtb : ltac:(refine (M.Val u32.t)) :=
        let* α0 : ltac:(refine (M.Val u32.t)) :=
          (core.ops.bit.Not.not (Self := ref u32.t) (Trait := ltac:(refine _)))
            other in
        (core.ops.bit.BitAnd.bitand
            (Self := ref u32.t)
            (Trait := ltac:(refine _)))
          self
          α0 in
      let* ltb : ltac:(refine (M.Val u32.t)) :=
        let* α0 : ltac:(refine (M.Val u32.t)) :=
          (core.ops.bit.Not.not (Self := ref u32.t) (Trait := ltac:(refine _)))
            self in
        (core.ops.bit.BitAnd.bitand (Self := u32.t) (Trait := ltac:(refine _)))
          α0
          other in
      let* pow : ltac:(refine (M.Val i32.t)) := M.alloc 1 in
      let* _ : ltac:(refine (M.Val unit)) :=
        loop
          (let* α0 : ltac:(refine (M.Val i32.t)) := M.alloc 32 in
          let* α1 : ltac:(refine (M.Val bool.t)) := BinOp.lt pow α0 in
          let* α2 : ltac:(refine (M.Val bool.t)) := use α1 in
          let* α3 := M.read α2 in
          if (α3 : bool) then
            let* _ : ltac:(refine (M.Val unit)) :=
              let* α0 : ltac:(refine (M.Val u32.t)) := BinOp.shr ltb pow in
              assign_op bitor ltb α0 in
            let* _ : ltac:(refine (M.Val unit)) := assign_op add pow pow in
            M.alloc tt
          else
            let* _ : ltac:(refine (M.Val unit)) :=
              let* α0 : ltac:(refine (M.Val never.t)) := Break in
              never_to_any α0 in
            let* α0 : ltac:(refine (M.Val unit)) := M.alloc tt in
            never_to_any α0) in
      let* bit : ltac:(refine (M.Val u32.t)) :=
        let* α0 : ltac:(refine (M.Val u32.t)) := UnOp.not ltb in
        BinOp.bit_and gtb α0 in
      let* pow : ltac:(refine (M.Val i32.t)) := M.alloc 1 in
      let* _ : ltac:(refine (M.Val unit)) :=
        loop
          (let* α0 : ltac:(refine (M.Val i32.t)) := M.alloc 32 in
          let* α1 : ltac:(refine (M.Val bool.t)) := BinOp.lt pow α0 in
          let* α2 : ltac:(refine (M.Val bool.t)) := use α1 in
          let* α3 := M.read α2 in
          if (α3 : bool) then
            let* _ : ltac:(refine (M.Val unit)) :=
              let* α0 : ltac:(refine (M.Val u32.t)) := BinOp.shr bit pow in
              assign_op bitor bit α0 in
            let* _ : ltac:(refine (M.Val unit)) := assign_op add pow pow in
            M.alloc tt
          else
            let* _ : ltac:(refine (M.Val unit)) :=
              let* α0 : ltac:(refine (M.Val never.t)) := Break in
              never_to_any α0 in
            let* α0 : ltac:(refine (M.Val unit)) := M.alloc tt in
            never_to_any α0) in
      let* α0 : ltac:(refine (M.Val u32.t)) := M.alloc 1 in
      let* α1 : ltac:(refine (M.Val u32.t)) := BinOp.bit_and bit α0 in
      let* α2 : ltac:(refine (M.Val u8.t)) := cast α1 in
      (core.convert.From.from
          (Self := subtle.Choice.t)
          (Trait := ltac:(refine _)))
        α2).
  
  Global Instance AssociatedFunction_ct_gt :
    Notation.DoubleColon ltac:(Self) "ct_gt" := {
    Notation.double_colon := ct_gt;
  }.
  
  Global Instance ℐ : subtle.ConstantTimeGreater.Trait ltac:(Self) := {
    subtle.ConstantTimeGreater.ct_gt := ct_gt;
  }.
End Impl_subtle_ConstantTimeGreater_for_u32_t.
End Impl_subtle_ConstantTimeGreater_for_u32_t.

Module  Impl_subtle_ConstantTimeGreater_for_u64_t.
Section Impl_subtle_ConstantTimeGreater_for_u64_t.
  Ltac Self := exact u64.t.
  
  Definition ct_gt
      (self : M.Val (ref ltac:(Self)))
      (other : M.Val (ref u64.t))
      : M (M.Val subtle.Choice.t) :=
    M.function_body
      (let* gtb : ltac:(refine (M.Val u64.t)) :=
        let* α0 : ltac:(refine (M.Val u64.t)) :=
          (core.ops.bit.Not.not (Self := ref u64.t) (Trait := ltac:(refine _)))
            other in
        (core.ops.bit.BitAnd.bitand
            (Self := ref u64.t)
            (Trait := ltac:(refine _)))
          self
          α0 in
      let* ltb : ltac:(refine (M.Val u64.t)) :=
        let* α0 : ltac:(refine (M.Val u64.t)) :=
          (core.ops.bit.Not.not (Self := ref u64.t) (Trait := ltac:(refine _)))
            self in
        (core.ops.bit.BitAnd.bitand (Self := u64.t) (Trait := ltac:(refine _)))
          α0
          other in
      let* pow : ltac:(refine (M.Val i32.t)) := M.alloc 1 in
      let* _ : ltac:(refine (M.Val unit)) :=
        loop
          (let* α0 : ltac:(refine (M.Val i32.t)) := M.alloc 64 in
          let* α1 : ltac:(refine (M.Val bool.t)) := BinOp.lt pow α0 in
          let* α2 : ltac:(refine (M.Val bool.t)) := use α1 in
          let* α3 := M.read α2 in
          if (α3 : bool) then
            let* _ : ltac:(refine (M.Val unit)) :=
              let* α0 : ltac:(refine (M.Val u64.t)) := BinOp.shr ltb pow in
              assign_op bitor ltb α0 in
            let* _ : ltac:(refine (M.Val unit)) := assign_op add pow pow in
            M.alloc tt
          else
            let* _ : ltac:(refine (M.Val unit)) :=
              let* α0 : ltac:(refine (M.Val never.t)) := Break in
              never_to_any α0 in
            let* α0 : ltac:(refine (M.Val unit)) := M.alloc tt in
            never_to_any α0) in
      let* bit : ltac:(refine (M.Val u64.t)) :=
        let* α0 : ltac:(refine (M.Val u64.t)) := UnOp.not ltb in
        BinOp.bit_and gtb α0 in
      let* pow : ltac:(refine (M.Val i32.t)) := M.alloc 1 in
      let* _ : ltac:(refine (M.Val unit)) :=
        loop
          (let* α0 : ltac:(refine (M.Val i32.t)) := M.alloc 64 in
          let* α1 : ltac:(refine (M.Val bool.t)) := BinOp.lt pow α0 in
          let* α2 : ltac:(refine (M.Val bool.t)) := use α1 in
          let* α3 := M.read α2 in
          if (α3 : bool) then
            let* _ : ltac:(refine (M.Val unit)) :=
              let* α0 : ltac:(refine (M.Val u64.t)) := BinOp.shr bit pow in
              assign_op bitor bit α0 in
            let* _ : ltac:(refine (M.Val unit)) := assign_op add pow pow in
            M.alloc tt
          else
            let* _ : ltac:(refine (M.Val unit)) :=
              let* α0 : ltac:(refine (M.Val never.t)) := Break in
              never_to_any α0 in
            let* α0 : ltac:(refine (M.Val unit)) := M.alloc tt in
            never_to_any α0) in
      let* α0 : ltac:(refine (M.Val u64.t)) := M.alloc 1 in
      let* α1 : ltac:(refine (M.Val u64.t)) := BinOp.bit_and bit α0 in
      let* α2 : ltac:(refine (M.Val u8.t)) := cast α1 in
      (core.convert.From.from
          (Self := subtle.Choice.t)
          (Trait := ltac:(refine _)))
        α2).
  
  Global Instance AssociatedFunction_ct_gt :
    Notation.DoubleColon ltac:(Self) "ct_gt" := {
    Notation.double_colon := ct_gt;
  }.
  
  Global Instance ℐ : subtle.ConstantTimeGreater.Trait ltac:(Self) := {
    subtle.ConstantTimeGreater.ct_gt := ct_gt;
  }.
End Impl_subtle_ConstantTimeGreater_for_u64_t.
End Impl_subtle_ConstantTimeGreater_for_u64_t.

Module  ConstantTimeLess.
Section ConstantTimeLess.
  Class Trait (Self : Set) : Type := {
    ℒ_0 :: subtle.ConstantTimeEq.Trait Self;
    ℒ_1 :: subtle.ConstantTimeGreater.Trait Self;
  }.
  
End ConstantTimeLess.
End ConstantTimeLess.

Module  Impl_subtle_ConstantTimeLess_for_u8_t.
Section Impl_subtle_ConstantTimeLess_for_u8_t.
  Ltac Self := exact u8.t.
  
  Global Instance ℐ : subtle.ConstantTimeLess.Required.Trait ltac:(Self) := {
    subtle.ConstantTimeLess.ct_lt := Datatypes.None;
  }.
End Impl_subtle_ConstantTimeLess_for_u8_t.
End Impl_subtle_ConstantTimeLess_for_u8_t.

Module  Impl_subtle_ConstantTimeLess_for_u16_t.
Section Impl_subtle_ConstantTimeLess_for_u16_t.
  Ltac Self := exact u16.t.
  
  Global Instance ℐ : subtle.ConstantTimeLess.Required.Trait ltac:(Self) := {
    subtle.ConstantTimeLess.ct_lt := Datatypes.None;
  }.
End Impl_subtle_ConstantTimeLess_for_u16_t.
End Impl_subtle_ConstantTimeLess_for_u16_t.

Module  Impl_subtle_ConstantTimeLess_for_u32_t.
Section Impl_subtle_ConstantTimeLess_for_u32_t.
  Ltac Self := exact u32.t.
  
  Global Instance ℐ : subtle.ConstantTimeLess.Required.Trait ltac:(Self) := {
    subtle.ConstantTimeLess.ct_lt := Datatypes.None;
  }.
End Impl_subtle_ConstantTimeLess_for_u32_t.
End Impl_subtle_ConstantTimeLess_for_u32_t.

Module  Impl_subtle_ConstantTimeLess_for_u64_t.
Section Impl_subtle_ConstantTimeLess_for_u64_t.
  Ltac Self := exact u64.t.
  
  Global Instance ℐ : subtle.ConstantTimeLess.Required.Trait ltac:(Self) := {
    subtle.ConstantTimeLess.ct_lt := Datatypes.None;
  }.
End Impl_subtle_ConstantTimeLess_for_u64_t.
End Impl_subtle_ConstantTimeLess_for_u64_t.
