(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module  Account.
Section Account.
  Record t : Set := {
    username : ref str.t;
    password : ref str.t;
  }.
  
  Global Instance Get_username : Notation.Dot "username" := {
    Notation.dot x := let* x := M.read x in M.alloc x.(username) : M _;
  }.
  Global Instance Get_AF_username : Notation.DoubleColon t "username" := {
    Notation.double_colon x := let* x := M.read x in M.alloc x.(username) : M _;
  }.
  Global Instance Get_password : Notation.Dot "password" := {
    Notation.dot x := let* x := M.read x in M.alloc x.(password) : M _;
  }.
  Global Instance Get_AF_password : Notation.DoubleColon t "password" := {
    Notation.double_colon x := let* x := M.read x in M.alloc x.(password) : M _;
  }.
End Account.
End Account.

Module  Impl_core_marker_StructuralPartialEq_for_hash_map_alternate_or_custom_key_types_Account_t.
Section Impl_core_marker_StructuralPartialEq_for_hash_map_alternate_or_custom_key_types_Account_t.
  Ltac Self := exact hash_map_alternate_or_custom_key_types.Account.t.
  
  Global Instance ℐ : core.marker.StructuralPartialEq.Trait ltac:(Self) := {
  }.
End Impl_core_marker_StructuralPartialEq_for_hash_map_alternate_or_custom_key_types_Account_t.
End Impl_core_marker_StructuralPartialEq_for_hash_map_alternate_or_custom_key_types_Account_t.

Module  Impl_core_cmp_PartialEq_for_hash_map_alternate_or_custom_key_types_Account_t.
Section Impl_core_cmp_PartialEq_for_hash_map_alternate_or_custom_key_types_Account_t.
  Ltac Self := exact hash_map_alternate_or_custom_key_types.Account.t.
  
  (*
  PartialEq
  *)
  Parameter eq :
      (M.Val (ref ltac:(Self))) ->
        (M.Val (ref hash_map_alternate_or_custom_key_types.Account.t)) ->
        M (M.Val bool.t).
  
  Global Instance AssociatedFunction_eq :
    Notation.DoubleColon ltac:(Self) "eq" := {
    Notation.double_colon := eq;
  }.
  
  Global Instance ℐ :
    core.cmp.PartialEq.Required.Trait ltac:(Self)
      (Rhs := core.cmp.PartialEq.Default.Rhs ltac:(Self)) := {
    core.cmp.PartialEq.eq := eq;
    core.cmp.PartialEq.ne := Datatypes.None;
  }.
End Impl_core_cmp_PartialEq_for_hash_map_alternate_or_custom_key_types_Account_t.
End Impl_core_cmp_PartialEq_for_hash_map_alternate_or_custom_key_types_Account_t.

Module  Impl_core_marker_StructuralEq_for_hash_map_alternate_or_custom_key_types_Account_t.
Section Impl_core_marker_StructuralEq_for_hash_map_alternate_or_custom_key_types_Account_t.
  Ltac Self := exact hash_map_alternate_or_custom_key_types.Account.t.
  
  Global Instance ℐ : core.marker.StructuralEq.Trait ltac:(Self) := {
  }.
End Impl_core_marker_StructuralEq_for_hash_map_alternate_or_custom_key_types_Account_t.
End Impl_core_marker_StructuralEq_for_hash_map_alternate_or_custom_key_types_Account_t.

Module  Impl_core_cmp_Eq_for_hash_map_alternate_or_custom_key_types_Account_t.
Section Impl_core_cmp_Eq_for_hash_map_alternate_or_custom_key_types_Account_t.
  Ltac Self := exact hash_map_alternate_or_custom_key_types.Account.t.
  
  (*
  Eq
  *)
  Parameter assert_receiver_is_total_eq :
      (M.Val (ref ltac:(Self))) -> M (M.Val unit).
  
  Global Instance AssociatedFunction_assert_receiver_is_total_eq :
    Notation.DoubleColon ltac:(Self) "assert_receiver_is_total_eq" := {
    Notation.double_colon := assert_receiver_is_total_eq;
  }.
  
  Global Instance ℐ : core.cmp.Eq.Required.Trait ltac:(Self) := {
    core.cmp.Eq.assert_receiver_is_total_eq :=
      Datatypes.Some assert_receiver_is_total_eq;
  }.
End Impl_core_cmp_Eq_for_hash_map_alternate_or_custom_key_types_Account_t.
End Impl_core_cmp_Eq_for_hash_map_alternate_or_custom_key_types_Account_t.

Module  Impl_core_hash_Hash_for_hash_map_alternate_or_custom_key_types_Account_t.
Section Impl_core_hash_Hash_for_hash_map_alternate_or_custom_key_types_Account_t.
  Ltac Self := exact hash_map_alternate_or_custom_key_types.Account.t.
  
  (*
  Hash
  *)
  Parameter hash :
      forall {__H : Set} {ℋ_0 : core.hash.Hasher.Trait __H},
      (M.Val (ref ltac:(Self))) -> (M.Val (mut_ref __H)) -> M (M.Val unit).
  
  Global Instance AssociatedFunction_hash
      {__H : Set}
      {ℋ_0 : core.hash.Hasher.Trait __H} :
    Notation.DoubleColon ltac:(Self) "hash" := {
    Notation.double_colon := hash (__H := __H);
  }.
  
  Global Instance ℐ : core.hash.Hash.Required.Trait ltac:(Self) := {
    core.hash.Hash.hash {__H : Set} {ℋ_0 : core.hash.Hasher.Trait __H} :=
      hash (__H := __H);
    core.hash.Hash.hash_slice := Datatypes.None;
  }.
End Impl_core_hash_Hash_for_hash_map_alternate_or_custom_key_types_Account_t.
End Impl_core_hash_Hash_for_hash_map_alternate_or_custom_key_types_Account_t.

Module  AccountInfo.
Section AccountInfo.
  Record t : Set := {
    name : ref str.t;
    email : ref str.t;
  }.
  
  Global Instance Get_name : Notation.Dot "name" := {
    Notation.dot x := let* x := M.read x in M.alloc x.(name) : M _;
  }.
  Global Instance Get_AF_name : Notation.DoubleColon t "name" := {
    Notation.double_colon x := let* x := M.read x in M.alloc x.(name) : M _;
  }.
  Global Instance Get_email : Notation.Dot "email" := {
    Notation.dot x := let* x := M.read x in M.alloc x.(email) : M _;
  }.
  Global Instance Get_AF_email : Notation.DoubleColon t "email" := {
    Notation.double_colon x := let* x := M.read x in M.alloc x.(email) : M _;
  }.
End AccountInfo.
End AccountInfo.

Ltac Accounts :=
  exact
    (std.collections.hash.map.HashMap.t
      hash_map_alternate_or_custom_key_types.Account.t
      hash_map_alternate_or_custom_key_types.AccountInfo.t
      std.collections.hash.map.HashMap.Default.S).

(*
fn try_logon<'a>(accounts: &Accounts<'a>, username: &'a str, password: &'a str) {
    println!("Username: {}", username);
    println!("Password: {}", password);
    println!("Attempting logon...");

    let logon = Account { username, password };

    match accounts.get(&logon) {
        Some(account_info) => {
            println!("Successful logon!");
            println!("Name: {}", account_info.name);
            println!("Email: {}", account_info.email);
        }
        _ => println!("Login failed!"),
    }
}
*)
Parameter try_logon :
    (M.Val (ref ltac:(hash_map_alternate_or_custom_key_types.Accounts))) ->
      (M.Val (ref str.t)) ->
      (M.Val (ref str.t)) ->
      M (M.Val unit).

(*
fn main() {
    let mut accounts: Accounts = HashMap::new();

    let account = Account {
        username: "j.everyman",
        password: "password123",
    };

    let account_info = AccountInfo {
        name: "John Everyman",
        email: "j.everyman@email.com",
    };

    accounts.insert(account, account_info);

    try_logon(&accounts, "j.everyman", "psasword123");

    try_logon(&accounts, "j.everyman", "password123");
}
*)
(* #[allow(dead_code)] - function was ignored by the compiler *)
Parameter main : M (M.Val unit).
