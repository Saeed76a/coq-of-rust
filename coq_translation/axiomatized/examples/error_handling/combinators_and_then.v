(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module Food.
  Inductive t : Set :=
  | CordonBleu
  | Steak
  | Sushi.
End Food.

Module  Impl_core_fmt_Debug_for_combinators_and_then_Food_t.
Section Impl_core_fmt_Debug_for_combinators_and_then_Food_t.
  Ltac Self := exact combinators_and_then.Food.t.
  
  (*
  Debug
  *)
  Parameter fmt :
      (M.Val (ref ltac:(Self))) ->
        (M.Val (mut_ref core.fmt.Formatter.t)) ->
        M (M.Val ltac:(core.fmt.Result)).
  
  Global Instance AssociatedFunction_fmt :
    Notations.DoubleColon ltac:(Self) "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait ltac:(Self) := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_combinators_and_then_Food_t.
End Impl_core_fmt_Debug_for_combinators_and_then_Food_t.

Module Day.
  Inductive t : Set :=
  | Monday
  | Tuesday
  | Wednesday.
End Day.

Module  Impl_core_fmt_Debug_for_combinators_and_then_Day_t.
Section Impl_core_fmt_Debug_for_combinators_and_then_Day_t.
  Ltac Self := exact combinators_and_then.Day.t.
  
  (*
  Debug
  *)
  Parameter fmt :
      (M.Val (ref ltac:(Self))) ->
        (M.Val (mut_ref core.fmt.Formatter.t)) ->
        M (M.Val ltac:(core.fmt.Result)).
  
  Global Instance AssociatedFunction_fmt :
    Notations.DoubleColon ltac:(Self) "fmt" := {
    Notations.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait ltac:(Self) := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_combinators_and_then_Day_t.
End Impl_core_fmt_Debug_for_combinators_and_then_Day_t.

(*
fn have_ingredients(food: Food) -> Option<Food> {
    match food {
        Food::Sushi => None,
        _ => Some(food),
    }
}
*)
Parameter have_ingredients :
    (M.Val combinators_and_then.Food.t) ->
      M (M.Val (core.option.Option.t combinators_and_then.Food.t)).

(*
fn have_recipe(food: Food) -> Option<Food> {
    match food {
        Food::CordonBleu => None,
        _ => Some(food),
    }
}
*)
Parameter have_recipe :
    (M.Val combinators_and_then.Food.t) ->
      M (M.Val (core.option.Option.t combinators_and_then.Food.t)).

(*
fn cookable_v1(food: Food) -> Option<Food> {
    match have_recipe(food) {
        None => None,
        Some(food) => match have_ingredients(food) {
            None => None,
            Some(food) => Some(food),
        },
    }
}
*)
Parameter cookable_v1 :
    (M.Val combinators_and_then.Food.t) ->
      M (M.Val (core.option.Option.t combinators_and_then.Food.t)).

(*
fn cookable_v2(food: Food) -> Option<Food> {
    have_recipe(food).and_then(have_ingredients)
}
*)
Parameter cookable_v2 :
    (M.Val combinators_and_then.Food.t) ->
      M (M.Val (core.option.Option.t combinators_and_then.Food.t)).

(*
fn eat(food: Food, day: Day) {
    match cookable_v2(food) {
        Some(food) => println!("Yay! On {:?} we get to eat {:?}.", day, food),
        None => println!("Oh no. We don't get to eat on {:?}?", day),
    }
}
*)
Parameter eat :
    (M.Val combinators_and_then.Food.t) ->
      (M.Val combinators_and_then.Day.t) ->
      M (M.Val unit).

(*
fn main() {
    let (cordon_bleu, steak, sushi) = (Food::CordonBleu, Food::Steak, Food::Sushi);

    eat(cordon_bleu, Day::Monday);
    eat(steak, Day::Tuesday);
    eat(sushi, Day::Wednesday);
}
*)
(* #[allow(dead_code)] - function was ignored by the compiler *)
Parameter main : M (M.Val unit).
